/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 87351:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issue = exports.issueCommand = void 0;
const os = __importStar(__nccwpck_require__(22037));
const utils_1 = __nccwpck_require__(5278);
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 42186:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
const command_1 = __nccwpck_require__(87351);
const file_command_1 = __nccwpck_require__(717);
const utils_1 = __nccwpck_require__(5278);
const os = __importStar(__nccwpck_require__(22037));
const path = __importStar(__nccwpck_require__(71017));
const oidc_utils_1 = __nccwpck_require__(98041);
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));
    }
    command_1.issueCommand('set-env', { name }, convertedVal);
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueFileCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.
 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
 * Returns an empty string if the value is not defined.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
        return val;
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Gets the values of an multiline input.  Each value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string[]
 *
 */
function getMultilineInput(name, options) {
    const inputs = getInput(name, options)
        .split('\n')
        .filter(x => x !== '');
    if (options && options.trimWhitespace === false) {
        return inputs;
    }
    return inputs.map(input => input.trim());
}
exports.getMultilineInput = getMultilineInput;
/**
 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
 * The return value is also in boolean type.
 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   boolean
 */
function getBooleanInput(name, options) {
    const trueValue = ['true', 'True', 'TRUE'];
    const falseValue = ['false', 'False', 'FALSE'];
    const val = getInput(name, options);
    if (trueValue.includes(val))
        return true;
    if (falseValue.includes(val))
        return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
}
exports.getBooleanInput = getBooleanInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    const filePath = process.env['GITHUB_OUTPUT'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));
    }
    process.stdout.write(os.EOL);
    command_1.issueCommand('set-output', { name }, utils_1.toCommandValue(value));
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function error(message, properties = {}) {
    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds a warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function warning(message, properties = {}) {
    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Adds a notice issue
 * @param message notice issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function notice(message, properties = {}) {
    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.notice = notice;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    const filePath = process.env['GITHUB_STATE'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));
    }
    command_1.issueCommand('save-state', { name }, utils_1.toCommandValue(value));
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
function getIDToken(aud) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
}
exports.getIDToken = getIDToken;
/**
 * Summary exports
 */
var summary_1 = __nccwpck_require__(81327);
Object.defineProperty(exports, "summary", ({ enumerable: true, get: function () { return summary_1.summary; } }));
/**
 * @deprecated use core.summary
 */
var summary_2 = __nccwpck_require__(81327);
Object.defineProperty(exports, "markdownSummary", ({ enumerable: true, get: function () { return summary_2.markdownSummary; } }));
/**
 * Path exports
 */
var path_utils_1 = __nccwpck_require__(2981);
Object.defineProperty(exports, "toPosixPath", ({ enumerable: true, get: function () { return path_utils_1.toPosixPath; } }));
Object.defineProperty(exports, "toWin32Path", ({ enumerable: true, get: function () { return path_utils_1.toWin32Path; } }));
Object.defineProperty(exports, "toPlatformPath", ({ enumerable: true, get: function () { return path_utils_1.toPlatformPath; } }));
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 717:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

// For internal use, subject to change.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__nccwpck_require__(57147));
const os = __importStar(__nccwpck_require__(22037));
const uuid_1 = __nccwpck_require__(75840);
const utils_1 = __nccwpck_require__(5278);
function issueFileCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueFileCommand = issueFileCommand;
function prepareKeyValueMessage(key, value) {
    const delimiter = `ghadelimiter_${uuid_1.v4()}`;
    const convertedValue = utils_1.toCommandValue(value);
    // These should realistically never happen, but just in case someone finds a
    // way to exploit uuid generation let's not allow keys or values that contain
    // the delimiter.
    if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
    }
    if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
    }
    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
}
exports.prepareKeyValueMessage = prepareKeyValueMessage;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ 98041:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OidcClient = void 0;
const http_client_1 = __nccwpck_require__(96255);
const auth_1 = __nccwpck_require__(35526);
const core_1 = __nccwpck_require__(42186);
class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
            allowRetries: allowRetry,
            maxRetries: maxRetry
        };
        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
        if (!token) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
        }
        return token;
    }
    static getIDTokenUrl() {
        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
        if (!runtimeUrl) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
        }
        return runtimeUrl;
    }
    static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const httpclient = OidcClient.createHttpClient();
            const res = yield httpclient
                .getJson(id_token_url)
                .catch(error => {
                throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.message}`);
            });
            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
            if (!id_token) {
                throw new Error('Response json body do not have ID Token field');
            }
            return id_token;
        });
    }
    static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // New ID Token is requested from action service
                let id_token_url = OidcClient.getIDTokenUrl();
                if (audience) {
                    const encodedAudience = encodeURIComponent(audience);
                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;
                }
                core_1.debug(`ID token url is ${id_token_url}`);
                const id_token = yield OidcClient.getCall(id_token_url);
                core_1.setSecret(id_token);
                return id_token;
            }
            catch (error) {
                throw new Error(`Error message: ${error.message}`);
            }
        });
    }
}
exports.OidcClient = OidcClient;
//# sourceMappingURL=oidc-utils.js.map

/***/ }),

/***/ 2981:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
const path = __importStar(__nccwpck_require__(71017));
/**
 * toPosixPath converts the given path to the posix form. On Windows, \\ will be
 * replaced with /.
 *
 * @param pth. Path to transform.
 * @return string Posix path.
 */
function toPosixPath(pth) {
    return pth.replace(/[\\]/g, '/');
}
exports.toPosixPath = toPosixPath;
/**
 * toWin32Path converts the given path to the win32 form. On Linux, / will be
 * replaced with \\.
 *
 * @param pth. Path to transform.
 * @return string Win32 path.
 */
function toWin32Path(pth) {
    return pth.replace(/[/]/g, '\\');
}
exports.toWin32Path = toWin32Path;
/**
 * toPlatformPath converts the given path to a platform-specific path. It does
 * this by replacing instances of / and \ with the platform-specific path
 * separator.
 *
 * @param pth The path to platformize.
 * @return string The platform-specific path.
 */
function toPlatformPath(pth) {
    return pth.replace(/[/\\]/g, path.sep);
}
exports.toPlatformPath = toPlatformPath;
//# sourceMappingURL=path-utils.js.map

/***/ }),

/***/ 81327:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
const os_1 = __nccwpck_require__(22037);
const fs_1 = __nccwpck_require__(57147);
const { access, appendFile, writeFile } = fs_1.promises;
exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
exports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
class Summary {
    constructor() {
        this._buffer = '';
    }
    /**
     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
     * Also checks r/w permissions.
     *
     * @returns step summary file path
     */
    filePath() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._filePath) {
                return this._filePath;
            }
            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
            if (!pathFromEnv) {
                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
            }
            try {
                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
            }
            catch (_a) {
                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
            }
            this._filePath = pathFromEnv;
            return this._filePath;
        });
    }
    /**
     * Wraps content in an HTML tag, adding any HTML attributes
     *
     * @param {string} tag HTML tag to wrap
     * @param {string | null} content content within the tag
     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
     *
     * @returns {string} content wrapped in HTML element
     */
    wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs)
            .map(([key, value]) => ` ${key}="${value}"`)
            .join('');
        if (!content) {
            return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
    }
    /**
     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
     *
     * @param {SummaryWriteOptions} [options] (optional) options for write operation
     *
     * @returns {Promise<Summary>} summary instance
     */
    write(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
            const filePath = yield this.filePath();
            const writeFunc = overwrite ? writeFile : appendFile;
            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });
            return this.emptyBuffer();
        });
    }
    /**
     * Clears the summary buffer and wipes the summary file
     *
     * @returns {Summary} summary instance
     */
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.emptyBuffer().write({ overwrite: true });
        });
    }
    /**
     * Returns the current summary buffer as a string
     *
     * @returns {string} string of summary buffer
     */
    stringify() {
        return this._buffer;
    }
    /**
     * If the summary buffer is empty
     *
     * @returns {boolen} true if the buffer is empty
     */
    isEmptyBuffer() {
        return this._buffer.length === 0;
    }
    /**
     * Resets the summary buffer without writing to summary file
     *
     * @returns {Summary} summary instance
     */
    emptyBuffer() {
        this._buffer = '';
        return this;
    }
    /**
     * Adds raw text to the summary buffer
     *
     * @param {string} text content to add
     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
     *
     * @returns {Summary} summary instance
     */
    addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
    }
    /**
     * Adds the operating system-specific end-of-line marker to the buffer
     *
     * @returns {Summary} summary instance
     */
    addEOL() {
        return this.addRaw(os_1.EOL);
    }
    /**
     * Adds an HTML codeblock to the summary buffer
     *
     * @param {string} code content to render within fenced code block
     * @param {string} lang (optional) language to syntax highlight code
     *
     * @returns {Summary} summary instance
     */
    addCodeBlock(code, lang) {
        const attrs = Object.assign({}, (lang && { lang }));
        const element = this.wrap('pre', this.wrap('code', code), attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML list to the summary buffer
     *
     * @param {string[]} items list of items to render
     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
     *
     * @returns {Summary} summary instance
     */
    addList(items, ordered = false) {
        const tag = ordered ? 'ol' : 'ul';
        const listItems = items.map(item => this.wrap('li', item)).join('');
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML table to the summary buffer
     *
     * @param {SummaryTableCell[]} rows table rows
     *
     * @returns {Summary} summary instance
     */
    addTable(rows) {
        const tableBody = rows
            .map(row => {
            const cells = row
                .map(cell => {
                if (typeof cell === 'string') {
                    return this.wrap('td', cell);
                }
                const { header, data, colspan, rowspan } = cell;
                const tag = header ? 'th' : 'td';
                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));
                return this.wrap(tag, data, attrs);
            })
                .join('');
            return this.wrap('tr', cells);
        })
            .join('');
        const element = this.wrap('table', tableBody);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds a collapsable HTML details element to the summary buffer
     *
     * @param {string} label text for the closed state
     * @param {string} content collapsable content
     *
     * @returns {Summary} summary instance
     */
    addDetails(label, content) {
        const element = this.wrap('details', this.wrap('summary', label) + content);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML image tag to the summary buffer
     *
     * @param {string} src path to the image you to embed
     * @param {string} alt text description of the image
     * @param {SummaryImageOptions} options (optional) addition image attributes
     *
     * @returns {Summary} summary instance
     */
    addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));
        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML section heading element
     *
     * @param {string} text heading text
     * @param {number | string} [level=1] (optional) the heading level, default: 1
     *
     * @returns {Summary} summary instance
     */
    addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
            ? tag
            : 'h1';
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML thematic break (<hr>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addSeparator() {
        const element = this.wrap('hr', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML line break (<br>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addBreak() {
        const element = this.wrap('br', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML blockquote to the summary buffer
     *
     * @param {string} text quote text
     * @param {string} cite (optional) citation url
     *
     * @returns {Summary} summary instance
     */
    addQuote(text, cite) {
        const attrs = Object.assign({}, (cite && { cite }));
        const element = this.wrap('blockquote', text, attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML anchor tag to the summary buffer
     *
     * @param {string} text link text/content
     * @param {string} href hyperlink
     *
     * @returns {Summary} summary instance
     */
    addLink(text, href) {
        const element = this.wrap('a', text, { href });
        return this.addRaw(element).addEOL();
    }
}
const _summary = new Summary();
/**
 * @deprecated use `core.summary`
 */
exports.markdownSummary = _summary;
exports.summary = _summary;
//# sourceMappingURL=summary.js.map

/***/ }),

/***/ 5278:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCommandProperties = exports.toCommandValue = void 0;
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
/**
 *
 * @param annotationProperties
 * @returns The command properties to send with the actual annotation command
 * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
 */
function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
        return {};
    }
    return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
    };
}
exports.toCommandProperties = toCommandProperties;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 28090:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hashFiles = exports.create = void 0;
const internal_globber_1 = __nccwpck_require__(28298);
const internal_hash_files_1 = __nccwpck_require__(2448);
/**
 * Constructs a globber
 *
 * @param patterns  Patterns separated by newlines
 * @param options   Glob options
 */
function create(patterns, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield internal_globber_1.DefaultGlobber.create(patterns, options);
    });
}
exports.create = create;
/**
 * Computes the sha256 hash of a glob
 *
 * @param patterns  Patterns separated by newlines
 * @param currentWorkspace  Workspace used when matching files
 * @param options   Glob options
 * @param verbose   Enables verbose logging
 */
function hashFiles(patterns, currentWorkspace = '', options, verbose = false) {
    return __awaiter(this, void 0, void 0, function* () {
        let followSymbolicLinks = true;
        if (options && typeof options.followSymbolicLinks === 'boolean') {
            followSymbolicLinks = options.followSymbolicLinks;
        }
        const globber = yield create(patterns, { followSymbolicLinks });
        return internal_hash_files_1.hashFiles(globber, currentWorkspace, verbose);
    });
}
exports.hashFiles = hashFiles;
//# sourceMappingURL=glob.js.map

/***/ }),

/***/ 51026:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOptions = void 0;
const core = __importStar(__nccwpck_require__(42186));
/**
 * Returns a copy with defaults filled in.
 */
function getOptions(copy) {
    const result = {
        followSymbolicLinks: true,
        implicitDescendants: true,
        matchDirectories: true,
        omitBrokenSymbolicLinks: true
    };
    if (copy) {
        if (typeof copy.followSymbolicLinks === 'boolean') {
            result.followSymbolicLinks = copy.followSymbolicLinks;
            core.debug(`followSymbolicLinks '${result.followSymbolicLinks}'`);
        }
        if (typeof copy.implicitDescendants === 'boolean') {
            result.implicitDescendants = copy.implicitDescendants;
            core.debug(`implicitDescendants '${result.implicitDescendants}'`);
        }
        if (typeof copy.matchDirectories === 'boolean') {
            result.matchDirectories = copy.matchDirectories;
            core.debug(`matchDirectories '${result.matchDirectories}'`);
        }
        if (typeof copy.omitBrokenSymbolicLinks === 'boolean') {
            result.omitBrokenSymbolicLinks = copy.omitBrokenSymbolicLinks;
            core.debug(`omitBrokenSymbolicLinks '${result.omitBrokenSymbolicLinks}'`);
        }
    }
    return result;
}
exports.getOptions = getOptions;
//# sourceMappingURL=internal-glob-options-helper.js.map

/***/ }),

/***/ 28298:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultGlobber = void 0;
const core = __importStar(__nccwpck_require__(42186));
const fs = __importStar(__nccwpck_require__(57147));
const globOptionsHelper = __importStar(__nccwpck_require__(51026));
const path = __importStar(__nccwpck_require__(71017));
const patternHelper = __importStar(__nccwpck_require__(29005));
const internal_match_kind_1 = __nccwpck_require__(81063);
const internal_pattern_1 = __nccwpck_require__(64536);
const internal_search_state_1 = __nccwpck_require__(89117);
const IS_WINDOWS = process.platform === 'win32';
class DefaultGlobber {
    constructor(options) {
        this.patterns = [];
        this.searchPaths = [];
        this.options = globOptionsHelper.getOptions(options);
    }
    getSearchPaths() {
        // Return a copy
        return this.searchPaths.slice();
    }
    glob() {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            try {
                for (var _b = __asyncValues(this.globGenerator()), _c; _c = yield _b.next(), !_c.done;) {
                    const itemPath = _c.value;
                    result.push(itemPath);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result;
        });
    }
    globGenerator() {
        return __asyncGenerator(this, arguments, function* globGenerator_1() {
            // Fill in defaults options
            const options = globOptionsHelper.getOptions(this.options);
            // Implicit descendants?
            const patterns = [];
            for (const pattern of this.patterns) {
                patterns.push(pattern);
                if (options.implicitDescendants &&
                    (pattern.trailingSeparator ||
                        pattern.segments[pattern.segments.length - 1] !== '**')) {
                    patterns.push(new internal_pattern_1.Pattern(pattern.negate, true, pattern.segments.concat('**')));
                }
            }
            // Push the search paths
            const stack = [];
            for (const searchPath of patternHelper.getSearchPaths(patterns)) {
                core.debug(`Search path '${searchPath}'`);
                // Exists?
                try {
                    // Intentionally using lstat. Detection for broken symlink
                    // will be performed later (if following symlinks).
                    yield __await(fs.promises.lstat(searchPath));
                }
                catch (err) {
                    if (err.code === 'ENOENT') {
                        continue;
                    }
                    throw err;
                }
                stack.unshift(new internal_search_state_1.SearchState(searchPath, 1));
            }
            // Search
            const traversalChain = []; // used to detect cycles
            while (stack.length) {
                // Pop
                const item = stack.pop();
                // Match?
                const match = patternHelper.match(patterns, item.path);
                const partialMatch = !!match || patternHelper.partialMatch(patterns, item.path);
                if (!match && !partialMatch) {
                    continue;
                }
                // Stat
                const stats = yield __await(DefaultGlobber.stat(item, options, traversalChain)
                // Broken symlink, or symlink cycle detected, or no longer exists
                );
                // Broken symlink, or symlink cycle detected, or no longer exists
                if (!stats) {
                    continue;
                }
                // Directory
                if (stats.isDirectory()) {
                    // Matched
                    if (match & internal_match_kind_1.MatchKind.Directory && options.matchDirectories) {
                        yield yield __await(item.path);
                    }
                    // Descend?
                    else if (!partialMatch) {
                        continue;
                    }
                    // Push the child items in reverse
                    const childLevel = item.level + 1;
                    const childItems = (yield __await(fs.promises.readdir(item.path))).map(x => new internal_search_state_1.SearchState(path.join(item.path, x), childLevel));
                    stack.push(...childItems.reverse());
                }
                // File
                else if (match & internal_match_kind_1.MatchKind.File) {
                    yield yield __await(item.path);
                }
            }
        });
    }
    /**
     * Constructs a DefaultGlobber
     */
    static create(patterns, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = new DefaultGlobber(options);
            if (IS_WINDOWS) {
                patterns = patterns.replace(/\r\n/g, '\n');
                patterns = patterns.replace(/\r/g, '\n');
            }
            const lines = patterns.split('\n').map(x => x.trim());
            for (const line of lines) {
                // Empty or comment
                if (!line || line.startsWith('#')) {
                    continue;
                }
                // Pattern
                else {
                    result.patterns.push(new internal_pattern_1.Pattern(line));
                }
            }
            result.searchPaths.push(...patternHelper.getSearchPaths(result.patterns));
            return result;
        });
    }
    static stat(item, options, traversalChain) {
        return __awaiter(this, void 0, void 0, function* () {
            // Note:
            // `stat` returns info about the target of a symlink (or symlink chain)
            // `lstat` returns info about a symlink itself
            let stats;
            if (options.followSymbolicLinks) {
                try {
                    // Use `stat` (following symlinks)
                    stats = yield fs.promises.stat(item.path);
                }
                catch (err) {
                    if (err.code === 'ENOENT') {
                        if (options.omitBrokenSymbolicLinks) {
                            core.debug(`Broken symlink '${item.path}'`);
                            return undefined;
                        }
                        throw new Error(`No information found for the path '${item.path}'. This may indicate a broken symbolic link.`);
                    }
                    throw err;
                }
            }
            else {
                // Use `lstat` (not following symlinks)
                stats = yield fs.promises.lstat(item.path);
            }
            // Note, isDirectory() returns false for the lstat of a symlink
            if (stats.isDirectory() && options.followSymbolicLinks) {
                // Get the realpath
                const realPath = yield fs.promises.realpath(item.path);
                // Fixup the traversal chain to match the item level
                while (traversalChain.length >= item.level) {
                    traversalChain.pop();
                }
                // Test for a cycle
                if (traversalChain.some((x) => x === realPath)) {
                    core.debug(`Symlink cycle detected for path '${item.path}' and realpath '${realPath}'`);
                    return undefined;
                }
                // Update the traversal chain
                traversalChain.push(realPath);
            }
            return stats;
        });
    }
}
exports.DefaultGlobber = DefaultGlobber;
//# sourceMappingURL=internal-globber.js.map

/***/ }),

/***/ 2448:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hashFiles = void 0;
const crypto = __importStar(__nccwpck_require__(6113));
const core = __importStar(__nccwpck_require__(42186));
const fs = __importStar(__nccwpck_require__(57147));
const stream = __importStar(__nccwpck_require__(12781));
const util = __importStar(__nccwpck_require__(73837));
const path = __importStar(__nccwpck_require__(71017));
function hashFiles(globber, currentWorkspace, verbose = false) {
    var e_1, _a;
    var _b;
    return __awaiter(this, void 0, void 0, function* () {
        const writeDelegate = verbose ? core.info : core.debug;
        let hasMatch = false;
        const githubWorkspace = currentWorkspace
            ? currentWorkspace
            : (_b = process.env['GITHUB_WORKSPACE']) !== null && _b !== void 0 ? _b : process.cwd();
        const result = crypto.createHash('sha256');
        let count = 0;
        try {
            for (var _c = __asyncValues(globber.globGenerator()), _d; _d = yield _c.next(), !_d.done;) {
                const file = _d.value;
                writeDelegate(file);
                if (!file.startsWith(`${githubWorkspace}${path.sep}`)) {
                    writeDelegate(`Ignore '${file}' since it is not under GITHUB_WORKSPACE.`);
                    continue;
                }
                if (fs.statSync(file).isDirectory()) {
                    writeDelegate(`Skip directory '${file}'.`);
                    continue;
                }
                const hash = crypto.createHash('sha256');
                const pipeline = util.promisify(stream.pipeline);
                yield pipeline(fs.createReadStream(file), hash);
                result.write(hash.digest());
                count++;
                if (!hasMatch) {
                    hasMatch = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) yield _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        result.end();
        if (hasMatch) {
            writeDelegate(`Found ${count} files to hash.`);
            return result.digest('hex');
        }
        else {
            writeDelegate(`No matches found for glob`);
            return '';
        }
    });
}
exports.hashFiles = hashFiles;
//# sourceMappingURL=internal-hash-files.js.map

/***/ }),

/***/ 81063:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MatchKind = void 0;
/**
 * Indicates whether a pattern matches a path
 */
var MatchKind;
(function (MatchKind) {
    /** Not matched */
    MatchKind[MatchKind["None"] = 0] = "None";
    /** Matched if the path is a directory */
    MatchKind[MatchKind["Directory"] = 1] = "Directory";
    /** Matched if the path is a regular file */
    MatchKind[MatchKind["File"] = 2] = "File";
    /** Matched */
    MatchKind[MatchKind["All"] = 3] = "All";
})(MatchKind = exports.MatchKind || (exports.MatchKind = {}));
//# sourceMappingURL=internal-match-kind.js.map

/***/ }),

/***/ 1849:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.safeTrimTrailingSeparator = exports.normalizeSeparators = exports.hasRoot = exports.hasAbsoluteRoot = exports.ensureAbsoluteRoot = exports.dirname = void 0;
const path = __importStar(__nccwpck_require__(71017));
const assert_1 = __importDefault(__nccwpck_require__(39491));
const IS_WINDOWS = process.platform === 'win32';
/**
 * Similar to path.dirname except normalizes the path separators and slightly better handling for Windows UNC paths.
 *
 * For example, on Linux/macOS:
 * - `/               => /`
 * - `/hello          => /`
 *
 * For example, on Windows:
 * - `C:\             => C:\`
 * - `C:\hello        => C:\`
 * - `C:              => C:`
 * - `C:hello         => C:`
 * - `\               => \`
 * - `\hello          => \`
 * - `\\hello         => \\hello`
 * - `\\hello\world   => \\hello\world`
 */
function dirname(p) {
    // Normalize slashes and trim unnecessary trailing slash
    p = safeTrimTrailingSeparator(p);
    // Windows UNC root, e.g. \\hello or \\hello\world
    if (IS_WINDOWS && /^\\\\[^\\]+(\\[^\\]+)?$/.test(p)) {
        return p;
    }
    // Get dirname
    let result = path.dirname(p);
    // Trim trailing slash for Windows UNC root, e.g. \\hello\world\
    if (IS_WINDOWS && /^\\\\[^\\]+\\[^\\]+\\$/.test(result)) {
        result = safeTrimTrailingSeparator(result);
    }
    return result;
}
exports.dirname = dirname;
/**
 * Roots the path if not already rooted. On Windows, relative roots like `\`
 * or `C:` are expanded based on the current working directory.
 */
function ensureAbsoluteRoot(root, itemPath) {
    assert_1.default(root, `ensureAbsoluteRoot parameter 'root' must not be empty`);
    assert_1.default(itemPath, `ensureAbsoluteRoot parameter 'itemPath' must not be empty`);
    // Already rooted
    if (hasAbsoluteRoot(itemPath)) {
        return itemPath;
    }
    // Windows
    if (IS_WINDOWS) {
        // Check for itemPath like C: or C:foo
        if (itemPath.match(/^[A-Z]:[^\\/]|^[A-Z]:$/i)) {
            let cwd = process.cwd();
            assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
            // Drive letter matches cwd? Expand to cwd
            if (itemPath[0].toUpperCase() === cwd[0].toUpperCase()) {
                // Drive only, e.g. C:
                if (itemPath.length === 2) {
                    // Preserve specified drive letter case (upper or lower)
                    return `${itemPath[0]}:\\${cwd.substr(3)}`;
                }
                // Drive + path, e.g. C:foo
                else {
                    if (!cwd.endsWith('\\')) {
                        cwd += '\\';
                    }
                    // Preserve specified drive letter case (upper or lower)
                    return `${itemPath[0]}:\\${cwd.substr(3)}${itemPath.substr(2)}`;
                }
            }
            // Different drive
            else {
                return `${itemPath[0]}:\\${itemPath.substr(2)}`;
            }
        }
        // Check for itemPath like \ or \foo
        else if (normalizeSeparators(itemPath).match(/^\\$|^\\[^\\]/)) {
            const cwd = process.cwd();
            assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
            return `${cwd[0]}:\\${itemPath.substr(1)}`;
        }
    }
    assert_1.default(hasAbsoluteRoot(root), `ensureAbsoluteRoot parameter 'root' must have an absolute root`);
    // Otherwise ensure root ends with a separator
    if (root.endsWith('/') || (IS_WINDOWS && root.endsWith('\\'))) {
        // Intentionally empty
    }
    else {
        // Append separator
        root += path.sep;
    }
    return root + itemPath;
}
exports.ensureAbsoluteRoot = ensureAbsoluteRoot;
/**
 * On Linux/macOS, true if path starts with `/`. On Windows, true for paths like:
 * `\\hello\share` and `C:\hello` (and using alternate separator).
 */
function hasAbsoluteRoot(itemPath) {
    assert_1.default(itemPath, `hasAbsoluteRoot parameter 'itemPath' must not be empty`);
    // Normalize separators
    itemPath = normalizeSeparators(itemPath);
    // Windows
    if (IS_WINDOWS) {
        // E.g. \\hello\share or C:\hello
        return itemPath.startsWith('\\\\') || /^[A-Z]:\\/i.test(itemPath);
    }
    // E.g. /hello
    return itemPath.startsWith('/');
}
exports.hasAbsoluteRoot = hasAbsoluteRoot;
/**
 * On Linux/macOS, true if path starts with `/`. On Windows, true for paths like:
 * `\`, `\hello`, `\\hello\share`, `C:`, and `C:\hello` (and using alternate separator).
 */
function hasRoot(itemPath) {
    assert_1.default(itemPath, `isRooted parameter 'itemPath' must not be empty`);
    // Normalize separators
    itemPath = normalizeSeparators(itemPath);
    // Windows
    if (IS_WINDOWS) {
        // E.g. \ or \hello or \\hello
        // E.g. C: or C:\hello
        return itemPath.startsWith('\\') || /^[A-Z]:/i.test(itemPath);
    }
    // E.g. /hello
    return itemPath.startsWith('/');
}
exports.hasRoot = hasRoot;
/**
 * Removes redundant slashes and converts `/` to `\` on Windows
 */
function normalizeSeparators(p) {
    p = p || '';
    // Windows
    if (IS_WINDOWS) {
        // Convert slashes on Windows
        p = p.replace(/\//g, '\\');
        // Remove redundant slashes
        const isUnc = /^\\\\+[^\\]/.test(p); // e.g. \\hello
        return (isUnc ? '\\' : '') + p.replace(/\\\\+/g, '\\'); // preserve leading \\ for UNC
    }
    // Remove redundant slashes
    return p.replace(/\/\/+/g, '/');
}
exports.normalizeSeparators = normalizeSeparators;
/**
 * Normalizes the path separators and trims the trailing separator (when safe).
 * For example, `/foo/ => /foo` but `/ => /`
 */
function safeTrimTrailingSeparator(p) {
    // Short-circuit if empty
    if (!p) {
        return '';
    }
    // Normalize separators
    p = normalizeSeparators(p);
    // No trailing slash
    if (!p.endsWith(path.sep)) {
        return p;
    }
    // Check '/' on Linux/macOS and '\' on Windows
    if (p === path.sep) {
        return p;
    }
    // On Windows check if drive root. E.g. C:\
    if (IS_WINDOWS && /^[A-Z]:\\$/i.test(p)) {
        return p;
    }
    // Otherwise trim trailing slash
    return p.substr(0, p.length - 1);
}
exports.safeTrimTrailingSeparator = safeTrimTrailingSeparator;
//# sourceMappingURL=internal-path-helper.js.map

/***/ }),

/***/ 96836:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Path = void 0;
const path = __importStar(__nccwpck_require__(71017));
const pathHelper = __importStar(__nccwpck_require__(1849));
const assert_1 = __importDefault(__nccwpck_require__(39491));
const IS_WINDOWS = process.platform === 'win32';
/**
 * Helper class for parsing paths into segments
 */
class Path {
    /**
     * Constructs a Path
     * @param itemPath Path or array of segments
     */
    constructor(itemPath) {
        this.segments = [];
        // String
        if (typeof itemPath === 'string') {
            assert_1.default(itemPath, `Parameter 'itemPath' must not be empty`);
            // Normalize slashes and trim unnecessary trailing slash
            itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
            // Not rooted
            if (!pathHelper.hasRoot(itemPath)) {
                this.segments = itemPath.split(path.sep);
            }
            // Rooted
            else {
                // Add all segments, while not at the root
                let remaining = itemPath;
                let dir = pathHelper.dirname(remaining);
                while (dir !== remaining) {
                    // Add the segment
                    const basename = path.basename(remaining);
                    this.segments.unshift(basename);
                    // Truncate the last segment
                    remaining = dir;
                    dir = pathHelper.dirname(remaining);
                }
                // Remainder is the root
                this.segments.unshift(remaining);
            }
        }
        // Array
        else {
            // Must not be empty
            assert_1.default(itemPath.length > 0, `Parameter 'itemPath' must not be an empty array`);
            // Each segment
            for (let i = 0; i < itemPath.length; i++) {
                let segment = itemPath[i];
                // Must not be empty
                assert_1.default(segment, `Parameter 'itemPath' must not contain any empty segments`);
                // Normalize slashes
                segment = pathHelper.normalizeSeparators(itemPath[i]);
                // Root segment
                if (i === 0 && pathHelper.hasRoot(segment)) {
                    segment = pathHelper.safeTrimTrailingSeparator(segment);
                    assert_1.default(segment === pathHelper.dirname(segment), `Parameter 'itemPath' root segment contains information for multiple segments`);
                    this.segments.push(segment);
                }
                // All other segments
                else {
                    // Must not contain slash
                    assert_1.default(!segment.includes(path.sep), `Parameter 'itemPath' contains unexpected path separators`);
                    this.segments.push(segment);
                }
            }
        }
    }
    /**
     * Converts the path to it's string representation
     */
    toString() {
        // First segment
        let result = this.segments[0];
        // All others
        let skipSlash = result.endsWith(path.sep) || (IS_WINDOWS && /^[A-Z]:$/i.test(result));
        for (let i = 1; i < this.segments.length; i++) {
            if (skipSlash) {
                skipSlash = false;
            }
            else {
                result += path.sep;
            }
            result += this.segments[i];
        }
        return result;
    }
}
exports.Path = Path;
//# sourceMappingURL=internal-path.js.map

/***/ }),

/***/ 29005:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.partialMatch = exports.match = exports.getSearchPaths = void 0;
const pathHelper = __importStar(__nccwpck_require__(1849));
const internal_match_kind_1 = __nccwpck_require__(81063);
const IS_WINDOWS = process.platform === 'win32';
/**
 * Given an array of patterns, returns an array of paths to search.
 * Duplicates and paths under other included paths are filtered out.
 */
function getSearchPaths(patterns) {
    // Ignore negate patterns
    patterns = patterns.filter(x => !x.negate);
    // Create a map of all search paths
    const searchPathMap = {};
    for (const pattern of patterns) {
        const key = IS_WINDOWS
            ? pattern.searchPath.toUpperCase()
            : pattern.searchPath;
        searchPathMap[key] = 'candidate';
    }
    const result = [];
    for (const pattern of patterns) {
        // Check if already included
        const key = IS_WINDOWS
            ? pattern.searchPath.toUpperCase()
            : pattern.searchPath;
        if (searchPathMap[key] === 'included') {
            continue;
        }
        // Check for an ancestor search path
        let foundAncestor = false;
        let tempKey = key;
        let parent = pathHelper.dirname(tempKey);
        while (parent !== tempKey) {
            if (searchPathMap[parent]) {
                foundAncestor = true;
                break;
            }
            tempKey = parent;
            parent = pathHelper.dirname(tempKey);
        }
        // Include the search pattern in the result
        if (!foundAncestor) {
            result.push(pattern.searchPath);
            searchPathMap[key] = 'included';
        }
    }
    return result;
}
exports.getSearchPaths = getSearchPaths;
/**
 * Matches the patterns against the path
 */
function match(patterns, itemPath) {
    let result = internal_match_kind_1.MatchKind.None;
    for (const pattern of patterns) {
        if (pattern.negate) {
            result &= ~pattern.match(itemPath);
        }
        else {
            result |= pattern.match(itemPath);
        }
    }
    return result;
}
exports.match = match;
/**
 * Checks whether to descend further into the directory
 */
function partialMatch(patterns, itemPath) {
    return patterns.some(x => !x.negate && x.partialMatch(itemPath));
}
exports.partialMatch = partialMatch;
//# sourceMappingURL=internal-pattern-helper.js.map

/***/ }),

/***/ 64536:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pattern = void 0;
const os = __importStar(__nccwpck_require__(22037));
const path = __importStar(__nccwpck_require__(71017));
const pathHelper = __importStar(__nccwpck_require__(1849));
const assert_1 = __importDefault(__nccwpck_require__(39491));
const minimatch_1 = __nccwpck_require__(83973);
const internal_match_kind_1 = __nccwpck_require__(81063);
const internal_path_1 = __nccwpck_require__(96836);
const IS_WINDOWS = process.platform === 'win32';
class Pattern {
    constructor(patternOrNegate, isImplicitPattern = false, segments, homedir) {
        /**
         * Indicates whether matches should be excluded from the result set
         */
        this.negate = false;
        // Pattern overload
        let pattern;
        if (typeof patternOrNegate === 'string') {
            pattern = patternOrNegate.trim();
        }
        // Segments overload
        else {
            // Convert to pattern
            segments = segments || [];
            assert_1.default(segments.length, `Parameter 'segments' must not empty`);
            const root = Pattern.getLiteral(segments[0]);
            assert_1.default(root && pathHelper.hasAbsoluteRoot(root), `Parameter 'segments' first element must be a root path`);
            pattern = new internal_path_1.Path(segments).toString().trim();
            if (patternOrNegate) {
                pattern = `!${pattern}`;
            }
        }
        // Negate
        while (pattern.startsWith('!')) {
            this.negate = !this.negate;
            pattern = pattern.substr(1).trim();
        }
        // Normalize slashes and ensures absolute root
        pattern = Pattern.fixupPattern(pattern, homedir);
        // Segments
        this.segments = new internal_path_1.Path(pattern).segments;
        // Trailing slash indicates the pattern should only match directories, not regular files
        this.trailingSeparator = pathHelper
            .normalizeSeparators(pattern)
            .endsWith(path.sep);
        pattern = pathHelper.safeTrimTrailingSeparator(pattern);
        // Search path (literal path prior to the first glob segment)
        let foundGlob = false;
        const searchSegments = this.segments
            .map(x => Pattern.getLiteral(x))
            .filter(x => !foundGlob && !(foundGlob = x === ''));
        this.searchPath = new internal_path_1.Path(searchSegments).toString();
        // Root RegExp (required when determining partial match)
        this.rootRegExp = new RegExp(Pattern.regExpEscape(searchSegments[0]), IS_WINDOWS ? 'i' : '');
        this.isImplicitPattern = isImplicitPattern;
        // Create minimatch
        const minimatchOptions = {
            dot: true,
            nobrace: true,
            nocase: IS_WINDOWS,
            nocomment: true,
            noext: true,
            nonegate: true
        };
        pattern = IS_WINDOWS ? pattern.replace(/\\/g, '/') : pattern;
        this.minimatch = new minimatch_1.Minimatch(pattern, minimatchOptions);
    }
    /**
     * Matches the pattern against the specified path
     */
    match(itemPath) {
        // Last segment is globstar?
        if (this.segments[this.segments.length - 1] === '**') {
            // Normalize slashes
            itemPath = pathHelper.normalizeSeparators(itemPath);
            // Append a trailing slash. Otherwise Minimatch will not match the directory immediately
            // preceding the globstar. For example, given the pattern `/foo/**`, Minimatch returns
            // false for `/foo` but returns true for `/foo/`. Append a trailing slash to handle that quirk.
            if (!itemPath.endsWith(path.sep) && this.isImplicitPattern === false) {
                // Note, this is safe because the constructor ensures the pattern has an absolute root.
                // For example, formats like C: and C:foo on Windows are resolved to an absolute root.
                itemPath = `${itemPath}${path.sep}`;
            }
        }
        else {
            // Normalize slashes and trim unnecessary trailing slash
            itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
        }
        // Match
        if (this.minimatch.match(itemPath)) {
            return this.trailingSeparator ? internal_match_kind_1.MatchKind.Directory : internal_match_kind_1.MatchKind.All;
        }
        return internal_match_kind_1.MatchKind.None;
    }
    /**
     * Indicates whether the pattern may match descendants of the specified path
     */
    partialMatch(itemPath) {
        // Normalize slashes and trim unnecessary trailing slash
        itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
        // matchOne does not handle root path correctly
        if (pathHelper.dirname(itemPath) === itemPath) {
            return this.rootRegExp.test(itemPath);
        }
        return this.minimatch.matchOne(itemPath.split(IS_WINDOWS ? /\\+/ : /\/+/), this.minimatch.set[0], true);
    }
    /**
     * Escapes glob patterns within a path
     */
    static globEscape(s) {
        return (IS_WINDOWS ? s : s.replace(/\\/g, '\\\\')) // escape '\' on Linux/macOS
            .replace(/(\[)(?=[^/]+\])/g, '[[]') // escape '[' when ']' follows within the path segment
            .replace(/\?/g, '[?]') // escape '?'
            .replace(/\*/g, '[*]'); // escape '*'
    }
    /**
     * Normalizes slashes and ensures absolute root
     */
    static fixupPattern(pattern, homedir) {
        // Empty
        assert_1.default(pattern, 'pattern cannot be empty');
        // Must not contain `.` segment, unless first segment
        // Must not contain `..` segment
        const literalSegments = new internal_path_1.Path(pattern).segments.map(x => Pattern.getLiteral(x));
        assert_1.default(literalSegments.every((x, i) => (x !== '.' || i === 0) && x !== '..'), `Invalid pattern '${pattern}'. Relative pathing '.' and '..' is not allowed.`);
        // Must not contain globs in root, e.g. Windows UNC path \\foo\b*r
        assert_1.default(!pathHelper.hasRoot(pattern) || literalSegments[0], `Invalid pattern '${pattern}'. Root segment must not contain globs.`);
        // Normalize slashes
        pattern = pathHelper.normalizeSeparators(pattern);
        // Replace leading `.` segment
        if (pattern === '.' || pattern.startsWith(`.${path.sep}`)) {
            pattern = Pattern.globEscape(process.cwd()) + pattern.substr(1);
        }
        // Replace leading `~` segment
        else if (pattern === '~' || pattern.startsWith(`~${path.sep}`)) {
            homedir = homedir || os.homedir();
            assert_1.default(homedir, 'Unable to determine HOME directory');
            assert_1.default(pathHelper.hasAbsoluteRoot(homedir), `Expected HOME directory to be a rooted path. Actual '${homedir}'`);
            pattern = Pattern.globEscape(homedir) + pattern.substr(1);
        }
        // Replace relative drive root, e.g. pattern is C: or C:foo
        else if (IS_WINDOWS &&
            (pattern.match(/^[A-Z]:$/i) || pattern.match(/^[A-Z]:[^\\]/i))) {
            let root = pathHelper.ensureAbsoluteRoot('C:\\dummy-root', pattern.substr(0, 2));
            if (pattern.length > 2 && !root.endsWith('\\')) {
                root += '\\';
            }
            pattern = Pattern.globEscape(root) + pattern.substr(2);
        }
        // Replace relative root, e.g. pattern is \ or \foo
        else if (IS_WINDOWS && (pattern === '\\' || pattern.match(/^\\[^\\]/))) {
            let root = pathHelper.ensureAbsoluteRoot('C:\\dummy-root', '\\');
            if (!root.endsWith('\\')) {
                root += '\\';
            }
            pattern = Pattern.globEscape(root) + pattern.substr(1);
        }
        // Otherwise ensure absolute root
        else {
            pattern = pathHelper.ensureAbsoluteRoot(Pattern.globEscape(process.cwd()), pattern);
        }
        return pathHelper.normalizeSeparators(pattern);
    }
    /**
     * Attempts to unescape a pattern segment to create a literal path segment.
     * Otherwise returns empty string.
     */
    static getLiteral(segment) {
        let literal = '';
        for (let i = 0; i < segment.length; i++) {
            const c = segment[i];
            // Escape
            if (c === '\\' && !IS_WINDOWS && i + 1 < segment.length) {
                literal += segment[++i];
                continue;
            }
            // Wildcard
            else if (c === '*' || c === '?') {
                return '';
            }
            // Character set
            else if (c === '[' && i + 1 < segment.length) {
                let set = '';
                let closed = -1;
                for (let i2 = i + 1; i2 < segment.length; i2++) {
                    const c2 = segment[i2];
                    // Escape
                    if (c2 === '\\' && !IS_WINDOWS && i2 + 1 < segment.length) {
                        set += segment[++i2];
                        continue;
                    }
                    // Closed
                    else if (c2 === ']') {
                        closed = i2;
                        break;
                    }
                    // Otherwise
                    else {
                        set += c2;
                    }
                }
                // Closed?
                if (closed >= 0) {
                    // Cannot convert
                    if (set.length > 1) {
                        return '';
                    }
                    // Convert to literal
                    if (set) {
                        literal += set;
                        i = closed;
                        continue;
                    }
                }
                // Otherwise fall thru
            }
            // Append
            literal += c;
        }
        return literal;
    }
    /**
     * Escapes regexp special characters
     * https://javascript.info/regexp-escaping
     */
    static regExpEscape(s) {
        return s.replace(/[[\\^$.|?*+()]/g, '\\$&');
    }
}
exports.Pattern = Pattern;
//# sourceMappingURL=internal-pattern.js.map

/***/ }),

/***/ 89117:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchState = void 0;
class SearchState {
    constructor(path, level) {
        this.path = path;
        this.level = level;
    }
}
exports.SearchState = SearchState;
//# sourceMappingURL=internal-search-state.js.map

/***/ }),

/***/ 35526:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
class BasicCredentialHandler {
    constructor(username, password) {
        this.username = username;
        this.password = password;
    }
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BasicCredentialHandler = BasicCredentialHandler;
class BearerCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Bearer ${this.token}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BearerCredentialHandler = BearerCredentialHandler;
class PersonalAccessTokenCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
//# sourceMappingURL=auth.js.map

/***/ }),

/***/ 96255:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
const http = __importStar(__nccwpck_require__(13685));
const https = __importStar(__nccwpck_require__(95687));
const pm = __importStar(__nccwpck_require__(19835));
const tunnel = __importStar(__nccwpck_require__(74294));
var HttpCodes;
(function (HttpCodes) {
    HttpCodes[HttpCodes["OK"] = 200] = "OK";
    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
var Headers;
(function (Headers) {
    Headers["Accept"] = "accept";
    Headers["ContentType"] = "content-type";
})(Headers = exports.Headers || (exports.Headers = {}));
var MediaTypes;
(function (MediaTypes) {
    MediaTypes["ApplicationJson"] = "application/json";
})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
/**
 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
 */
function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : '';
}
exports.getProxyUrl = getProxyUrl;
const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
];
const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
];
const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
const ExponentialBackoffCeiling = 10;
const ExponentialBackoffTimeSlice = 5;
class HttpClientError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = 'HttpClientError';
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
    }
}
exports.HttpClientError = HttpClientError;
class HttpClientResponse {
    constructor(message) {
        this.message = message;
    }
    readBody() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                let output = Buffer.alloc(0);
                this.message.on('data', (chunk) => {
                    output = Buffer.concat([output, chunk]);
                });
                this.message.on('end', () => {
                    resolve(output.toString());
                });
            }));
        });
    }
    readBodyBuffer() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                const chunks = [];
                this.message.on('data', (chunk) => {
                    chunks.push(chunk);
                });
                this.message.on('end', () => {
                    resolve(Buffer.concat(chunks));
                });
            }));
        });
    }
}
exports.HttpClientResponse = HttpClientResponse;
function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === 'https:';
}
exports.isHttps = isHttps;
class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
                this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
                this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
                this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
                this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
                this._maxRetries = requestOptions.maxRetries;
            }
        }
    }
    options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
        });
    }
    get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('GET', requestUrl, null, additionalHeaders || {});
        });
    }
    del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('DELETE', requestUrl, null, additionalHeaders || {});
        });
    }
    post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('POST', requestUrl, data, additionalHeaders || {});
        });
    }
    patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PATCH', requestUrl, data, additionalHeaders || {});
        });
    }
    put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PUT', requestUrl, data, additionalHeaders || {});
        });
    }
    head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('HEAD', requestUrl, null, additionalHeaders || {});
        });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request(verb, requestUrl, stream, additionalHeaders);
        });
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            const res = yield this.get(requestUrl, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.post(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.put(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.patch(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._disposed) {
                throw new Error('Client has already been disposed.');
            }
            const parsedUrl = new URL(requestUrl);
            let info = this._prepareRequest(verb, parsedUrl, headers);
            // Only perform retries on reads since writes may not be idempotent.
            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)
                ? this._maxRetries + 1
                : 1;
            let numTries = 0;
            let response;
            do {
                response = yield this.requestRaw(info, data);
                // Check if it's an authentication challenge
                if (response &&
                    response.message &&
                    response.message.statusCode === HttpCodes.Unauthorized) {
                    let authenticationHandler;
                    for (const handler of this.handlers) {
                        if (handler.canHandleAuthentication(response)) {
                            authenticationHandler = handler;
                            break;
                        }
                    }
                    if (authenticationHandler) {
                        return authenticationHandler.handleAuthentication(this, info, data);
                    }
                    else {
                        // We have received an unauthorized response but have no handlers to handle it.
                        // Let the response return to the caller.
                        return response;
                    }
                }
                let redirectsRemaining = this._maxRedirects;
                while (response.message.statusCode &&
                    HttpRedirectCodes.includes(response.message.statusCode) &&
                    this._allowRedirects &&
                    redirectsRemaining > 0) {
                    const redirectUrl = response.message.headers['location'];
                    if (!redirectUrl) {
                        // if there's no location to redirect to, we won't
                        break;
                    }
                    const parsedRedirectUrl = new URL(redirectUrl);
                    if (parsedUrl.protocol === 'https:' &&
                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&
                        !this._allowRedirectDowngrade) {
                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                    }
                    // we need to finish reading the response before reassigning response
                    // which will leak the open socket.
                    yield response.readBody();
                    // strip authorization header if redirected to a different hostname
                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                        for (const header in headers) {
                            // header names are case insensitive
                            if (header.toLowerCase() === 'authorization') {
                                delete headers[header];
                            }
                        }
                    }
                    // let's make the request with the new redirectUrl
                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                    response = yield this.requestRaw(info, data);
                    redirectsRemaining--;
                }
                if (!response.message.statusCode ||
                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {
                    // If not a retry code, return immediately instead of retrying
                    return response;
                }
                numTries += 1;
                if (numTries < maxTries) {
                    yield response.readBody();
                    yield this._performExponentialBackoff(numTries);
                }
            } while (numTries < maxTries);
            return response;
        });
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
        if (this._agent) {
            this._agent.destroy();
        }
        this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                function callbackForResult(err, res) {
                    if (err) {
                        reject(err);
                    }
                    else if (!res) {
                        // If `err` is not passed, then `res` must be passed.
                        reject(new Error('Unknown error'));
                    }
                    else {
                        resolve(res);
                    }
                }
                this.requestRawWithCallback(info, data, callbackForResult);
            });
        });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
        if (typeof data === 'string') {
            if (!info.options.headers) {
                info.options.headers = {};
            }
            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
        }
        let callbackCalled = false;
        function handleResult(err, res) {
            if (!callbackCalled) {
                callbackCalled = true;
                onResult(err, res);
            }
        }
        const req = info.httpModule.request(info.options, (msg) => {
            const res = new HttpClientResponse(msg);
            handleResult(undefined, res);
        });
        let socket;
        req.on('socket', sock => {
            socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
                socket.end();
            }
            handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err);
        });
        if (data && typeof data === 'string') {
            req.write(data, 'utf8');
        }
        if (data && typeof data !== 'string') {
            data.on('close', function () {
                req.end();
            });
            data.pipe(req);
        }
        else {
            req.end();
        }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === 'https:';
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port
            ? parseInt(info.parsedUrl.port)
            : defaultPort;
        info.options.path =
            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
            info.options.headers['user-agent'] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        // gives handlers an opportunity to participate
        if (this.handlers) {
            for (const handler of this.handlers) {
                handler.prepareRequest(info.options);
            }
        }
        return info;
    }
    _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
            agent = this._agent;
        }
        // if agent is already assigned use that agent.
        if (agent) {
            return agent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        let maxSockets = 100;
        if (this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
        if (proxyUrl && proxyUrl.hostname) {
            const agentOptions = {
                maxSockets,
                keepAlive: this._keepAlive,
                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {
                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
                })), { host: proxyUrl.hostname, port: proxyUrl.port })
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === 'https:';
            if (usingSsl) {
                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            }
            else {
                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
        }
        // if reusing agent across request and tunneling agent isn't assigned create a new agent
        if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
        }
        // if not using private agent and tunnel agent isn't setup then use global agent
        if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
                rejectUnauthorized: false
            });
        }
        return agent;
    }
    _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
            return new Promise(resolve => setTimeout(() => resolve(), ms));
        });
    }
    _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const statusCode = res.message.statusCode || 0;
                const response = {
                    statusCode,
                    result: null,
                    headers: {}
                };
                // not found leads to null obj returned
                if (statusCode === HttpCodes.NotFound) {
                    resolve(response);
                }
                // get the result from the body
                function dateTimeDeserializer(key, value) {
                    if (typeof value === 'string') {
                        const a = new Date(value);
                        if (!isNaN(a.valueOf())) {
                            return a;
                        }
                    }
                    return value;
                }
                let obj;
                let contents;
                try {
                    contents = yield res.readBody();
                    if (contents && contents.length > 0) {
                        if (options && options.deserializeDates) {
                            obj = JSON.parse(contents, dateTimeDeserializer);
                        }
                        else {
                            obj = JSON.parse(contents);
                        }
                        response.result = obj;
                    }
                    response.headers = res.message.headers;
                }
                catch (err) {
                    // Invalid resource (contents not json);  leaving result obj null
                }
                // note that 3xx redirects are handled by the http layer.
                if (statusCode > 299) {
                    let msg;
                    // if exception/error in body, attempt to get better error
                    if (obj && obj.message) {
                        msg = obj.message;
                    }
                    else if (contents && contents.length > 0) {
                        // it may be the case that the exception is in the body message as string
                        msg = contents;
                    }
                    else {
                        msg = `Failed request: (${statusCode})`;
                    }
                    const err = new HttpClientError(msg, statusCode);
                    err.result = response.result;
                    reject(err);
                }
                else {
                    resolve(response);
                }
            }));
        });
    }
}
exports.HttpClient = HttpClient;
const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 19835:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkBypass = exports.getProxyUrl = void 0;
function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === 'https:';
    if (checkBypass(reqUrl)) {
        return undefined;
    }
    const proxyVar = (() => {
        if (usingSsl) {
            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
        }
        else {
            return process.env['http_proxy'] || process.env['HTTP_PROXY'];
        }
    })();
    if (proxyVar) {
        try {
            return new URL(proxyVar);
        }
        catch (_a) {
            if (!proxyVar.startsWith('http://') && !proxyVar.startsWith('https://'))
                return new URL(`http://${proxyVar}`);
        }
    }
    else {
        return undefined;
    }
}
exports.getProxyUrl = getProxyUrl;
function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
        return false;
    }
    const reqHost = reqUrl.hostname;
    if (isLoopbackAddress(reqHost)) {
        return true;
    }
    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
    if (!noProxy) {
        return false;
    }
    // Determine the request port
    let reqPort;
    if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
    }
    else if (reqUrl.protocol === 'http:') {
        reqPort = 80;
    }
    else if (reqUrl.protocol === 'https:') {
        reqPort = 443;
    }
    // Format the request hostname and hostname with port
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === 'number') {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    // Compare request host against noproxy
    for (const upperNoProxyItem of noProxy
        .split(',')
        .map(x => x.trim().toUpperCase())
        .filter(x => x)) {
        if (upperNoProxyItem === '*' ||
            upperReqHosts.some(x => x === upperNoProxyItem ||
                x.endsWith(`.${upperNoProxyItem}`) ||
                (upperNoProxyItem.startsWith('.') &&
                    x.endsWith(`${upperNoProxyItem}`)))) {
            return true;
        }
    }
    return false;
}
exports.checkBypass = checkBypass;
function isLoopbackAddress(host) {
    const hostLower = host.toLowerCase();
    return (hostLower === 'localhost' ||
        hostLower.startsWith('127.') ||
        hostLower.startsWith('[::1]') ||
        hostLower.startsWith('[0:0:0:0:0:0:0:1]'));
}
//# sourceMappingURL=proxy.js.map

/***/ }),

/***/ 32374:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AwsCrc32 = void 0;
var tslib_1 = __nccwpck_require__(5066);
var util_1 = __nccwpck_require__(41236);
var index_1 = __nccwpck_require__(47327);
var AwsCrc32 = /** @class */ (function () {
    function AwsCrc32() {
        this.crc32 = new index_1.Crc32();
    }
    AwsCrc32.prototype.update = function (toHash) {
        if ((0, util_1.isEmptyData)(toHash))
            return;
        this.crc32.update((0, util_1.convertToBuffer)(toHash));
    };
    AwsCrc32.prototype.digest = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, (0, util_1.numToUint8)(this.crc32.digest())];
            });
        });
    };
    AwsCrc32.prototype.reset = function () {
        this.crc32 = new index_1.Crc32();
    };
    return AwsCrc32;
}());
exports.AwsCrc32 = AwsCrc32;
//# sourceMappingURL=aws_crc32.js.map

/***/ }),

/***/ 47327:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AwsCrc32 = exports.Crc32 = exports.crc32 = void 0;
var tslib_1 = __nccwpck_require__(5066);
var util_1 = __nccwpck_require__(41236);
function crc32(data) {
    return new Crc32().update(data).digest();
}
exports.crc32 = crc32;
var Crc32 = /** @class */ (function () {
    function Crc32() {
        this.checksum = 0xffffffff;
    }
    Crc32.prototype.update = function (data) {
        var e_1, _a;
        try {
            for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                var byte = data_1_1.value;
                this.checksum =
                    (this.checksum >>> 8) ^ lookupTable[(this.checksum ^ byte) & 0xff];
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return this;
    };
    Crc32.prototype.digest = function () {
        return (this.checksum ^ 0xffffffff) >>> 0;
    };
    return Crc32;
}());
exports.Crc32 = Crc32;
// prettier-ignore
var a_lookUpTable = [
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D,
];
var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookUpTable);
var aws_crc32_1 = __nccwpck_require__(32374);
Object.defineProperty(exports, "AwsCrc32", ({ enumerable: true, get: function () { return aws_crc32_1.AwsCrc32; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 5066:
/***/ ((module) => {

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
var __classPrivateFieldGet;
var __classPrivateFieldSet;
var __createBinding;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if ( true && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __createBinding = function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __spreadArrays = function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result["default"] = mod;
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    __classPrivateFieldGet = function (receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    };

    __classPrivateFieldSet = function (receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
});


/***/ }),

/***/ 85651:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AwsCrc32c = void 0;
var tslib_1 = __nccwpck_require__(22831);
var util_1 = __nccwpck_require__(41236);
var index_1 = __nccwpck_require__(27507);
var AwsCrc32c = /** @class */ (function () {
    function AwsCrc32c() {
        this.crc32c = new index_1.Crc32c();
    }
    AwsCrc32c.prototype.update = function (toHash) {
        if ((0, util_1.isEmptyData)(toHash))
            return;
        this.crc32c.update((0, util_1.convertToBuffer)(toHash));
    };
    AwsCrc32c.prototype.digest = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, (0, util_1.numToUint8)(this.crc32c.digest())];
            });
        });
    };
    AwsCrc32c.prototype.reset = function () {
        this.crc32c = new index_1.Crc32c();
    };
    return AwsCrc32c;
}());
exports.AwsCrc32c = AwsCrc32c;
//# sourceMappingURL=aws_crc32c.js.map

/***/ }),

/***/ 27507:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AwsCrc32c = exports.Crc32c = exports.crc32c = void 0;
var tslib_1 = __nccwpck_require__(22831);
var util_1 = __nccwpck_require__(41236);
function crc32c(data) {
    return new Crc32c().update(data).digest();
}
exports.crc32c = crc32c;
var Crc32c = /** @class */ (function () {
    function Crc32c() {
        this.checksum = 0xffffffff;
    }
    Crc32c.prototype.update = function (data) {
        var e_1, _a;
        try {
            for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                var byte = data_1_1.value;
                this.checksum =
                    (this.checksum >>> 8) ^ lookupTable[(this.checksum ^ byte) & 0xff];
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return this;
    };
    Crc32c.prototype.digest = function () {
        return (this.checksum ^ 0xffffffff) >>> 0;
    };
    return Crc32c;
}());
exports.Crc32c = Crc32c;
// prettier-ignore
var a_lookupTable = [
    0x00000000, 0xF26B8303, 0xE13B70F7, 0x1350F3F4, 0xC79A971F, 0x35F1141C, 0x26A1E7E8, 0xD4CA64EB,
    0x8AD958CF, 0x78B2DBCC, 0x6BE22838, 0x9989AB3B, 0x4D43CFD0, 0xBF284CD3, 0xAC78BF27, 0x5E133C24,
    0x105EC76F, 0xE235446C, 0xF165B798, 0x030E349B, 0xD7C45070, 0x25AFD373, 0x36FF2087, 0xC494A384,
    0x9A879FA0, 0x68EC1CA3, 0x7BBCEF57, 0x89D76C54, 0x5D1D08BF, 0xAF768BBC, 0xBC267848, 0x4E4DFB4B,
    0x20BD8EDE, 0xD2D60DDD, 0xC186FE29, 0x33ED7D2A, 0xE72719C1, 0x154C9AC2, 0x061C6936, 0xF477EA35,
    0xAA64D611, 0x580F5512, 0x4B5FA6E6, 0xB93425E5, 0x6DFE410E, 0x9F95C20D, 0x8CC531F9, 0x7EAEB2FA,
    0x30E349B1, 0xC288CAB2, 0xD1D83946, 0x23B3BA45, 0xF779DEAE, 0x05125DAD, 0x1642AE59, 0xE4292D5A,
    0xBA3A117E, 0x4851927D, 0x5B016189, 0xA96AE28A, 0x7DA08661, 0x8FCB0562, 0x9C9BF696, 0x6EF07595,
    0x417B1DBC, 0xB3109EBF, 0xA0406D4B, 0x522BEE48, 0x86E18AA3, 0x748A09A0, 0x67DAFA54, 0x95B17957,
    0xCBA24573, 0x39C9C670, 0x2A993584, 0xD8F2B687, 0x0C38D26C, 0xFE53516F, 0xED03A29B, 0x1F682198,
    0x5125DAD3, 0xA34E59D0, 0xB01EAA24, 0x42752927, 0x96BF4DCC, 0x64D4CECF, 0x77843D3B, 0x85EFBE38,
    0xDBFC821C, 0x2997011F, 0x3AC7F2EB, 0xC8AC71E8, 0x1C661503, 0xEE0D9600, 0xFD5D65F4, 0x0F36E6F7,
    0x61C69362, 0x93AD1061, 0x80FDE395, 0x72966096, 0xA65C047D, 0x5437877E, 0x4767748A, 0xB50CF789,
    0xEB1FCBAD, 0x197448AE, 0x0A24BB5A, 0xF84F3859, 0x2C855CB2, 0xDEEEDFB1, 0xCDBE2C45, 0x3FD5AF46,
    0x7198540D, 0x83F3D70E, 0x90A324FA, 0x62C8A7F9, 0xB602C312, 0x44694011, 0x5739B3E5, 0xA55230E6,
    0xFB410CC2, 0x092A8FC1, 0x1A7A7C35, 0xE811FF36, 0x3CDB9BDD, 0xCEB018DE, 0xDDE0EB2A, 0x2F8B6829,
    0x82F63B78, 0x709DB87B, 0x63CD4B8F, 0x91A6C88C, 0x456CAC67, 0xB7072F64, 0xA457DC90, 0x563C5F93,
    0x082F63B7, 0xFA44E0B4, 0xE9141340, 0x1B7F9043, 0xCFB5F4A8, 0x3DDE77AB, 0x2E8E845F, 0xDCE5075C,
    0x92A8FC17, 0x60C37F14, 0x73938CE0, 0x81F80FE3, 0x55326B08, 0xA759E80B, 0xB4091BFF, 0x466298FC,
    0x1871A4D8, 0xEA1A27DB, 0xF94AD42F, 0x0B21572C, 0xDFEB33C7, 0x2D80B0C4, 0x3ED04330, 0xCCBBC033,
    0xA24BB5A6, 0x502036A5, 0x4370C551, 0xB11B4652, 0x65D122B9, 0x97BAA1BA, 0x84EA524E, 0x7681D14D,
    0x2892ED69, 0xDAF96E6A, 0xC9A99D9E, 0x3BC21E9D, 0xEF087A76, 0x1D63F975, 0x0E330A81, 0xFC588982,
    0xB21572C9, 0x407EF1CA, 0x532E023E, 0xA145813D, 0x758FE5D6, 0x87E466D5, 0x94B49521, 0x66DF1622,
    0x38CC2A06, 0xCAA7A905, 0xD9F75AF1, 0x2B9CD9F2, 0xFF56BD19, 0x0D3D3E1A, 0x1E6DCDEE, 0xEC064EED,
    0xC38D26C4, 0x31E6A5C7, 0x22B65633, 0xD0DDD530, 0x0417B1DB, 0xF67C32D8, 0xE52CC12C, 0x1747422F,
    0x49547E0B, 0xBB3FFD08, 0xA86F0EFC, 0x5A048DFF, 0x8ECEE914, 0x7CA56A17, 0x6FF599E3, 0x9D9E1AE0,
    0xD3D3E1AB, 0x21B862A8, 0x32E8915C, 0xC083125F, 0x144976B4, 0xE622F5B7, 0xF5720643, 0x07198540,
    0x590AB964, 0xAB613A67, 0xB831C993, 0x4A5A4A90, 0x9E902E7B, 0x6CFBAD78, 0x7FAB5E8C, 0x8DC0DD8F,
    0xE330A81A, 0x115B2B19, 0x020BD8ED, 0xF0605BEE, 0x24AA3F05, 0xD6C1BC06, 0xC5914FF2, 0x37FACCF1,
    0x69E9F0D5, 0x9B8273D6, 0x88D28022, 0x7AB90321, 0xAE7367CA, 0x5C18E4C9, 0x4F48173D, 0xBD23943E,
    0xF36E6F75, 0x0105EC76, 0x12551F82, 0xE03E9C81, 0x34F4F86A, 0xC69F7B69, 0xD5CF889D, 0x27A40B9E,
    0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351,
];
var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookupTable);
var aws_crc32c_1 = __nccwpck_require__(85651);
Object.defineProperty(exports, "AwsCrc32c", ({ enumerable: true, get: function () { return aws_crc32c_1.AwsCrc32c; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 22831:
/***/ ((module) => {

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
var __classPrivateFieldGet;
var __classPrivateFieldSet;
var __createBinding;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if ( true && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __createBinding = function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __spreadArrays = function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result["default"] = mod;
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    __classPrivateFieldGet = function (receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    };

    __classPrivateFieldSet = function (receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
});


/***/ }),

/***/ 43228:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertToBuffer = void 0;
var util_utf8_browser_1 = __nccwpck_require__(28172);
// Quick polyfill
var fromUtf8 = typeof Buffer !== "undefined" && Buffer.from
    ? function (input) { return Buffer.from(input, "utf8"); }
    : util_utf8_browser_1.fromUtf8;
function convertToBuffer(data) {
    // Already a Uint8, do nothing
    if (data instanceof Uint8Array)
        return data;
    if (typeof data === "string") {
        return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
}
exports.convertToBuffer = convertToBuffer;
//# sourceMappingURL=convertToBuffer.js.map

/***/ }),

/***/ 41236:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
var convertToBuffer_1 = __nccwpck_require__(43228);
Object.defineProperty(exports, "convertToBuffer", ({ enumerable: true, get: function () { return convertToBuffer_1.convertToBuffer; } }));
var isEmptyData_1 = __nccwpck_require__(18275);
Object.defineProperty(exports, "isEmptyData", ({ enumerable: true, get: function () { return isEmptyData_1.isEmptyData; } }));
var numToUint8_1 = __nccwpck_require__(93775);
Object.defineProperty(exports, "numToUint8", ({ enumerable: true, get: function () { return numToUint8_1.numToUint8; } }));
var uint32ArrayFrom_1 = __nccwpck_require__(39404);
Object.defineProperty(exports, "uint32ArrayFrom", ({ enumerable: true, get: function () { return uint32ArrayFrom_1.uint32ArrayFrom; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 18275:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isEmptyData = void 0;
function isEmptyData(data) {
    if (typeof data === "string") {
        return data.length === 0;
    }
    return data.byteLength === 0;
}
exports.isEmptyData = isEmptyData;
//# sourceMappingURL=isEmptyData.js.map

/***/ }),

/***/ 93775:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.numToUint8 = void 0;
function numToUint8(num) {
    return new Uint8Array([
        (num & 0xff000000) >> 24,
        (num & 0x00ff0000) >> 16,
        (num & 0x0000ff00) >> 8,
        num & 0x000000ff,
    ]);
}
exports.numToUint8 = numToUint8;
//# sourceMappingURL=numToUint8.js.map

/***/ }),

/***/ 39404:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uint32ArrayFrom = void 0;
// IE 11 does not support Array.from, so we do it manually
function uint32ArrayFrom(a_lookUpTable) {
    if (!Uint32Array.from) {
        var return_array = new Uint32Array(a_lookUpTable.length);
        var a_index = 0;
        while (a_index < a_lookUpTable.length) {
            return_array[a_index] = a_lookUpTable[a_index];
            a_index += 1;
        }
        return return_array;
    }
    return Uint32Array.from(a_lookUpTable);
}
exports.uint32ArrayFrom = uint32ArrayFrom;
//# sourceMappingURL=uint32ArrayFrom.js.map

/***/ }),

/***/ 43546:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudFront = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const CloudFrontClient_1 = __nccwpck_require__(59397);
const AssociateAliasCommand_1 = __nccwpck_require__(44154);
const CopyDistributionCommand_1 = __nccwpck_require__(38992);
const CreateCachePolicyCommand_1 = __nccwpck_require__(64787);
const CreateCloudFrontOriginAccessIdentityCommand_1 = __nccwpck_require__(7974);
const CreateContinuousDeploymentPolicyCommand_1 = __nccwpck_require__(27271);
const CreateDistributionCommand_1 = __nccwpck_require__(23482);
const CreateDistributionWithTagsCommand_1 = __nccwpck_require__(67399);
const CreateFieldLevelEncryptionConfigCommand_1 = __nccwpck_require__(66484);
const CreateFieldLevelEncryptionProfileCommand_1 = __nccwpck_require__(27893);
const CreateFunctionCommand_1 = __nccwpck_require__(48883);
const CreateInvalidationCommand_1 = __nccwpck_require__(79113);
const CreateKeyGroupCommand_1 = __nccwpck_require__(59033);
const CreateKeyValueStoreCommand_1 = __nccwpck_require__(13992);
const CreateMonitoringSubscriptionCommand_1 = __nccwpck_require__(93508);
const CreateOriginAccessControlCommand_1 = __nccwpck_require__(91109);
const CreateOriginRequestPolicyCommand_1 = __nccwpck_require__(97230);
const CreatePublicKeyCommand_1 = __nccwpck_require__(84954);
const CreateRealtimeLogConfigCommand_1 = __nccwpck_require__(602);
const CreateResponseHeadersPolicyCommand_1 = __nccwpck_require__(86066);
const CreateStreamingDistributionCommand_1 = __nccwpck_require__(7186);
const CreateStreamingDistributionWithTagsCommand_1 = __nccwpck_require__(57717);
const DeleteCachePolicyCommand_1 = __nccwpck_require__(29881);
const DeleteCloudFrontOriginAccessIdentityCommand_1 = __nccwpck_require__(78381);
const DeleteContinuousDeploymentPolicyCommand_1 = __nccwpck_require__(81934);
const DeleteDistributionCommand_1 = __nccwpck_require__(17292);
const DeleteFieldLevelEncryptionConfigCommand_1 = __nccwpck_require__(95507);
const DeleteFieldLevelEncryptionProfileCommand_1 = __nccwpck_require__(77942);
const DeleteFunctionCommand_1 = __nccwpck_require__(42889);
const DeleteKeyGroupCommand_1 = __nccwpck_require__(20380);
const DeleteKeyValueStoreCommand_1 = __nccwpck_require__(14838);
const DeleteMonitoringSubscriptionCommand_1 = __nccwpck_require__(13716);
const DeleteOriginAccessControlCommand_1 = __nccwpck_require__(66869);
const DeleteOriginRequestPolicyCommand_1 = __nccwpck_require__(28399);
const DeletePublicKeyCommand_1 = __nccwpck_require__(92155);
const DeleteRealtimeLogConfigCommand_1 = __nccwpck_require__(66380);
const DeleteResponseHeadersPolicyCommand_1 = __nccwpck_require__(61490);
const DeleteStreamingDistributionCommand_1 = __nccwpck_require__(96770);
const DescribeFunctionCommand_1 = __nccwpck_require__(49756);
const DescribeKeyValueStoreCommand_1 = __nccwpck_require__(91605);
const GetCachePolicyCommand_1 = __nccwpck_require__(75298);
const GetCachePolicyConfigCommand_1 = __nccwpck_require__(77669);
const GetCloudFrontOriginAccessIdentityCommand_1 = __nccwpck_require__(63955);
const GetCloudFrontOriginAccessIdentityConfigCommand_1 = __nccwpck_require__(70758);
const GetContinuousDeploymentPolicyCommand_1 = __nccwpck_require__(71071);
const GetContinuousDeploymentPolicyConfigCommand_1 = __nccwpck_require__(76109);
const GetDistributionCommand_1 = __nccwpck_require__(13290);
const GetDistributionConfigCommand_1 = __nccwpck_require__(46437);
const GetFieldLevelEncryptionCommand_1 = __nccwpck_require__(10741);
const GetFieldLevelEncryptionConfigCommand_1 = __nccwpck_require__(42847);
const GetFieldLevelEncryptionProfileCommand_1 = __nccwpck_require__(68768);
const GetFieldLevelEncryptionProfileConfigCommand_1 = __nccwpck_require__(68693);
const GetFunctionCommand_1 = __nccwpck_require__(95407);
const GetInvalidationCommand_1 = __nccwpck_require__(93931);
const GetKeyGroupCommand_1 = __nccwpck_require__(7156);
const GetKeyGroupConfigCommand_1 = __nccwpck_require__(81892);
const GetMonitoringSubscriptionCommand_1 = __nccwpck_require__(91938);
const GetOriginAccessControlCommand_1 = __nccwpck_require__(77599);
const GetOriginAccessControlConfigCommand_1 = __nccwpck_require__(49799);
const GetOriginRequestPolicyCommand_1 = __nccwpck_require__(14325);
const GetOriginRequestPolicyConfigCommand_1 = __nccwpck_require__(19125);
const GetPublicKeyCommand_1 = __nccwpck_require__(67029);
const GetPublicKeyConfigCommand_1 = __nccwpck_require__(22573);
const GetRealtimeLogConfigCommand_1 = __nccwpck_require__(98488);
const GetResponseHeadersPolicyCommand_1 = __nccwpck_require__(37342);
const GetResponseHeadersPolicyConfigCommand_1 = __nccwpck_require__(56804);
const GetStreamingDistributionCommand_1 = __nccwpck_require__(23846);
const GetStreamingDistributionConfigCommand_1 = __nccwpck_require__(75823);
const ListCachePoliciesCommand_1 = __nccwpck_require__(2602);
const ListCloudFrontOriginAccessIdentitiesCommand_1 = __nccwpck_require__(74932);
const ListConflictingAliasesCommand_1 = __nccwpck_require__(81860);
const ListContinuousDeploymentPoliciesCommand_1 = __nccwpck_require__(97910);
const ListDistributionsByCachePolicyIdCommand_1 = __nccwpck_require__(18103);
const ListDistributionsByKeyGroupCommand_1 = __nccwpck_require__(10329);
const ListDistributionsByOriginRequestPolicyIdCommand_1 = __nccwpck_require__(79703);
const ListDistributionsByRealtimeLogConfigCommand_1 = __nccwpck_require__(1570);
const ListDistributionsByResponseHeadersPolicyIdCommand_1 = __nccwpck_require__(42162);
const ListDistributionsByWebACLIdCommand_1 = __nccwpck_require__(37570);
const ListDistributionsCommand_1 = __nccwpck_require__(80928);
const ListFieldLevelEncryptionConfigsCommand_1 = __nccwpck_require__(24871);
const ListFieldLevelEncryptionProfilesCommand_1 = __nccwpck_require__(88042);
const ListFunctionsCommand_1 = __nccwpck_require__(24603);
const ListInvalidationsCommand_1 = __nccwpck_require__(65495);
const ListKeyGroupsCommand_1 = __nccwpck_require__(63118);
const ListKeyValueStoresCommand_1 = __nccwpck_require__(95246);
const ListOriginAccessControlsCommand_1 = __nccwpck_require__(30976);
const ListOriginRequestPoliciesCommand_1 = __nccwpck_require__(62175);
const ListPublicKeysCommand_1 = __nccwpck_require__(50336);
const ListRealtimeLogConfigsCommand_1 = __nccwpck_require__(56172);
const ListResponseHeadersPoliciesCommand_1 = __nccwpck_require__(58751);
const ListStreamingDistributionsCommand_1 = __nccwpck_require__(83635);
const ListTagsForResourceCommand_1 = __nccwpck_require__(38093);
const PublishFunctionCommand_1 = __nccwpck_require__(20442);
const TagResourceCommand_1 = __nccwpck_require__(53320);
const TestFunctionCommand_1 = __nccwpck_require__(19154);
const UntagResourceCommand_1 = __nccwpck_require__(44877);
const UpdateCachePolicyCommand_1 = __nccwpck_require__(8205);
const UpdateCloudFrontOriginAccessIdentityCommand_1 = __nccwpck_require__(47646);
const UpdateContinuousDeploymentPolicyCommand_1 = __nccwpck_require__(68555);
const UpdateDistributionCommand_1 = __nccwpck_require__(79123);
const UpdateDistributionWithStagingConfigCommand_1 = __nccwpck_require__(57562);
const UpdateFieldLevelEncryptionConfigCommand_1 = __nccwpck_require__(97650);
const UpdateFieldLevelEncryptionProfileCommand_1 = __nccwpck_require__(95833);
const UpdateFunctionCommand_1 = __nccwpck_require__(63324);
const UpdateKeyGroupCommand_1 = __nccwpck_require__(24172);
const UpdateKeyValueStoreCommand_1 = __nccwpck_require__(53244);
const UpdateOriginAccessControlCommand_1 = __nccwpck_require__(91408);
const UpdateOriginRequestPolicyCommand_1 = __nccwpck_require__(53753);
const UpdatePublicKeyCommand_1 = __nccwpck_require__(78571);
const UpdateRealtimeLogConfigCommand_1 = __nccwpck_require__(37922);
const UpdateResponseHeadersPolicyCommand_1 = __nccwpck_require__(41523);
const UpdateStreamingDistributionCommand_1 = __nccwpck_require__(3621);
const commands = {
    AssociateAliasCommand: AssociateAliasCommand_1.AssociateAliasCommand,
    CopyDistributionCommand: CopyDistributionCommand_1.CopyDistributionCommand,
    CreateCachePolicyCommand: CreateCachePolicyCommand_1.CreateCachePolicyCommand,
    CreateCloudFrontOriginAccessIdentityCommand: CreateCloudFrontOriginAccessIdentityCommand_1.CreateCloudFrontOriginAccessIdentityCommand,
    CreateContinuousDeploymentPolicyCommand: CreateContinuousDeploymentPolicyCommand_1.CreateContinuousDeploymentPolicyCommand,
    CreateDistributionCommand: CreateDistributionCommand_1.CreateDistributionCommand,
    CreateDistributionWithTagsCommand: CreateDistributionWithTagsCommand_1.CreateDistributionWithTagsCommand,
    CreateFieldLevelEncryptionConfigCommand: CreateFieldLevelEncryptionConfigCommand_1.CreateFieldLevelEncryptionConfigCommand,
    CreateFieldLevelEncryptionProfileCommand: CreateFieldLevelEncryptionProfileCommand_1.CreateFieldLevelEncryptionProfileCommand,
    CreateFunctionCommand: CreateFunctionCommand_1.CreateFunctionCommand,
    CreateInvalidationCommand: CreateInvalidationCommand_1.CreateInvalidationCommand,
    CreateKeyGroupCommand: CreateKeyGroupCommand_1.CreateKeyGroupCommand,
    CreateKeyValueStoreCommand: CreateKeyValueStoreCommand_1.CreateKeyValueStoreCommand,
    CreateMonitoringSubscriptionCommand: CreateMonitoringSubscriptionCommand_1.CreateMonitoringSubscriptionCommand,
    CreateOriginAccessControlCommand: CreateOriginAccessControlCommand_1.CreateOriginAccessControlCommand,
    CreateOriginRequestPolicyCommand: CreateOriginRequestPolicyCommand_1.CreateOriginRequestPolicyCommand,
    CreatePublicKeyCommand: CreatePublicKeyCommand_1.CreatePublicKeyCommand,
    CreateRealtimeLogConfigCommand: CreateRealtimeLogConfigCommand_1.CreateRealtimeLogConfigCommand,
    CreateResponseHeadersPolicyCommand: CreateResponseHeadersPolicyCommand_1.CreateResponseHeadersPolicyCommand,
    CreateStreamingDistributionCommand: CreateStreamingDistributionCommand_1.CreateStreamingDistributionCommand,
    CreateStreamingDistributionWithTagsCommand: CreateStreamingDistributionWithTagsCommand_1.CreateStreamingDistributionWithTagsCommand,
    DeleteCachePolicyCommand: DeleteCachePolicyCommand_1.DeleteCachePolicyCommand,
    DeleteCloudFrontOriginAccessIdentityCommand: DeleteCloudFrontOriginAccessIdentityCommand_1.DeleteCloudFrontOriginAccessIdentityCommand,
    DeleteContinuousDeploymentPolicyCommand: DeleteContinuousDeploymentPolicyCommand_1.DeleteContinuousDeploymentPolicyCommand,
    DeleteDistributionCommand: DeleteDistributionCommand_1.DeleteDistributionCommand,
    DeleteFieldLevelEncryptionConfigCommand: DeleteFieldLevelEncryptionConfigCommand_1.DeleteFieldLevelEncryptionConfigCommand,
    DeleteFieldLevelEncryptionProfileCommand: DeleteFieldLevelEncryptionProfileCommand_1.DeleteFieldLevelEncryptionProfileCommand,
    DeleteFunctionCommand: DeleteFunctionCommand_1.DeleteFunctionCommand,
    DeleteKeyGroupCommand: DeleteKeyGroupCommand_1.DeleteKeyGroupCommand,
    DeleteKeyValueStoreCommand: DeleteKeyValueStoreCommand_1.DeleteKeyValueStoreCommand,
    DeleteMonitoringSubscriptionCommand: DeleteMonitoringSubscriptionCommand_1.DeleteMonitoringSubscriptionCommand,
    DeleteOriginAccessControlCommand: DeleteOriginAccessControlCommand_1.DeleteOriginAccessControlCommand,
    DeleteOriginRequestPolicyCommand: DeleteOriginRequestPolicyCommand_1.DeleteOriginRequestPolicyCommand,
    DeletePublicKeyCommand: DeletePublicKeyCommand_1.DeletePublicKeyCommand,
    DeleteRealtimeLogConfigCommand: DeleteRealtimeLogConfigCommand_1.DeleteRealtimeLogConfigCommand,
    DeleteResponseHeadersPolicyCommand: DeleteResponseHeadersPolicyCommand_1.DeleteResponseHeadersPolicyCommand,
    DeleteStreamingDistributionCommand: DeleteStreamingDistributionCommand_1.DeleteStreamingDistributionCommand,
    DescribeFunctionCommand: DescribeFunctionCommand_1.DescribeFunctionCommand,
    DescribeKeyValueStoreCommand: DescribeKeyValueStoreCommand_1.DescribeKeyValueStoreCommand,
    GetCachePolicyCommand: GetCachePolicyCommand_1.GetCachePolicyCommand,
    GetCachePolicyConfigCommand: GetCachePolicyConfigCommand_1.GetCachePolicyConfigCommand,
    GetCloudFrontOriginAccessIdentityCommand: GetCloudFrontOriginAccessIdentityCommand_1.GetCloudFrontOriginAccessIdentityCommand,
    GetCloudFrontOriginAccessIdentityConfigCommand: GetCloudFrontOriginAccessIdentityConfigCommand_1.GetCloudFrontOriginAccessIdentityConfigCommand,
    GetContinuousDeploymentPolicyCommand: GetContinuousDeploymentPolicyCommand_1.GetContinuousDeploymentPolicyCommand,
    GetContinuousDeploymentPolicyConfigCommand: GetContinuousDeploymentPolicyConfigCommand_1.GetContinuousDeploymentPolicyConfigCommand,
    GetDistributionCommand: GetDistributionCommand_1.GetDistributionCommand,
    GetDistributionConfigCommand: GetDistributionConfigCommand_1.GetDistributionConfigCommand,
    GetFieldLevelEncryptionCommand: GetFieldLevelEncryptionCommand_1.GetFieldLevelEncryptionCommand,
    GetFieldLevelEncryptionConfigCommand: GetFieldLevelEncryptionConfigCommand_1.GetFieldLevelEncryptionConfigCommand,
    GetFieldLevelEncryptionProfileCommand: GetFieldLevelEncryptionProfileCommand_1.GetFieldLevelEncryptionProfileCommand,
    GetFieldLevelEncryptionProfileConfigCommand: GetFieldLevelEncryptionProfileConfigCommand_1.GetFieldLevelEncryptionProfileConfigCommand,
    GetFunctionCommand: GetFunctionCommand_1.GetFunctionCommand,
    GetInvalidationCommand: GetInvalidationCommand_1.GetInvalidationCommand,
    GetKeyGroupCommand: GetKeyGroupCommand_1.GetKeyGroupCommand,
    GetKeyGroupConfigCommand: GetKeyGroupConfigCommand_1.GetKeyGroupConfigCommand,
    GetMonitoringSubscriptionCommand: GetMonitoringSubscriptionCommand_1.GetMonitoringSubscriptionCommand,
    GetOriginAccessControlCommand: GetOriginAccessControlCommand_1.GetOriginAccessControlCommand,
    GetOriginAccessControlConfigCommand: GetOriginAccessControlConfigCommand_1.GetOriginAccessControlConfigCommand,
    GetOriginRequestPolicyCommand: GetOriginRequestPolicyCommand_1.GetOriginRequestPolicyCommand,
    GetOriginRequestPolicyConfigCommand: GetOriginRequestPolicyConfigCommand_1.GetOriginRequestPolicyConfigCommand,
    GetPublicKeyCommand: GetPublicKeyCommand_1.GetPublicKeyCommand,
    GetPublicKeyConfigCommand: GetPublicKeyConfigCommand_1.GetPublicKeyConfigCommand,
    GetRealtimeLogConfigCommand: GetRealtimeLogConfigCommand_1.GetRealtimeLogConfigCommand,
    GetResponseHeadersPolicyCommand: GetResponseHeadersPolicyCommand_1.GetResponseHeadersPolicyCommand,
    GetResponseHeadersPolicyConfigCommand: GetResponseHeadersPolicyConfigCommand_1.GetResponseHeadersPolicyConfigCommand,
    GetStreamingDistributionCommand: GetStreamingDistributionCommand_1.GetStreamingDistributionCommand,
    GetStreamingDistributionConfigCommand: GetStreamingDistributionConfigCommand_1.GetStreamingDistributionConfigCommand,
    ListCachePoliciesCommand: ListCachePoliciesCommand_1.ListCachePoliciesCommand,
    ListCloudFrontOriginAccessIdentitiesCommand: ListCloudFrontOriginAccessIdentitiesCommand_1.ListCloudFrontOriginAccessIdentitiesCommand,
    ListConflictingAliasesCommand: ListConflictingAliasesCommand_1.ListConflictingAliasesCommand,
    ListContinuousDeploymentPoliciesCommand: ListContinuousDeploymentPoliciesCommand_1.ListContinuousDeploymentPoliciesCommand,
    ListDistributionsCommand: ListDistributionsCommand_1.ListDistributionsCommand,
    ListDistributionsByCachePolicyIdCommand: ListDistributionsByCachePolicyIdCommand_1.ListDistributionsByCachePolicyIdCommand,
    ListDistributionsByKeyGroupCommand: ListDistributionsByKeyGroupCommand_1.ListDistributionsByKeyGroupCommand,
    ListDistributionsByOriginRequestPolicyIdCommand: ListDistributionsByOriginRequestPolicyIdCommand_1.ListDistributionsByOriginRequestPolicyIdCommand,
    ListDistributionsByRealtimeLogConfigCommand: ListDistributionsByRealtimeLogConfigCommand_1.ListDistributionsByRealtimeLogConfigCommand,
    ListDistributionsByResponseHeadersPolicyIdCommand: ListDistributionsByResponseHeadersPolicyIdCommand_1.ListDistributionsByResponseHeadersPolicyIdCommand,
    ListDistributionsByWebACLIdCommand: ListDistributionsByWebACLIdCommand_1.ListDistributionsByWebACLIdCommand,
    ListFieldLevelEncryptionConfigsCommand: ListFieldLevelEncryptionConfigsCommand_1.ListFieldLevelEncryptionConfigsCommand,
    ListFieldLevelEncryptionProfilesCommand: ListFieldLevelEncryptionProfilesCommand_1.ListFieldLevelEncryptionProfilesCommand,
    ListFunctionsCommand: ListFunctionsCommand_1.ListFunctionsCommand,
    ListInvalidationsCommand: ListInvalidationsCommand_1.ListInvalidationsCommand,
    ListKeyGroupsCommand: ListKeyGroupsCommand_1.ListKeyGroupsCommand,
    ListKeyValueStoresCommand: ListKeyValueStoresCommand_1.ListKeyValueStoresCommand,
    ListOriginAccessControlsCommand: ListOriginAccessControlsCommand_1.ListOriginAccessControlsCommand,
    ListOriginRequestPoliciesCommand: ListOriginRequestPoliciesCommand_1.ListOriginRequestPoliciesCommand,
    ListPublicKeysCommand: ListPublicKeysCommand_1.ListPublicKeysCommand,
    ListRealtimeLogConfigsCommand: ListRealtimeLogConfigsCommand_1.ListRealtimeLogConfigsCommand,
    ListResponseHeadersPoliciesCommand: ListResponseHeadersPoliciesCommand_1.ListResponseHeadersPoliciesCommand,
    ListStreamingDistributionsCommand: ListStreamingDistributionsCommand_1.ListStreamingDistributionsCommand,
    ListTagsForResourceCommand: ListTagsForResourceCommand_1.ListTagsForResourceCommand,
    PublishFunctionCommand: PublishFunctionCommand_1.PublishFunctionCommand,
    TagResourceCommand: TagResourceCommand_1.TagResourceCommand,
    TestFunctionCommand: TestFunctionCommand_1.TestFunctionCommand,
    UntagResourceCommand: UntagResourceCommand_1.UntagResourceCommand,
    UpdateCachePolicyCommand: UpdateCachePolicyCommand_1.UpdateCachePolicyCommand,
    UpdateCloudFrontOriginAccessIdentityCommand: UpdateCloudFrontOriginAccessIdentityCommand_1.UpdateCloudFrontOriginAccessIdentityCommand,
    UpdateContinuousDeploymentPolicyCommand: UpdateContinuousDeploymentPolicyCommand_1.UpdateContinuousDeploymentPolicyCommand,
    UpdateDistributionCommand: UpdateDistributionCommand_1.UpdateDistributionCommand,
    UpdateDistributionWithStagingConfigCommand: UpdateDistributionWithStagingConfigCommand_1.UpdateDistributionWithStagingConfigCommand,
    UpdateFieldLevelEncryptionConfigCommand: UpdateFieldLevelEncryptionConfigCommand_1.UpdateFieldLevelEncryptionConfigCommand,
    UpdateFieldLevelEncryptionProfileCommand: UpdateFieldLevelEncryptionProfileCommand_1.UpdateFieldLevelEncryptionProfileCommand,
    UpdateFunctionCommand: UpdateFunctionCommand_1.UpdateFunctionCommand,
    UpdateKeyGroupCommand: UpdateKeyGroupCommand_1.UpdateKeyGroupCommand,
    UpdateKeyValueStoreCommand: UpdateKeyValueStoreCommand_1.UpdateKeyValueStoreCommand,
    UpdateOriginAccessControlCommand: UpdateOriginAccessControlCommand_1.UpdateOriginAccessControlCommand,
    UpdateOriginRequestPolicyCommand: UpdateOriginRequestPolicyCommand_1.UpdateOriginRequestPolicyCommand,
    UpdatePublicKeyCommand: UpdatePublicKeyCommand_1.UpdatePublicKeyCommand,
    UpdateRealtimeLogConfigCommand: UpdateRealtimeLogConfigCommand_1.UpdateRealtimeLogConfigCommand,
    UpdateResponseHeadersPolicyCommand: UpdateResponseHeadersPolicyCommand_1.UpdateResponseHeadersPolicyCommand,
    UpdateStreamingDistributionCommand: UpdateStreamingDistributionCommand_1.UpdateStreamingDistributionCommand,
};
class CloudFront extends CloudFrontClient_1.CloudFrontClient {
}
exports.CloudFront = CloudFront;
(0, smithy_client_1.createAggregatedClient)(commands, CloudFront);


/***/ }),

/***/ 59397:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudFrontClient = exports.__Client = void 0;
const middleware_host_header_1 = __nccwpck_require__(22545);
const middleware_logger_1 = __nccwpck_require__(20014);
const middleware_recursion_detection_1 = __nccwpck_require__(85525);
const middleware_signing_1 = __nccwpck_require__(14935);
const middleware_user_agent_1 = __nccwpck_require__(64688);
const config_resolver_1 = __nccwpck_require__(53098);
const middleware_content_length_1 = __nccwpck_require__(82800);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_retry_1 = __nccwpck_require__(96039);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "__Client", ({ enumerable: true, get: function () { return smithy_client_1.Client; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const runtimeConfig_1 = __nccwpck_require__(49895);
const runtimeExtensions_1 = __nccwpck_require__(44124);
class CloudFrontClient extends smithy_client_1.Client {
    constructor(...[configuration]) {
        const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration || {});
        const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_signing_1.resolveAwsAuthConfig)(_config_5);
        const _config_7 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_6);
        const _config_8 = (0, runtimeExtensions_1.resolveRuntimeExtensions)(_config_7, configuration?.extensions || []);
        super(_config_8);
        this.config = _config_8;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}
exports.CloudFrontClient = CloudFrontClient;


/***/ }),

/***/ 44154:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssociateAliasCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class AssociateAliasCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "AssociateAlias", {})
    .n("CloudFrontClient", "AssociateAliasCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_AssociateAliasCommand)
    .de(Aws_restXml_1.de_AssociateAliasCommand)
    .build() {
}
exports.AssociateAliasCommand = AssociateAliasCommand;


/***/ }),

/***/ 38992:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CopyDistributionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const models_0_1 = __nccwpck_require__(52996);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CopyDistributionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CopyDistribution", {})
    .n("CloudFrontClient", "CopyDistributionCommand")
    .f(void 0, models_0_1.CopyDistributionResultFilterSensitiveLog)
    .ser(Aws_restXml_1.se_CopyDistributionCommand)
    .de(Aws_restXml_1.de_CopyDistributionCommand)
    .build() {
}
exports.CopyDistributionCommand = CopyDistributionCommand;


/***/ }),

/***/ 64787:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateCachePolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreateCachePolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreateCachePolicy", {})
    .n("CloudFrontClient", "CreateCachePolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_CreateCachePolicyCommand)
    .de(Aws_restXml_1.de_CreateCachePolicyCommand)
    .build() {
}
exports.CreateCachePolicyCommand = CreateCachePolicyCommand;


/***/ }),

/***/ 7974:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateCloudFrontOriginAccessIdentityCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreateCloudFrontOriginAccessIdentityCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreateCloudFrontOriginAccessIdentity", {})
    .n("CloudFrontClient", "CreateCloudFrontOriginAccessIdentityCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_CreateCloudFrontOriginAccessIdentityCommand)
    .de(Aws_restXml_1.de_CreateCloudFrontOriginAccessIdentityCommand)
    .build() {
}
exports.CreateCloudFrontOriginAccessIdentityCommand = CreateCloudFrontOriginAccessIdentityCommand;


/***/ }),

/***/ 27271:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateContinuousDeploymentPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreateContinuousDeploymentPolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreateContinuousDeploymentPolicy", {})
    .n("CloudFrontClient", "CreateContinuousDeploymentPolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_CreateContinuousDeploymentPolicyCommand)
    .de(Aws_restXml_1.de_CreateContinuousDeploymentPolicyCommand)
    .build() {
}
exports.CreateContinuousDeploymentPolicyCommand = CreateContinuousDeploymentPolicyCommand;


/***/ }),

/***/ 23482:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateDistributionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const models_0_1 = __nccwpck_require__(52996);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreateDistributionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreateDistribution", {})
    .n("CloudFrontClient", "CreateDistributionCommand")
    .f(models_0_1.CreateDistributionRequestFilterSensitiveLog, models_0_1.CreateDistributionResultFilterSensitiveLog)
    .ser(Aws_restXml_1.se_CreateDistributionCommand)
    .de(Aws_restXml_1.de_CreateDistributionCommand)
    .build() {
}
exports.CreateDistributionCommand = CreateDistributionCommand;


/***/ }),

/***/ 67399:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateDistributionWithTagsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const models_0_1 = __nccwpck_require__(52996);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreateDistributionWithTagsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreateDistributionWithTags", {})
    .n("CloudFrontClient", "CreateDistributionWithTagsCommand")
    .f(models_0_1.CreateDistributionWithTagsRequestFilterSensitiveLog, models_0_1.CreateDistributionWithTagsResultFilterSensitiveLog)
    .ser(Aws_restXml_1.se_CreateDistributionWithTagsCommand)
    .de(Aws_restXml_1.de_CreateDistributionWithTagsCommand)
    .build() {
}
exports.CreateDistributionWithTagsCommand = CreateDistributionWithTagsCommand;


/***/ }),

/***/ 66484:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateFieldLevelEncryptionConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreateFieldLevelEncryptionConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreateFieldLevelEncryptionConfig", {})
    .n("CloudFrontClient", "CreateFieldLevelEncryptionConfigCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_CreateFieldLevelEncryptionConfigCommand)
    .de(Aws_restXml_1.de_CreateFieldLevelEncryptionConfigCommand)
    .build() {
}
exports.CreateFieldLevelEncryptionConfigCommand = CreateFieldLevelEncryptionConfigCommand;


/***/ }),

/***/ 27893:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateFieldLevelEncryptionProfileCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreateFieldLevelEncryptionProfileCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreateFieldLevelEncryptionProfile", {})
    .n("CloudFrontClient", "CreateFieldLevelEncryptionProfileCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_CreateFieldLevelEncryptionProfileCommand)
    .de(Aws_restXml_1.de_CreateFieldLevelEncryptionProfileCommand)
    .build() {
}
exports.CreateFieldLevelEncryptionProfileCommand = CreateFieldLevelEncryptionProfileCommand;


/***/ }),

/***/ 48883:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateFunctionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const models_0_1 = __nccwpck_require__(52996);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreateFunctionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreateFunction", {})
    .n("CloudFrontClient", "CreateFunctionCommand")
    .f(models_0_1.CreateFunctionRequestFilterSensitiveLog, void 0)
    .ser(Aws_restXml_1.se_CreateFunctionCommand)
    .de(Aws_restXml_1.de_CreateFunctionCommand)
    .build() {
}
exports.CreateFunctionCommand = CreateFunctionCommand;


/***/ }),

/***/ 79113:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateInvalidationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreateInvalidationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreateInvalidation", {})
    .n("CloudFrontClient", "CreateInvalidationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_CreateInvalidationCommand)
    .de(Aws_restXml_1.de_CreateInvalidationCommand)
    .build() {
}
exports.CreateInvalidationCommand = CreateInvalidationCommand;


/***/ }),

/***/ 59033:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateKeyGroupCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreateKeyGroupCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreateKeyGroup", {})
    .n("CloudFrontClient", "CreateKeyGroupCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_CreateKeyGroupCommand)
    .de(Aws_restXml_1.de_CreateKeyGroupCommand)
    .build() {
}
exports.CreateKeyGroupCommand = CreateKeyGroupCommand;


/***/ }),

/***/ 13992:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateKeyValueStoreCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreateKeyValueStoreCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreateKeyValueStore", {})
    .n("CloudFrontClient", "CreateKeyValueStoreCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_CreateKeyValueStoreCommand)
    .de(Aws_restXml_1.de_CreateKeyValueStoreCommand)
    .build() {
}
exports.CreateKeyValueStoreCommand = CreateKeyValueStoreCommand;


/***/ }),

/***/ 93508:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateMonitoringSubscriptionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreateMonitoringSubscriptionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreateMonitoringSubscription", {})
    .n("CloudFrontClient", "CreateMonitoringSubscriptionCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_CreateMonitoringSubscriptionCommand)
    .de(Aws_restXml_1.de_CreateMonitoringSubscriptionCommand)
    .build() {
}
exports.CreateMonitoringSubscriptionCommand = CreateMonitoringSubscriptionCommand;


/***/ }),

/***/ 91109:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateOriginAccessControlCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreateOriginAccessControlCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreateOriginAccessControl", {})
    .n("CloudFrontClient", "CreateOriginAccessControlCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_CreateOriginAccessControlCommand)
    .de(Aws_restXml_1.de_CreateOriginAccessControlCommand)
    .build() {
}
exports.CreateOriginAccessControlCommand = CreateOriginAccessControlCommand;


/***/ }),

/***/ 97230:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateOriginRequestPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreateOriginRequestPolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreateOriginRequestPolicy", {})
    .n("CloudFrontClient", "CreateOriginRequestPolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_CreateOriginRequestPolicyCommand)
    .de(Aws_restXml_1.de_CreateOriginRequestPolicyCommand)
    .build() {
}
exports.CreateOriginRequestPolicyCommand = CreateOriginRequestPolicyCommand;


/***/ }),

/***/ 84954:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreatePublicKeyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreatePublicKeyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreatePublicKey", {})
    .n("CloudFrontClient", "CreatePublicKeyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_CreatePublicKeyCommand)
    .de(Aws_restXml_1.de_CreatePublicKeyCommand)
    .build() {
}
exports.CreatePublicKeyCommand = CreatePublicKeyCommand;


/***/ }),

/***/ 602:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateRealtimeLogConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreateRealtimeLogConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreateRealtimeLogConfig", {})
    .n("CloudFrontClient", "CreateRealtimeLogConfigCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_CreateRealtimeLogConfigCommand)
    .de(Aws_restXml_1.de_CreateRealtimeLogConfigCommand)
    .build() {
}
exports.CreateRealtimeLogConfigCommand = CreateRealtimeLogConfigCommand;


/***/ }),

/***/ 86066:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateResponseHeadersPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreateResponseHeadersPolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreateResponseHeadersPolicy", {})
    .n("CloudFrontClient", "CreateResponseHeadersPolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_CreateResponseHeadersPolicyCommand)
    .de(Aws_restXml_1.de_CreateResponseHeadersPolicyCommand)
    .build() {
}
exports.CreateResponseHeadersPolicyCommand = CreateResponseHeadersPolicyCommand;


/***/ }),

/***/ 7186:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateStreamingDistributionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreateStreamingDistributionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreateStreamingDistribution", {})
    .n("CloudFrontClient", "CreateStreamingDistributionCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_CreateStreamingDistributionCommand)
    .de(Aws_restXml_1.de_CreateStreamingDistributionCommand)
    .build() {
}
exports.CreateStreamingDistributionCommand = CreateStreamingDistributionCommand;


/***/ }),

/***/ 57717:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateStreamingDistributionWithTagsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class CreateStreamingDistributionWithTagsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "CreateStreamingDistributionWithTags", {})
    .n("CloudFrontClient", "CreateStreamingDistributionWithTagsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_CreateStreamingDistributionWithTagsCommand)
    .de(Aws_restXml_1.de_CreateStreamingDistributionWithTagsCommand)
    .build() {
}
exports.CreateStreamingDistributionWithTagsCommand = CreateStreamingDistributionWithTagsCommand;


/***/ }),

/***/ 29881:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteCachePolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class DeleteCachePolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "DeleteCachePolicy", {})
    .n("CloudFrontClient", "DeleteCachePolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteCachePolicyCommand)
    .de(Aws_restXml_1.de_DeleteCachePolicyCommand)
    .build() {
}
exports.DeleteCachePolicyCommand = DeleteCachePolicyCommand;


/***/ }),

/***/ 78381:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteCloudFrontOriginAccessIdentityCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class DeleteCloudFrontOriginAccessIdentityCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "DeleteCloudFrontOriginAccessIdentity", {})
    .n("CloudFrontClient", "DeleteCloudFrontOriginAccessIdentityCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteCloudFrontOriginAccessIdentityCommand)
    .de(Aws_restXml_1.de_DeleteCloudFrontOriginAccessIdentityCommand)
    .build() {
}
exports.DeleteCloudFrontOriginAccessIdentityCommand = DeleteCloudFrontOriginAccessIdentityCommand;


/***/ }),

/***/ 81934:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteContinuousDeploymentPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class DeleteContinuousDeploymentPolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "DeleteContinuousDeploymentPolicy", {})
    .n("CloudFrontClient", "DeleteContinuousDeploymentPolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteContinuousDeploymentPolicyCommand)
    .de(Aws_restXml_1.de_DeleteContinuousDeploymentPolicyCommand)
    .build() {
}
exports.DeleteContinuousDeploymentPolicyCommand = DeleteContinuousDeploymentPolicyCommand;


/***/ }),

/***/ 17292:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteDistributionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class DeleteDistributionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "DeleteDistribution", {})
    .n("CloudFrontClient", "DeleteDistributionCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteDistributionCommand)
    .de(Aws_restXml_1.de_DeleteDistributionCommand)
    .build() {
}
exports.DeleteDistributionCommand = DeleteDistributionCommand;


/***/ }),

/***/ 95507:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteFieldLevelEncryptionConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class DeleteFieldLevelEncryptionConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "DeleteFieldLevelEncryptionConfig", {})
    .n("CloudFrontClient", "DeleteFieldLevelEncryptionConfigCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteFieldLevelEncryptionConfigCommand)
    .de(Aws_restXml_1.de_DeleteFieldLevelEncryptionConfigCommand)
    .build() {
}
exports.DeleteFieldLevelEncryptionConfigCommand = DeleteFieldLevelEncryptionConfigCommand;


/***/ }),

/***/ 77942:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteFieldLevelEncryptionProfileCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class DeleteFieldLevelEncryptionProfileCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "DeleteFieldLevelEncryptionProfile", {})
    .n("CloudFrontClient", "DeleteFieldLevelEncryptionProfileCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteFieldLevelEncryptionProfileCommand)
    .de(Aws_restXml_1.de_DeleteFieldLevelEncryptionProfileCommand)
    .build() {
}
exports.DeleteFieldLevelEncryptionProfileCommand = DeleteFieldLevelEncryptionProfileCommand;


/***/ }),

/***/ 42889:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteFunctionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class DeleteFunctionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "DeleteFunction", {})
    .n("CloudFrontClient", "DeleteFunctionCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteFunctionCommand)
    .de(Aws_restXml_1.de_DeleteFunctionCommand)
    .build() {
}
exports.DeleteFunctionCommand = DeleteFunctionCommand;


/***/ }),

/***/ 20380:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteKeyGroupCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class DeleteKeyGroupCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "DeleteKeyGroup", {})
    .n("CloudFrontClient", "DeleteKeyGroupCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteKeyGroupCommand)
    .de(Aws_restXml_1.de_DeleteKeyGroupCommand)
    .build() {
}
exports.DeleteKeyGroupCommand = DeleteKeyGroupCommand;


/***/ }),

/***/ 14838:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteKeyValueStoreCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class DeleteKeyValueStoreCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "DeleteKeyValueStore", {})
    .n("CloudFrontClient", "DeleteKeyValueStoreCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteKeyValueStoreCommand)
    .de(Aws_restXml_1.de_DeleteKeyValueStoreCommand)
    .build() {
}
exports.DeleteKeyValueStoreCommand = DeleteKeyValueStoreCommand;


/***/ }),

/***/ 13716:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteMonitoringSubscriptionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class DeleteMonitoringSubscriptionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "DeleteMonitoringSubscription", {})
    .n("CloudFrontClient", "DeleteMonitoringSubscriptionCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteMonitoringSubscriptionCommand)
    .de(Aws_restXml_1.de_DeleteMonitoringSubscriptionCommand)
    .build() {
}
exports.DeleteMonitoringSubscriptionCommand = DeleteMonitoringSubscriptionCommand;


/***/ }),

/***/ 66869:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteOriginAccessControlCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class DeleteOriginAccessControlCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "DeleteOriginAccessControl", {})
    .n("CloudFrontClient", "DeleteOriginAccessControlCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteOriginAccessControlCommand)
    .de(Aws_restXml_1.de_DeleteOriginAccessControlCommand)
    .build() {
}
exports.DeleteOriginAccessControlCommand = DeleteOriginAccessControlCommand;


/***/ }),

/***/ 28399:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteOriginRequestPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class DeleteOriginRequestPolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "DeleteOriginRequestPolicy", {})
    .n("CloudFrontClient", "DeleteOriginRequestPolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteOriginRequestPolicyCommand)
    .de(Aws_restXml_1.de_DeleteOriginRequestPolicyCommand)
    .build() {
}
exports.DeleteOriginRequestPolicyCommand = DeleteOriginRequestPolicyCommand;


/***/ }),

/***/ 92155:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeletePublicKeyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class DeletePublicKeyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "DeletePublicKey", {})
    .n("CloudFrontClient", "DeletePublicKeyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeletePublicKeyCommand)
    .de(Aws_restXml_1.de_DeletePublicKeyCommand)
    .build() {
}
exports.DeletePublicKeyCommand = DeletePublicKeyCommand;


/***/ }),

/***/ 66380:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteRealtimeLogConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class DeleteRealtimeLogConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "DeleteRealtimeLogConfig", {})
    .n("CloudFrontClient", "DeleteRealtimeLogConfigCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteRealtimeLogConfigCommand)
    .de(Aws_restXml_1.de_DeleteRealtimeLogConfigCommand)
    .build() {
}
exports.DeleteRealtimeLogConfigCommand = DeleteRealtimeLogConfigCommand;


/***/ }),

/***/ 61490:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteResponseHeadersPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class DeleteResponseHeadersPolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "DeleteResponseHeadersPolicy", {})
    .n("CloudFrontClient", "DeleteResponseHeadersPolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteResponseHeadersPolicyCommand)
    .de(Aws_restXml_1.de_DeleteResponseHeadersPolicyCommand)
    .build() {
}
exports.DeleteResponseHeadersPolicyCommand = DeleteResponseHeadersPolicyCommand;


/***/ }),

/***/ 96770:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteStreamingDistributionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class DeleteStreamingDistributionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "DeleteStreamingDistribution", {})
    .n("CloudFrontClient", "DeleteStreamingDistributionCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteStreamingDistributionCommand)
    .de(Aws_restXml_1.de_DeleteStreamingDistributionCommand)
    .build() {
}
exports.DeleteStreamingDistributionCommand = DeleteStreamingDistributionCommand;


/***/ }),

/***/ 49756:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeFunctionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class DescribeFunctionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "DescribeFunction", {})
    .n("CloudFrontClient", "DescribeFunctionCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DescribeFunctionCommand)
    .de(Aws_restXml_1.de_DescribeFunctionCommand)
    .build() {
}
exports.DescribeFunctionCommand = DescribeFunctionCommand;


/***/ }),

/***/ 91605:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescribeKeyValueStoreCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class DescribeKeyValueStoreCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "DescribeKeyValueStore", {})
    .n("CloudFrontClient", "DescribeKeyValueStoreCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DescribeKeyValueStoreCommand)
    .de(Aws_restXml_1.de_DescribeKeyValueStoreCommand)
    .build() {
}
exports.DescribeKeyValueStoreCommand = DescribeKeyValueStoreCommand;


/***/ }),

/***/ 75298:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetCachePolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetCachePolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetCachePolicy", {})
    .n("CloudFrontClient", "GetCachePolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetCachePolicyCommand)
    .de(Aws_restXml_1.de_GetCachePolicyCommand)
    .build() {
}
exports.GetCachePolicyCommand = GetCachePolicyCommand;


/***/ }),

/***/ 77669:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetCachePolicyConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetCachePolicyConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetCachePolicyConfig", {})
    .n("CloudFrontClient", "GetCachePolicyConfigCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetCachePolicyConfigCommand)
    .de(Aws_restXml_1.de_GetCachePolicyConfigCommand)
    .build() {
}
exports.GetCachePolicyConfigCommand = GetCachePolicyConfigCommand;


/***/ }),

/***/ 63955:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetCloudFrontOriginAccessIdentityCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetCloudFrontOriginAccessIdentityCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetCloudFrontOriginAccessIdentity", {})
    .n("CloudFrontClient", "GetCloudFrontOriginAccessIdentityCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetCloudFrontOriginAccessIdentityCommand)
    .de(Aws_restXml_1.de_GetCloudFrontOriginAccessIdentityCommand)
    .build() {
}
exports.GetCloudFrontOriginAccessIdentityCommand = GetCloudFrontOriginAccessIdentityCommand;


/***/ }),

/***/ 70758:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetCloudFrontOriginAccessIdentityConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetCloudFrontOriginAccessIdentityConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetCloudFrontOriginAccessIdentityConfig", {})
    .n("CloudFrontClient", "GetCloudFrontOriginAccessIdentityConfigCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetCloudFrontOriginAccessIdentityConfigCommand)
    .de(Aws_restXml_1.de_GetCloudFrontOriginAccessIdentityConfigCommand)
    .build() {
}
exports.GetCloudFrontOriginAccessIdentityConfigCommand = GetCloudFrontOriginAccessIdentityConfigCommand;


/***/ }),

/***/ 71071:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetContinuousDeploymentPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetContinuousDeploymentPolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetContinuousDeploymentPolicy", {})
    .n("CloudFrontClient", "GetContinuousDeploymentPolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetContinuousDeploymentPolicyCommand)
    .de(Aws_restXml_1.de_GetContinuousDeploymentPolicyCommand)
    .build() {
}
exports.GetContinuousDeploymentPolicyCommand = GetContinuousDeploymentPolicyCommand;


/***/ }),

/***/ 76109:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetContinuousDeploymentPolicyConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetContinuousDeploymentPolicyConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetContinuousDeploymentPolicyConfig", {})
    .n("CloudFrontClient", "GetContinuousDeploymentPolicyConfigCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetContinuousDeploymentPolicyConfigCommand)
    .de(Aws_restXml_1.de_GetContinuousDeploymentPolicyConfigCommand)
    .build() {
}
exports.GetContinuousDeploymentPolicyConfigCommand = GetContinuousDeploymentPolicyConfigCommand;


/***/ }),

/***/ 13290:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDistributionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const models_1_1 = __nccwpck_require__(76429);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetDistributionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetDistribution", {})
    .n("CloudFrontClient", "GetDistributionCommand")
    .f(void 0, models_1_1.GetDistributionResultFilterSensitiveLog)
    .ser(Aws_restXml_1.se_GetDistributionCommand)
    .de(Aws_restXml_1.de_GetDistributionCommand)
    .build() {
}
exports.GetDistributionCommand = GetDistributionCommand;


/***/ }),

/***/ 46437:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDistributionConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const models_1_1 = __nccwpck_require__(76429);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetDistributionConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetDistributionConfig", {})
    .n("CloudFrontClient", "GetDistributionConfigCommand")
    .f(void 0, models_1_1.GetDistributionConfigResultFilterSensitiveLog)
    .ser(Aws_restXml_1.se_GetDistributionConfigCommand)
    .de(Aws_restXml_1.de_GetDistributionConfigCommand)
    .build() {
}
exports.GetDistributionConfigCommand = GetDistributionConfigCommand;


/***/ }),

/***/ 10741:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetFieldLevelEncryptionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetFieldLevelEncryptionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetFieldLevelEncryption", {})
    .n("CloudFrontClient", "GetFieldLevelEncryptionCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetFieldLevelEncryptionCommand)
    .de(Aws_restXml_1.de_GetFieldLevelEncryptionCommand)
    .build() {
}
exports.GetFieldLevelEncryptionCommand = GetFieldLevelEncryptionCommand;


/***/ }),

/***/ 42847:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetFieldLevelEncryptionConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetFieldLevelEncryptionConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetFieldLevelEncryptionConfig", {})
    .n("CloudFrontClient", "GetFieldLevelEncryptionConfigCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetFieldLevelEncryptionConfigCommand)
    .de(Aws_restXml_1.de_GetFieldLevelEncryptionConfigCommand)
    .build() {
}
exports.GetFieldLevelEncryptionConfigCommand = GetFieldLevelEncryptionConfigCommand;


/***/ }),

/***/ 68768:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetFieldLevelEncryptionProfileCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetFieldLevelEncryptionProfileCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetFieldLevelEncryptionProfile", {})
    .n("CloudFrontClient", "GetFieldLevelEncryptionProfileCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetFieldLevelEncryptionProfileCommand)
    .de(Aws_restXml_1.de_GetFieldLevelEncryptionProfileCommand)
    .build() {
}
exports.GetFieldLevelEncryptionProfileCommand = GetFieldLevelEncryptionProfileCommand;


/***/ }),

/***/ 68693:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetFieldLevelEncryptionProfileConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetFieldLevelEncryptionProfileConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetFieldLevelEncryptionProfileConfig", {})
    .n("CloudFrontClient", "GetFieldLevelEncryptionProfileConfigCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetFieldLevelEncryptionProfileConfigCommand)
    .de(Aws_restXml_1.de_GetFieldLevelEncryptionProfileConfigCommand)
    .build() {
}
exports.GetFieldLevelEncryptionProfileConfigCommand = GetFieldLevelEncryptionProfileConfigCommand;


/***/ }),

/***/ 95407:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetFunctionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const models_1_1 = __nccwpck_require__(76429);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetFunctionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetFunction", {})
    .n("CloudFrontClient", "GetFunctionCommand")
    .f(void 0, models_1_1.GetFunctionResultFilterSensitiveLog)
    .ser(Aws_restXml_1.se_GetFunctionCommand)
    .de(Aws_restXml_1.de_GetFunctionCommand)
    .build() {
}
exports.GetFunctionCommand = GetFunctionCommand;


/***/ }),

/***/ 93931:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetInvalidationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetInvalidationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetInvalidation", {})
    .n("CloudFrontClient", "GetInvalidationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetInvalidationCommand)
    .de(Aws_restXml_1.de_GetInvalidationCommand)
    .build() {
}
exports.GetInvalidationCommand = GetInvalidationCommand;


/***/ }),

/***/ 7156:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetKeyGroupCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetKeyGroupCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetKeyGroup", {})
    .n("CloudFrontClient", "GetKeyGroupCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetKeyGroupCommand)
    .de(Aws_restXml_1.de_GetKeyGroupCommand)
    .build() {
}
exports.GetKeyGroupCommand = GetKeyGroupCommand;


/***/ }),

/***/ 81892:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetKeyGroupConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetKeyGroupConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetKeyGroupConfig", {})
    .n("CloudFrontClient", "GetKeyGroupConfigCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetKeyGroupConfigCommand)
    .de(Aws_restXml_1.de_GetKeyGroupConfigCommand)
    .build() {
}
exports.GetKeyGroupConfigCommand = GetKeyGroupConfigCommand;


/***/ }),

/***/ 91938:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetMonitoringSubscriptionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetMonitoringSubscriptionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetMonitoringSubscription", {})
    .n("CloudFrontClient", "GetMonitoringSubscriptionCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetMonitoringSubscriptionCommand)
    .de(Aws_restXml_1.de_GetMonitoringSubscriptionCommand)
    .build() {
}
exports.GetMonitoringSubscriptionCommand = GetMonitoringSubscriptionCommand;


/***/ }),

/***/ 77599:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetOriginAccessControlCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetOriginAccessControlCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetOriginAccessControl", {})
    .n("CloudFrontClient", "GetOriginAccessControlCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetOriginAccessControlCommand)
    .de(Aws_restXml_1.de_GetOriginAccessControlCommand)
    .build() {
}
exports.GetOriginAccessControlCommand = GetOriginAccessControlCommand;


/***/ }),

/***/ 49799:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetOriginAccessControlConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetOriginAccessControlConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetOriginAccessControlConfig", {})
    .n("CloudFrontClient", "GetOriginAccessControlConfigCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetOriginAccessControlConfigCommand)
    .de(Aws_restXml_1.de_GetOriginAccessControlConfigCommand)
    .build() {
}
exports.GetOriginAccessControlConfigCommand = GetOriginAccessControlConfigCommand;


/***/ }),

/***/ 14325:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetOriginRequestPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetOriginRequestPolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetOriginRequestPolicy", {})
    .n("CloudFrontClient", "GetOriginRequestPolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetOriginRequestPolicyCommand)
    .de(Aws_restXml_1.de_GetOriginRequestPolicyCommand)
    .build() {
}
exports.GetOriginRequestPolicyCommand = GetOriginRequestPolicyCommand;


/***/ }),

/***/ 19125:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetOriginRequestPolicyConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetOriginRequestPolicyConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetOriginRequestPolicyConfig", {})
    .n("CloudFrontClient", "GetOriginRequestPolicyConfigCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetOriginRequestPolicyConfigCommand)
    .de(Aws_restXml_1.de_GetOriginRequestPolicyConfigCommand)
    .build() {
}
exports.GetOriginRequestPolicyConfigCommand = GetOriginRequestPolicyConfigCommand;


/***/ }),

/***/ 67029:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetPublicKeyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetPublicKeyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetPublicKey", {})
    .n("CloudFrontClient", "GetPublicKeyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetPublicKeyCommand)
    .de(Aws_restXml_1.de_GetPublicKeyCommand)
    .build() {
}
exports.GetPublicKeyCommand = GetPublicKeyCommand;


/***/ }),

/***/ 22573:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetPublicKeyConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetPublicKeyConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetPublicKeyConfig", {})
    .n("CloudFrontClient", "GetPublicKeyConfigCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetPublicKeyConfigCommand)
    .de(Aws_restXml_1.de_GetPublicKeyConfigCommand)
    .build() {
}
exports.GetPublicKeyConfigCommand = GetPublicKeyConfigCommand;


/***/ }),

/***/ 98488:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetRealtimeLogConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetRealtimeLogConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetRealtimeLogConfig", {})
    .n("CloudFrontClient", "GetRealtimeLogConfigCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetRealtimeLogConfigCommand)
    .de(Aws_restXml_1.de_GetRealtimeLogConfigCommand)
    .build() {
}
exports.GetRealtimeLogConfigCommand = GetRealtimeLogConfigCommand;


/***/ }),

/***/ 37342:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetResponseHeadersPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetResponseHeadersPolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetResponseHeadersPolicy", {})
    .n("CloudFrontClient", "GetResponseHeadersPolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetResponseHeadersPolicyCommand)
    .de(Aws_restXml_1.de_GetResponseHeadersPolicyCommand)
    .build() {
}
exports.GetResponseHeadersPolicyCommand = GetResponseHeadersPolicyCommand;


/***/ }),

/***/ 56804:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetResponseHeadersPolicyConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetResponseHeadersPolicyConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetResponseHeadersPolicyConfig", {})
    .n("CloudFrontClient", "GetResponseHeadersPolicyConfigCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetResponseHeadersPolicyConfigCommand)
    .de(Aws_restXml_1.de_GetResponseHeadersPolicyConfigCommand)
    .build() {
}
exports.GetResponseHeadersPolicyConfigCommand = GetResponseHeadersPolicyConfigCommand;


/***/ }),

/***/ 23846:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetStreamingDistributionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetStreamingDistributionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetStreamingDistribution", {})
    .n("CloudFrontClient", "GetStreamingDistributionCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetStreamingDistributionCommand)
    .de(Aws_restXml_1.de_GetStreamingDistributionCommand)
    .build() {
}
exports.GetStreamingDistributionCommand = GetStreamingDistributionCommand;


/***/ }),

/***/ 75823:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetStreamingDistributionConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class GetStreamingDistributionConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "GetStreamingDistributionConfig", {})
    .n("CloudFrontClient", "GetStreamingDistributionConfigCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetStreamingDistributionConfigCommand)
    .de(Aws_restXml_1.de_GetStreamingDistributionConfigCommand)
    .build() {
}
exports.GetStreamingDistributionConfigCommand = GetStreamingDistributionConfigCommand;


/***/ }),

/***/ 2602:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListCachePoliciesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListCachePoliciesCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListCachePolicies", {})
    .n("CloudFrontClient", "ListCachePoliciesCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListCachePoliciesCommand)
    .de(Aws_restXml_1.de_ListCachePoliciesCommand)
    .build() {
}
exports.ListCachePoliciesCommand = ListCachePoliciesCommand;


/***/ }),

/***/ 74932:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListCloudFrontOriginAccessIdentitiesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListCloudFrontOriginAccessIdentitiesCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListCloudFrontOriginAccessIdentities", {})
    .n("CloudFrontClient", "ListCloudFrontOriginAccessIdentitiesCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListCloudFrontOriginAccessIdentitiesCommand)
    .de(Aws_restXml_1.de_ListCloudFrontOriginAccessIdentitiesCommand)
    .build() {
}
exports.ListCloudFrontOriginAccessIdentitiesCommand = ListCloudFrontOriginAccessIdentitiesCommand;


/***/ }),

/***/ 81860:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListConflictingAliasesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListConflictingAliasesCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListConflictingAliases", {})
    .n("CloudFrontClient", "ListConflictingAliasesCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListConflictingAliasesCommand)
    .de(Aws_restXml_1.de_ListConflictingAliasesCommand)
    .build() {
}
exports.ListConflictingAliasesCommand = ListConflictingAliasesCommand;


/***/ }),

/***/ 97910:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListContinuousDeploymentPoliciesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListContinuousDeploymentPoliciesCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListContinuousDeploymentPolicies", {})
    .n("CloudFrontClient", "ListContinuousDeploymentPoliciesCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListContinuousDeploymentPoliciesCommand)
    .de(Aws_restXml_1.de_ListContinuousDeploymentPoliciesCommand)
    .build() {
}
exports.ListContinuousDeploymentPoliciesCommand = ListContinuousDeploymentPoliciesCommand;


/***/ }),

/***/ 18103:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListDistributionsByCachePolicyIdCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListDistributionsByCachePolicyIdCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListDistributionsByCachePolicyId", {})
    .n("CloudFrontClient", "ListDistributionsByCachePolicyIdCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListDistributionsByCachePolicyIdCommand)
    .de(Aws_restXml_1.de_ListDistributionsByCachePolicyIdCommand)
    .build() {
}
exports.ListDistributionsByCachePolicyIdCommand = ListDistributionsByCachePolicyIdCommand;


/***/ }),

/***/ 10329:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListDistributionsByKeyGroupCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListDistributionsByKeyGroupCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListDistributionsByKeyGroup", {})
    .n("CloudFrontClient", "ListDistributionsByKeyGroupCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListDistributionsByKeyGroupCommand)
    .de(Aws_restXml_1.de_ListDistributionsByKeyGroupCommand)
    .build() {
}
exports.ListDistributionsByKeyGroupCommand = ListDistributionsByKeyGroupCommand;


/***/ }),

/***/ 79703:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListDistributionsByOriginRequestPolicyIdCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListDistributionsByOriginRequestPolicyIdCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListDistributionsByOriginRequestPolicyId", {})
    .n("CloudFrontClient", "ListDistributionsByOriginRequestPolicyIdCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListDistributionsByOriginRequestPolicyIdCommand)
    .de(Aws_restXml_1.de_ListDistributionsByOriginRequestPolicyIdCommand)
    .build() {
}
exports.ListDistributionsByOriginRequestPolicyIdCommand = ListDistributionsByOriginRequestPolicyIdCommand;


/***/ }),

/***/ 1570:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListDistributionsByRealtimeLogConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const models_1_1 = __nccwpck_require__(76429);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListDistributionsByRealtimeLogConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListDistributionsByRealtimeLogConfig", {})
    .n("CloudFrontClient", "ListDistributionsByRealtimeLogConfigCommand")
    .f(void 0, models_1_1.ListDistributionsByRealtimeLogConfigResultFilterSensitiveLog)
    .ser(Aws_restXml_1.se_ListDistributionsByRealtimeLogConfigCommand)
    .de(Aws_restXml_1.de_ListDistributionsByRealtimeLogConfigCommand)
    .build() {
}
exports.ListDistributionsByRealtimeLogConfigCommand = ListDistributionsByRealtimeLogConfigCommand;


/***/ }),

/***/ 42162:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListDistributionsByResponseHeadersPolicyIdCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListDistributionsByResponseHeadersPolicyIdCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListDistributionsByResponseHeadersPolicyId", {})
    .n("CloudFrontClient", "ListDistributionsByResponseHeadersPolicyIdCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListDistributionsByResponseHeadersPolicyIdCommand)
    .de(Aws_restXml_1.de_ListDistributionsByResponseHeadersPolicyIdCommand)
    .build() {
}
exports.ListDistributionsByResponseHeadersPolicyIdCommand = ListDistributionsByResponseHeadersPolicyIdCommand;


/***/ }),

/***/ 37570:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListDistributionsByWebACLIdCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const models_1_1 = __nccwpck_require__(76429);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListDistributionsByWebACLIdCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListDistributionsByWebACLId", {})
    .n("CloudFrontClient", "ListDistributionsByWebACLIdCommand")
    .f(void 0, models_1_1.ListDistributionsByWebACLIdResultFilterSensitiveLog)
    .ser(Aws_restXml_1.se_ListDistributionsByWebACLIdCommand)
    .de(Aws_restXml_1.de_ListDistributionsByWebACLIdCommand)
    .build() {
}
exports.ListDistributionsByWebACLIdCommand = ListDistributionsByWebACLIdCommand;


/***/ }),

/***/ 80928:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListDistributionsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const models_1_1 = __nccwpck_require__(76429);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListDistributionsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListDistributions", {})
    .n("CloudFrontClient", "ListDistributionsCommand")
    .f(void 0, models_1_1.ListDistributionsResultFilterSensitiveLog)
    .ser(Aws_restXml_1.se_ListDistributionsCommand)
    .de(Aws_restXml_1.de_ListDistributionsCommand)
    .build() {
}
exports.ListDistributionsCommand = ListDistributionsCommand;


/***/ }),

/***/ 24871:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListFieldLevelEncryptionConfigsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListFieldLevelEncryptionConfigsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListFieldLevelEncryptionConfigs", {})
    .n("CloudFrontClient", "ListFieldLevelEncryptionConfigsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListFieldLevelEncryptionConfigsCommand)
    .de(Aws_restXml_1.de_ListFieldLevelEncryptionConfigsCommand)
    .build() {
}
exports.ListFieldLevelEncryptionConfigsCommand = ListFieldLevelEncryptionConfigsCommand;


/***/ }),

/***/ 88042:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListFieldLevelEncryptionProfilesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListFieldLevelEncryptionProfilesCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListFieldLevelEncryptionProfiles", {})
    .n("CloudFrontClient", "ListFieldLevelEncryptionProfilesCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListFieldLevelEncryptionProfilesCommand)
    .de(Aws_restXml_1.de_ListFieldLevelEncryptionProfilesCommand)
    .build() {
}
exports.ListFieldLevelEncryptionProfilesCommand = ListFieldLevelEncryptionProfilesCommand;


/***/ }),

/***/ 24603:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListFunctionsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListFunctionsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListFunctions", {})
    .n("CloudFrontClient", "ListFunctionsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListFunctionsCommand)
    .de(Aws_restXml_1.de_ListFunctionsCommand)
    .build() {
}
exports.ListFunctionsCommand = ListFunctionsCommand;


/***/ }),

/***/ 65495:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListInvalidationsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListInvalidationsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListInvalidations", {})
    .n("CloudFrontClient", "ListInvalidationsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListInvalidationsCommand)
    .de(Aws_restXml_1.de_ListInvalidationsCommand)
    .build() {
}
exports.ListInvalidationsCommand = ListInvalidationsCommand;


/***/ }),

/***/ 63118:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListKeyGroupsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListKeyGroupsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListKeyGroups", {})
    .n("CloudFrontClient", "ListKeyGroupsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListKeyGroupsCommand)
    .de(Aws_restXml_1.de_ListKeyGroupsCommand)
    .build() {
}
exports.ListKeyGroupsCommand = ListKeyGroupsCommand;


/***/ }),

/***/ 95246:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListKeyValueStoresCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListKeyValueStoresCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListKeyValueStores", {})
    .n("CloudFrontClient", "ListKeyValueStoresCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListKeyValueStoresCommand)
    .de(Aws_restXml_1.de_ListKeyValueStoresCommand)
    .build() {
}
exports.ListKeyValueStoresCommand = ListKeyValueStoresCommand;


/***/ }),

/***/ 30976:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListOriginAccessControlsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListOriginAccessControlsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListOriginAccessControls", {})
    .n("CloudFrontClient", "ListOriginAccessControlsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListOriginAccessControlsCommand)
    .de(Aws_restXml_1.de_ListOriginAccessControlsCommand)
    .build() {
}
exports.ListOriginAccessControlsCommand = ListOriginAccessControlsCommand;


/***/ }),

/***/ 62175:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListOriginRequestPoliciesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListOriginRequestPoliciesCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListOriginRequestPolicies", {})
    .n("CloudFrontClient", "ListOriginRequestPoliciesCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListOriginRequestPoliciesCommand)
    .de(Aws_restXml_1.de_ListOriginRequestPoliciesCommand)
    .build() {
}
exports.ListOriginRequestPoliciesCommand = ListOriginRequestPoliciesCommand;


/***/ }),

/***/ 50336:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListPublicKeysCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListPublicKeysCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListPublicKeys", {})
    .n("CloudFrontClient", "ListPublicKeysCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListPublicKeysCommand)
    .de(Aws_restXml_1.de_ListPublicKeysCommand)
    .build() {
}
exports.ListPublicKeysCommand = ListPublicKeysCommand;


/***/ }),

/***/ 56172:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListRealtimeLogConfigsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListRealtimeLogConfigsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListRealtimeLogConfigs", {})
    .n("CloudFrontClient", "ListRealtimeLogConfigsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListRealtimeLogConfigsCommand)
    .de(Aws_restXml_1.de_ListRealtimeLogConfigsCommand)
    .build() {
}
exports.ListRealtimeLogConfigsCommand = ListRealtimeLogConfigsCommand;


/***/ }),

/***/ 58751:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListResponseHeadersPoliciesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListResponseHeadersPoliciesCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListResponseHeadersPolicies", {})
    .n("CloudFrontClient", "ListResponseHeadersPoliciesCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListResponseHeadersPoliciesCommand)
    .de(Aws_restXml_1.de_ListResponseHeadersPoliciesCommand)
    .build() {
}
exports.ListResponseHeadersPoliciesCommand = ListResponseHeadersPoliciesCommand;


/***/ }),

/***/ 83635:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListStreamingDistributionsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListStreamingDistributionsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListStreamingDistributions", {})
    .n("CloudFrontClient", "ListStreamingDistributionsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListStreamingDistributionsCommand)
    .de(Aws_restXml_1.de_ListStreamingDistributionsCommand)
    .build() {
}
exports.ListStreamingDistributionsCommand = ListStreamingDistributionsCommand;


/***/ }),

/***/ 38093:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListTagsForResourceCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class ListTagsForResourceCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "ListTagsForResource", {})
    .n("CloudFrontClient", "ListTagsForResourceCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListTagsForResourceCommand)
    .de(Aws_restXml_1.de_ListTagsForResourceCommand)
    .build() {
}
exports.ListTagsForResourceCommand = ListTagsForResourceCommand;


/***/ }),

/***/ 20442:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PublishFunctionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class PublishFunctionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "PublishFunction", {})
    .n("CloudFrontClient", "PublishFunctionCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PublishFunctionCommand)
    .de(Aws_restXml_1.de_PublishFunctionCommand)
    .build() {
}
exports.PublishFunctionCommand = PublishFunctionCommand;


/***/ }),

/***/ 53320:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TagResourceCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class TagResourceCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "TagResource", {})
    .n("CloudFrontClient", "TagResourceCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_TagResourceCommand)
    .de(Aws_restXml_1.de_TagResourceCommand)
    .build() {
}
exports.TagResourceCommand = TagResourceCommand;


/***/ }),

/***/ 19154:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestFunctionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const models_1_1 = __nccwpck_require__(76429);
const Aws_restXml_1 = __nccwpck_require__(1983);
class TestFunctionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "TestFunction", {})
    .n("CloudFrontClient", "TestFunctionCommand")
    .f(models_1_1.TestFunctionRequestFilterSensitiveLog, models_1_1.TestFunctionResultFilterSensitiveLog)
    .ser(Aws_restXml_1.se_TestFunctionCommand)
    .de(Aws_restXml_1.de_TestFunctionCommand)
    .build() {
}
exports.TestFunctionCommand = TestFunctionCommand;


/***/ }),

/***/ 44877:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UntagResourceCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class UntagResourceCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "UntagResource", {})
    .n("CloudFrontClient", "UntagResourceCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_UntagResourceCommand)
    .de(Aws_restXml_1.de_UntagResourceCommand)
    .build() {
}
exports.UntagResourceCommand = UntagResourceCommand;


/***/ }),

/***/ 8205:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateCachePolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class UpdateCachePolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "UpdateCachePolicy", {})
    .n("CloudFrontClient", "UpdateCachePolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_UpdateCachePolicyCommand)
    .de(Aws_restXml_1.de_UpdateCachePolicyCommand)
    .build() {
}
exports.UpdateCachePolicyCommand = UpdateCachePolicyCommand;


/***/ }),

/***/ 47646:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateCloudFrontOriginAccessIdentityCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class UpdateCloudFrontOriginAccessIdentityCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "UpdateCloudFrontOriginAccessIdentity", {})
    .n("CloudFrontClient", "UpdateCloudFrontOriginAccessIdentityCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_UpdateCloudFrontOriginAccessIdentityCommand)
    .de(Aws_restXml_1.de_UpdateCloudFrontOriginAccessIdentityCommand)
    .build() {
}
exports.UpdateCloudFrontOriginAccessIdentityCommand = UpdateCloudFrontOriginAccessIdentityCommand;


/***/ }),

/***/ 68555:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateContinuousDeploymentPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class UpdateContinuousDeploymentPolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "UpdateContinuousDeploymentPolicy", {})
    .n("CloudFrontClient", "UpdateContinuousDeploymentPolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_UpdateContinuousDeploymentPolicyCommand)
    .de(Aws_restXml_1.de_UpdateContinuousDeploymentPolicyCommand)
    .build() {
}
exports.UpdateContinuousDeploymentPolicyCommand = UpdateContinuousDeploymentPolicyCommand;


/***/ }),

/***/ 79123:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateDistributionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const models_1_1 = __nccwpck_require__(76429);
const Aws_restXml_1 = __nccwpck_require__(1983);
class UpdateDistributionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "UpdateDistribution", {})
    .n("CloudFrontClient", "UpdateDistributionCommand")
    .f(models_1_1.UpdateDistributionRequestFilterSensitiveLog, models_1_1.UpdateDistributionResultFilterSensitiveLog)
    .ser(Aws_restXml_1.se_UpdateDistributionCommand)
    .de(Aws_restXml_1.de_UpdateDistributionCommand)
    .build() {
}
exports.UpdateDistributionCommand = UpdateDistributionCommand;


/***/ }),

/***/ 57562:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateDistributionWithStagingConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const models_1_1 = __nccwpck_require__(76429);
const Aws_restXml_1 = __nccwpck_require__(1983);
class UpdateDistributionWithStagingConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "UpdateDistributionWithStagingConfig", {})
    .n("CloudFrontClient", "UpdateDistributionWithStagingConfigCommand")
    .f(void 0, models_1_1.UpdateDistributionWithStagingConfigResultFilterSensitiveLog)
    .ser(Aws_restXml_1.se_UpdateDistributionWithStagingConfigCommand)
    .de(Aws_restXml_1.de_UpdateDistributionWithStagingConfigCommand)
    .build() {
}
exports.UpdateDistributionWithStagingConfigCommand = UpdateDistributionWithStagingConfigCommand;


/***/ }),

/***/ 97650:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateFieldLevelEncryptionConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class UpdateFieldLevelEncryptionConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "UpdateFieldLevelEncryptionConfig", {})
    .n("CloudFrontClient", "UpdateFieldLevelEncryptionConfigCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_UpdateFieldLevelEncryptionConfigCommand)
    .de(Aws_restXml_1.de_UpdateFieldLevelEncryptionConfigCommand)
    .build() {
}
exports.UpdateFieldLevelEncryptionConfigCommand = UpdateFieldLevelEncryptionConfigCommand;


/***/ }),

/***/ 95833:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateFieldLevelEncryptionProfileCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class UpdateFieldLevelEncryptionProfileCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "UpdateFieldLevelEncryptionProfile", {})
    .n("CloudFrontClient", "UpdateFieldLevelEncryptionProfileCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_UpdateFieldLevelEncryptionProfileCommand)
    .de(Aws_restXml_1.de_UpdateFieldLevelEncryptionProfileCommand)
    .build() {
}
exports.UpdateFieldLevelEncryptionProfileCommand = UpdateFieldLevelEncryptionProfileCommand;


/***/ }),

/***/ 63324:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateFunctionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const models_1_1 = __nccwpck_require__(76429);
const Aws_restXml_1 = __nccwpck_require__(1983);
class UpdateFunctionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "UpdateFunction", {})
    .n("CloudFrontClient", "UpdateFunctionCommand")
    .f(models_1_1.UpdateFunctionRequestFilterSensitiveLog, void 0)
    .ser(Aws_restXml_1.se_UpdateFunctionCommand)
    .de(Aws_restXml_1.de_UpdateFunctionCommand)
    .build() {
}
exports.UpdateFunctionCommand = UpdateFunctionCommand;


/***/ }),

/***/ 24172:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateKeyGroupCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class UpdateKeyGroupCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "UpdateKeyGroup", {})
    .n("CloudFrontClient", "UpdateKeyGroupCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_UpdateKeyGroupCommand)
    .de(Aws_restXml_1.de_UpdateKeyGroupCommand)
    .build() {
}
exports.UpdateKeyGroupCommand = UpdateKeyGroupCommand;


/***/ }),

/***/ 53244:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateKeyValueStoreCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class UpdateKeyValueStoreCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "UpdateKeyValueStore", {})
    .n("CloudFrontClient", "UpdateKeyValueStoreCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_UpdateKeyValueStoreCommand)
    .de(Aws_restXml_1.de_UpdateKeyValueStoreCommand)
    .build() {
}
exports.UpdateKeyValueStoreCommand = UpdateKeyValueStoreCommand;


/***/ }),

/***/ 91408:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateOriginAccessControlCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class UpdateOriginAccessControlCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "UpdateOriginAccessControl", {})
    .n("CloudFrontClient", "UpdateOriginAccessControlCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_UpdateOriginAccessControlCommand)
    .de(Aws_restXml_1.de_UpdateOriginAccessControlCommand)
    .build() {
}
exports.UpdateOriginAccessControlCommand = UpdateOriginAccessControlCommand;


/***/ }),

/***/ 53753:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateOriginRequestPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class UpdateOriginRequestPolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "UpdateOriginRequestPolicy", {})
    .n("CloudFrontClient", "UpdateOriginRequestPolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_UpdateOriginRequestPolicyCommand)
    .de(Aws_restXml_1.de_UpdateOriginRequestPolicyCommand)
    .build() {
}
exports.UpdateOriginRequestPolicyCommand = UpdateOriginRequestPolicyCommand;


/***/ }),

/***/ 78571:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdatePublicKeyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class UpdatePublicKeyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "UpdatePublicKey", {})
    .n("CloudFrontClient", "UpdatePublicKeyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_UpdatePublicKeyCommand)
    .de(Aws_restXml_1.de_UpdatePublicKeyCommand)
    .build() {
}
exports.UpdatePublicKeyCommand = UpdatePublicKeyCommand;


/***/ }),

/***/ 37922:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateRealtimeLogConfigCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class UpdateRealtimeLogConfigCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "UpdateRealtimeLogConfig", {})
    .n("CloudFrontClient", "UpdateRealtimeLogConfigCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_UpdateRealtimeLogConfigCommand)
    .de(Aws_restXml_1.de_UpdateRealtimeLogConfigCommand)
    .build() {
}
exports.UpdateRealtimeLogConfigCommand = UpdateRealtimeLogConfigCommand;


/***/ }),

/***/ 41523:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateResponseHeadersPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class UpdateResponseHeadersPolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "UpdateResponseHeadersPolicy", {})
    .n("CloudFrontClient", "UpdateResponseHeadersPolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_UpdateResponseHeadersPolicyCommand)
    .de(Aws_restXml_1.de_UpdateResponseHeadersPolicyCommand)
    .build() {
}
exports.UpdateResponseHeadersPolicyCommand = UpdateResponseHeadersPolicyCommand;


/***/ }),

/***/ 3621:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateStreamingDistributionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(73605);
const Aws_restXml_1 = __nccwpck_require__(1983);
class UpdateStreamingDistributionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Cloudfront2020_05_31", "UpdateStreamingDistribution", {})
    .n("CloudFrontClient", "UpdateStreamingDistributionCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_UpdateStreamingDistributionCommand)
    .de(Aws_restXml_1.de_UpdateStreamingDistributionCommand)
    .build() {
}
exports.UpdateStreamingDistributionCommand = UpdateStreamingDistributionCommand;


/***/ }),

/***/ 20792:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(44154), exports);
tslib_1.__exportStar(__nccwpck_require__(38992), exports);
tslib_1.__exportStar(__nccwpck_require__(64787), exports);
tslib_1.__exportStar(__nccwpck_require__(7974), exports);
tslib_1.__exportStar(__nccwpck_require__(27271), exports);
tslib_1.__exportStar(__nccwpck_require__(23482), exports);
tslib_1.__exportStar(__nccwpck_require__(67399), exports);
tslib_1.__exportStar(__nccwpck_require__(66484), exports);
tslib_1.__exportStar(__nccwpck_require__(27893), exports);
tslib_1.__exportStar(__nccwpck_require__(48883), exports);
tslib_1.__exportStar(__nccwpck_require__(79113), exports);
tslib_1.__exportStar(__nccwpck_require__(59033), exports);
tslib_1.__exportStar(__nccwpck_require__(13992), exports);
tslib_1.__exportStar(__nccwpck_require__(93508), exports);
tslib_1.__exportStar(__nccwpck_require__(91109), exports);
tslib_1.__exportStar(__nccwpck_require__(97230), exports);
tslib_1.__exportStar(__nccwpck_require__(84954), exports);
tslib_1.__exportStar(__nccwpck_require__(602), exports);
tslib_1.__exportStar(__nccwpck_require__(86066), exports);
tslib_1.__exportStar(__nccwpck_require__(7186), exports);
tslib_1.__exportStar(__nccwpck_require__(57717), exports);
tslib_1.__exportStar(__nccwpck_require__(29881), exports);
tslib_1.__exportStar(__nccwpck_require__(78381), exports);
tslib_1.__exportStar(__nccwpck_require__(81934), exports);
tslib_1.__exportStar(__nccwpck_require__(17292), exports);
tslib_1.__exportStar(__nccwpck_require__(95507), exports);
tslib_1.__exportStar(__nccwpck_require__(77942), exports);
tslib_1.__exportStar(__nccwpck_require__(42889), exports);
tslib_1.__exportStar(__nccwpck_require__(20380), exports);
tslib_1.__exportStar(__nccwpck_require__(14838), exports);
tslib_1.__exportStar(__nccwpck_require__(13716), exports);
tslib_1.__exportStar(__nccwpck_require__(66869), exports);
tslib_1.__exportStar(__nccwpck_require__(28399), exports);
tslib_1.__exportStar(__nccwpck_require__(92155), exports);
tslib_1.__exportStar(__nccwpck_require__(66380), exports);
tslib_1.__exportStar(__nccwpck_require__(61490), exports);
tslib_1.__exportStar(__nccwpck_require__(96770), exports);
tslib_1.__exportStar(__nccwpck_require__(49756), exports);
tslib_1.__exportStar(__nccwpck_require__(91605), exports);
tslib_1.__exportStar(__nccwpck_require__(75298), exports);
tslib_1.__exportStar(__nccwpck_require__(77669), exports);
tslib_1.__exportStar(__nccwpck_require__(63955), exports);
tslib_1.__exportStar(__nccwpck_require__(70758), exports);
tslib_1.__exportStar(__nccwpck_require__(71071), exports);
tslib_1.__exportStar(__nccwpck_require__(76109), exports);
tslib_1.__exportStar(__nccwpck_require__(13290), exports);
tslib_1.__exportStar(__nccwpck_require__(46437), exports);
tslib_1.__exportStar(__nccwpck_require__(10741), exports);
tslib_1.__exportStar(__nccwpck_require__(42847), exports);
tslib_1.__exportStar(__nccwpck_require__(68768), exports);
tslib_1.__exportStar(__nccwpck_require__(68693), exports);
tslib_1.__exportStar(__nccwpck_require__(95407), exports);
tslib_1.__exportStar(__nccwpck_require__(93931), exports);
tslib_1.__exportStar(__nccwpck_require__(7156), exports);
tslib_1.__exportStar(__nccwpck_require__(81892), exports);
tslib_1.__exportStar(__nccwpck_require__(91938), exports);
tslib_1.__exportStar(__nccwpck_require__(77599), exports);
tslib_1.__exportStar(__nccwpck_require__(49799), exports);
tslib_1.__exportStar(__nccwpck_require__(14325), exports);
tslib_1.__exportStar(__nccwpck_require__(19125), exports);
tslib_1.__exportStar(__nccwpck_require__(67029), exports);
tslib_1.__exportStar(__nccwpck_require__(22573), exports);
tslib_1.__exportStar(__nccwpck_require__(98488), exports);
tslib_1.__exportStar(__nccwpck_require__(37342), exports);
tslib_1.__exportStar(__nccwpck_require__(56804), exports);
tslib_1.__exportStar(__nccwpck_require__(23846), exports);
tslib_1.__exportStar(__nccwpck_require__(75823), exports);
tslib_1.__exportStar(__nccwpck_require__(2602), exports);
tslib_1.__exportStar(__nccwpck_require__(74932), exports);
tslib_1.__exportStar(__nccwpck_require__(81860), exports);
tslib_1.__exportStar(__nccwpck_require__(97910), exports);
tslib_1.__exportStar(__nccwpck_require__(18103), exports);
tslib_1.__exportStar(__nccwpck_require__(10329), exports);
tslib_1.__exportStar(__nccwpck_require__(79703), exports);
tslib_1.__exportStar(__nccwpck_require__(1570), exports);
tslib_1.__exportStar(__nccwpck_require__(42162), exports);
tslib_1.__exportStar(__nccwpck_require__(37570), exports);
tslib_1.__exportStar(__nccwpck_require__(80928), exports);
tslib_1.__exportStar(__nccwpck_require__(24871), exports);
tslib_1.__exportStar(__nccwpck_require__(88042), exports);
tslib_1.__exportStar(__nccwpck_require__(24603), exports);
tslib_1.__exportStar(__nccwpck_require__(65495), exports);
tslib_1.__exportStar(__nccwpck_require__(63118), exports);
tslib_1.__exportStar(__nccwpck_require__(95246), exports);
tslib_1.__exportStar(__nccwpck_require__(30976), exports);
tslib_1.__exportStar(__nccwpck_require__(62175), exports);
tslib_1.__exportStar(__nccwpck_require__(50336), exports);
tslib_1.__exportStar(__nccwpck_require__(56172), exports);
tslib_1.__exportStar(__nccwpck_require__(58751), exports);
tslib_1.__exportStar(__nccwpck_require__(83635), exports);
tslib_1.__exportStar(__nccwpck_require__(38093), exports);
tslib_1.__exportStar(__nccwpck_require__(20442), exports);
tslib_1.__exportStar(__nccwpck_require__(53320), exports);
tslib_1.__exportStar(__nccwpck_require__(19154), exports);
tslib_1.__exportStar(__nccwpck_require__(44877), exports);
tslib_1.__exportStar(__nccwpck_require__(8205), exports);
tslib_1.__exportStar(__nccwpck_require__(47646), exports);
tslib_1.__exportStar(__nccwpck_require__(68555), exports);
tslib_1.__exportStar(__nccwpck_require__(79123), exports);
tslib_1.__exportStar(__nccwpck_require__(57562), exports);
tslib_1.__exportStar(__nccwpck_require__(97650), exports);
tslib_1.__exportStar(__nccwpck_require__(95833), exports);
tslib_1.__exportStar(__nccwpck_require__(63324), exports);
tslib_1.__exportStar(__nccwpck_require__(24172), exports);
tslib_1.__exportStar(__nccwpck_require__(53244), exports);
tslib_1.__exportStar(__nccwpck_require__(91408), exports);
tslib_1.__exportStar(__nccwpck_require__(53753), exports);
tslib_1.__exportStar(__nccwpck_require__(78571), exports);
tslib_1.__exportStar(__nccwpck_require__(37922), exports);
tslib_1.__exportStar(__nccwpck_require__(41523), exports);
tslib_1.__exportStar(__nccwpck_require__(3621), exports);


/***/ }),

/***/ 73605:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.commonParams = exports.resolveClientEndpointParameters = void 0;
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "cloudfront",
    };
};
exports.resolveClientEndpointParameters = resolveClientEndpointParameters;
exports.commonParams = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
};


/***/ }),

/***/ 34887:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __nccwpck_require__(45473);
const ruleset_1 = __nccwpck_require__(55942);
const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
exports.defaultEndpointResolver = defaultEndpointResolver;


/***/ }),

/***/ 55942:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ruleSet = void 0;
const A = "required", B = "fn", C = "argv", D = "ref";
const a = true, b = "isSet", c = "booleanEquals", d = "error", e = "endpoint", f = "tree", g = "PartitionResult", h = "stringEquals", i = "sigv4", j = "cloudfront", k = { [A]: false, "type": "String" }, l = { [A]: true, "default": false, "type": "Boolean" }, m = { [D]: "Endpoint" }, n = { [B]: c, [C]: [{ [D]: "UseFIPS" }, true] }, o = { [B]: c, [C]: [{ [D]: "UseDualStack" }, true] }, p = {}, q = { [B]: h, [C]: [{ [B]: "getAttr", [C]: [{ [D]: g }, "name"] }, "aws"] }, r = { [B]: "getAttr", [C]: [{ [D]: g }, "name"] }, s = { [B]: c, [C]: [{ [D]: "UseFIPS" }, false] }, t = { [B]: c, [C]: [{ [D]: "UseDualStack" }, false] }, u = { "authSchemes": [{ "name": i, "signingName": j, "signingRegion": "us-east-1" }] }, v = { [B]: "getAttr", [C]: [{ [D]: g }, "supportsFIPS"] }, w = { [B]: c, [C]: [true, { [B]: "getAttr", [C]: [{ [D]: g }, "supportsDualStack"] }] }, x = [n], y = [o], z = [{ [D]: "Region" }];
const _data = { version: "1.0", parameters: { Region: k, UseDualStack: l, UseFIPS: l, Endpoint: k }, rules: [{ conditions: [{ [B]: b, [C]: [m] }], rules: [{ conditions: x, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: y, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: m, properties: p, headers: p }, type: e }], type: f }, { conditions: [{ [B]: b, [C]: z }], rules: [{ conditions: [{ [B]: "aws.partition", [C]: z, assign: g }], rules: [{ conditions: [q, s, t], endpoint: { url: "https://cloudfront.amazonaws.com", properties: u, headers: p }, type: e }, { conditions: [q, n, t], endpoint: { url: "https://cloudfront-fips.amazonaws.com", properties: u, headers: p }, type: e }, { conditions: [{ [B]: h, [C]: [r, "aws-cn"] }, s, t], endpoint: { url: "https://cloudfront.cn-northwest-1.amazonaws.com.cn", properties: { authSchemes: [{ name: i, signingName: j, signingRegion: "cn-northwest-1" }] }, headers: p }, type: e }, { conditions: [n, o], rules: [{ conditions: [{ [B]: c, [C]: [a, v] }, w], rules: [{ endpoint: { url: "https://cloudfront-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: p, headers: p }, type: e }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: x, rules: [{ conditions: [{ [B]: c, [C]: [v, a] }], rules: [{ endpoint: { url: "https://cloudfront-fips.{Region}.{PartitionResult#dnsSuffix}", properties: p, headers: p }, type: e }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: y, rules: [{ conditions: [w], rules: [{ endpoint: { url: "https://cloudfront.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: p, headers: p }, type: e }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://cloudfront.{Region}.{PartitionResult#dnsSuffix}", properties: p, headers: p }, type: e }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
exports.ruleSet = _data;


/***/ }),

/***/ 72928:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudFrontServiceException = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(59397), exports);
tslib_1.__exportStar(__nccwpck_require__(43546), exports);
tslib_1.__exportStar(__nccwpck_require__(20792), exports);
tslib_1.__exportStar(__nccwpck_require__(87517), exports);
tslib_1.__exportStar(__nccwpck_require__(41467), exports);
tslib_1.__exportStar(__nccwpck_require__(4118), exports);
__nccwpck_require__(13350);
var CloudFrontServiceException_1 = __nccwpck_require__(90671);
Object.defineProperty(exports, "CloudFrontServiceException", ({ enumerable: true, get: function () { return CloudFrontServiceException_1.CloudFrontServiceException; } }));


/***/ }),

/***/ 90671:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudFrontServiceException = exports.__ServiceException = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "__ServiceException", ({ enumerable: true, get: function () { return smithy_client_1.ServiceException; } }));
class CloudFrontServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, CloudFrontServiceException.prototype);
    }
}
exports.CloudFrontServiceException = CloudFrontServiceException;


/***/ }),

/***/ 4118:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(52996), exports);
tslib_1.__exportStar(__nccwpck_require__(76429), exports);


/***/ }),

/***/ 52996:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidRelativePath = exports.InvalidQueryStringParameters = exports.InvalidProtocolSettings = exports.InvalidOriginReadTimeout = exports.InvalidOriginKeepaliveTimeout = exports.InvalidOriginAccessIdentity = exports.InvalidOriginAccessControl = exports.InvalidOrigin = exports.InvalidMinimumProtocolVersion = exports.InvalidLocationCode = exports.InvalidLambdaFunctionAssociation = exports.InvalidIfMatchVersion = exports.InvalidHeadersForS3Origin = exports.InvalidGeoRestrictionParameter = exports.InvalidFunctionAssociation = exports.InvalidForwardCookies = exports.InvalidErrorCode = exports.InvalidDefaultRootObject = exports.InconsistentQuantities = exports.IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior = exports.DistributionAlreadyExists = exports.SSLSupportMethod = exports.MinimumProtocolVersion = exports.GeoRestrictionType = exports.PriceClass = exports.SslProtocol = exports.OriginProtocolPolicy = exports.HttpVersion = exports.CNAMEAlreadyExists = exports.CertificateSource = exports.CannotDeleteEntityWhileInUse = exports.CannotChangeImmutablePublicKeyFields = exports.CachePolicyType = exports.CachePolicyInUse = exports.CachePolicyAlreadyExists = exports.CachePolicyQueryStringBehavior = exports.CachePolicyHeaderBehavior = exports.CachePolicyCookieBehavior = exports.ViewerProtocolPolicy = exports.EventType = exports.ItemSelection = exports.BatchTooLarge = exports.TooManyDistributionCNAMEs = exports.NoSuchDistribution = exports.InvalidArgument = exports.IllegalUpdate = exports.Method = exports.ICPRecordalStatus = exports.AccessDenied = exports.ResponseHeadersPolicyAccessControlAllowMethodsValues = void 0;
exports.IllegalOriginAccessConfiguration = exports.ContinuousDeploymentPolicyInUse = exports.TooManyContinuousDeploymentPolicies = exports.StagingDistributionInUse = exports.ContinuousDeploymentPolicyType = exports.ContinuousDeploymentPolicyAlreadyExists = exports.TooManyCloudFrontOriginAccessIdentities = exports.CloudFrontOriginAccessIdentityAlreadyExists = exports.TooManyQueryStringsInCachePolicy = exports.TooManyHeadersInCachePolicy = exports.TooManyCookiesInCachePolicy = exports.TooManyCachePolicies = exports.TrustedSignerDoesNotExist = exports.TrustedKeyGroupDoesNotExist = exports.TooManyTrustedSigners = exports.TooManyQueryStringParameters = exports.TooManyOrigins = exports.TooManyOriginGroupsPerDistribution = exports.TooManyOriginCustomHeaders = exports.TooManyLambdaFunctionAssociations = exports.TooManyKeyGroupsAssociatedToDistribution = exports.TooManyHeadersInForwardedValues = exports.TooManyFunctionAssociations = exports.TooManyDistributionsWithSingleFunctionARN = exports.TooManyDistributionsWithLambdaAssociations = exports.TooManyDistributionsWithFunctionAssociations = exports.TooManyDistributionsAssociatedToResponseHeadersPolicy = exports.TooManyDistributionsAssociatedToOriginRequestPolicy = exports.TooManyDistributionsAssociatedToOriginAccessControl = exports.TooManyDistributionsAssociatedToKeyGroup = exports.TooManyDistributionsAssociatedToFieldLevelEncryptionConfig = exports.TooManyDistributionsAssociatedToCachePolicy = exports.TooManyDistributions = exports.TooManyCookieNamesInWhiteList = exports.TooManyCertificates = exports.TooManyCacheBehaviors = exports.RealtimeLogConfigOwnerMismatch = exports.PreconditionFailed = exports.NoSuchResponseHeadersPolicy = exports.NoSuchRealtimeLogConfig = exports.NoSuchOriginRequestPolicy = exports.NoSuchOrigin = exports.NoSuchFieldLevelEncryptionConfig = exports.NoSuchCachePolicy = exports.MissingBody = exports.InvalidWebACLId = exports.InvalidViewerCertificate = exports.InvalidTTLOrder = exports.InvalidResponseCode = exports.InvalidRequiredProtocol = void 0;
exports.OriginCustomHeaderFilterSensitiveLog = exports.TooManyRealtimeLogConfigs = exports.RealtimeLogConfigAlreadyExists = exports.TooManyPublicKeys = exports.PublicKeyAlreadyExists = exports.TooManyQueryStringsInOriginRequestPolicy = exports.TooManyOriginRequestPolicies = exports.TooManyHeadersInOriginRequestPolicy = exports.TooManyCookiesInOriginRequestPolicy = exports.OriginRequestPolicyAlreadyExists = exports.OriginRequestPolicyQueryStringBehavior = exports.OriginRequestPolicyHeaderBehavior = exports.OriginRequestPolicyCookieBehavior = exports.TooManyOriginAccessControls = exports.OriginAccessControlAlreadyExists = exports.OriginAccessControlSigningProtocols = exports.OriginAccessControlSigningBehaviors = exports.OriginAccessControlOriginTypes = exports.MonitoringSubscriptionAlreadyExists = exports.RealtimeMetricsSubscriptionStatus = exports.EntitySizeLimitExceeded = exports.EntityLimitExceeded = exports.EntityAlreadyExists = exports.ImportSourceType = exports.TooManyPublicKeysInKeyGroup = exports.TooManyKeyGroups = exports.KeyGroupAlreadyExists = exports.TooManyInvalidationsInProgress = exports.UnsupportedOperation = exports.TooManyFunctions = exports.FunctionSizeLimitExceeded = exports.FunctionAlreadyExists = exports.FunctionStage = exports.FunctionRuntime = exports.TooManyFieldLevelEncryptionProfiles = exports.TooManyFieldLevelEncryptionFieldPatterns = exports.TooManyFieldLevelEncryptionEncryptionEntities = exports.NoSuchPublicKey = exports.FieldLevelEncryptionProfileSizeExceeded = exports.FieldLevelEncryptionProfileAlreadyExists = exports.TooManyFieldLevelEncryptionQueryArgProfiles = exports.TooManyFieldLevelEncryptionContentTypeProfiles = exports.TooManyFieldLevelEncryptionConfigs = exports.QueryArgProfileEmpty = exports.NoSuchFieldLevelEncryptionProfile = exports.FieldLevelEncryptionConfigAlreadyExists = exports.Format = exports.InvalidTagging = exports.NoSuchContinuousDeploymentPolicy = exports.InvalidDomainNameForOriginAccessControl = void 0;
exports.CreateFunctionRequestFilterSensitiveLog = exports.CreateDistributionWithTagsResultFilterSensitiveLog = exports.CreateDistributionWithTagsRequestFilterSensitiveLog = exports.DistributionConfigWithTagsFilterSensitiveLog = exports.CreateDistributionResultFilterSensitiveLog = exports.CreateDistributionRequestFilterSensitiveLog = exports.CopyDistributionResultFilterSensitiveLog = exports.DistributionFilterSensitiveLog = exports.DistributionConfigFilterSensitiveLog = exports.OriginsFilterSensitiveLog = exports.OriginFilterSensitiveLog = exports.CustomHeadersFilterSensitiveLog = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const CloudFrontServiceException_1 = __nccwpck_require__(90671);
exports.ResponseHeadersPolicyAccessControlAllowMethodsValues = {
    ALL: "ALL",
    DELETE: "DELETE",
    GET: "GET",
    HEAD: "HEAD",
    OPTIONS: "OPTIONS",
    PATCH: "PATCH",
    POST: "POST",
    PUT: "PUT",
};
class AccessDenied extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "AccessDenied",
            $fault: "client",
            ...opts,
        });
        this.name = "AccessDenied";
        this.$fault = "client";
        Object.setPrototypeOf(this, AccessDenied.prototype);
        this.Message = opts.Message;
    }
}
exports.AccessDenied = AccessDenied;
exports.ICPRecordalStatus = {
    APPROVED: "APPROVED",
    PENDING: "PENDING",
    SUSPENDED: "SUSPENDED",
};
exports.Method = {
    DELETE: "DELETE",
    GET: "GET",
    HEAD: "HEAD",
    OPTIONS: "OPTIONS",
    PATCH: "PATCH",
    POST: "POST",
    PUT: "PUT",
};
class IllegalUpdate extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "IllegalUpdate",
            $fault: "client",
            ...opts,
        });
        this.name = "IllegalUpdate";
        this.$fault = "client";
        Object.setPrototypeOf(this, IllegalUpdate.prototype);
        this.Message = opts.Message;
    }
}
exports.IllegalUpdate = IllegalUpdate;
class InvalidArgument extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidArgument",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidArgument";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidArgument.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidArgument = InvalidArgument;
class NoSuchDistribution extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "NoSuchDistribution",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchDistribution";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchDistribution.prototype);
        this.Message = opts.Message;
    }
}
exports.NoSuchDistribution = NoSuchDistribution;
class TooManyDistributionCNAMEs extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyDistributionCNAMEs",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyDistributionCNAMEs";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyDistributionCNAMEs.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyDistributionCNAMEs = TooManyDistributionCNAMEs;
class BatchTooLarge extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "BatchTooLarge",
            $fault: "client",
            ...opts,
        });
        this.name = "BatchTooLarge";
        this.$fault = "client";
        Object.setPrototypeOf(this, BatchTooLarge.prototype);
        this.Message = opts.Message;
    }
}
exports.BatchTooLarge = BatchTooLarge;
exports.ItemSelection = {
    all: "all",
    none: "none",
    whitelist: "whitelist",
};
exports.EventType = {
    origin_request: "origin-request",
    origin_response: "origin-response",
    viewer_request: "viewer-request",
    viewer_response: "viewer-response",
};
exports.ViewerProtocolPolicy = {
    allow_all: "allow-all",
    https_only: "https-only",
    redirect_to_https: "redirect-to-https",
};
exports.CachePolicyCookieBehavior = {
    all: "all",
    allExcept: "allExcept",
    none: "none",
    whitelist: "whitelist",
};
exports.CachePolicyHeaderBehavior = {
    none: "none",
    whitelist: "whitelist",
};
exports.CachePolicyQueryStringBehavior = {
    all: "all",
    allExcept: "allExcept",
    none: "none",
    whitelist: "whitelist",
};
class CachePolicyAlreadyExists extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "CachePolicyAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "CachePolicyAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, CachePolicyAlreadyExists.prototype);
        this.Message = opts.Message;
    }
}
exports.CachePolicyAlreadyExists = CachePolicyAlreadyExists;
class CachePolicyInUse extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "CachePolicyInUse",
            $fault: "client",
            ...opts,
        });
        this.name = "CachePolicyInUse";
        this.$fault = "client";
        Object.setPrototypeOf(this, CachePolicyInUse.prototype);
        this.Message = opts.Message;
    }
}
exports.CachePolicyInUse = CachePolicyInUse;
exports.CachePolicyType = {
    custom: "custom",
    managed: "managed",
};
class CannotChangeImmutablePublicKeyFields extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "CannotChangeImmutablePublicKeyFields",
            $fault: "client",
            ...opts,
        });
        this.name = "CannotChangeImmutablePublicKeyFields";
        this.$fault = "client";
        Object.setPrototypeOf(this, CannotChangeImmutablePublicKeyFields.prototype);
        this.Message = opts.Message;
    }
}
exports.CannotChangeImmutablePublicKeyFields = CannotChangeImmutablePublicKeyFields;
class CannotDeleteEntityWhileInUse extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "CannotDeleteEntityWhileInUse",
            $fault: "client",
            ...opts,
        });
        this.name = "CannotDeleteEntityWhileInUse";
        this.$fault = "client";
        Object.setPrototypeOf(this, CannotDeleteEntityWhileInUse.prototype);
        this.Message = opts.Message;
    }
}
exports.CannotDeleteEntityWhileInUse = CannotDeleteEntityWhileInUse;
exports.CertificateSource = {
    acm: "acm",
    cloudfront: "cloudfront",
    iam: "iam",
};
class CNAMEAlreadyExists extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "CNAMEAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "CNAMEAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, CNAMEAlreadyExists.prototype);
        this.Message = opts.Message;
    }
}
exports.CNAMEAlreadyExists = CNAMEAlreadyExists;
exports.HttpVersion = {
    http1_1: "http1.1",
    http2: "http2",
    http2and3: "http2and3",
    http3: "http3",
};
exports.OriginProtocolPolicy = {
    http_only: "http-only",
    https_only: "https-only",
    match_viewer: "match-viewer",
};
exports.SslProtocol = {
    SSLv3: "SSLv3",
    TLSv1: "TLSv1",
    TLSv1_1: "TLSv1.1",
    TLSv1_2: "TLSv1.2",
};
exports.PriceClass = {
    PriceClass_100: "PriceClass_100",
    PriceClass_200: "PriceClass_200",
    PriceClass_All: "PriceClass_All",
};
exports.GeoRestrictionType = {
    blacklist: "blacklist",
    none: "none",
    whitelist: "whitelist",
};
exports.MinimumProtocolVersion = {
    SSLv3: "SSLv3",
    TLSv1: "TLSv1",
    TLSv1_1_2016: "TLSv1.1_2016",
    TLSv1_2016: "TLSv1_2016",
    TLSv1_2_2018: "TLSv1.2_2018",
    TLSv1_2_2019: "TLSv1.2_2019",
    TLSv1_2_2021: "TLSv1.2_2021",
};
exports.SSLSupportMethod = {
    sni_only: "sni-only",
    static_ip: "static-ip",
    vip: "vip",
};
class DistributionAlreadyExists extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "DistributionAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "DistributionAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, DistributionAlreadyExists.prototype);
        this.Message = opts.Message;
    }
}
exports.DistributionAlreadyExists = DistributionAlreadyExists;
class IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior",
            $fault: "client",
            ...opts,
        });
        this.name = "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior";
        this.$fault = "client";
        Object.setPrototypeOf(this, IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior.prototype);
        this.Message = opts.Message;
    }
}
exports.IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior = IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior;
class InconsistentQuantities extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InconsistentQuantities",
            $fault: "client",
            ...opts,
        });
        this.name = "InconsistentQuantities";
        this.$fault = "client";
        Object.setPrototypeOf(this, InconsistentQuantities.prototype);
        this.Message = opts.Message;
    }
}
exports.InconsistentQuantities = InconsistentQuantities;
class InvalidDefaultRootObject extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidDefaultRootObject",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidDefaultRootObject";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidDefaultRootObject.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidDefaultRootObject = InvalidDefaultRootObject;
class InvalidErrorCode extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidErrorCode",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidErrorCode";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidErrorCode.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidErrorCode = InvalidErrorCode;
class InvalidForwardCookies extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidForwardCookies",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidForwardCookies";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidForwardCookies.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidForwardCookies = InvalidForwardCookies;
class InvalidFunctionAssociation extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidFunctionAssociation",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidFunctionAssociation";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidFunctionAssociation.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidFunctionAssociation = InvalidFunctionAssociation;
class InvalidGeoRestrictionParameter extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidGeoRestrictionParameter",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidGeoRestrictionParameter";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidGeoRestrictionParameter.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidGeoRestrictionParameter = InvalidGeoRestrictionParameter;
class InvalidHeadersForS3Origin extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidHeadersForS3Origin",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidHeadersForS3Origin";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidHeadersForS3Origin.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidHeadersForS3Origin = InvalidHeadersForS3Origin;
class InvalidIfMatchVersion extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidIfMatchVersion",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidIfMatchVersion";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidIfMatchVersion.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidIfMatchVersion = InvalidIfMatchVersion;
class InvalidLambdaFunctionAssociation extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidLambdaFunctionAssociation",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidLambdaFunctionAssociation";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidLambdaFunctionAssociation.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidLambdaFunctionAssociation = InvalidLambdaFunctionAssociation;
class InvalidLocationCode extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidLocationCode",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidLocationCode";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidLocationCode.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidLocationCode = InvalidLocationCode;
class InvalidMinimumProtocolVersion extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidMinimumProtocolVersion",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidMinimumProtocolVersion";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidMinimumProtocolVersion.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidMinimumProtocolVersion = InvalidMinimumProtocolVersion;
class InvalidOrigin extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidOrigin",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidOrigin";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidOrigin.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidOrigin = InvalidOrigin;
class InvalidOriginAccessControl extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidOriginAccessControl",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidOriginAccessControl";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidOriginAccessControl.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidOriginAccessControl = InvalidOriginAccessControl;
class InvalidOriginAccessIdentity extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidOriginAccessIdentity",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidOriginAccessIdentity";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidOriginAccessIdentity.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidOriginAccessIdentity = InvalidOriginAccessIdentity;
class InvalidOriginKeepaliveTimeout extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidOriginKeepaliveTimeout",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidOriginKeepaliveTimeout";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidOriginKeepaliveTimeout.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidOriginKeepaliveTimeout = InvalidOriginKeepaliveTimeout;
class InvalidOriginReadTimeout extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidOriginReadTimeout",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidOriginReadTimeout";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidOriginReadTimeout.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidOriginReadTimeout = InvalidOriginReadTimeout;
class InvalidProtocolSettings extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidProtocolSettings",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidProtocolSettings";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidProtocolSettings.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidProtocolSettings = InvalidProtocolSettings;
class InvalidQueryStringParameters extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidQueryStringParameters",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidQueryStringParameters";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidQueryStringParameters.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidQueryStringParameters = InvalidQueryStringParameters;
class InvalidRelativePath extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidRelativePath",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRelativePath";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRelativePath.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidRelativePath = InvalidRelativePath;
class InvalidRequiredProtocol extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidRequiredProtocol",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRequiredProtocol";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRequiredProtocol.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidRequiredProtocol = InvalidRequiredProtocol;
class InvalidResponseCode extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidResponseCode",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidResponseCode";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidResponseCode.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidResponseCode = InvalidResponseCode;
class InvalidTTLOrder extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidTTLOrder",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidTTLOrder";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidTTLOrder.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidTTLOrder = InvalidTTLOrder;
class InvalidViewerCertificate extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidViewerCertificate",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidViewerCertificate";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidViewerCertificate.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidViewerCertificate = InvalidViewerCertificate;
class InvalidWebACLId extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidWebACLId",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidWebACLId";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidWebACLId.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidWebACLId = InvalidWebACLId;
class MissingBody extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "MissingBody",
            $fault: "client",
            ...opts,
        });
        this.name = "MissingBody";
        this.$fault = "client";
        Object.setPrototypeOf(this, MissingBody.prototype);
        this.Message = opts.Message;
    }
}
exports.MissingBody = MissingBody;
class NoSuchCachePolicy extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "NoSuchCachePolicy",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchCachePolicy";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchCachePolicy.prototype);
        this.Message = opts.Message;
    }
}
exports.NoSuchCachePolicy = NoSuchCachePolicy;
class NoSuchFieldLevelEncryptionConfig extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "NoSuchFieldLevelEncryptionConfig",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchFieldLevelEncryptionConfig";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchFieldLevelEncryptionConfig.prototype);
        this.Message = opts.Message;
    }
}
exports.NoSuchFieldLevelEncryptionConfig = NoSuchFieldLevelEncryptionConfig;
class NoSuchOrigin extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "NoSuchOrigin",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchOrigin";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchOrigin.prototype);
        this.Message = opts.Message;
    }
}
exports.NoSuchOrigin = NoSuchOrigin;
class NoSuchOriginRequestPolicy extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "NoSuchOriginRequestPolicy",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchOriginRequestPolicy";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchOriginRequestPolicy.prototype);
        this.Message = opts.Message;
    }
}
exports.NoSuchOriginRequestPolicy = NoSuchOriginRequestPolicy;
class NoSuchRealtimeLogConfig extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "NoSuchRealtimeLogConfig",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchRealtimeLogConfig";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchRealtimeLogConfig.prototype);
        this.Message = opts.Message;
    }
}
exports.NoSuchRealtimeLogConfig = NoSuchRealtimeLogConfig;
class NoSuchResponseHeadersPolicy extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "NoSuchResponseHeadersPolicy",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchResponseHeadersPolicy";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchResponseHeadersPolicy.prototype);
        this.Message = opts.Message;
    }
}
exports.NoSuchResponseHeadersPolicy = NoSuchResponseHeadersPolicy;
class PreconditionFailed extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "PreconditionFailed",
            $fault: "client",
            ...opts,
        });
        this.name = "PreconditionFailed";
        this.$fault = "client";
        Object.setPrototypeOf(this, PreconditionFailed.prototype);
        this.Message = opts.Message;
    }
}
exports.PreconditionFailed = PreconditionFailed;
class RealtimeLogConfigOwnerMismatch extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "RealtimeLogConfigOwnerMismatch",
            $fault: "client",
            ...opts,
        });
        this.name = "RealtimeLogConfigOwnerMismatch";
        this.$fault = "client";
        Object.setPrototypeOf(this, RealtimeLogConfigOwnerMismatch.prototype);
        this.Message = opts.Message;
    }
}
exports.RealtimeLogConfigOwnerMismatch = RealtimeLogConfigOwnerMismatch;
class TooManyCacheBehaviors extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyCacheBehaviors",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyCacheBehaviors";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyCacheBehaviors.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyCacheBehaviors = TooManyCacheBehaviors;
class TooManyCertificates extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyCertificates",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyCertificates";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyCertificates.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyCertificates = TooManyCertificates;
class TooManyCookieNamesInWhiteList extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyCookieNamesInWhiteList",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyCookieNamesInWhiteList";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyCookieNamesInWhiteList.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyCookieNamesInWhiteList = TooManyCookieNamesInWhiteList;
class TooManyDistributions extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyDistributions",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyDistributions";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyDistributions.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyDistributions = TooManyDistributions;
class TooManyDistributionsAssociatedToCachePolicy extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyDistributionsAssociatedToCachePolicy",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyDistributionsAssociatedToCachePolicy";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyDistributionsAssociatedToCachePolicy.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyDistributionsAssociatedToCachePolicy = TooManyDistributionsAssociatedToCachePolicy;
class TooManyDistributionsAssociatedToFieldLevelEncryptionConfig extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyDistributionsAssociatedToFieldLevelEncryptionConfig.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyDistributionsAssociatedToFieldLevelEncryptionConfig = TooManyDistributionsAssociatedToFieldLevelEncryptionConfig;
class TooManyDistributionsAssociatedToKeyGroup extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyDistributionsAssociatedToKeyGroup",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyDistributionsAssociatedToKeyGroup";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyDistributionsAssociatedToKeyGroup.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyDistributionsAssociatedToKeyGroup = TooManyDistributionsAssociatedToKeyGroup;
class TooManyDistributionsAssociatedToOriginAccessControl extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyDistributionsAssociatedToOriginAccessControl",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyDistributionsAssociatedToOriginAccessControl";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyDistributionsAssociatedToOriginAccessControl.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyDistributionsAssociatedToOriginAccessControl = TooManyDistributionsAssociatedToOriginAccessControl;
class TooManyDistributionsAssociatedToOriginRequestPolicy extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyDistributionsAssociatedToOriginRequestPolicy",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyDistributionsAssociatedToOriginRequestPolicy";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyDistributionsAssociatedToOriginRequestPolicy.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyDistributionsAssociatedToOriginRequestPolicy = TooManyDistributionsAssociatedToOriginRequestPolicy;
class TooManyDistributionsAssociatedToResponseHeadersPolicy extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyDistributionsAssociatedToResponseHeadersPolicy",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyDistributionsAssociatedToResponseHeadersPolicy";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyDistributionsAssociatedToResponseHeadersPolicy.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyDistributionsAssociatedToResponseHeadersPolicy = TooManyDistributionsAssociatedToResponseHeadersPolicy;
class TooManyDistributionsWithFunctionAssociations extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyDistributionsWithFunctionAssociations",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyDistributionsWithFunctionAssociations";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyDistributionsWithFunctionAssociations.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyDistributionsWithFunctionAssociations = TooManyDistributionsWithFunctionAssociations;
class TooManyDistributionsWithLambdaAssociations extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyDistributionsWithLambdaAssociations",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyDistributionsWithLambdaAssociations";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyDistributionsWithLambdaAssociations.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyDistributionsWithLambdaAssociations = TooManyDistributionsWithLambdaAssociations;
class TooManyDistributionsWithSingleFunctionARN extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyDistributionsWithSingleFunctionARN",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyDistributionsWithSingleFunctionARN";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyDistributionsWithSingleFunctionARN.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyDistributionsWithSingleFunctionARN = TooManyDistributionsWithSingleFunctionARN;
class TooManyFunctionAssociations extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyFunctionAssociations",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyFunctionAssociations";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyFunctionAssociations.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyFunctionAssociations = TooManyFunctionAssociations;
class TooManyHeadersInForwardedValues extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyHeadersInForwardedValues",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyHeadersInForwardedValues";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyHeadersInForwardedValues.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyHeadersInForwardedValues = TooManyHeadersInForwardedValues;
class TooManyKeyGroupsAssociatedToDistribution extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyKeyGroupsAssociatedToDistribution",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyKeyGroupsAssociatedToDistribution";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyKeyGroupsAssociatedToDistribution.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyKeyGroupsAssociatedToDistribution = TooManyKeyGroupsAssociatedToDistribution;
class TooManyLambdaFunctionAssociations extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyLambdaFunctionAssociations",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyLambdaFunctionAssociations";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyLambdaFunctionAssociations.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyLambdaFunctionAssociations = TooManyLambdaFunctionAssociations;
class TooManyOriginCustomHeaders extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyOriginCustomHeaders",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyOriginCustomHeaders";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyOriginCustomHeaders.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyOriginCustomHeaders = TooManyOriginCustomHeaders;
class TooManyOriginGroupsPerDistribution extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyOriginGroupsPerDistribution",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyOriginGroupsPerDistribution";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyOriginGroupsPerDistribution.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyOriginGroupsPerDistribution = TooManyOriginGroupsPerDistribution;
class TooManyOrigins extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyOrigins",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyOrigins";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyOrigins.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyOrigins = TooManyOrigins;
class TooManyQueryStringParameters extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyQueryStringParameters",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyQueryStringParameters";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyQueryStringParameters.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyQueryStringParameters = TooManyQueryStringParameters;
class TooManyTrustedSigners extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyTrustedSigners",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyTrustedSigners";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyTrustedSigners.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyTrustedSigners = TooManyTrustedSigners;
class TrustedKeyGroupDoesNotExist extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TrustedKeyGroupDoesNotExist",
            $fault: "client",
            ...opts,
        });
        this.name = "TrustedKeyGroupDoesNotExist";
        this.$fault = "client";
        Object.setPrototypeOf(this, TrustedKeyGroupDoesNotExist.prototype);
        this.Message = opts.Message;
    }
}
exports.TrustedKeyGroupDoesNotExist = TrustedKeyGroupDoesNotExist;
class TrustedSignerDoesNotExist extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TrustedSignerDoesNotExist",
            $fault: "client",
            ...opts,
        });
        this.name = "TrustedSignerDoesNotExist";
        this.$fault = "client";
        Object.setPrototypeOf(this, TrustedSignerDoesNotExist.prototype);
        this.Message = opts.Message;
    }
}
exports.TrustedSignerDoesNotExist = TrustedSignerDoesNotExist;
class TooManyCachePolicies extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyCachePolicies",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyCachePolicies";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyCachePolicies.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyCachePolicies = TooManyCachePolicies;
class TooManyCookiesInCachePolicy extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyCookiesInCachePolicy",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyCookiesInCachePolicy";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyCookiesInCachePolicy.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyCookiesInCachePolicy = TooManyCookiesInCachePolicy;
class TooManyHeadersInCachePolicy extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyHeadersInCachePolicy",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyHeadersInCachePolicy";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyHeadersInCachePolicy.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyHeadersInCachePolicy = TooManyHeadersInCachePolicy;
class TooManyQueryStringsInCachePolicy extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyQueryStringsInCachePolicy",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyQueryStringsInCachePolicy";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyQueryStringsInCachePolicy.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyQueryStringsInCachePolicy = TooManyQueryStringsInCachePolicy;
class CloudFrontOriginAccessIdentityAlreadyExists extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "CloudFrontOriginAccessIdentityAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "CloudFrontOriginAccessIdentityAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, CloudFrontOriginAccessIdentityAlreadyExists.prototype);
        this.Message = opts.Message;
    }
}
exports.CloudFrontOriginAccessIdentityAlreadyExists = CloudFrontOriginAccessIdentityAlreadyExists;
class TooManyCloudFrontOriginAccessIdentities extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyCloudFrontOriginAccessIdentities",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyCloudFrontOriginAccessIdentities";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyCloudFrontOriginAccessIdentities.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyCloudFrontOriginAccessIdentities = TooManyCloudFrontOriginAccessIdentities;
class ContinuousDeploymentPolicyAlreadyExists extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "ContinuousDeploymentPolicyAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "ContinuousDeploymentPolicyAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, ContinuousDeploymentPolicyAlreadyExists.prototype);
        this.Message = opts.Message;
    }
}
exports.ContinuousDeploymentPolicyAlreadyExists = ContinuousDeploymentPolicyAlreadyExists;
exports.ContinuousDeploymentPolicyType = {
    SingleHeader: "SingleHeader",
    SingleWeight: "SingleWeight",
};
class StagingDistributionInUse extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "StagingDistributionInUse",
            $fault: "client",
            ...opts,
        });
        this.name = "StagingDistributionInUse";
        this.$fault = "client";
        Object.setPrototypeOf(this, StagingDistributionInUse.prototype);
        this.Message = opts.Message;
    }
}
exports.StagingDistributionInUse = StagingDistributionInUse;
class TooManyContinuousDeploymentPolicies extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyContinuousDeploymentPolicies",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyContinuousDeploymentPolicies";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyContinuousDeploymentPolicies.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyContinuousDeploymentPolicies = TooManyContinuousDeploymentPolicies;
class ContinuousDeploymentPolicyInUse extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "ContinuousDeploymentPolicyInUse",
            $fault: "client",
            ...opts,
        });
        this.name = "ContinuousDeploymentPolicyInUse";
        this.$fault = "client";
        Object.setPrototypeOf(this, ContinuousDeploymentPolicyInUse.prototype);
        this.Message = opts.Message;
    }
}
exports.ContinuousDeploymentPolicyInUse = ContinuousDeploymentPolicyInUse;
class IllegalOriginAccessConfiguration extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "IllegalOriginAccessConfiguration",
            $fault: "client",
            ...opts,
        });
        this.name = "IllegalOriginAccessConfiguration";
        this.$fault = "client";
        Object.setPrototypeOf(this, IllegalOriginAccessConfiguration.prototype);
        this.Message = opts.Message;
    }
}
exports.IllegalOriginAccessConfiguration = IllegalOriginAccessConfiguration;
class InvalidDomainNameForOriginAccessControl extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidDomainNameForOriginAccessControl",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidDomainNameForOriginAccessControl";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidDomainNameForOriginAccessControl.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidDomainNameForOriginAccessControl = InvalidDomainNameForOriginAccessControl;
class NoSuchContinuousDeploymentPolicy extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "NoSuchContinuousDeploymentPolicy",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchContinuousDeploymentPolicy";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchContinuousDeploymentPolicy.prototype);
        this.Message = opts.Message;
    }
}
exports.NoSuchContinuousDeploymentPolicy = NoSuchContinuousDeploymentPolicy;
class InvalidTagging extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "InvalidTagging",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidTagging";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidTagging.prototype);
        this.Message = opts.Message;
    }
}
exports.InvalidTagging = InvalidTagging;
exports.Format = {
    URLEncoded: "URLEncoded",
};
class FieldLevelEncryptionConfigAlreadyExists extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "FieldLevelEncryptionConfigAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "FieldLevelEncryptionConfigAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, FieldLevelEncryptionConfigAlreadyExists.prototype);
        this.Message = opts.Message;
    }
}
exports.FieldLevelEncryptionConfigAlreadyExists = FieldLevelEncryptionConfigAlreadyExists;
class NoSuchFieldLevelEncryptionProfile extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "NoSuchFieldLevelEncryptionProfile",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchFieldLevelEncryptionProfile";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchFieldLevelEncryptionProfile.prototype);
        this.Message = opts.Message;
    }
}
exports.NoSuchFieldLevelEncryptionProfile = NoSuchFieldLevelEncryptionProfile;
class QueryArgProfileEmpty extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "QueryArgProfileEmpty",
            $fault: "client",
            ...opts,
        });
        this.name = "QueryArgProfileEmpty";
        this.$fault = "client";
        Object.setPrototypeOf(this, QueryArgProfileEmpty.prototype);
        this.Message = opts.Message;
    }
}
exports.QueryArgProfileEmpty = QueryArgProfileEmpty;
class TooManyFieldLevelEncryptionConfigs extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyFieldLevelEncryptionConfigs",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyFieldLevelEncryptionConfigs";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyFieldLevelEncryptionConfigs.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyFieldLevelEncryptionConfigs = TooManyFieldLevelEncryptionConfigs;
class TooManyFieldLevelEncryptionContentTypeProfiles extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyFieldLevelEncryptionContentTypeProfiles",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyFieldLevelEncryptionContentTypeProfiles";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyFieldLevelEncryptionContentTypeProfiles.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyFieldLevelEncryptionContentTypeProfiles = TooManyFieldLevelEncryptionContentTypeProfiles;
class TooManyFieldLevelEncryptionQueryArgProfiles extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyFieldLevelEncryptionQueryArgProfiles",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyFieldLevelEncryptionQueryArgProfiles";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyFieldLevelEncryptionQueryArgProfiles.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyFieldLevelEncryptionQueryArgProfiles = TooManyFieldLevelEncryptionQueryArgProfiles;
class FieldLevelEncryptionProfileAlreadyExists extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "FieldLevelEncryptionProfileAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "FieldLevelEncryptionProfileAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, FieldLevelEncryptionProfileAlreadyExists.prototype);
        this.Message = opts.Message;
    }
}
exports.FieldLevelEncryptionProfileAlreadyExists = FieldLevelEncryptionProfileAlreadyExists;
class FieldLevelEncryptionProfileSizeExceeded extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "FieldLevelEncryptionProfileSizeExceeded",
            $fault: "client",
            ...opts,
        });
        this.name = "FieldLevelEncryptionProfileSizeExceeded";
        this.$fault = "client";
        Object.setPrototypeOf(this, FieldLevelEncryptionProfileSizeExceeded.prototype);
        this.Message = opts.Message;
    }
}
exports.FieldLevelEncryptionProfileSizeExceeded = FieldLevelEncryptionProfileSizeExceeded;
class NoSuchPublicKey extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "NoSuchPublicKey",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchPublicKey";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchPublicKey.prototype);
        this.Message = opts.Message;
    }
}
exports.NoSuchPublicKey = NoSuchPublicKey;
class TooManyFieldLevelEncryptionEncryptionEntities extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyFieldLevelEncryptionEncryptionEntities",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyFieldLevelEncryptionEncryptionEntities";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyFieldLevelEncryptionEncryptionEntities.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyFieldLevelEncryptionEncryptionEntities = TooManyFieldLevelEncryptionEncryptionEntities;
class TooManyFieldLevelEncryptionFieldPatterns extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyFieldLevelEncryptionFieldPatterns",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyFieldLevelEncryptionFieldPatterns";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyFieldLevelEncryptionFieldPatterns.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyFieldLevelEncryptionFieldPatterns = TooManyFieldLevelEncryptionFieldPatterns;
class TooManyFieldLevelEncryptionProfiles extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyFieldLevelEncryptionProfiles",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyFieldLevelEncryptionProfiles";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyFieldLevelEncryptionProfiles.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyFieldLevelEncryptionProfiles = TooManyFieldLevelEncryptionProfiles;
exports.FunctionRuntime = {
    cloudfront_js_1_0: "cloudfront-js-1.0",
    cloudfront_js_2_0: "cloudfront-js-2.0",
};
exports.FunctionStage = {
    DEVELOPMENT: "DEVELOPMENT",
    LIVE: "LIVE",
};
class FunctionAlreadyExists extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "FunctionAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "FunctionAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, FunctionAlreadyExists.prototype);
        this.Message = opts.Message;
    }
}
exports.FunctionAlreadyExists = FunctionAlreadyExists;
class FunctionSizeLimitExceeded extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "FunctionSizeLimitExceeded",
            $fault: "client",
            ...opts,
        });
        this.name = "FunctionSizeLimitExceeded";
        this.$fault = "client";
        Object.setPrototypeOf(this, FunctionSizeLimitExceeded.prototype);
        this.Message = opts.Message;
    }
}
exports.FunctionSizeLimitExceeded = FunctionSizeLimitExceeded;
class TooManyFunctions extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyFunctions",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyFunctions";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyFunctions.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyFunctions = TooManyFunctions;
class UnsupportedOperation extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "UnsupportedOperation",
            $fault: "client",
            ...opts,
        });
        this.name = "UnsupportedOperation";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnsupportedOperation.prototype);
        this.Message = opts.Message;
    }
}
exports.UnsupportedOperation = UnsupportedOperation;
class TooManyInvalidationsInProgress extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyInvalidationsInProgress",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyInvalidationsInProgress";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyInvalidationsInProgress.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyInvalidationsInProgress = TooManyInvalidationsInProgress;
class KeyGroupAlreadyExists extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "KeyGroupAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "KeyGroupAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, KeyGroupAlreadyExists.prototype);
        this.Message = opts.Message;
    }
}
exports.KeyGroupAlreadyExists = KeyGroupAlreadyExists;
class TooManyKeyGroups extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyKeyGroups",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyKeyGroups";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyKeyGroups.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyKeyGroups = TooManyKeyGroups;
class TooManyPublicKeysInKeyGroup extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyPublicKeysInKeyGroup",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyPublicKeysInKeyGroup";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyPublicKeysInKeyGroup.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyPublicKeysInKeyGroup = TooManyPublicKeysInKeyGroup;
exports.ImportSourceType = {
    S3: "S3",
};
class EntityAlreadyExists extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "EntityAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "EntityAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, EntityAlreadyExists.prototype);
        this.Message = opts.Message;
    }
}
exports.EntityAlreadyExists = EntityAlreadyExists;
class EntityLimitExceeded extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "EntityLimitExceeded",
            $fault: "client",
            ...opts,
        });
        this.name = "EntityLimitExceeded";
        this.$fault = "client";
        Object.setPrototypeOf(this, EntityLimitExceeded.prototype);
        this.Message = opts.Message;
    }
}
exports.EntityLimitExceeded = EntityLimitExceeded;
class EntitySizeLimitExceeded extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "EntitySizeLimitExceeded",
            $fault: "client",
            ...opts,
        });
        this.name = "EntitySizeLimitExceeded";
        this.$fault = "client";
        Object.setPrototypeOf(this, EntitySizeLimitExceeded.prototype);
        this.Message = opts.Message;
    }
}
exports.EntitySizeLimitExceeded = EntitySizeLimitExceeded;
exports.RealtimeMetricsSubscriptionStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled",
};
class MonitoringSubscriptionAlreadyExists extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "MonitoringSubscriptionAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "MonitoringSubscriptionAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, MonitoringSubscriptionAlreadyExists.prototype);
        this.Message = opts.Message;
    }
}
exports.MonitoringSubscriptionAlreadyExists = MonitoringSubscriptionAlreadyExists;
exports.OriginAccessControlOriginTypes = {
    mediastore: "mediastore",
    s3: "s3",
};
exports.OriginAccessControlSigningBehaviors = {
    always: "always",
    never: "never",
    no_override: "no-override",
};
exports.OriginAccessControlSigningProtocols = {
    sigv4: "sigv4",
};
class OriginAccessControlAlreadyExists extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "OriginAccessControlAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "OriginAccessControlAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, OriginAccessControlAlreadyExists.prototype);
        this.Message = opts.Message;
    }
}
exports.OriginAccessControlAlreadyExists = OriginAccessControlAlreadyExists;
class TooManyOriginAccessControls extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyOriginAccessControls",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyOriginAccessControls";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyOriginAccessControls.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyOriginAccessControls = TooManyOriginAccessControls;
exports.OriginRequestPolicyCookieBehavior = {
    all: "all",
    allExcept: "allExcept",
    none: "none",
    whitelist: "whitelist",
};
exports.OriginRequestPolicyHeaderBehavior = {
    allExcept: "allExcept",
    allViewer: "allViewer",
    allViewerAndWhitelistCloudFront: "allViewerAndWhitelistCloudFront",
    none: "none",
    whitelist: "whitelist",
};
exports.OriginRequestPolicyQueryStringBehavior = {
    all: "all",
    allExcept: "allExcept",
    none: "none",
    whitelist: "whitelist",
};
class OriginRequestPolicyAlreadyExists extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "OriginRequestPolicyAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "OriginRequestPolicyAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, OriginRequestPolicyAlreadyExists.prototype);
        this.Message = opts.Message;
    }
}
exports.OriginRequestPolicyAlreadyExists = OriginRequestPolicyAlreadyExists;
class TooManyCookiesInOriginRequestPolicy extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyCookiesInOriginRequestPolicy",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyCookiesInOriginRequestPolicy";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyCookiesInOriginRequestPolicy.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyCookiesInOriginRequestPolicy = TooManyCookiesInOriginRequestPolicy;
class TooManyHeadersInOriginRequestPolicy extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyHeadersInOriginRequestPolicy",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyHeadersInOriginRequestPolicy";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyHeadersInOriginRequestPolicy.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyHeadersInOriginRequestPolicy = TooManyHeadersInOriginRequestPolicy;
class TooManyOriginRequestPolicies extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyOriginRequestPolicies",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyOriginRequestPolicies";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyOriginRequestPolicies.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyOriginRequestPolicies = TooManyOriginRequestPolicies;
class TooManyQueryStringsInOriginRequestPolicy extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyQueryStringsInOriginRequestPolicy",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyQueryStringsInOriginRequestPolicy";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyQueryStringsInOriginRequestPolicy.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyQueryStringsInOriginRequestPolicy = TooManyQueryStringsInOriginRequestPolicy;
class PublicKeyAlreadyExists extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "PublicKeyAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "PublicKeyAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, PublicKeyAlreadyExists.prototype);
        this.Message = opts.Message;
    }
}
exports.PublicKeyAlreadyExists = PublicKeyAlreadyExists;
class TooManyPublicKeys extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyPublicKeys",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyPublicKeys";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyPublicKeys.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyPublicKeys = TooManyPublicKeys;
class RealtimeLogConfigAlreadyExists extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "RealtimeLogConfigAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "RealtimeLogConfigAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, RealtimeLogConfigAlreadyExists.prototype);
        this.Message = opts.Message;
    }
}
exports.RealtimeLogConfigAlreadyExists = RealtimeLogConfigAlreadyExists;
class TooManyRealtimeLogConfigs extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyRealtimeLogConfigs",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyRealtimeLogConfigs";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyRealtimeLogConfigs.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyRealtimeLogConfigs = TooManyRealtimeLogConfigs;
const OriginCustomHeaderFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.HeaderValue && { HeaderValue: smithy_client_1.SENSITIVE_STRING }),
});
exports.OriginCustomHeaderFilterSensitiveLog = OriginCustomHeaderFilterSensitiveLog;
const CustomHeadersFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Items && { Items: obj.Items.map((item) => (0, exports.OriginCustomHeaderFilterSensitiveLog)(item)) }),
});
exports.CustomHeadersFilterSensitiveLog = CustomHeadersFilterSensitiveLog;
const OriginFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.CustomHeaders && { CustomHeaders: (0, exports.CustomHeadersFilterSensitiveLog)(obj.CustomHeaders) }),
});
exports.OriginFilterSensitiveLog = OriginFilterSensitiveLog;
const OriginsFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.OriginsFilterSensitiveLog = OriginsFilterSensitiveLog;
const DistributionConfigFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Comment && { Comment: smithy_client_1.SENSITIVE_STRING }),
});
exports.DistributionConfigFilterSensitiveLog = DistributionConfigFilterSensitiveLog;
const DistributionFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.DistributionConfig && { DistributionConfig: (0, exports.DistributionConfigFilterSensitiveLog)(obj.DistributionConfig) }),
});
exports.DistributionFilterSensitiveLog = DistributionFilterSensitiveLog;
const CopyDistributionResultFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Distribution && { Distribution: (0, exports.DistributionFilterSensitiveLog)(obj.Distribution) }),
});
exports.CopyDistributionResultFilterSensitiveLog = CopyDistributionResultFilterSensitiveLog;
const CreateDistributionRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.DistributionConfig && { DistributionConfig: (0, exports.DistributionConfigFilterSensitiveLog)(obj.DistributionConfig) }),
});
exports.CreateDistributionRequestFilterSensitiveLog = CreateDistributionRequestFilterSensitiveLog;
const CreateDistributionResultFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Distribution && { Distribution: (0, exports.DistributionFilterSensitiveLog)(obj.Distribution) }),
});
exports.CreateDistributionResultFilterSensitiveLog = CreateDistributionResultFilterSensitiveLog;
const DistributionConfigWithTagsFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.DistributionConfig && { DistributionConfig: (0, exports.DistributionConfigFilterSensitiveLog)(obj.DistributionConfig) }),
});
exports.DistributionConfigWithTagsFilterSensitiveLog = DistributionConfigWithTagsFilterSensitiveLog;
const CreateDistributionWithTagsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.DistributionConfigWithTags && {
        DistributionConfigWithTags: (0, exports.DistributionConfigWithTagsFilterSensitiveLog)(obj.DistributionConfigWithTags),
    }),
});
exports.CreateDistributionWithTagsRequestFilterSensitiveLog = CreateDistributionWithTagsRequestFilterSensitiveLog;
const CreateDistributionWithTagsResultFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Distribution && { Distribution: (0, exports.DistributionFilterSensitiveLog)(obj.Distribution) }),
});
exports.CreateDistributionWithTagsResultFilterSensitiveLog = CreateDistributionWithTagsResultFilterSensitiveLog;
const CreateFunctionRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.FunctionCode && { FunctionCode: smithy_client_1.SENSITIVE_STRING }),
});
exports.CreateFunctionRequestFilterSensitiveLog = CreateFunctionRequestFilterSensitiveLog;


/***/ }),

/***/ 76429:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateFunctionRequestFilterSensitiveLog = exports.UpdateDistributionWithStagingConfigResultFilterSensitiveLog = exports.UpdateDistributionResultFilterSensitiveLog = exports.UpdateDistributionRequestFilterSensitiveLog = exports.TestFunctionResultFilterSensitiveLog = exports.TestResultFilterSensitiveLog = exports.TestFunctionRequestFilterSensitiveLog = exports.ListDistributionsByWebACLIdResultFilterSensitiveLog = exports.ListDistributionsByRealtimeLogConfigResultFilterSensitiveLog = exports.ListDistributionsResultFilterSensitiveLog = exports.DistributionListFilterSensitiveLog = exports.DistributionSummaryFilterSensitiveLog = exports.GetFunctionResultFilterSensitiveLog = exports.GetDistributionConfigResultFilterSensitiveLog = exports.GetDistributionResultFilterSensitiveLog = exports.TestFunctionFailed = exports.ResponseHeadersPolicyType = exports.OriginRequestPolicyType = exports.NoSuchInvalidation = exports.StreamingDistributionNotDisabled = exports.NoSuchStreamingDistribution = exports.ResponseHeadersPolicyInUse = exports.RealtimeLogConfigInUse = exports.PublicKeyInUse = exports.OriginRequestPolicyInUse = exports.OriginAccessControlInUse = exports.NoSuchOriginAccessControl = exports.NoSuchMonitoringSubscription = exports.EntityNotFound = exports.ResourceInUse = exports.NoSuchResource = exports.NoSuchFunctionExists = exports.FunctionInUse = exports.FieldLevelEncryptionProfileInUse = exports.FieldLevelEncryptionConfigInUse = exports.DistributionNotDisabled = exports.NoSuchCloudFrontOriginAccessIdentity = exports.CloudFrontOriginAccessIdentityInUse = exports.IllegalDelete = exports.TooManyStreamingDistributions = exports.TooManyStreamingDistributionCNAMEs = exports.StreamingDistributionAlreadyExists = exports.TooManyResponseHeadersPolicies = exports.TooManyRemoveHeadersInResponseHeadersPolicy = exports.TooManyCustomHeadersInResponseHeadersPolicy = exports.TooLongCSPInResponseHeadersPolicy = exports.ResponseHeadersPolicyAlreadyExists = exports.ReferrerPolicyList = exports.FrameOptionsList = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const CloudFrontServiceException_1 = __nccwpck_require__(90671);
const models_0_1 = __nccwpck_require__(52996);
exports.FrameOptionsList = {
    DENY: "DENY",
    SAMEORIGIN: "SAMEORIGIN",
};
exports.ReferrerPolicyList = {
    no_referrer: "no-referrer",
    no_referrer_when_downgrade: "no-referrer-when-downgrade",
    origin: "origin",
    origin_when_cross_origin: "origin-when-cross-origin",
    same_origin: "same-origin",
    strict_origin: "strict-origin",
    strict_origin_when_cross_origin: "strict-origin-when-cross-origin",
    unsafe_url: "unsafe-url",
};
class ResponseHeadersPolicyAlreadyExists extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "ResponseHeadersPolicyAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "ResponseHeadersPolicyAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResponseHeadersPolicyAlreadyExists.prototype);
        this.Message = opts.Message;
    }
}
exports.ResponseHeadersPolicyAlreadyExists = ResponseHeadersPolicyAlreadyExists;
class TooLongCSPInResponseHeadersPolicy extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooLongCSPInResponseHeadersPolicy",
            $fault: "client",
            ...opts,
        });
        this.name = "TooLongCSPInResponseHeadersPolicy";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooLongCSPInResponseHeadersPolicy.prototype);
        this.Message = opts.Message;
    }
}
exports.TooLongCSPInResponseHeadersPolicy = TooLongCSPInResponseHeadersPolicy;
class TooManyCustomHeadersInResponseHeadersPolicy extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyCustomHeadersInResponseHeadersPolicy",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyCustomHeadersInResponseHeadersPolicy";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyCustomHeadersInResponseHeadersPolicy.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyCustomHeadersInResponseHeadersPolicy = TooManyCustomHeadersInResponseHeadersPolicy;
class TooManyRemoveHeadersInResponseHeadersPolicy extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyRemoveHeadersInResponseHeadersPolicy",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyRemoveHeadersInResponseHeadersPolicy";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyRemoveHeadersInResponseHeadersPolicy.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyRemoveHeadersInResponseHeadersPolicy = TooManyRemoveHeadersInResponseHeadersPolicy;
class TooManyResponseHeadersPolicies extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyResponseHeadersPolicies",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyResponseHeadersPolicies";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyResponseHeadersPolicies.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyResponseHeadersPolicies = TooManyResponseHeadersPolicies;
class StreamingDistributionAlreadyExists extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "StreamingDistributionAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "StreamingDistributionAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, StreamingDistributionAlreadyExists.prototype);
        this.Message = opts.Message;
    }
}
exports.StreamingDistributionAlreadyExists = StreamingDistributionAlreadyExists;
class TooManyStreamingDistributionCNAMEs extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyStreamingDistributionCNAMEs",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyStreamingDistributionCNAMEs";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyStreamingDistributionCNAMEs.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyStreamingDistributionCNAMEs = TooManyStreamingDistributionCNAMEs;
class TooManyStreamingDistributions extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TooManyStreamingDistributions",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyStreamingDistributions";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyStreamingDistributions.prototype);
        this.Message = opts.Message;
    }
}
exports.TooManyStreamingDistributions = TooManyStreamingDistributions;
class IllegalDelete extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "IllegalDelete",
            $fault: "client",
            ...opts,
        });
        this.name = "IllegalDelete";
        this.$fault = "client";
        Object.setPrototypeOf(this, IllegalDelete.prototype);
        this.Message = opts.Message;
    }
}
exports.IllegalDelete = IllegalDelete;
class CloudFrontOriginAccessIdentityInUse extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "CloudFrontOriginAccessIdentityInUse",
            $fault: "client",
            ...opts,
        });
        this.name = "CloudFrontOriginAccessIdentityInUse";
        this.$fault = "client";
        Object.setPrototypeOf(this, CloudFrontOriginAccessIdentityInUse.prototype);
        this.Message = opts.Message;
    }
}
exports.CloudFrontOriginAccessIdentityInUse = CloudFrontOriginAccessIdentityInUse;
class NoSuchCloudFrontOriginAccessIdentity extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "NoSuchCloudFrontOriginAccessIdentity",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchCloudFrontOriginAccessIdentity";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchCloudFrontOriginAccessIdentity.prototype);
        this.Message = opts.Message;
    }
}
exports.NoSuchCloudFrontOriginAccessIdentity = NoSuchCloudFrontOriginAccessIdentity;
class DistributionNotDisabled extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "DistributionNotDisabled",
            $fault: "client",
            ...opts,
        });
        this.name = "DistributionNotDisabled";
        this.$fault = "client";
        Object.setPrototypeOf(this, DistributionNotDisabled.prototype);
        this.Message = opts.Message;
    }
}
exports.DistributionNotDisabled = DistributionNotDisabled;
class FieldLevelEncryptionConfigInUse extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "FieldLevelEncryptionConfigInUse",
            $fault: "client",
            ...opts,
        });
        this.name = "FieldLevelEncryptionConfigInUse";
        this.$fault = "client";
        Object.setPrototypeOf(this, FieldLevelEncryptionConfigInUse.prototype);
        this.Message = opts.Message;
    }
}
exports.FieldLevelEncryptionConfigInUse = FieldLevelEncryptionConfigInUse;
class FieldLevelEncryptionProfileInUse extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "FieldLevelEncryptionProfileInUse",
            $fault: "client",
            ...opts,
        });
        this.name = "FieldLevelEncryptionProfileInUse";
        this.$fault = "client";
        Object.setPrototypeOf(this, FieldLevelEncryptionProfileInUse.prototype);
        this.Message = opts.Message;
    }
}
exports.FieldLevelEncryptionProfileInUse = FieldLevelEncryptionProfileInUse;
class FunctionInUse extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "FunctionInUse",
            $fault: "client",
            ...opts,
        });
        this.name = "FunctionInUse";
        this.$fault = "client";
        Object.setPrototypeOf(this, FunctionInUse.prototype);
        this.Message = opts.Message;
    }
}
exports.FunctionInUse = FunctionInUse;
class NoSuchFunctionExists extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "NoSuchFunctionExists",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchFunctionExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchFunctionExists.prototype);
        this.Message = opts.Message;
    }
}
exports.NoSuchFunctionExists = NoSuchFunctionExists;
class NoSuchResource extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "NoSuchResource",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchResource";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchResource.prototype);
        this.Message = opts.Message;
    }
}
exports.NoSuchResource = NoSuchResource;
class ResourceInUse extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "ResourceInUse",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceInUse";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceInUse.prototype);
        this.Message = opts.Message;
    }
}
exports.ResourceInUse = ResourceInUse;
class EntityNotFound extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "EntityNotFound",
            $fault: "client",
            ...opts,
        });
        this.name = "EntityNotFound";
        this.$fault = "client";
        Object.setPrototypeOf(this, EntityNotFound.prototype);
        this.Message = opts.Message;
    }
}
exports.EntityNotFound = EntityNotFound;
class NoSuchMonitoringSubscription extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "NoSuchMonitoringSubscription",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchMonitoringSubscription";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchMonitoringSubscription.prototype);
        this.Message = opts.Message;
    }
}
exports.NoSuchMonitoringSubscription = NoSuchMonitoringSubscription;
class NoSuchOriginAccessControl extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "NoSuchOriginAccessControl",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchOriginAccessControl";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchOriginAccessControl.prototype);
        this.Message = opts.Message;
    }
}
exports.NoSuchOriginAccessControl = NoSuchOriginAccessControl;
class OriginAccessControlInUse extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "OriginAccessControlInUse",
            $fault: "client",
            ...opts,
        });
        this.name = "OriginAccessControlInUse";
        this.$fault = "client";
        Object.setPrototypeOf(this, OriginAccessControlInUse.prototype);
        this.Message = opts.Message;
    }
}
exports.OriginAccessControlInUse = OriginAccessControlInUse;
class OriginRequestPolicyInUse extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "OriginRequestPolicyInUse",
            $fault: "client",
            ...opts,
        });
        this.name = "OriginRequestPolicyInUse";
        this.$fault = "client";
        Object.setPrototypeOf(this, OriginRequestPolicyInUse.prototype);
        this.Message = opts.Message;
    }
}
exports.OriginRequestPolicyInUse = OriginRequestPolicyInUse;
class PublicKeyInUse extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "PublicKeyInUse",
            $fault: "client",
            ...opts,
        });
        this.name = "PublicKeyInUse";
        this.$fault = "client";
        Object.setPrototypeOf(this, PublicKeyInUse.prototype);
        this.Message = opts.Message;
    }
}
exports.PublicKeyInUse = PublicKeyInUse;
class RealtimeLogConfigInUse extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "RealtimeLogConfigInUse",
            $fault: "client",
            ...opts,
        });
        this.name = "RealtimeLogConfigInUse";
        this.$fault = "client";
        Object.setPrototypeOf(this, RealtimeLogConfigInUse.prototype);
        this.Message = opts.Message;
    }
}
exports.RealtimeLogConfigInUse = RealtimeLogConfigInUse;
class ResponseHeadersPolicyInUse extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "ResponseHeadersPolicyInUse",
            $fault: "client",
            ...opts,
        });
        this.name = "ResponseHeadersPolicyInUse";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResponseHeadersPolicyInUse.prototype);
        this.Message = opts.Message;
    }
}
exports.ResponseHeadersPolicyInUse = ResponseHeadersPolicyInUse;
class NoSuchStreamingDistribution extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "NoSuchStreamingDistribution",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchStreamingDistribution";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchStreamingDistribution.prototype);
        this.Message = opts.Message;
    }
}
exports.NoSuchStreamingDistribution = NoSuchStreamingDistribution;
class StreamingDistributionNotDisabled extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "StreamingDistributionNotDisabled",
            $fault: "client",
            ...opts,
        });
        this.name = "StreamingDistributionNotDisabled";
        this.$fault = "client";
        Object.setPrototypeOf(this, StreamingDistributionNotDisabled.prototype);
        this.Message = opts.Message;
    }
}
exports.StreamingDistributionNotDisabled = StreamingDistributionNotDisabled;
class NoSuchInvalidation extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "NoSuchInvalidation",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchInvalidation";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchInvalidation.prototype);
        this.Message = opts.Message;
    }
}
exports.NoSuchInvalidation = NoSuchInvalidation;
exports.OriginRequestPolicyType = {
    custom: "custom",
    managed: "managed",
};
exports.ResponseHeadersPolicyType = {
    custom: "custom",
    managed: "managed",
};
class TestFunctionFailed extends CloudFrontServiceException_1.CloudFrontServiceException {
    constructor(opts) {
        super({
            name: "TestFunctionFailed",
            $fault: "server",
            ...opts,
        });
        this.name = "TestFunctionFailed";
        this.$fault = "server";
        Object.setPrototypeOf(this, TestFunctionFailed.prototype);
        this.Message = opts.Message;
    }
}
exports.TestFunctionFailed = TestFunctionFailed;
const GetDistributionResultFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Distribution && { Distribution: (0, models_0_1.DistributionFilterSensitiveLog)(obj.Distribution) }),
});
exports.GetDistributionResultFilterSensitiveLog = GetDistributionResultFilterSensitiveLog;
const GetDistributionConfigResultFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.DistributionConfig && { DistributionConfig: (0, models_0_1.DistributionConfigFilterSensitiveLog)(obj.DistributionConfig) }),
});
exports.GetDistributionConfigResultFilterSensitiveLog = GetDistributionConfigResultFilterSensitiveLog;
const GetFunctionResultFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.FunctionCode && { FunctionCode: smithy_client_1.SENSITIVE_STRING }),
});
exports.GetFunctionResultFilterSensitiveLog = GetFunctionResultFilterSensitiveLog;
const DistributionSummaryFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DistributionSummaryFilterSensitiveLog = DistributionSummaryFilterSensitiveLog;
const DistributionListFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.DistributionListFilterSensitiveLog = DistributionListFilterSensitiveLog;
const ListDistributionsResultFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListDistributionsResultFilterSensitiveLog = ListDistributionsResultFilterSensitiveLog;
const ListDistributionsByRealtimeLogConfigResultFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListDistributionsByRealtimeLogConfigResultFilterSensitiveLog = ListDistributionsByRealtimeLogConfigResultFilterSensitiveLog;
const ListDistributionsByWebACLIdResultFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.ListDistributionsByWebACLIdResultFilterSensitiveLog = ListDistributionsByWebACLIdResultFilterSensitiveLog;
const TestFunctionRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.EventObject && { EventObject: smithy_client_1.SENSITIVE_STRING }),
});
exports.TestFunctionRequestFilterSensitiveLog = TestFunctionRequestFilterSensitiveLog;
const TestResultFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.FunctionExecutionLogs && { FunctionExecutionLogs: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.FunctionErrorMessage && { FunctionErrorMessage: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.FunctionOutput && { FunctionOutput: smithy_client_1.SENSITIVE_STRING }),
});
exports.TestResultFilterSensitiveLog = TestResultFilterSensitiveLog;
const TestFunctionResultFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.TestResult && { TestResult: (0, exports.TestResultFilterSensitiveLog)(obj.TestResult) }),
});
exports.TestFunctionResultFilterSensitiveLog = TestFunctionResultFilterSensitiveLog;
const UpdateDistributionRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.DistributionConfig && { DistributionConfig: (0, models_0_1.DistributionConfigFilterSensitiveLog)(obj.DistributionConfig) }),
});
exports.UpdateDistributionRequestFilterSensitiveLog = UpdateDistributionRequestFilterSensitiveLog;
const UpdateDistributionResultFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Distribution && { Distribution: (0, models_0_1.DistributionFilterSensitiveLog)(obj.Distribution) }),
});
exports.UpdateDistributionResultFilterSensitiveLog = UpdateDistributionResultFilterSensitiveLog;
const UpdateDistributionWithStagingConfigResultFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Distribution && { Distribution: (0, models_0_1.DistributionFilterSensitiveLog)(obj.Distribution) }),
});
exports.UpdateDistributionWithStagingConfigResultFilterSensitiveLog = UpdateDistributionWithStagingConfigResultFilterSensitiveLog;
const UpdateFunctionRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.FunctionCode && { FunctionCode: smithy_client_1.SENSITIVE_STRING }),
});
exports.UpdateFunctionRequestFilterSensitiveLog = UpdateFunctionRequestFilterSensitiveLog;


/***/ }),

/***/ 20302:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 2937:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListCloudFrontOriginAccessIdentities = void 0;
const core_1 = __nccwpck_require__(55829);
const CloudFrontClient_1 = __nccwpck_require__(59397);
const ListCloudFrontOriginAccessIdentitiesCommand_1 = __nccwpck_require__(74932);
exports.paginateListCloudFrontOriginAccessIdentities = (0, core_1.createPaginator)(CloudFrontClient_1.CloudFrontClient, ListCloudFrontOriginAccessIdentitiesCommand_1.ListCloudFrontOriginAccessIdentitiesCommand, "Marker", "CloudFrontOriginAccessIdentityList.NextMarker", "MaxItems");


/***/ }),

/***/ 29497:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListDistributions = void 0;
const core_1 = __nccwpck_require__(55829);
const CloudFrontClient_1 = __nccwpck_require__(59397);
const ListDistributionsCommand_1 = __nccwpck_require__(80928);
exports.paginateListDistributions = (0, core_1.createPaginator)(CloudFrontClient_1.CloudFrontClient, ListDistributionsCommand_1.ListDistributionsCommand, "Marker", "DistributionList.NextMarker", "MaxItems");


/***/ }),

/***/ 26605:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListInvalidations = void 0;
const core_1 = __nccwpck_require__(55829);
const CloudFrontClient_1 = __nccwpck_require__(59397);
const ListInvalidationsCommand_1 = __nccwpck_require__(65495);
exports.paginateListInvalidations = (0, core_1.createPaginator)(CloudFrontClient_1.CloudFrontClient, ListInvalidationsCommand_1.ListInvalidationsCommand, "Marker", "InvalidationList.NextMarker", "MaxItems");


/***/ }),

/***/ 6515:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListKeyValueStores = void 0;
const core_1 = __nccwpck_require__(55829);
const CloudFrontClient_1 = __nccwpck_require__(59397);
const ListKeyValueStoresCommand_1 = __nccwpck_require__(95246);
exports.paginateListKeyValueStores = (0, core_1.createPaginator)(CloudFrontClient_1.CloudFrontClient, ListKeyValueStoresCommand_1.ListKeyValueStoresCommand, "Marker", "KeyValueStoreList.NextMarker", "MaxItems");


/***/ }),

/***/ 88103:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListStreamingDistributions = void 0;
const core_1 = __nccwpck_require__(55829);
const CloudFrontClient_1 = __nccwpck_require__(59397);
const ListStreamingDistributionsCommand_1 = __nccwpck_require__(83635);
exports.paginateListStreamingDistributions = (0, core_1.createPaginator)(CloudFrontClient_1.CloudFrontClient, ListStreamingDistributionsCommand_1.ListStreamingDistributionsCommand, "Marker", "StreamingDistributionList.NextMarker", "MaxItems");


/***/ }),

/***/ 87517:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(20302), exports);
tslib_1.__exportStar(__nccwpck_require__(2937), exports);
tslib_1.__exportStar(__nccwpck_require__(29497), exports);
tslib_1.__exportStar(__nccwpck_require__(26605), exports);
tslib_1.__exportStar(__nccwpck_require__(6515), exports);
tslib_1.__exportStar(__nccwpck_require__(88103), exports);


/***/ }),

/***/ 1983:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.se_GetFieldLevelEncryptionProfileCommand = exports.se_GetFieldLevelEncryptionConfigCommand = exports.se_GetFieldLevelEncryptionCommand = exports.se_GetDistributionConfigCommand = exports.se_GetDistributionCommand = exports.se_GetContinuousDeploymentPolicyConfigCommand = exports.se_GetContinuousDeploymentPolicyCommand = exports.se_GetCloudFrontOriginAccessIdentityConfigCommand = exports.se_GetCloudFrontOriginAccessIdentityCommand = exports.se_GetCachePolicyConfigCommand = exports.se_GetCachePolicyCommand = exports.se_DescribeKeyValueStoreCommand = exports.se_DescribeFunctionCommand = exports.se_DeleteStreamingDistributionCommand = exports.se_DeleteResponseHeadersPolicyCommand = exports.se_DeleteRealtimeLogConfigCommand = exports.se_DeletePublicKeyCommand = exports.se_DeleteOriginRequestPolicyCommand = exports.se_DeleteOriginAccessControlCommand = exports.se_DeleteMonitoringSubscriptionCommand = exports.se_DeleteKeyValueStoreCommand = exports.se_DeleteKeyGroupCommand = exports.se_DeleteFunctionCommand = exports.se_DeleteFieldLevelEncryptionProfileCommand = exports.se_DeleteFieldLevelEncryptionConfigCommand = exports.se_DeleteDistributionCommand = exports.se_DeleteContinuousDeploymentPolicyCommand = exports.se_DeleteCloudFrontOriginAccessIdentityCommand = exports.se_DeleteCachePolicyCommand = exports.se_CreateStreamingDistributionWithTagsCommand = exports.se_CreateStreamingDistributionCommand = exports.se_CreateResponseHeadersPolicyCommand = exports.se_CreateRealtimeLogConfigCommand = exports.se_CreatePublicKeyCommand = exports.se_CreateOriginRequestPolicyCommand = exports.se_CreateOriginAccessControlCommand = exports.se_CreateMonitoringSubscriptionCommand = exports.se_CreateKeyValueStoreCommand = exports.se_CreateKeyGroupCommand = exports.se_CreateInvalidationCommand = exports.se_CreateFunctionCommand = exports.se_CreateFieldLevelEncryptionProfileCommand = exports.se_CreateFieldLevelEncryptionConfigCommand = exports.se_CreateDistributionWithTagsCommand = exports.se_CreateDistributionCommand = exports.se_CreateContinuousDeploymentPolicyCommand = exports.se_CreateCloudFrontOriginAccessIdentityCommand = exports.se_CreateCachePolicyCommand = exports.se_CopyDistributionCommand = exports.se_AssociateAliasCommand = void 0;
exports.se_UpdateDistributionWithStagingConfigCommand = exports.se_UpdateDistributionCommand = exports.se_UpdateContinuousDeploymentPolicyCommand = exports.se_UpdateCloudFrontOriginAccessIdentityCommand = exports.se_UpdateCachePolicyCommand = exports.se_UntagResourceCommand = exports.se_TestFunctionCommand = exports.se_TagResourceCommand = exports.se_PublishFunctionCommand = exports.se_ListTagsForResourceCommand = exports.se_ListStreamingDistributionsCommand = exports.se_ListResponseHeadersPoliciesCommand = exports.se_ListRealtimeLogConfigsCommand = exports.se_ListPublicKeysCommand = exports.se_ListOriginRequestPoliciesCommand = exports.se_ListOriginAccessControlsCommand = exports.se_ListKeyValueStoresCommand = exports.se_ListKeyGroupsCommand = exports.se_ListInvalidationsCommand = exports.se_ListFunctionsCommand = exports.se_ListFieldLevelEncryptionProfilesCommand = exports.se_ListFieldLevelEncryptionConfigsCommand = exports.se_ListDistributionsByWebACLIdCommand = exports.se_ListDistributionsByResponseHeadersPolicyIdCommand = exports.se_ListDistributionsByRealtimeLogConfigCommand = exports.se_ListDistributionsByOriginRequestPolicyIdCommand = exports.se_ListDistributionsByKeyGroupCommand = exports.se_ListDistributionsByCachePolicyIdCommand = exports.se_ListDistributionsCommand = exports.se_ListContinuousDeploymentPoliciesCommand = exports.se_ListConflictingAliasesCommand = exports.se_ListCloudFrontOriginAccessIdentitiesCommand = exports.se_ListCachePoliciesCommand = exports.se_GetStreamingDistributionConfigCommand = exports.se_GetStreamingDistributionCommand = exports.se_GetResponseHeadersPolicyConfigCommand = exports.se_GetResponseHeadersPolicyCommand = exports.se_GetRealtimeLogConfigCommand = exports.se_GetPublicKeyConfigCommand = exports.se_GetPublicKeyCommand = exports.se_GetOriginRequestPolicyConfigCommand = exports.se_GetOriginRequestPolicyCommand = exports.se_GetOriginAccessControlConfigCommand = exports.se_GetOriginAccessControlCommand = exports.se_GetMonitoringSubscriptionCommand = exports.se_GetKeyGroupConfigCommand = exports.se_GetKeyGroupCommand = exports.se_GetInvalidationCommand = exports.se_GetFunctionCommand = exports.se_GetFieldLevelEncryptionProfileConfigCommand = void 0;
exports.de_DescribeKeyValueStoreCommand = exports.de_DescribeFunctionCommand = exports.de_DeleteStreamingDistributionCommand = exports.de_DeleteResponseHeadersPolicyCommand = exports.de_DeleteRealtimeLogConfigCommand = exports.de_DeletePublicKeyCommand = exports.de_DeleteOriginRequestPolicyCommand = exports.de_DeleteOriginAccessControlCommand = exports.de_DeleteMonitoringSubscriptionCommand = exports.de_DeleteKeyValueStoreCommand = exports.de_DeleteKeyGroupCommand = exports.de_DeleteFunctionCommand = exports.de_DeleteFieldLevelEncryptionProfileCommand = exports.de_DeleteFieldLevelEncryptionConfigCommand = exports.de_DeleteDistributionCommand = exports.de_DeleteContinuousDeploymentPolicyCommand = exports.de_DeleteCloudFrontOriginAccessIdentityCommand = exports.de_DeleteCachePolicyCommand = exports.de_CreateStreamingDistributionWithTagsCommand = exports.de_CreateStreamingDistributionCommand = exports.de_CreateResponseHeadersPolicyCommand = exports.de_CreateRealtimeLogConfigCommand = exports.de_CreatePublicKeyCommand = exports.de_CreateOriginRequestPolicyCommand = exports.de_CreateOriginAccessControlCommand = exports.de_CreateMonitoringSubscriptionCommand = exports.de_CreateKeyValueStoreCommand = exports.de_CreateKeyGroupCommand = exports.de_CreateInvalidationCommand = exports.de_CreateFunctionCommand = exports.de_CreateFieldLevelEncryptionProfileCommand = exports.de_CreateFieldLevelEncryptionConfigCommand = exports.de_CreateDistributionWithTagsCommand = exports.de_CreateDistributionCommand = exports.de_CreateContinuousDeploymentPolicyCommand = exports.de_CreateCloudFrontOriginAccessIdentityCommand = exports.de_CreateCachePolicyCommand = exports.de_CopyDistributionCommand = exports.de_AssociateAliasCommand = exports.se_UpdateStreamingDistributionCommand = exports.se_UpdateResponseHeadersPolicyCommand = exports.se_UpdateRealtimeLogConfigCommand = exports.se_UpdatePublicKeyCommand = exports.se_UpdateOriginRequestPolicyCommand = exports.se_UpdateOriginAccessControlCommand = exports.se_UpdateKeyValueStoreCommand = exports.se_UpdateKeyGroupCommand = exports.se_UpdateFunctionCommand = exports.se_UpdateFieldLevelEncryptionProfileCommand = exports.se_UpdateFieldLevelEncryptionConfigCommand = void 0;
exports.de_ListResponseHeadersPoliciesCommand = exports.de_ListRealtimeLogConfigsCommand = exports.de_ListPublicKeysCommand = exports.de_ListOriginRequestPoliciesCommand = exports.de_ListOriginAccessControlsCommand = exports.de_ListKeyValueStoresCommand = exports.de_ListKeyGroupsCommand = exports.de_ListInvalidationsCommand = exports.de_ListFunctionsCommand = exports.de_ListFieldLevelEncryptionProfilesCommand = exports.de_ListFieldLevelEncryptionConfigsCommand = exports.de_ListDistributionsByWebACLIdCommand = exports.de_ListDistributionsByResponseHeadersPolicyIdCommand = exports.de_ListDistributionsByRealtimeLogConfigCommand = exports.de_ListDistributionsByOriginRequestPolicyIdCommand = exports.de_ListDistributionsByKeyGroupCommand = exports.de_ListDistributionsByCachePolicyIdCommand = exports.de_ListDistributionsCommand = exports.de_ListContinuousDeploymentPoliciesCommand = exports.de_ListConflictingAliasesCommand = exports.de_ListCloudFrontOriginAccessIdentitiesCommand = exports.de_ListCachePoliciesCommand = exports.de_GetStreamingDistributionConfigCommand = exports.de_GetStreamingDistributionCommand = exports.de_GetResponseHeadersPolicyConfigCommand = exports.de_GetResponseHeadersPolicyCommand = exports.de_GetRealtimeLogConfigCommand = exports.de_GetPublicKeyConfigCommand = exports.de_GetPublicKeyCommand = exports.de_GetOriginRequestPolicyConfigCommand = exports.de_GetOriginRequestPolicyCommand = exports.de_GetOriginAccessControlConfigCommand = exports.de_GetOriginAccessControlCommand = exports.de_GetMonitoringSubscriptionCommand = exports.de_GetKeyGroupConfigCommand = exports.de_GetKeyGroupCommand = exports.de_GetInvalidationCommand = exports.de_GetFunctionCommand = exports.de_GetFieldLevelEncryptionProfileConfigCommand = exports.de_GetFieldLevelEncryptionProfileCommand = exports.de_GetFieldLevelEncryptionConfigCommand = exports.de_GetFieldLevelEncryptionCommand = exports.de_GetDistributionConfigCommand = exports.de_GetDistributionCommand = exports.de_GetContinuousDeploymentPolicyConfigCommand = exports.de_GetContinuousDeploymentPolicyCommand = exports.de_GetCloudFrontOriginAccessIdentityConfigCommand = exports.de_GetCloudFrontOriginAccessIdentityCommand = exports.de_GetCachePolicyConfigCommand = exports.de_GetCachePolicyCommand = void 0;
exports.de_UpdateStreamingDistributionCommand = exports.de_UpdateResponseHeadersPolicyCommand = exports.de_UpdateRealtimeLogConfigCommand = exports.de_UpdatePublicKeyCommand = exports.de_UpdateOriginRequestPolicyCommand = exports.de_UpdateOriginAccessControlCommand = exports.de_UpdateKeyValueStoreCommand = exports.de_UpdateKeyGroupCommand = exports.de_UpdateFunctionCommand = exports.de_UpdateFieldLevelEncryptionProfileCommand = exports.de_UpdateFieldLevelEncryptionConfigCommand = exports.de_UpdateDistributionWithStagingConfigCommand = exports.de_UpdateDistributionCommand = exports.de_UpdateContinuousDeploymentPolicyCommand = exports.de_UpdateCloudFrontOriginAccessIdentityCommand = exports.de_UpdateCachePolicyCommand = exports.de_UntagResourceCommand = exports.de_TestFunctionCommand = exports.de_TagResourceCommand = exports.de_PublishFunctionCommand = exports.de_ListTagsForResourceCommand = exports.de_ListStreamingDistributionsCommand = void 0;
const xml_builder_1 = __nccwpck_require__(42329);
const core_1 = __nccwpck_require__(55829);
const smithy_client_1 = __nccwpck_require__(63570);
const fast_xml_parser_1 = __nccwpck_require__(12603);
const CloudFrontServiceException_1 = __nccwpck_require__(90671);
const models_0_1 = __nccwpck_require__(52996);
const models_1_1 = __nccwpck_require__(76429);
const se_AssociateAliasCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distribution/{TargetDistributionId}/associate-alias");
    b.p("TargetDistributionId", () => input.TargetDistributionId, "{TargetDistributionId}", false);
    const query = (0, smithy_client_1.map)({
        [_A]: [, (0, smithy_client_1.expectNonNull)(input[_A], `Alias`)],
    });
    let body;
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_AssociateAliasCommand = se_AssociateAliasCommand;
const se_CopyDistributionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_s]: [() => isSerializableHeaderValue(input[_S]), () => input[_S].toString()],
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/distribution/{PrimaryDistributionId}/copy");
    b.p("PrimaryDistributionId", () => input.PrimaryDistributionId, "{PrimaryDistributionId}", false);
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_CDR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_CR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CR]).n(_CR));
    }
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    body += bn.toString();
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CopyDistributionCommand = se_CopyDistributionCommand;
const se_CreateCachePolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/cache-policy");
    let body;
    let contents;
    if (input.CachePolicyConfig !== undefined) {
        contents = se_CachePolicyConfig(input.CachePolicyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateCachePolicyCommand = se_CreateCachePolicyCommand;
const se_CreateCloudFrontOriginAccessIdentityCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/origin-access-identity/cloudfront");
    let body;
    let contents;
    if (input.CloudFrontOriginAccessIdentityConfig !== undefined) {
        contents = se_CloudFrontOriginAccessIdentityConfig(input.CloudFrontOriginAccessIdentityConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateCloudFrontOriginAccessIdentityCommand = se_CreateCloudFrontOriginAccessIdentityCommand;
const se_CreateContinuousDeploymentPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/continuous-deployment-policy");
    let body;
    let contents;
    if (input.ContinuousDeploymentPolicyConfig !== undefined) {
        contents = se_ContinuousDeploymentPolicyConfig(input.ContinuousDeploymentPolicyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateContinuousDeploymentPolicyCommand = se_CreateContinuousDeploymentPolicyCommand;
const se_CreateDistributionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/distribution");
    let body;
    let contents;
    if (input.DistributionConfig !== undefined) {
        contents = se_DistributionConfig(input.DistributionConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateDistributionCommand = se_CreateDistributionCommand;
const se_CreateDistributionWithTagsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/distribution");
    const query = (0, smithy_client_1.map)({
        [_WT]: [, ""],
    });
    let body;
    let contents;
    if (input.DistributionConfigWithTags !== undefined) {
        contents = se_DistributionConfigWithTags(input.DistributionConfigWithTags, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_CreateDistributionWithTagsCommand = se_CreateDistributionWithTagsCommand;
const se_CreateFieldLevelEncryptionConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/field-level-encryption");
    let body;
    let contents;
    if (input.FieldLevelEncryptionConfig !== undefined) {
        contents = se_FieldLevelEncryptionConfig(input.FieldLevelEncryptionConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateFieldLevelEncryptionConfigCommand = se_CreateFieldLevelEncryptionConfigCommand;
const se_CreateFieldLevelEncryptionProfileCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/field-level-encryption-profile");
    let body;
    let contents;
    if (input.FieldLevelEncryptionProfileConfig !== undefined) {
        contents = se_FieldLevelEncryptionProfileConfig(input.FieldLevelEncryptionProfileConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateFieldLevelEncryptionProfileCommand = se_CreateFieldLevelEncryptionProfileCommand;
const se_CreateFunctionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/function");
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_CFR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_FC] != null) {
        bn.c(xml_builder_1.XmlNode.of(_FB, context.base64Encoder(input[_FC])).n(_FC));
    }
    if (input[_FCu] != null) {
        bn.c(se_FunctionConfig(input[_FCu], context).n(_FCu));
    }
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_FN, input[_N]).n(_N));
    }
    body += bn.toString();
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateFunctionCommand = se_CreateFunctionCommand;
const se_CreateInvalidationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/distribution/{DistributionId}/invalidation");
    b.p("DistributionId", () => input.DistributionId, "{DistributionId}", false);
    let body;
    let contents;
    if (input.InvalidationBatch !== undefined) {
        contents = se_InvalidationBatch(input.InvalidationBatch, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateInvalidationCommand = se_CreateInvalidationCommand;
const se_CreateKeyGroupCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/key-group");
    let body;
    let contents;
    if (input.KeyGroupConfig !== undefined) {
        contents = se_KeyGroupConfig(input.KeyGroupConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateKeyGroupCommand = se_CreateKeyGroupCommand;
const se_CreateKeyValueStoreCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/key-value-store");
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_CKVSR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_KVSC, input[_C]).n(_C));
    }
    if (input[_IS] != null) {
        bn.c(se_ImportSource(input[_IS], context).n(_IS));
    }
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_KVSN, input[_N]).n(_N));
    }
    body += bn.toString();
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateKeyValueStoreCommand = se_CreateKeyValueStoreCommand;
const se_CreateMonitoringSubscriptionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/distributions/{DistributionId}/monitoring-subscription");
    b.p("DistributionId", () => input.DistributionId, "{DistributionId}", false);
    let body;
    let contents;
    if (input.MonitoringSubscription !== undefined) {
        contents = se_MonitoringSubscription(input.MonitoringSubscription, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateMonitoringSubscriptionCommand = se_CreateMonitoringSubscriptionCommand;
const se_CreateOriginAccessControlCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/origin-access-control");
    let body;
    let contents;
    if (input.OriginAccessControlConfig !== undefined) {
        contents = se_OriginAccessControlConfig(input.OriginAccessControlConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateOriginAccessControlCommand = se_CreateOriginAccessControlCommand;
const se_CreateOriginRequestPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/origin-request-policy");
    let body;
    let contents;
    if (input.OriginRequestPolicyConfig !== undefined) {
        contents = se_OriginRequestPolicyConfig(input.OriginRequestPolicyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateOriginRequestPolicyCommand = se_CreateOriginRequestPolicyCommand;
const se_CreatePublicKeyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/public-key");
    let body;
    let contents;
    if (input.PublicKeyConfig !== undefined) {
        contents = se_PublicKeyConfig(input.PublicKeyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreatePublicKeyCommand = se_CreatePublicKeyCommand;
const se_CreateRealtimeLogConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/realtime-log-config");
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_CRLCR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    bn.lc(input, "EndPoints", "EndPoints", () => se_EndPointList(input[_EP], context));
    bn.lc(input, "Fields", "Fields", () => se_FieldList(input[_F], context));
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    if (input[_SR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_SR])).n(_SR));
    }
    body += bn.toString();
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateRealtimeLogConfigCommand = se_CreateRealtimeLogConfigCommand;
const se_CreateResponseHeadersPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/response-headers-policy");
    let body;
    let contents;
    if (input.ResponseHeadersPolicyConfig !== undefined) {
        contents = se_ResponseHeadersPolicyConfig(input.ResponseHeadersPolicyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateResponseHeadersPolicyCommand = se_CreateResponseHeadersPolicyCommand;
const se_CreateStreamingDistributionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/streaming-distribution");
    let body;
    let contents;
    if (input.StreamingDistributionConfig !== undefined) {
        contents = se_StreamingDistributionConfig(input.StreamingDistributionConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_CreateStreamingDistributionCommand = se_CreateStreamingDistributionCommand;
const se_CreateStreamingDistributionWithTagsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/streaming-distribution");
    const query = (0, smithy_client_1.map)({
        [_WT]: [, ""],
    });
    let body;
    let contents;
    if (input.StreamingDistributionConfigWithTags !== undefined) {
        contents = se_StreamingDistributionConfigWithTags(input.StreamingDistributionConfigWithTags, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_CreateStreamingDistributionWithTagsCommand = se_CreateStreamingDistributionWithTagsCommand;
const se_DeleteCachePolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/cache-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteCachePolicyCommand = se_DeleteCachePolicyCommand;
const se_DeleteCloudFrontOriginAccessIdentityCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/origin-access-identity/cloudfront/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteCloudFrontOriginAccessIdentityCommand = se_DeleteCloudFrontOriginAccessIdentityCommand;
const se_DeleteContinuousDeploymentPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/continuous-deployment-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteContinuousDeploymentPolicyCommand = se_DeleteContinuousDeploymentPolicyCommand;
const se_DeleteDistributionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/distribution/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteDistributionCommand = se_DeleteDistributionCommand;
const se_DeleteFieldLevelEncryptionConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/field-level-encryption/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteFieldLevelEncryptionConfigCommand = se_DeleteFieldLevelEncryptionConfigCommand;
const se_DeleteFieldLevelEncryptionProfileCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/field-level-encryption-profile/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteFieldLevelEncryptionProfileCommand = se_DeleteFieldLevelEncryptionProfileCommand;
const se_DeleteFunctionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/function/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteFunctionCommand = se_DeleteFunctionCommand;
const se_DeleteKeyGroupCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/key-group/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteKeyGroupCommand = se_DeleteKeyGroupCommand;
const se_DeleteKeyValueStoreCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/key-value-store/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteKeyValueStoreCommand = se_DeleteKeyValueStoreCommand;
const se_DeleteMonitoringSubscriptionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distributions/{DistributionId}/monitoring-subscription");
    b.p("DistributionId", () => input.DistributionId, "{DistributionId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteMonitoringSubscriptionCommand = se_DeleteMonitoringSubscriptionCommand;
const se_DeleteOriginAccessControlCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/origin-access-control/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteOriginAccessControlCommand = se_DeleteOriginAccessControlCommand;
const se_DeleteOriginRequestPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/origin-request-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteOriginRequestPolicyCommand = se_DeleteOriginRequestPolicyCommand;
const se_DeletePublicKeyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/public-key/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeletePublicKeyCommand = se_DeletePublicKeyCommand;
const se_DeleteRealtimeLogConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/delete-realtime-log-config");
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_DRLCR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_ARN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_ARN]).n(_ARN));
    }
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    body += bn.toString();
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_DeleteRealtimeLogConfigCommand = se_DeleteRealtimeLogConfigCommand;
const se_DeleteResponseHeadersPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/response-headers-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteResponseHeadersPolicyCommand = se_DeleteResponseHeadersPolicyCommand;
const se_DeleteStreamingDistributionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/streaming-distribution/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteStreamingDistributionCommand = se_DeleteStreamingDistributionCommand;
const se_DescribeFunctionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/function/{Name}/describe");
    b.p("Name", () => input.Name, "{Name}", false);
    const query = (0, smithy_client_1.map)({
        [_St]: [, input[_St]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_DescribeFunctionCommand = se_DescribeFunctionCommand;
const se_DescribeKeyValueStoreCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/key-value-store/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_DescribeKeyValueStoreCommand = se_DescribeKeyValueStoreCommand;
const se_GetCachePolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/cache-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetCachePolicyCommand = se_GetCachePolicyCommand;
const se_GetCachePolicyConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/cache-policy/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetCachePolicyConfigCommand = se_GetCachePolicyConfigCommand;
const se_GetCloudFrontOriginAccessIdentityCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/origin-access-identity/cloudfront/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetCloudFrontOriginAccessIdentityCommand = se_GetCloudFrontOriginAccessIdentityCommand;
const se_GetCloudFrontOriginAccessIdentityConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/origin-access-identity/cloudfront/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetCloudFrontOriginAccessIdentityConfigCommand = se_GetCloudFrontOriginAccessIdentityConfigCommand;
const se_GetContinuousDeploymentPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/continuous-deployment-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetContinuousDeploymentPolicyCommand = se_GetContinuousDeploymentPolicyCommand;
const se_GetContinuousDeploymentPolicyConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/continuous-deployment-policy/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetContinuousDeploymentPolicyConfigCommand = se_GetContinuousDeploymentPolicyConfigCommand;
const se_GetDistributionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distribution/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetDistributionCommand = se_GetDistributionCommand;
const se_GetDistributionConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distribution/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetDistributionConfigCommand = se_GetDistributionConfigCommand;
const se_GetFieldLevelEncryptionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/field-level-encryption/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetFieldLevelEncryptionCommand = se_GetFieldLevelEncryptionCommand;
const se_GetFieldLevelEncryptionConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/field-level-encryption/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetFieldLevelEncryptionConfigCommand = se_GetFieldLevelEncryptionConfigCommand;
const se_GetFieldLevelEncryptionProfileCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/field-level-encryption-profile/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetFieldLevelEncryptionProfileCommand = se_GetFieldLevelEncryptionProfileCommand;
const se_GetFieldLevelEncryptionProfileConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/field-level-encryption-profile/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetFieldLevelEncryptionProfileConfigCommand = se_GetFieldLevelEncryptionProfileConfigCommand;
const se_GetFunctionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/function/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    const query = (0, smithy_client_1.map)({
        [_St]: [, input[_St]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetFunctionCommand = se_GetFunctionCommand;
const se_GetInvalidationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distribution/{DistributionId}/invalidation/{Id}");
    b.p("DistributionId", () => input.DistributionId, "{DistributionId}", false);
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetInvalidationCommand = se_GetInvalidationCommand;
const se_GetKeyGroupCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/key-group/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetKeyGroupCommand = se_GetKeyGroupCommand;
const se_GetKeyGroupConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/key-group/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetKeyGroupConfigCommand = se_GetKeyGroupConfigCommand;
const se_GetMonitoringSubscriptionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distributions/{DistributionId}/monitoring-subscription");
    b.p("DistributionId", () => input.DistributionId, "{DistributionId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetMonitoringSubscriptionCommand = se_GetMonitoringSubscriptionCommand;
const se_GetOriginAccessControlCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/origin-access-control/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetOriginAccessControlCommand = se_GetOriginAccessControlCommand;
const se_GetOriginAccessControlConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/origin-access-control/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetOriginAccessControlConfigCommand = se_GetOriginAccessControlConfigCommand;
const se_GetOriginRequestPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/origin-request-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetOriginRequestPolicyCommand = se_GetOriginRequestPolicyCommand;
const se_GetOriginRequestPolicyConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/origin-request-policy/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetOriginRequestPolicyConfigCommand = se_GetOriginRequestPolicyConfigCommand;
const se_GetPublicKeyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/public-key/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetPublicKeyCommand = se_GetPublicKeyCommand;
const se_GetPublicKeyConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/public-key/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetPublicKeyConfigCommand = se_GetPublicKeyConfigCommand;
const se_GetRealtimeLogConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/get-realtime-log-config");
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_GRLCR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_ARN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_ARN]).n(_ARN));
    }
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    body += bn.toString();
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_GetRealtimeLogConfigCommand = se_GetRealtimeLogConfigCommand;
const se_GetResponseHeadersPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/response-headers-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetResponseHeadersPolicyCommand = se_GetResponseHeadersPolicyCommand;
const se_GetResponseHeadersPolicyConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/response-headers-policy/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetResponseHeadersPolicyConfigCommand = se_GetResponseHeadersPolicyConfigCommand;
const se_GetStreamingDistributionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/streaming-distribution/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetStreamingDistributionCommand = se_GetStreamingDistributionCommand;
const se_GetStreamingDistributionConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/streaming-distribution/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
exports.se_GetStreamingDistributionConfigCommand = se_GetStreamingDistributionConfigCommand;
const se_ListCachePoliciesCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/cache-policy");
    const query = (0, smithy_client_1.map)({
        [_T]: [, input[_T]],
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListCachePoliciesCommand = se_ListCachePoliciesCommand;
const se_ListCloudFrontOriginAccessIdentitiesCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/origin-access-identity/cloudfront");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListCloudFrontOriginAccessIdentitiesCommand = se_ListCloudFrontOriginAccessIdentitiesCommand;
const se_ListConflictingAliasesCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/conflicting-alias");
    const query = (0, smithy_client_1.map)({
        [_DI]: [, (0, smithy_client_1.expectNonNull)(input[_DI], `DistributionId`)],
        [_A]: [, (0, smithy_client_1.expectNonNull)(input[_A], `Alias`)],
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListConflictingAliasesCommand = se_ListConflictingAliasesCommand;
const se_ListContinuousDeploymentPoliciesCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/continuous-deployment-policy");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListContinuousDeploymentPoliciesCommand = se_ListContinuousDeploymentPoliciesCommand;
const se_ListDistributionsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distribution");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListDistributionsCommand = se_ListDistributionsCommand;
const se_ListDistributionsByCachePolicyIdCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distributionsByCachePolicyId/{CachePolicyId}");
    b.p("CachePolicyId", () => input.CachePolicyId, "{CachePolicyId}", false);
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListDistributionsByCachePolicyIdCommand = se_ListDistributionsByCachePolicyIdCommand;
const se_ListDistributionsByKeyGroupCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distributionsByKeyGroupId/{KeyGroupId}");
    b.p("KeyGroupId", () => input.KeyGroupId, "{KeyGroupId}", false);
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListDistributionsByKeyGroupCommand = se_ListDistributionsByKeyGroupCommand;
const se_ListDistributionsByOriginRequestPolicyIdCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distributionsByOriginRequestPolicyId/{OriginRequestPolicyId}");
    b.p("OriginRequestPolicyId", () => input.OriginRequestPolicyId, "{OriginRequestPolicyId}", false);
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListDistributionsByOriginRequestPolicyIdCommand = se_ListDistributionsByOriginRequestPolicyIdCommand;
const se_ListDistributionsByRealtimeLogConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/distributionsByRealtimeLogConfig");
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_LDBRLCR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_M] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_M]).n(_M));
    }
    if (input[_MI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_I, String(input[_MI])).n(_MI));
    }
    if (input[_RLCA] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RLCA]).n(_RLCA));
    }
    if (input[_RLCN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RLCN]).n(_RLCN));
    }
    body += bn.toString();
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_ListDistributionsByRealtimeLogConfigCommand = se_ListDistributionsByRealtimeLogConfigCommand;
const se_ListDistributionsByResponseHeadersPolicyIdCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distributionsByResponseHeadersPolicyId/{ResponseHeadersPolicyId}");
    b.p("ResponseHeadersPolicyId", () => input.ResponseHeadersPolicyId, "{ResponseHeadersPolicyId}", false);
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListDistributionsByResponseHeadersPolicyIdCommand = se_ListDistributionsByResponseHeadersPolicyIdCommand;
const se_ListDistributionsByWebACLIdCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distributionsByWebACLId/{WebACLId}");
    b.p("WebACLId", () => input.WebACLId, "{WebACLId}", false);
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListDistributionsByWebACLIdCommand = se_ListDistributionsByWebACLIdCommand;
const se_ListFieldLevelEncryptionConfigsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/field-level-encryption");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListFieldLevelEncryptionConfigsCommand = se_ListFieldLevelEncryptionConfigsCommand;
const se_ListFieldLevelEncryptionProfilesCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/field-level-encryption-profile");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListFieldLevelEncryptionProfilesCommand = se_ListFieldLevelEncryptionProfilesCommand;
const se_ListFunctionsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/function");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
        [_St]: [, input[_St]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListFunctionsCommand = se_ListFunctionsCommand;
const se_ListInvalidationsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/distribution/{DistributionId}/invalidation");
    b.p("DistributionId", () => input.DistributionId, "{DistributionId}", false);
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListInvalidationsCommand = se_ListInvalidationsCommand;
const se_ListKeyGroupsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/key-group");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListKeyGroupsCommand = se_ListKeyGroupsCommand;
const se_ListKeyValueStoresCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/key-value-store");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
        [_Sta]: [, input[_Sta]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListKeyValueStoresCommand = se_ListKeyValueStoresCommand;
const se_ListOriginAccessControlsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/origin-access-control");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListOriginAccessControlsCommand = se_ListOriginAccessControlsCommand;
const se_ListOriginRequestPoliciesCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/origin-request-policy");
    const query = (0, smithy_client_1.map)({
        [_T]: [, input[_T]],
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListOriginRequestPoliciesCommand = se_ListOriginRequestPoliciesCommand;
const se_ListPublicKeysCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/public-key");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListPublicKeysCommand = se_ListPublicKeysCommand;
const se_ListRealtimeLogConfigsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/realtime-log-config");
    const query = (0, smithy_client_1.map)({
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
        [_M]: [, input[_M]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListRealtimeLogConfigsCommand = se_ListRealtimeLogConfigsCommand;
const se_ListResponseHeadersPoliciesCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/response-headers-policy");
    const query = (0, smithy_client_1.map)({
        [_T]: [, input[_T]],
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListResponseHeadersPoliciesCommand = se_ListResponseHeadersPoliciesCommand;
const se_ListStreamingDistributionsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/streaming-distribution");
    const query = (0, smithy_client_1.map)({
        [_M]: [, input[_M]],
        [_MI]: [() => input.MaxItems !== void 0, () => input[_MI].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListStreamingDistributionsCommand = se_ListStreamingDistributionsCommand;
const se_ListTagsForResourceCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/2020-05-31/tagging");
    const query = (0, smithy_client_1.map)({
        [_R]: [, (0, smithy_client_1.expectNonNull)(input[_R], `Resource`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListTagsForResourceCommand = se_ListTagsForResourceCommand;
const se_PublishFunctionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/function/{Name}/publish");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_PublishFunctionCommand = se_PublishFunctionCommand;
const se_TagResourceCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/tagging");
    const query = (0, smithy_client_1.map)({
        [_O]: [, "Tag"],
        [_R]: [, (0, smithy_client_1.expectNonNull)(input[_R], `Resource`)],
    });
    let body;
    let contents;
    if (input.Tags !== undefined) {
        contents = se_Tags(input.Tags, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_TagResourceCommand = se_TagResourceCommand;
const se_TestFunctionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/function/{Name}/test");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_TFR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_EO] != null) {
        bn.c(xml_builder_1.XmlNode.of(_FEO, context.base64Encoder(input[_EO])).n(_EO));
    }
    if (input[_St] != null) {
        bn.c(xml_builder_1.XmlNode.of(_FS, input[_St]).n(_St));
    }
    body += bn.toString();
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_TestFunctionCommand = se_TestFunctionCommand;
const se_UntagResourceCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/tagging");
    const query = (0, smithy_client_1.map)({
        [_O]: [, "Untag"],
        [_R]: [, (0, smithy_client_1.expectNonNull)(input[_R], `Resource`)],
    });
    let body;
    let contents;
    if (input.TagKeys !== undefined) {
        contents = se_TagKeys(input.TagKeys, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_UntagResourceCommand = se_UntagResourceCommand;
const se_UpdateCachePolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/cache-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.CachePolicyConfig !== undefined) {
        contents = se_CachePolicyConfig(input.CachePolicyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateCachePolicyCommand = se_UpdateCachePolicyCommand;
const se_UpdateCloudFrontOriginAccessIdentityCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/origin-access-identity/cloudfront/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.CloudFrontOriginAccessIdentityConfig !== undefined) {
        contents = se_CloudFrontOriginAccessIdentityConfig(input.CloudFrontOriginAccessIdentityConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateCloudFrontOriginAccessIdentityCommand = se_UpdateCloudFrontOriginAccessIdentityCommand;
const se_UpdateContinuousDeploymentPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/continuous-deployment-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.ContinuousDeploymentPolicyConfig !== undefined) {
        contents = se_ContinuousDeploymentPolicyConfig(input.ContinuousDeploymentPolicyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateContinuousDeploymentPolicyCommand = se_UpdateContinuousDeploymentPolicyCommand;
const se_UpdateDistributionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/distribution/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.DistributionConfig !== undefined) {
        contents = se_DistributionConfig(input.DistributionConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateDistributionCommand = se_UpdateDistributionCommand;
const se_UpdateDistributionWithStagingConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/distribution/{Id}/promote-staging-config");
    b.p("Id", () => input.Id, "{Id}", false);
    const query = (0, smithy_client_1.map)({
        [_SDI]: [, input[_SDI]],
    });
    let body;
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_UpdateDistributionWithStagingConfigCommand = se_UpdateDistributionWithStagingConfigCommand;
const se_UpdateFieldLevelEncryptionConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/field-level-encryption/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.FieldLevelEncryptionConfig !== undefined) {
        contents = se_FieldLevelEncryptionConfig(input.FieldLevelEncryptionConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateFieldLevelEncryptionConfigCommand = se_UpdateFieldLevelEncryptionConfigCommand;
const se_UpdateFieldLevelEncryptionProfileCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/field-level-encryption-profile/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.FieldLevelEncryptionProfileConfig !== undefined) {
        contents = se_FieldLevelEncryptionProfileConfig(input.FieldLevelEncryptionProfileConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateFieldLevelEncryptionProfileCommand = se_UpdateFieldLevelEncryptionProfileCommand;
const se_UpdateFunctionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/function/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_UFR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_FC] != null) {
        bn.c(xml_builder_1.XmlNode.of(_FB, context.base64Encoder(input[_FC])).n(_FC));
    }
    if (input[_FCu] != null) {
        bn.c(se_FunctionConfig(input[_FCu], context).n(_FCu));
    }
    body += bn.toString();
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateFunctionCommand = se_UpdateFunctionCommand;
const se_UpdateKeyGroupCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/key-group/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.KeyGroupConfig !== undefined) {
        contents = se_KeyGroupConfig(input.KeyGroupConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateKeyGroupCommand = se_UpdateKeyGroupCommand;
const se_UpdateKeyValueStoreCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/key-value-store/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_UKVSR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_KVSC, input[_C]).n(_C));
    }
    body += bn.toString();
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateKeyValueStoreCommand = se_UpdateKeyValueStoreCommand;
const se_UpdateOriginAccessControlCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/origin-access-control/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.OriginAccessControlConfig !== undefined) {
        contents = se_OriginAccessControlConfig(input.OriginAccessControlConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateOriginAccessControlCommand = se_UpdateOriginAccessControlCommand;
const se_UpdateOriginRequestPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/origin-request-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.OriginRequestPolicyConfig !== undefined) {
        contents = se_OriginRequestPolicyConfig(input.OriginRequestPolicyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateOriginRequestPolicyCommand = se_UpdateOriginRequestPolicyCommand;
const se_UpdatePublicKeyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/public-key/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.PublicKeyConfig !== undefined) {
        contents = se_PublicKeyConfig(input.PublicKeyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdatePublicKeyCommand = se_UpdatePublicKeyCommand;
const se_UpdateRealtimeLogConfigCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/2020-05-31/realtime-log-config");
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_URLCR);
    bn.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
    if (input[_ARN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_ARN]).n(_ARN));
    }
    bn.lc(input, "EndPoints", "EndPoints", () => se_EndPointList(input[_EP], context));
    bn.lc(input, "Fields", "Fields", () => se_FieldList(input[_F], context));
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    if (input[_SR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_SR])).n(_SR));
    }
    body += bn.toString();
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateRealtimeLogConfigCommand = se_UpdateRealtimeLogConfigCommand;
const se_UpdateResponseHeadersPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/response-headers-policy/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.ResponseHeadersPolicyConfig !== undefined) {
        contents = se_ResponseHeadersPolicyConfig(input.ResponseHeadersPolicyConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateResponseHeadersPolicyCommand = se_UpdateResponseHeadersPolicyCommand;
const se_UpdateStreamingDistributionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_im]: input[_IM],
    });
    b.bp("/2020-05-31/streaming-distribution/{Id}/config");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    let contents;
    if (input.StreamingDistributionConfig !== undefined) {
        contents = se_StreamingDistributionConfig(input.StreamingDistributionConfig, context);
        body = _ve;
        contents.a("xmlns", "http://cloudfront.amazonaws.com/doc/2020-05-31/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_UpdateStreamingDistributionCommand = se_UpdateStreamingDistributionCommand;
const de_AssociateAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AssociateAliasCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_AssociateAliasCommand = de_AssociateAliasCommand;
const de_AssociateAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "TooManyDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
            throw await de_TooManyDistributionCNAMEsRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CopyDistributionCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CopyDistributionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Distribution = de_Distribution(data, context);
    return contents;
};
exports.de_CopyDistributionCommand = de_CopyDistributionCommand;
const de_CopyDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await de_CNAMEAlreadyExistsRes(parsedOutput, context);
        case "DistributionAlreadyExists":
        case "com.amazonaws.cloudfront#DistributionAlreadyExists":
            throw await de_DistributionAlreadyExistsRes(parsedOutput, context);
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
        case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
            throw await de_IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidDefaultRootObject":
        case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
            throw await de_InvalidDefaultRootObjectRes(parsedOutput, context);
        case "InvalidErrorCode":
        case "com.amazonaws.cloudfront#InvalidErrorCode":
            throw await de_InvalidErrorCodeRes(parsedOutput, context);
        case "InvalidForwardCookies":
        case "com.amazonaws.cloudfront#InvalidForwardCookies":
            throw await de_InvalidForwardCookiesRes(parsedOutput, context);
        case "InvalidFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidFunctionAssociation":
            throw await de_InvalidFunctionAssociationRes(parsedOutput, context);
        case "InvalidGeoRestrictionParameter":
        case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
            throw await de_InvalidGeoRestrictionParameterRes(parsedOutput, context);
        case "InvalidHeadersForS3Origin":
        case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
            throw await de_InvalidHeadersForS3OriginRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "InvalidLambdaFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
            throw await de_InvalidLambdaFunctionAssociationRes(parsedOutput, context);
        case "InvalidLocationCode":
        case "com.amazonaws.cloudfront#InvalidLocationCode":
            throw await de_InvalidLocationCodeRes(parsedOutput, context);
        case "InvalidMinimumProtocolVersion":
        case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
            throw await de_InvalidMinimumProtocolVersionRes(parsedOutput, context);
        case "InvalidOrigin":
        case "com.amazonaws.cloudfront#InvalidOrigin":
            throw await de_InvalidOriginRes(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await de_InvalidOriginAccessControlRes(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await de_InvalidOriginAccessIdentityRes(parsedOutput, context);
        case "InvalidOriginKeepaliveTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
            throw await de_InvalidOriginKeepaliveTimeoutRes(parsedOutput, context);
        case "InvalidOriginReadTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
            throw await de_InvalidOriginReadTimeoutRes(parsedOutput, context);
        case "InvalidProtocolSettings":
        case "com.amazonaws.cloudfront#InvalidProtocolSettings":
            throw await de_InvalidProtocolSettingsRes(parsedOutput, context);
        case "InvalidQueryStringParameters":
        case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
            throw await de_InvalidQueryStringParametersRes(parsedOutput, context);
        case "InvalidRelativePath":
        case "com.amazonaws.cloudfront#InvalidRelativePath":
            throw await de_InvalidRelativePathRes(parsedOutput, context);
        case "InvalidRequiredProtocol":
        case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
            throw await de_InvalidRequiredProtocolRes(parsedOutput, context);
        case "InvalidResponseCode":
        case "com.amazonaws.cloudfront#InvalidResponseCode":
            throw await de_InvalidResponseCodeRes(parsedOutput, context);
        case "InvalidTTLOrder":
        case "com.amazonaws.cloudfront#InvalidTTLOrder":
            throw await de_InvalidTTLOrderRes(parsedOutput, context);
        case "InvalidViewerCertificate":
        case "com.amazonaws.cloudfront#InvalidViewerCertificate":
            throw await de_InvalidViewerCertificateRes(parsedOutput, context);
        case "InvalidWebACLId":
        case "com.amazonaws.cloudfront#InvalidWebACLId":
            throw await de_InvalidWebACLIdRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await de_NoSuchFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "NoSuchOrigin":
        case "com.amazonaws.cloudfront#NoSuchOrigin":
            throw await de_NoSuchOriginRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await de_NoSuchRealtimeLogConfigRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "RealtimeLogConfigOwnerMismatch":
        case "com.amazonaws.cloudfront#RealtimeLogConfigOwnerMismatch":
            throw await de_RealtimeLogConfigOwnerMismatchRes(parsedOutput, context);
        case "TooManyCacheBehaviors":
        case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
            throw await de_TooManyCacheBehaviorsRes(parsedOutput, context);
        case "TooManyCertificates":
        case "com.amazonaws.cloudfront#TooManyCertificates":
            throw await de_TooManyCertificatesRes(parsedOutput, context);
        case "TooManyCookieNamesInWhiteList":
        case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
            throw await de_TooManyCookieNamesInWhiteListRes(parsedOutput, context);
        case "TooManyDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
            throw await de_TooManyDistributionCNAMEsRes(parsedOutput, context);
        case "TooManyDistributions":
        case "com.amazonaws.cloudfront#TooManyDistributions":
            throw await de_TooManyDistributionsRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToCachePolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToCachePolicy":
            throw await de_TooManyDistributionsAssociatedToCachePolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
            throw await de_TooManyDistributionsAssociatedToFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToKeyGroup":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToKeyGroup":
            throw await de_TooManyDistributionsAssociatedToKeyGroupRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginAccessControl":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginAccessControl":
            throw await de_TooManyDistributionsAssociatedToOriginAccessControlRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginRequestPolicy":
            throw await de_TooManyDistributionsAssociatedToOriginRequestPolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToResponseHeadersPolicy":
            throw await de_TooManyDistributionsAssociatedToResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyDistributionsWithFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithFunctionAssociations":
            throw await de_TooManyDistributionsWithFunctionAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithLambdaAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
            throw await de_TooManyDistributionsWithLambdaAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithSingleFunctionARN":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithSingleFunctionARN":
            throw await de_TooManyDistributionsWithSingleFunctionARNRes(parsedOutput, context);
        case "TooManyFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyFunctionAssociations":
            throw await de_TooManyFunctionAssociationsRes(parsedOutput, context);
        case "TooManyHeadersInForwardedValues":
        case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
            throw await de_TooManyHeadersInForwardedValuesRes(parsedOutput, context);
        case "TooManyKeyGroupsAssociatedToDistribution":
        case "com.amazonaws.cloudfront#TooManyKeyGroupsAssociatedToDistribution":
            throw await de_TooManyKeyGroupsAssociatedToDistributionRes(parsedOutput, context);
        case "TooManyLambdaFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
            throw await de_TooManyLambdaFunctionAssociationsRes(parsedOutput, context);
        case "TooManyOriginCustomHeaders":
        case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
            throw await de_TooManyOriginCustomHeadersRes(parsedOutput, context);
        case "TooManyOriginGroupsPerDistribution":
        case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
            throw await de_TooManyOriginGroupsPerDistributionRes(parsedOutput, context);
        case "TooManyOrigins":
        case "com.amazonaws.cloudfront#TooManyOrigins":
            throw await de_TooManyOriginsRes(parsedOutput, context);
        case "TooManyQueryStringParameters":
        case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
            throw await de_TooManyQueryStringParametersRes(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await de_TooManyTrustedSignersRes(parsedOutput, context);
        case "TrustedKeyGroupDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedKeyGroupDoesNotExist":
            throw await de_TrustedKeyGroupDoesNotExistRes(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await de_TrustedSignerDoesNotExistRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateCachePolicyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateCachePolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CachePolicy = de_CachePolicy(data, context);
    return contents;
};
exports.de_CreateCachePolicyCommand = de_CreateCachePolicyCommand;
const de_CreateCachePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CachePolicyAlreadyExists":
        case "com.amazonaws.cloudfront#CachePolicyAlreadyExists":
            throw await de_CachePolicyAlreadyExistsRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "TooManyCachePolicies":
        case "com.amazonaws.cloudfront#TooManyCachePolicies":
            throw await de_TooManyCachePoliciesRes(parsedOutput, context);
        case "TooManyCookiesInCachePolicy":
        case "com.amazonaws.cloudfront#TooManyCookiesInCachePolicy":
            throw await de_TooManyCookiesInCachePolicyRes(parsedOutput, context);
        case "TooManyHeadersInCachePolicy":
        case "com.amazonaws.cloudfront#TooManyHeadersInCachePolicy":
            throw await de_TooManyHeadersInCachePolicyRes(parsedOutput, context);
        case "TooManyQueryStringsInCachePolicy":
        case "com.amazonaws.cloudfront#TooManyQueryStringsInCachePolicy":
            throw await de_TooManyQueryStringsInCachePolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateCloudFrontOriginAccessIdentityCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateCloudFrontOriginAccessIdentityCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CloudFrontOriginAccessIdentity = de_CloudFrontOriginAccessIdentity(data, context);
    return contents;
};
exports.de_CreateCloudFrontOriginAccessIdentityCommand = de_CreateCloudFrontOriginAccessIdentityCommand;
const de_CreateCloudFrontOriginAccessIdentityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CloudFrontOriginAccessIdentityAlreadyExists":
        case "com.amazonaws.cloudfront#CloudFrontOriginAccessIdentityAlreadyExists":
            throw await de_CloudFrontOriginAccessIdentityAlreadyExistsRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "TooManyCloudFrontOriginAccessIdentities":
        case "com.amazonaws.cloudfront#TooManyCloudFrontOriginAccessIdentities":
            throw await de_TooManyCloudFrontOriginAccessIdentitiesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateContinuousDeploymentPolicyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateContinuousDeploymentPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ContinuousDeploymentPolicy = de_ContinuousDeploymentPolicy(data, context);
    return contents;
};
exports.de_CreateContinuousDeploymentPolicyCommand = de_CreateContinuousDeploymentPolicyCommand;
const de_CreateContinuousDeploymentPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "ContinuousDeploymentPolicyAlreadyExists":
        case "com.amazonaws.cloudfront#ContinuousDeploymentPolicyAlreadyExists":
            throw await de_ContinuousDeploymentPolicyAlreadyExistsRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "StagingDistributionInUse":
        case "com.amazonaws.cloudfront#StagingDistributionInUse":
            throw await de_StagingDistributionInUseRes(parsedOutput, context);
        case "TooManyContinuousDeploymentPolicies":
        case "com.amazonaws.cloudfront#TooManyContinuousDeploymentPolicies":
            throw await de_TooManyContinuousDeploymentPoliciesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateDistributionCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateDistributionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Distribution = de_Distribution(data, context);
    return contents;
};
exports.de_CreateDistributionCommand = de_CreateDistributionCommand;
const de_CreateDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await de_CNAMEAlreadyExistsRes(parsedOutput, context);
        case "ContinuousDeploymentPolicyInUse":
        case "com.amazonaws.cloudfront#ContinuousDeploymentPolicyInUse":
            throw await de_ContinuousDeploymentPolicyInUseRes(parsedOutput, context);
        case "DistributionAlreadyExists":
        case "com.amazonaws.cloudfront#DistributionAlreadyExists":
            throw await de_DistributionAlreadyExistsRes(parsedOutput, context);
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
        case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
            throw await de_IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorRes(parsedOutput, context);
        case "IllegalOriginAccessConfiguration":
        case "com.amazonaws.cloudfront#IllegalOriginAccessConfiguration":
            throw await de_IllegalOriginAccessConfigurationRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidDefaultRootObject":
        case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
            throw await de_InvalidDefaultRootObjectRes(parsedOutput, context);
        case "InvalidDomainNameForOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidDomainNameForOriginAccessControl":
            throw await de_InvalidDomainNameForOriginAccessControlRes(parsedOutput, context);
        case "InvalidErrorCode":
        case "com.amazonaws.cloudfront#InvalidErrorCode":
            throw await de_InvalidErrorCodeRes(parsedOutput, context);
        case "InvalidForwardCookies":
        case "com.amazonaws.cloudfront#InvalidForwardCookies":
            throw await de_InvalidForwardCookiesRes(parsedOutput, context);
        case "InvalidFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidFunctionAssociation":
            throw await de_InvalidFunctionAssociationRes(parsedOutput, context);
        case "InvalidGeoRestrictionParameter":
        case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
            throw await de_InvalidGeoRestrictionParameterRes(parsedOutput, context);
        case "InvalidHeadersForS3Origin":
        case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
            throw await de_InvalidHeadersForS3OriginRes(parsedOutput, context);
        case "InvalidLambdaFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
            throw await de_InvalidLambdaFunctionAssociationRes(parsedOutput, context);
        case "InvalidLocationCode":
        case "com.amazonaws.cloudfront#InvalidLocationCode":
            throw await de_InvalidLocationCodeRes(parsedOutput, context);
        case "InvalidMinimumProtocolVersion":
        case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
            throw await de_InvalidMinimumProtocolVersionRes(parsedOutput, context);
        case "InvalidOrigin":
        case "com.amazonaws.cloudfront#InvalidOrigin":
            throw await de_InvalidOriginRes(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await de_InvalidOriginAccessControlRes(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await de_InvalidOriginAccessIdentityRes(parsedOutput, context);
        case "InvalidOriginKeepaliveTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
            throw await de_InvalidOriginKeepaliveTimeoutRes(parsedOutput, context);
        case "InvalidOriginReadTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
            throw await de_InvalidOriginReadTimeoutRes(parsedOutput, context);
        case "InvalidProtocolSettings":
        case "com.amazonaws.cloudfront#InvalidProtocolSettings":
            throw await de_InvalidProtocolSettingsRes(parsedOutput, context);
        case "InvalidQueryStringParameters":
        case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
            throw await de_InvalidQueryStringParametersRes(parsedOutput, context);
        case "InvalidRelativePath":
        case "com.amazonaws.cloudfront#InvalidRelativePath":
            throw await de_InvalidRelativePathRes(parsedOutput, context);
        case "InvalidRequiredProtocol":
        case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
            throw await de_InvalidRequiredProtocolRes(parsedOutput, context);
        case "InvalidResponseCode":
        case "com.amazonaws.cloudfront#InvalidResponseCode":
            throw await de_InvalidResponseCodeRes(parsedOutput, context);
        case "InvalidTTLOrder":
        case "com.amazonaws.cloudfront#InvalidTTLOrder":
            throw await de_InvalidTTLOrderRes(parsedOutput, context);
        case "InvalidViewerCertificate":
        case "com.amazonaws.cloudfront#InvalidViewerCertificate":
            throw await de_InvalidViewerCertificateRes(parsedOutput, context);
        case "InvalidWebACLId":
        case "com.amazonaws.cloudfront#InvalidWebACLId":
            throw await de_InvalidWebACLIdRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        case "NoSuchContinuousDeploymentPolicy":
        case "com.amazonaws.cloudfront#NoSuchContinuousDeploymentPolicy":
            throw await de_NoSuchContinuousDeploymentPolicyRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await de_NoSuchFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "NoSuchOrigin":
        case "com.amazonaws.cloudfront#NoSuchOrigin":
            throw await de_NoSuchOriginRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await de_NoSuchRealtimeLogConfigRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        case "RealtimeLogConfigOwnerMismatch":
        case "com.amazonaws.cloudfront#RealtimeLogConfigOwnerMismatch":
            throw await de_RealtimeLogConfigOwnerMismatchRes(parsedOutput, context);
        case "TooManyCacheBehaviors":
        case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
            throw await de_TooManyCacheBehaviorsRes(parsedOutput, context);
        case "TooManyCertificates":
        case "com.amazonaws.cloudfront#TooManyCertificates":
            throw await de_TooManyCertificatesRes(parsedOutput, context);
        case "TooManyCookieNamesInWhiteList":
        case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
            throw await de_TooManyCookieNamesInWhiteListRes(parsedOutput, context);
        case "TooManyDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
            throw await de_TooManyDistributionCNAMEsRes(parsedOutput, context);
        case "TooManyDistributions":
        case "com.amazonaws.cloudfront#TooManyDistributions":
            throw await de_TooManyDistributionsRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToCachePolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToCachePolicy":
            throw await de_TooManyDistributionsAssociatedToCachePolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
            throw await de_TooManyDistributionsAssociatedToFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToKeyGroup":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToKeyGroup":
            throw await de_TooManyDistributionsAssociatedToKeyGroupRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginAccessControl":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginAccessControl":
            throw await de_TooManyDistributionsAssociatedToOriginAccessControlRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginRequestPolicy":
            throw await de_TooManyDistributionsAssociatedToOriginRequestPolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToResponseHeadersPolicy":
            throw await de_TooManyDistributionsAssociatedToResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyDistributionsWithFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithFunctionAssociations":
            throw await de_TooManyDistributionsWithFunctionAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithLambdaAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
            throw await de_TooManyDistributionsWithLambdaAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithSingleFunctionARN":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithSingleFunctionARN":
            throw await de_TooManyDistributionsWithSingleFunctionARNRes(parsedOutput, context);
        case "TooManyFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyFunctionAssociations":
            throw await de_TooManyFunctionAssociationsRes(parsedOutput, context);
        case "TooManyHeadersInForwardedValues":
        case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
            throw await de_TooManyHeadersInForwardedValuesRes(parsedOutput, context);
        case "TooManyKeyGroupsAssociatedToDistribution":
        case "com.amazonaws.cloudfront#TooManyKeyGroupsAssociatedToDistribution":
            throw await de_TooManyKeyGroupsAssociatedToDistributionRes(parsedOutput, context);
        case "TooManyLambdaFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
            throw await de_TooManyLambdaFunctionAssociationsRes(parsedOutput, context);
        case "TooManyOriginCustomHeaders":
        case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
            throw await de_TooManyOriginCustomHeadersRes(parsedOutput, context);
        case "TooManyOriginGroupsPerDistribution":
        case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
            throw await de_TooManyOriginGroupsPerDistributionRes(parsedOutput, context);
        case "TooManyOrigins":
        case "com.amazonaws.cloudfront#TooManyOrigins":
            throw await de_TooManyOriginsRes(parsedOutput, context);
        case "TooManyQueryStringParameters":
        case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
            throw await de_TooManyQueryStringParametersRes(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await de_TooManyTrustedSignersRes(parsedOutput, context);
        case "TrustedKeyGroupDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedKeyGroupDoesNotExist":
            throw await de_TrustedKeyGroupDoesNotExistRes(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await de_TrustedSignerDoesNotExistRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateDistributionWithTagsCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateDistributionWithTagsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Distribution = de_Distribution(data, context);
    return contents;
};
exports.de_CreateDistributionWithTagsCommand = de_CreateDistributionWithTagsCommand;
const de_CreateDistributionWithTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await de_CNAMEAlreadyExistsRes(parsedOutput, context);
        case "ContinuousDeploymentPolicyInUse":
        case "com.amazonaws.cloudfront#ContinuousDeploymentPolicyInUse":
            throw await de_ContinuousDeploymentPolicyInUseRes(parsedOutput, context);
        case "DistributionAlreadyExists":
        case "com.amazonaws.cloudfront#DistributionAlreadyExists":
            throw await de_DistributionAlreadyExistsRes(parsedOutput, context);
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
        case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
            throw await de_IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorRes(parsedOutput, context);
        case "IllegalOriginAccessConfiguration":
        case "com.amazonaws.cloudfront#IllegalOriginAccessConfiguration":
            throw await de_IllegalOriginAccessConfigurationRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidDefaultRootObject":
        case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
            throw await de_InvalidDefaultRootObjectRes(parsedOutput, context);
        case "InvalidDomainNameForOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidDomainNameForOriginAccessControl":
            throw await de_InvalidDomainNameForOriginAccessControlRes(parsedOutput, context);
        case "InvalidErrorCode":
        case "com.amazonaws.cloudfront#InvalidErrorCode":
            throw await de_InvalidErrorCodeRes(parsedOutput, context);
        case "InvalidForwardCookies":
        case "com.amazonaws.cloudfront#InvalidForwardCookies":
            throw await de_InvalidForwardCookiesRes(parsedOutput, context);
        case "InvalidFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidFunctionAssociation":
            throw await de_InvalidFunctionAssociationRes(parsedOutput, context);
        case "InvalidGeoRestrictionParameter":
        case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
            throw await de_InvalidGeoRestrictionParameterRes(parsedOutput, context);
        case "InvalidHeadersForS3Origin":
        case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
            throw await de_InvalidHeadersForS3OriginRes(parsedOutput, context);
        case "InvalidLambdaFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
            throw await de_InvalidLambdaFunctionAssociationRes(parsedOutput, context);
        case "InvalidLocationCode":
        case "com.amazonaws.cloudfront#InvalidLocationCode":
            throw await de_InvalidLocationCodeRes(parsedOutput, context);
        case "InvalidMinimumProtocolVersion":
        case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
            throw await de_InvalidMinimumProtocolVersionRes(parsedOutput, context);
        case "InvalidOrigin":
        case "com.amazonaws.cloudfront#InvalidOrigin":
            throw await de_InvalidOriginRes(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await de_InvalidOriginAccessControlRes(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await de_InvalidOriginAccessIdentityRes(parsedOutput, context);
        case "InvalidOriginKeepaliveTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
            throw await de_InvalidOriginKeepaliveTimeoutRes(parsedOutput, context);
        case "InvalidOriginReadTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
            throw await de_InvalidOriginReadTimeoutRes(parsedOutput, context);
        case "InvalidProtocolSettings":
        case "com.amazonaws.cloudfront#InvalidProtocolSettings":
            throw await de_InvalidProtocolSettingsRes(parsedOutput, context);
        case "InvalidQueryStringParameters":
        case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
            throw await de_InvalidQueryStringParametersRes(parsedOutput, context);
        case "InvalidRelativePath":
        case "com.amazonaws.cloudfront#InvalidRelativePath":
            throw await de_InvalidRelativePathRes(parsedOutput, context);
        case "InvalidRequiredProtocol":
        case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
            throw await de_InvalidRequiredProtocolRes(parsedOutput, context);
        case "InvalidResponseCode":
        case "com.amazonaws.cloudfront#InvalidResponseCode":
            throw await de_InvalidResponseCodeRes(parsedOutput, context);
        case "InvalidTTLOrder":
        case "com.amazonaws.cloudfront#InvalidTTLOrder":
            throw await de_InvalidTTLOrderRes(parsedOutput, context);
        case "InvalidTagging":
        case "com.amazonaws.cloudfront#InvalidTagging":
            throw await de_InvalidTaggingRes(parsedOutput, context);
        case "InvalidViewerCertificate":
        case "com.amazonaws.cloudfront#InvalidViewerCertificate":
            throw await de_InvalidViewerCertificateRes(parsedOutput, context);
        case "InvalidWebACLId":
        case "com.amazonaws.cloudfront#InvalidWebACLId":
            throw await de_InvalidWebACLIdRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        case "NoSuchContinuousDeploymentPolicy":
        case "com.amazonaws.cloudfront#NoSuchContinuousDeploymentPolicy":
            throw await de_NoSuchContinuousDeploymentPolicyRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await de_NoSuchFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "NoSuchOrigin":
        case "com.amazonaws.cloudfront#NoSuchOrigin":
            throw await de_NoSuchOriginRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await de_NoSuchRealtimeLogConfigRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        case "RealtimeLogConfigOwnerMismatch":
        case "com.amazonaws.cloudfront#RealtimeLogConfigOwnerMismatch":
            throw await de_RealtimeLogConfigOwnerMismatchRes(parsedOutput, context);
        case "TooManyCacheBehaviors":
        case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
            throw await de_TooManyCacheBehaviorsRes(parsedOutput, context);
        case "TooManyCertificates":
        case "com.amazonaws.cloudfront#TooManyCertificates":
            throw await de_TooManyCertificatesRes(parsedOutput, context);
        case "TooManyCookieNamesInWhiteList":
        case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
            throw await de_TooManyCookieNamesInWhiteListRes(parsedOutput, context);
        case "TooManyDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
            throw await de_TooManyDistributionCNAMEsRes(parsedOutput, context);
        case "TooManyDistributions":
        case "com.amazonaws.cloudfront#TooManyDistributions":
            throw await de_TooManyDistributionsRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToCachePolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToCachePolicy":
            throw await de_TooManyDistributionsAssociatedToCachePolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
            throw await de_TooManyDistributionsAssociatedToFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToKeyGroup":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToKeyGroup":
            throw await de_TooManyDistributionsAssociatedToKeyGroupRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginAccessControl":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginAccessControl":
            throw await de_TooManyDistributionsAssociatedToOriginAccessControlRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginRequestPolicy":
            throw await de_TooManyDistributionsAssociatedToOriginRequestPolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToResponseHeadersPolicy":
            throw await de_TooManyDistributionsAssociatedToResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyDistributionsWithFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithFunctionAssociations":
            throw await de_TooManyDistributionsWithFunctionAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithLambdaAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
            throw await de_TooManyDistributionsWithLambdaAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithSingleFunctionARN":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithSingleFunctionARN":
            throw await de_TooManyDistributionsWithSingleFunctionARNRes(parsedOutput, context);
        case "TooManyFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyFunctionAssociations":
            throw await de_TooManyFunctionAssociationsRes(parsedOutput, context);
        case "TooManyHeadersInForwardedValues":
        case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
            throw await de_TooManyHeadersInForwardedValuesRes(parsedOutput, context);
        case "TooManyKeyGroupsAssociatedToDistribution":
        case "com.amazonaws.cloudfront#TooManyKeyGroupsAssociatedToDistribution":
            throw await de_TooManyKeyGroupsAssociatedToDistributionRes(parsedOutput, context);
        case "TooManyLambdaFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
            throw await de_TooManyLambdaFunctionAssociationsRes(parsedOutput, context);
        case "TooManyOriginCustomHeaders":
        case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
            throw await de_TooManyOriginCustomHeadersRes(parsedOutput, context);
        case "TooManyOriginGroupsPerDistribution":
        case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
            throw await de_TooManyOriginGroupsPerDistributionRes(parsedOutput, context);
        case "TooManyOrigins":
        case "com.amazonaws.cloudfront#TooManyOrigins":
            throw await de_TooManyOriginsRes(parsedOutput, context);
        case "TooManyQueryStringParameters":
        case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
            throw await de_TooManyQueryStringParametersRes(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await de_TooManyTrustedSignersRes(parsedOutput, context);
        case "TrustedKeyGroupDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedKeyGroupDoesNotExist":
            throw await de_TrustedKeyGroupDoesNotExistRes(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await de_TrustedSignerDoesNotExistRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateFieldLevelEncryptionConfigCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateFieldLevelEncryptionConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryption = de_FieldLevelEncryption(data, context);
    return contents;
};
exports.de_CreateFieldLevelEncryptionConfigCommand = de_CreateFieldLevelEncryptionConfigCommand;
const de_CreateFieldLevelEncryptionConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "FieldLevelEncryptionConfigAlreadyExists":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionConfigAlreadyExists":
            throw await de_FieldLevelEncryptionConfigAlreadyExistsRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionProfile":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
            throw await de_NoSuchFieldLevelEncryptionProfileRes(parsedOutput, context);
        case "QueryArgProfileEmpty":
        case "com.amazonaws.cloudfront#QueryArgProfileEmpty":
            throw await de_QueryArgProfileEmptyRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionConfigs":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionConfigs":
            throw await de_TooManyFieldLevelEncryptionConfigsRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionContentTypeProfiles":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionContentTypeProfiles":
            throw await de_TooManyFieldLevelEncryptionContentTypeProfilesRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionQueryArgProfiles":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionQueryArgProfiles":
            throw await de_TooManyFieldLevelEncryptionQueryArgProfilesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateFieldLevelEncryptionProfileCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateFieldLevelEncryptionProfileCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionProfile = de_FieldLevelEncryptionProfile(data, context);
    return contents;
};
exports.de_CreateFieldLevelEncryptionProfileCommand = de_CreateFieldLevelEncryptionProfileCommand;
const de_CreateFieldLevelEncryptionProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "FieldLevelEncryptionProfileAlreadyExists":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileAlreadyExists":
            throw await de_FieldLevelEncryptionProfileAlreadyExistsRes(parsedOutput, context);
        case "FieldLevelEncryptionProfileSizeExceeded":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileSizeExceeded":
            throw await de_FieldLevelEncryptionProfileSizeExceededRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchPublicKey":
        case "com.amazonaws.cloudfront#NoSuchPublicKey":
            throw await de_NoSuchPublicKeyRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionEncryptionEntities":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionEncryptionEntities":
            throw await de_TooManyFieldLevelEncryptionEncryptionEntitiesRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionFieldPatterns":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionFieldPatterns":
            throw await de_TooManyFieldLevelEncryptionFieldPatternsRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionProfiles":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionProfiles":
            throw await de_TooManyFieldLevelEncryptionProfilesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateFunctionCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateFunctionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FunctionSummary = de_FunctionSummary(data, context);
    return contents;
};
exports.de_CreateFunctionCommand = de_CreateFunctionCommand;
const de_CreateFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "FunctionAlreadyExists":
        case "com.amazonaws.cloudfront#FunctionAlreadyExists":
            throw await de_FunctionAlreadyExistsRes(parsedOutput, context);
        case "FunctionSizeLimitExceeded":
        case "com.amazonaws.cloudfront#FunctionSizeLimitExceeded":
            throw await de_FunctionSizeLimitExceededRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "TooManyFunctions":
        case "com.amazonaws.cloudfront#TooManyFunctions":
            throw await de_TooManyFunctionsRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateInvalidationCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateInvalidationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Invalidation = de_Invalidation(data, context);
    return contents;
};
exports.de_CreateInvalidationCommand = de_CreateInvalidationCommand;
const de_CreateInvalidationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "BatchTooLarge":
        case "com.amazonaws.cloudfront#BatchTooLarge":
            throw await de_BatchTooLargeRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "TooManyInvalidationsInProgress":
        case "com.amazonaws.cloudfront#TooManyInvalidationsInProgress":
            throw await de_TooManyInvalidationsInProgressRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateKeyGroupCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateKeyGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyGroup = de_KeyGroup(data, context);
    return contents;
};
exports.de_CreateKeyGroupCommand = de_CreateKeyGroupCommand;
const de_CreateKeyGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "KeyGroupAlreadyExists":
        case "com.amazonaws.cloudfront#KeyGroupAlreadyExists":
            throw await de_KeyGroupAlreadyExistsRes(parsedOutput, context);
        case "TooManyKeyGroups":
        case "com.amazonaws.cloudfront#TooManyKeyGroups":
            throw await de_TooManyKeyGroupsRes(parsedOutput, context);
        case "TooManyPublicKeysInKeyGroup":
        case "com.amazonaws.cloudfront#TooManyPublicKeysInKeyGroup":
            throw await de_TooManyPublicKeysInKeyGroupRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateKeyValueStoreCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateKeyValueStoreCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
        [_L]: [, output.headers[_lo]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyValueStore = de_KeyValueStore(data, context);
    return contents;
};
exports.de_CreateKeyValueStoreCommand = de_CreateKeyValueStoreCommand;
const de_CreateKeyValueStoreCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.cloudfront#EntityAlreadyExists":
            throw await de_EntityAlreadyExistsRes(parsedOutput, context);
        case "EntityLimitExceeded":
        case "com.amazonaws.cloudfront#EntityLimitExceeded":
            throw await de_EntityLimitExceededRes(parsedOutput, context);
        case "EntitySizeLimitExceeded":
        case "com.amazonaws.cloudfront#EntitySizeLimitExceeded":
            throw await de_EntitySizeLimitExceededRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateMonitoringSubscriptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateMonitoringSubscriptionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.MonitoringSubscription = de_MonitoringSubscription(data, context);
    return contents;
};
exports.de_CreateMonitoringSubscriptionCommand = de_CreateMonitoringSubscriptionCommand;
const de_CreateMonitoringSubscriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "MonitoringSubscriptionAlreadyExists":
        case "com.amazonaws.cloudfront#MonitoringSubscriptionAlreadyExists":
            throw await de_MonitoringSubscriptionAlreadyExistsRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateOriginAccessControlCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateOriginAccessControlCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginAccessControl = de_OriginAccessControl(data, context);
    return contents;
};
exports.de_CreateOriginAccessControlCommand = de_CreateOriginAccessControlCommand;
const de_CreateOriginAccessControlCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "OriginAccessControlAlreadyExists":
        case "com.amazonaws.cloudfront#OriginAccessControlAlreadyExists":
            throw await de_OriginAccessControlAlreadyExistsRes(parsedOutput, context);
        case "TooManyOriginAccessControls":
        case "com.amazonaws.cloudfront#TooManyOriginAccessControls":
            throw await de_TooManyOriginAccessControlsRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateOriginRequestPolicyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateOriginRequestPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginRequestPolicy = de_OriginRequestPolicy(data, context);
    return contents;
};
exports.de_CreateOriginRequestPolicyCommand = de_CreateOriginRequestPolicyCommand;
const de_CreateOriginRequestPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "OriginRequestPolicyAlreadyExists":
        case "com.amazonaws.cloudfront#OriginRequestPolicyAlreadyExists":
            throw await de_OriginRequestPolicyAlreadyExistsRes(parsedOutput, context);
        case "TooManyCookiesInOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyCookiesInOriginRequestPolicy":
            throw await de_TooManyCookiesInOriginRequestPolicyRes(parsedOutput, context);
        case "TooManyHeadersInOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyHeadersInOriginRequestPolicy":
            throw await de_TooManyHeadersInOriginRequestPolicyRes(parsedOutput, context);
        case "TooManyOriginRequestPolicies":
        case "com.amazonaws.cloudfront#TooManyOriginRequestPolicies":
            throw await de_TooManyOriginRequestPoliciesRes(parsedOutput, context);
        case "TooManyQueryStringsInOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyQueryStringsInOriginRequestPolicy":
            throw await de_TooManyQueryStringsInOriginRequestPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreatePublicKeyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreatePublicKeyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.PublicKey = de_PublicKey(data, context);
    return contents;
};
exports.de_CreatePublicKeyCommand = de_CreatePublicKeyCommand;
const de_CreatePublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "PublicKeyAlreadyExists":
        case "com.amazonaws.cloudfront#PublicKeyAlreadyExists":
            throw await de_PublicKeyAlreadyExistsRes(parsedOutput, context);
        case "TooManyPublicKeys":
        case "com.amazonaws.cloudfront#TooManyPublicKeys":
            throw await de_TooManyPublicKeysRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateRealtimeLogConfigCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateRealtimeLogConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_RLC] != null) {
        contents[_RLC] = de_RealtimeLogConfig(data[_RLC], context);
    }
    return contents;
};
exports.de_CreateRealtimeLogConfigCommand = de_CreateRealtimeLogConfigCommand;
const de_CreateRealtimeLogConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "RealtimeLogConfigAlreadyExists":
        case "com.amazonaws.cloudfront#RealtimeLogConfigAlreadyExists":
            throw await de_RealtimeLogConfigAlreadyExistsRes(parsedOutput, context);
        case "TooManyRealtimeLogConfigs":
        case "com.amazonaws.cloudfront#TooManyRealtimeLogConfigs":
            throw await de_TooManyRealtimeLogConfigsRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateResponseHeadersPolicyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateResponseHeadersPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ResponseHeadersPolicy = de_ResponseHeadersPolicy(data, context);
    return contents;
};
exports.de_CreateResponseHeadersPolicyCommand = de_CreateResponseHeadersPolicyCommand;
const de_CreateResponseHeadersPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "ResponseHeadersPolicyAlreadyExists":
        case "com.amazonaws.cloudfront#ResponseHeadersPolicyAlreadyExists":
            throw await de_ResponseHeadersPolicyAlreadyExistsRes(parsedOutput, context);
        case "TooLongCSPInResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooLongCSPInResponseHeadersPolicy":
            throw await de_TooLongCSPInResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyCustomHeadersInResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyCustomHeadersInResponseHeadersPolicy":
            throw await de_TooManyCustomHeadersInResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyRemoveHeadersInResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyRemoveHeadersInResponseHeadersPolicy":
            throw await de_TooManyRemoveHeadersInResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyResponseHeadersPolicies":
        case "com.amazonaws.cloudfront#TooManyResponseHeadersPolicies":
            throw await de_TooManyResponseHeadersPoliciesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateStreamingDistributionCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateStreamingDistributionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.StreamingDistribution = de_StreamingDistribution(data, context);
    return contents;
};
exports.de_CreateStreamingDistributionCommand = de_CreateStreamingDistributionCommand;
const de_CreateStreamingDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await de_CNAMEAlreadyExistsRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidOrigin":
        case "com.amazonaws.cloudfront#InvalidOrigin":
            throw await de_InvalidOriginRes(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await de_InvalidOriginAccessControlRes(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await de_InvalidOriginAccessIdentityRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "StreamingDistributionAlreadyExists":
        case "com.amazonaws.cloudfront#StreamingDistributionAlreadyExists":
            throw await de_StreamingDistributionAlreadyExistsRes(parsedOutput, context);
        case "TooManyStreamingDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyStreamingDistributionCNAMEs":
            throw await de_TooManyStreamingDistributionCNAMEsRes(parsedOutput, context);
        case "TooManyStreamingDistributions":
        case "com.amazonaws.cloudfront#TooManyStreamingDistributions":
            throw await de_TooManyStreamingDistributionsRes(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await de_TooManyTrustedSignersRes(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await de_TrustedSignerDoesNotExistRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateStreamingDistributionWithTagsCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CreateStreamingDistributionWithTagsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.StreamingDistribution = de_StreamingDistribution(data, context);
    return contents;
};
exports.de_CreateStreamingDistributionWithTagsCommand = de_CreateStreamingDistributionWithTagsCommand;
const de_CreateStreamingDistributionWithTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await de_CNAMEAlreadyExistsRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidOrigin":
        case "com.amazonaws.cloudfront#InvalidOrigin":
            throw await de_InvalidOriginRes(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await de_InvalidOriginAccessControlRes(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await de_InvalidOriginAccessIdentityRes(parsedOutput, context);
        case "InvalidTagging":
        case "com.amazonaws.cloudfront#InvalidTagging":
            throw await de_InvalidTaggingRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "StreamingDistributionAlreadyExists":
        case "com.amazonaws.cloudfront#StreamingDistributionAlreadyExists":
            throw await de_StreamingDistributionAlreadyExistsRes(parsedOutput, context);
        case "TooManyStreamingDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyStreamingDistributionCNAMEs":
            throw await de_TooManyStreamingDistributionCNAMEsRes(parsedOutput, context);
        case "TooManyStreamingDistributions":
        case "com.amazonaws.cloudfront#TooManyStreamingDistributions":
            throw await de_TooManyStreamingDistributionsRes(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await de_TooManyTrustedSignersRes(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await de_TrustedSignerDoesNotExistRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteCachePolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteCachePolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteCachePolicyCommand = de_DeleteCachePolicyCommand;
const de_DeleteCachePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CachePolicyInUse":
        case "com.amazonaws.cloudfront#CachePolicyInUse":
            throw await de_CachePolicyInUseRes(parsedOutput, context);
        case "IllegalDelete":
        case "com.amazonaws.cloudfront#IllegalDelete":
            throw await de_IllegalDeleteRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteCloudFrontOriginAccessIdentityCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteCloudFrontOriginAccessIdentityCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteCloudFrontOriginAccessIdentityCommand = de_DeleteCloudFrontOriginAccessIdentityCommand;
const de_DeleteCloudFrontOriginAccessIdentityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CloudFrontOriginAccessIdentityInUse":
        case "com.amazonaws.cloudfront#CloudFrontOriginAccessIdentityInUse":
            throw await de_CloudFrontOriginAccessIdentityInUseRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchCloudFrontOriginAccessIdentity":
        case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
            throw await de_NoSuchCloudFrontOriginAccessIdentityRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteContinuousDeploymentPolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteContinuousDeploymentPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteContinuousDeploymentPolicyCommand = de_DeleteContinuousDeploymentPolicyCommand;
const de_DeleteContinuousDeploymentPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "ContinuousDeploymentPolicyInUse":
        case "com.amazonaws.cloudfront#ContinuousDeploymentPolicyInUse":
            throw await de_ContinuousDeploymentPolicyInUseRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchContinuousDeploymentPolicy":
        case "com.amazonaws.cloudfront#NoSuchContinuousDeploymentPolicy":
            throw await de_NoSuchContinuousDeploymentPolicyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteDistributionCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteDistributionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteDistributionCommand = de_DeleteDistributionCommand;
const de_DeleteDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "DistributionNotDisabled":
        case "com.amazonaws.cloudfront#DistributionNotDisabled":
            throw await de_DistributionNotDisabledRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteFieldLevelEncryptionConfigCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteFieldLevelEncryptionConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteFieldLevelEncryptionConfigCommand = de_DeleteFieldLevelEncryptionConfigCommand;
const de_DeleteFieldLevelEncryptionConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "FieldLevelEncryptionConfigInUse":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionConfigInUse":
            throw await de_FieldLevelEncryptionConfigInUseRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await de_NoSuchFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteFieldLevelEncryptionProfileCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteFieldLevelEncryptionProfileCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteFieldLevelEncryptionProfileCommand = de_DeleteFieldLevelEncryptionProfileCommand;
const de_DeleteFieldLevelEncryptionProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "FieldLevelEncryptionProfileInUse":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileInUse":
            throw await de_FieldLevelEncryptionProfileInUseRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionProfile":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
            throw await de_NoSuchFieldLevelEncryptionProfileRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteFunctionCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteFunctionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteFunctionCommand = de_DeleteFunctionCommand;
const de_DeleteFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "FunctionInUse":
        case "com.amazonaws.cloudfront#FunctionInUse":
            throw await de_FunctionInUseRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchFunctionExists":
        case "com.amazonaws.cloudfront#NoSuchFunctionExists":
            throw await de_NoSuchFunctionExistsRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteKeyGroupCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteKeyGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteKeyGroupCommand = de_DeleteKeyGroupCommand;
const de_DeleteKeyGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await de_NoSuchResourceRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "ResourceInUse":
        case "com.amazonaws.cloudfront#ResourceInUse":
            throw await de_ResourceInUseRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteKeyValueStoreCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteKeyValueStoreCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteKeyValueStoreCommand = de_DeleteKeyValueStoreCommand;
const de_DeleteKeyValueStoreCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CannotDeleteEntityWhileInUse":
        case "com.amazonaws.cloudfront#CannotDeleteEntityWhileInUse":
            throw await de_CannotDeleteEntityWhileInUseRes(parsedOutput, context);
        case "EntityNotFound":
        case "com.amazonaws.cloudfront#EntityNotFound":
            throw await de_EntityNotFoundRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteMonitoringSubscriptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteMonitoringSubscriptionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteMonitoringSubscriptionCommand = de_DeleteMonitoringSubscriptionCommand;
const de_DeleteMonitoringSubscriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "NoSuchMonitoringSubscription":
        case "com.amazonaws.cloudfront#NoSuchMonitoringSubscription":
            throw await de_NoSuchMonitoringSubscriptionRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteOriginAccessControlCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteOriginAccessControlCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteOriginAccessControlCommand = de_DeleteOriginAccessControlCommand;
const de_DeleteOriginAccessControlCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchOriginAccessControl":
        case "com.amazonaws.cloudfront#NoSuchOriginAccessControl":
            throw await de_NoSuchOriginAccessControlRes(parsedOutput, context);
        case "OriginAccessControlInUse":
        case "com.amazonaws.cloudfront#OriginAccessControlInUse":
            throw await de_OriginAccessControlInUseRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteOriginRequestPolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteOriginRequestPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteOriginRequestPolicyCommand = de_DeleteOriginRequestPolicyCommand;
const de_DeleteOriginRequestPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "IllegalDelete":
        case "com.amazonaws.cloudfront#IllegalDelete":
            throw await de_IllegalDeleteRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        case "OriginRequestPolicyInUse":
        case "com.amazonaws.cloudfront#OriginRequestPolicyInUse":
            throw await de_OriginRequestPolicyInUseRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeletePublicKeyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeletePublicKeyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeletePublicKeyCommand = de_DeletePublicKeyCommand;
const de_DeletePublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchPublicKey":
        case "com.amazonaws.cloudfront#NoSuchPublicKey":
            throw await de_NoSuchPublicKeyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "PublicKeyInUse":
        case "com.amazonaws.cloudfront#PublicKeyInUse":
            throw await de_PublicKeyInUseRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteRealtimeLogConfigCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteRealtimeLogConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteRealtimeLogConfigCommand = de_DeleteRealtimeLogConfigCommand;
const de_DeleteRealtimeLogConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await de_NoSuchRealtimeLogConfigRes(parsedOutput, context);
        case "RealtimeLogConfigInUse":
        case "com.amazonaws.cloudfront#RealtimeLogConfigInUse":
            throw await de_RealtimeLogConfigInUseRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteResponseHeadersPolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteResponseHeadersPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteResponseHeadersPolicyCommand = de_DeleteResponseHeadersPolicyCommand;
const de_DeleteResponseHeadersPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "IllegalDelete":
        case "com.amazonaws.cloudfront#IllegalDelete":
            throw await de_IllegalDeleteRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "ResponseHeadersPolicyInUse":
        case "com.amazonaws.cloudfront#ResponseHeadersPolicyInUse":
            throw await de_ResponseHeadersPolicyInUseRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteStreamingDistributionCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteStreamingDistributionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteStreamingDistributionCommand = de_DeleteStreamingDistributionCommand;
const de_DeleteStreamingDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchStreamingDistribution":
        case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
            throw await de_NoSuchStreamingDistributionRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "StreamingDistributionNotDisabled":
        case "com.amazonaws.cloudfront#StreamingDistributionNotDisabled":
            throw await de_StreamingDistributionNotDisabledRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DescribeFunctionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeFunctionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FunctionSummary = de_FunctionSummary(data, context);
    return contents;
};
exports.de_DescribeFunctionCommand = de_DescribeFunctionCommand;
const de_DescribeFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchFunctionExists":
        case "com.amazonaws.cloudfront#NoSuchFunctionExists":
            throw await de_NoSuchFunctionExistsRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DescribeKeyValueStoreCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeKeyValueStoreCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyValueStore = de_KeyValueStore(data, context);
    return contents;
};
exports.de_DescribeKeyValueStoreCommand = de_DescribeKeyValueStoreCommand;
const de_DescribeKeyValueStoreCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "EntityNotFound":
        case "com.amazonaws.cloudfront#EntityNotFound":
            throw await de_EntityNotFoundRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetCachePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetCachePolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CachePolicy = de_CachePolicy(data, context);
    return contents;
};
exports.de_GetCachePolicyCommand = de_GetCachePolicyCommand;
const de_GetCachePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetCachePolicyConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetCachePolicyConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CachePolicyConfig = de_CachePolicyConfig(data, context);
    return contents;
};
exports.de_GetCachePolicyConfigCommand = de_GetCachePolicyConfigCommand;
const de_GetCachePolicyConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetCloudFrontOriginAccessIdentityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetCloudFrontOriginAccessIdentityCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CloudFrontOriginAccessIdentity = de_CloudFrontOriginAccessIdentity(data, context);
    return contents;
};
exports.de_GetCloudFrontOriginAccessIdentityCommand = de_GetCloudFrontOriginAccessIdentityCommand;
const de_GetCloudFrontOriginAccessIdentityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchCloudFrontOriginAccessIdentity":
        case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
            throw await de_NoSuchCloudFrontOriginAccessIdentityRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetCloudFrontOriginAccessIdentityConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetCloudFrontOriginAccessIdentityConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CloudFrontOriginAccessIdentityConfig = de_CloudFrontOriginAccessIdentityConfig(data, context);
    return contents;
};
exports.de_GetCloudFrontOriginAccessIdentityConfigCommand = de_GetCloudFrontOriginAccessIdentityConfigCommand;
const de_GetCloudFrontOriginAccessIdentityConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchCloudFrontOriginAccessIdentity":
        case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
            throw await de_NoSuchCloudFrontOriginAccessIdentityRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetContinuousDeploymentPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetContinuousDeploymentPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ContinuousDeploymentPolicy = de_ContinuousDeploymentPolicy(data, context);
    return contents;
};
exports.de_GetContinuousDeploymentPolicyCommand = de_GetContinuousDeploymentPolicyCommand;
const de_GetContinuousDeploymentPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchContinuousDeploymentPolicy":
        case "com.amazonaws.cloudfront#NoSuchContinuousDeploymentPolicy":
            throw await de_NoSuchContinuousDeploymentPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetContinuousDeploymentPolicyConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetContinuousDeploymentPolicyConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ContinuousDeploymentPolicyConfig = de_ContinuousDeploymentPolicyConfig(data, context);
    return contents;
};
exports.de_GetContinuousDeploymentPolicyConfigCommand = de_GetContinuousDeploymentPolicyConfigCommand;
const de_GetContinuousDeploymentPolicyConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchContinuousDeploymentPolicy":
        case "com.amazonaws.cloudfront#NoSuchContinuousDeploymentPolicy":
            throw await de_NoSuchContinuousDeploymentPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetDistributionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDistributionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Distribution = de_Distribution(data, context);
    return contents;
};
exports.de_GetDistributionCommand = de_GetDistributionCommand;
const de_GetDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetDistributionConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetDistributionConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionConfig = de_DistributionConfig(data, context);
    return contents;
};
exports.de_GetDistributionConfigCommand = de_GetDistributionConfigCommand;
const de_GetDistributionConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetFieldLevelEncryptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetFieldLevelEncryptionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryption = de_FieldLevelEncryption(data, context);
    return contents;
};
exports.de_GetFieldLevelEncryptionCommand = de_GetFieldLevelEncryptionCommand;
const de_GetFieldLevelEncryptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await de_NoSuchFieldLevelEncryptionConfigRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetFieldLevelEncryptionConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetFieldLevelEncryptionConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionConfig = de_FieldLevelEncryptionConfig(data, context);
    return contents;
};
exports.de_GetFieldLevelEncryptionConfigCommand = de_GetFieldLevelEncryptionConfigCommand;
const de_GetFieldLevelEncryptionConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await de_NoSuchFieldLevelEncryptionConfigRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetFieldLevelEncryptionProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetFieldLevelEncryptionProfileCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionProfile = de_FieldLevelEncryptionProfile(data, context);
    return contents;
};
exports.de_GetFieldLevelEncryptionProfileCommand = de_GetFieldLevelEncryptionProfileCommand;
const de_GetFieldLevelEncryptionProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionProfile":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
            throw await de_NoSuchFieldLevelEncryptionProfileRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetFieldLevelEncryptionProfileConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetFieldLevelEncryptionProfileConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionProfileConfig = de_FieldLevelEncryptionProfileConfig(data, context);
    return contents;
};
exports.de_GetFieldLevelEncryptionProfileConfigCommand = de_GetFieldLevelEncryptionProfileConfigCommand;
const de_GetFieldLevelEncryptionProfileConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionProfile":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
            throw await de_NoSuchFieldLevelEncryptionProfileRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetFunctionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetFunctionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
        [_CT]: [, output.headers[_ct]],
    });
    const data = await (0, smithy_client_1.collectBody)(output.body, context);
    contents.FunctionCode = data;
    return contents;
};
exports.de_GetFunctionCommand = de_GetFunctionCommand;
const de_GetFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchFunctionExists":
        case "com.amazonaws.cloudfront#NoSuchFunctionExists":
            throw await de_NoSuchFunctionExistsRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetInvalidationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetInvalidationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Invalidation = de_Invalidation(data, context);
    return contents;
};
exports.de_GetInvalidationCommand = de_GetInvalidationCommand;
const de_GetInvalidationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "NoSuchInvalidation":
        case "com.amazonaws.cloudfront#NoSuchInvalidation":
            throw await de_NoSuchInvalidationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetKeyGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetKeyGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyGroup = de_KeyGroup(data, context);
    return contents;
};
exports.de_GetKeyGroupCommand = de_GetKeyGroupCommand;
const de_GetKeyGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await de_NoSuchResourceRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetKeyGroupConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetKeyGroupConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyGroupConfig = de_KeyGroupConfig(data, context);
    return contents;
};
exports.de_GetKeyGroupConfigCommand = de_GetKeyGroupConfigCommand;
const de_GetKeyGroupConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await de_NoSuchResourceRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetMonitoringSubscriptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetMonitoringSubscriptionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.MonitoringSubscription = de_MonitoringSubscription(data, context);
    return contents;
};
exports.de_GetMonitoringSubscriptionCommand = de_GetMonitoringSubscriptionCommand;
const de_GetMonitoringSubscriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "NoSuchMonitoringSubscription":
        case "com.amazonaws.cloudfront#NoSuchMonitoringSubscription":
            throw await de_NoSuchMonitoringSubscriptionRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetOriginAccessControlCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetOriginAccessControlCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginAccessControl = de_OriginAccessControl(data, context);
    return contents;
};
exports.de_GetOriginAccessControlCommand = de_GetOriginAccessControlCommand;
const de_GetOriginAccessControlCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchOriginAccessControl":
        case "com.amazonaws.cloudfront#NoSuchOriginAccessControl":
            throw await de_NoSuchOriginAccessControlRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetOriginAccessControlConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetOriginAccessControlConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginAccessControlConfig = de_OriginAccessControlConfig(data, context);
    return contents;
};
exports.de_GetOriginAccessControlConfigCommand = de_GetOriginAccessControlConfigCommand;
const de_GetOriginAccessControlConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchOriginAccessControl":
        case "com.amazonaws.cloudfront#NoSuchOriginAccessControl":
            throw await de_NoSuchOriginAccessControlRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetOriginRequestPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetOriginRequestPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginRequestPolicy = de_OriginRequestPolicy(data, context);
    return contents;
};
exports.de_GetOriginRequestPolicyCommand = de_GetOriginRequestPolicyCommand;
const de_GetOriginRequestPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetOriginRequestPolicyConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetOriginRequestPolicyConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginRequestPolicyConfig = de_OriginRequestPolicyConfig(data, context);
    return contents;
};
exports.de_GetOriginRequestPolicyConfigCommand = de_GetOriginRequestPolicyConfigCommand;
const de_GetOriginRequestPolicyConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetPublicKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetPublicKeyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.PublicKey = de_PublicKey(data, context);
    return contents;
};
exports.de_GetPublicKeyCommand = de_GetPublicKeyCommand;
const de_GetPublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchPublicKey":
        case "com.amazonaws.cloudfront#NoSuchPublicKey":
            throw await de_NoSuchPublicKeyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetPublicKeyConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetPublicKeyConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.PublicKeyConfig = de_PublicKeyConfig(data, context);
    return contents;
};
exports.de_GetPublicKeyConfigCommand = de_GetPublicKeyConfigCommand;
const de_GetPublicKeyConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchPublicKey":
        case "com.amazonaws.cloudfront#NoSuchPublicKey":
            throw await de_NoSuchPublicKeyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetRealtimeLogConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRealtimeLogConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_RLC] != null) {
        contents[_RLC] = de_RealtimeLogConfig(data[_RLC], context);
    }
    return contents;
};
exports.de_GetRealtimeLogConfigCommand = de_GetRealtimeLogConfigCommand;
const de_GetRealtimeLogConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await de_NoSuchRealtimeLogConfigRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetResponseHeadersPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetResponseHeadersPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ResponseHeadersPolicy = de_ResponseHeadersPolicy(data, context);
    return contents;
};
exports.de_GetResponseHeadersPolicyCommand = de_GetResponseHeadersPolicyCommand;
const de_GetResponseHeadersPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetResponseHeadersPolicyConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetResponseHeadersPolicyConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ResponseHeadersPolicyConfig = de_ResponseHeadersPolicyConfig(data, context);
    return contents;
};
exports.de_GetResponseHeadersPolicyConfigCommand = de_GetResponseHeadersPolicyConfigCommand;
const de_GetResponseHeadersPolicyConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetStreamingDistributionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetStreamingDistributionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.StreamingDistribution = de_StreamingDistribution(data, context);
    return contents;
};
exports.de_GetStreamingDistributionCommand = de_GetStreamingDistributionCommand;
const de_GetStreamingDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchStreamingDistribution":
        case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
            throw await de_NoSuchStreamingDistributionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetStreamingDistributionConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetStreamingDistributionConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.StreamingDistributionConfig = de_StreamingDistributionConfig(data, context);
    return contents;
};
exports.de_GetStreamingDistributionConfigCommand = de_GetStreamingDistributionConfigCommand;
const de_GetStreamingDistributionConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "NoSuchStreamingDistribution":
        case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
            throw await de_NoSuchStreamingDistributionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListCachePoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListCachePoliciesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CachePolicyList = de_CachePolicyList(data, context);
    return contents;
};
exports.de_ListCachePoliciesCommand = de_ListCachePoliciesCommand;
const de_ListCachePoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListCloudFrontOriginAccessIdentitiesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListCloudFrontOriginAccessIdentitiesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CloudFrontOriginAccessIdentityList = de_CloudFrontOriginAccessIdentityList(data, context);
    return contents;
};
exports.de_ListCloudFrontOriginAccessIdentitiesCommand = de_ListCloudFrontOriginAccessIdentitiesCommand;
const de_ListCloudFrontOriginAccessIdentitiesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListConflictingAliasesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListConflictingAliasesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ConflictingAliasesList = de_ConflictingAliasesList(data, context);
    return contents;
};
exports.de_ListConflictingAliasesCommand = de_ListConflictingAliasesCommand;
const de_ListConflictingAliasesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListContinuousDeploymentPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListContinuousDeploymentPoliciesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ContinuousDeploymentPolicyList = de_ContinuousDeploymentPolicyList(data, context);
    return contents;
};
exports.de_ListContinuousDeploymentPoliciesCommand = de_ListContinuousDeploymentPoliciesCommand;
const de_ListContinuousDeploymentPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchContinuousDeploymentPolicy":
        case "com.amazonaws.cloudfront#NoSuchContinuousDeploymentPolicy":
            throw await de_NoSuchContinuousDeploymentPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListDistributionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDistributionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionList = de_DistributionList(data, context);
    return contents;
};
exports.de_ListDistributionsCommand = de_ListDistributionsCommand;
const de_ListDistributionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListDistributionsByCachePolicyIdCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDistributionsByCachePolicyIdCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionIdList = de_DistributionIdList(data, context);
    return contents;
};
exports.de_ListDistributionsByCachePolicyIdCommand = de_ListDistributionsByCachePolicyIdCommand;
const de_ListDistributionsByCachePolicyIdCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListDistributionsByKeyGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDistributionsByKeyGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionIdList = de_DistributionIdList(data, context);
    return contents;
};
exports.de_ListDistributionsByKeyGroupCommand = de_ListDistributionsByKeyGroupCommand;
const de_ListDistributionsByKeyGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await de_NoSuchResourceRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListDistributionsByOriginRequestPolicyIdCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDistributionsByOriginRequestPolicyIdCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionIdList = de_DistributionIdList(data, context);
    return contents;
};
exports.de_ListDistributionsByOriginRequestPolicyIdCommand = de_ListDistributionsByOriginRequestPolicyIdCommand;
const de_ListDistributionsByOriginRequestPolicyIdCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListDistributionsByRealtimeLogConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDistributionsByRealtimeLogConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionList = de_DistributionList(data, context);
    return contents;
};
exports.de_ListDistributionsByRealtimeLogConfigCommand = de_ListDistributionsByRealtimeLogConfigCommand;
const de_ListDistributionsByRealtimeLogConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListDistributionsByResponseHeadersPolicyIdCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDistributionsByResponseHeadersPolicyIdCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionIdList = de_DistributionIdList(data, context);
    return contents;
};
exports.de_ListDistributionsByResponseHeadersPolicyIdCommand = de_ListDistributionsByResponseHeadersPolicyIdCommand;
const de_ListDistributionsByResponseHeadersPolicyIdCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListDistributionsByWebACLIdCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDistributionsByWebACLIdCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.DistributionList = de_DistributionList(data, context);
    return contents;
};
exports.de_ListDistributionsByWebACLIdCommand = de_ListDistributionsByWebACLIdCommand;
const de_ListDistributionsByWebACLIdCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidWebACLId":
        case "com.amazonaws.cloudfront#InvalidWebACLId":
            throw await de_InvalidWebACLIdRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListFieldLevelEncryptionConfigsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListFieldLevelEncryptionConfigsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionList = de_FieldLevelEncryptionList(data, context);
    return contents;
};
exports.de_ListFieldLevelEncryptionConfigsCommand = de_ListFieldLevelEncryptionConfigsCommand;
const de_ListFieldLevelEncryptionConfigsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListFieldLevelEncryptionProfilesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListFieldLevelEncryptionProfilesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionProfileList = de_FieldLevelEncryptionProfileList(data, context);
    return contents;
};
exports.de_ListFieldLevelEncryptionProfilesCommand = de_ListFieldLevelEncryptionProfilesCommand;
const de_ListFieldLevelEncryptionProfilesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListFunctionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListFunctionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FunctionList = de_FunctionList(data, context);
    return contents;
};
exports.de_ListFunctionsCommand = de_ListFunctionsCommand;
const de_ListFunctionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListInvalidationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListInvalidationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.InvalidationList = de_InvalidationList(data, context);
    return contents;
};
exports.de_ListInvalidationsCommand = de_ListInvalidationsCommand;
const de_ListInvalidationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListKeyGroupsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListKeyGroupsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyGroupList = de_KeyGroupList(data, context);
    return contents;
};
exports.de_ListKeyGroupsCommand = de_ListKeyGroupsCommand;
const de_ListKeyGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListKeyValueStoresCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListKeyValueStoresCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyValueStoreList = de_KeyValueStoreList(data, context);
    return contents;
};
exports.de_ListKeyValueStoresCommand = de_ListKeyValueStoresCommand;
const de_ListKeyValueStoresCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListOriginAccessControlsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListOriginAccessControlsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginAccessControlList = de_OriginAccessControlList(data, context);
    return contents;
};
exports.de_ListOriginAccessControlsCommand = de_ListOriginAccessControlsCommand;
const de_ListOriginAccessControlsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListOriginRequestPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListOriginRequestPoliciesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginRequestPolicyList = de_OriginRequestPolicyList(data, context);
    return contents;
};
exports.de_ListOriginRequestPoliciesCommand = de_ListOriginRequestPoliciesCommand;
const de_ListOriginRequestPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListPublicKeysCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListPublicKeysCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.PublicKeyList = de_PublicKeyList(data, context);
    return contents;
};
exports.de_ListPublicKeysCommand = de_ListPublicKeysCommand;
const de_ListPublicKeysCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListRealtimeLogConfigsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListRealtimeLogConfigsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.RealtimeLogConfigs = de_RealtimeLogConfigs(data, context);
    return contents;
};
exports.de_ListRealtimeLogConfigsCommand = de_ListRealtimeLogConfigsCommand;
const de_ListRealtimeLogConfigsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await de_NoSuchRealtimeLogConfigRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListResponseHeadersPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListResponseHeadersPoliciesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ResponseHeadersPolicyList = de_ResponseHeadersPolicyList(data, context);
    return contents;
};
exports.de_ListResponseHeadersPoliciesCommand = de_ListResponseHeadersPoliciesCommand;
const de_ListResponseHeadersPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListStreamingDistributionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListStreamingDistributionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.StreamingDistributionList = de_StreamingDistributionList(data, context);
    return contents;
};
exports.de_ListStreamingDistributionsCommand = de_ListStreamingDistributionsCommand;
const de_ListStreamingDistributionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTagsForResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Tags = de_Tags(data, context);
    return contents;
};
exports.de_ListTagsForResourceCommand = de_ListTagsForResourceCommand;
const de_ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidTagging":
        case "com.amazonaws.cloudfront#InvalidTagging":
            throw await de_InvalidTaggingRes(parsedOutput, context);
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await de_NoSuchResourceRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_PublishFunctionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PublishFunctionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FunctionSummary = de_FunctionSummary(data, context);
    return contents;
};
exports.de_PublishFunctionCommand = de_PublishFunctionCommand;
const de_PublishFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchFunctionExists":
        case "com.amazonaws.cloudfront#NoSuchFunctionExists":
            throw await de_NoSuchFunctionExistsRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_TagResourceCommand = de_TagResourceCommand;
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidTagging":
        case "com.amazonaws.cloudfront#InvalidTagging":
            throw await de_InvalidTaggingRes(parsedOutput, context);
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await de_NoSuchResourceRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_TestFunctionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_TestFunctionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.TestResult = de_TestResult(data, context);
    return contents;
};
exports.de_TestFunctionCommand = de_TestFunctionCommand;
const de_TestFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchFunctionExists":
        case "com.amazonaws.cloudfront#NoSuchFunctionExists":
            throw await de_NoSuchFunctionExistsRes(parsedOutput, context);
        case "TestFunctionFailed":
        case "com.amazonaws.cloudfront#TestFunctionFailed":
            throw await de_TestFunctionFailedRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UntagResourceCommand = de_UntagResourceCommand;
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidTagging":
        case "com.amazonaws.cloudfront#InvalidTagging":
            throw await de_InvalidTaggingRes(parsedOutput, context);
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await de_NoSuchResourceRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateCachePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateCachePolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CachePolicy = de_CachePolicy(data, context);
    return contents;
};
exports.de_UpdateCachePolicyCommand = de_UpdateCachePolicyCommand;
const de_UpdateCachePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CachePolicyAlreadyExists":
        case "com.amazonaws.cloudfront#CachePolicyAlreadyExists":
            throw await de_CachePolicyAlreadyExistsRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "TooManyCookiesInCachePolicy":
        case "com.amazonaws.cloudfront#TooManyCookiesInCachePolicy":
            throw await de_TooManyCookiesInCachePolicyRes(parsedOutput, context);
        case "TooManyHeadersInCachePolicy":
        case "com.amazonaws.cloudfront#TooManyHeadersInCachePolicy":
            throw await de_TooManyHeadersInCachePolicyRes(parsedOutput, context);
        case "TooManyQueryStringsInCachePolicy":
        case "com.amazonaws.cloudfront#TooManyQueryStringsInCachePolicy":
            throw await de_TooManyQueryStringsInCachePolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateCloudFrontOriginAccessIdentityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateCloudFrontOriginAccessIdentityCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CloudFrontOriginAccessIdentity = de_CloudFrontOriginAccessIdentity(data, context);
    return contents;
};
exports.de_UpdateCloudFrontOriginAccessIdentityCommand = de_UpdateCloudFrontOriginAccessIdentityCommand;
const de_UpdateCloudFrontOriginAccessIdentityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "NoSuchCloudFrontOriginAccessIdentity":
        case "com.amazonaws.cloudfront#NoSuchCloudFrontOriginAccessIdentity":
            throw await de_NoSuchCloudFrontOriginAccessIdentityRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateContinuousDeploymentPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateContinuousDeploymentPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ContinuousDeploymentPolicy = de_ContinuousDeploymentPolicy(data, context);
    return contents;
};
exports.de_UpdateContinuousDeploymentPolicyCommand = de_UpdateContinuousDeploymentPolicyCommand;
const de_UpdateContinuousDeploymentPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchContinuousDeploymentPolicy":
        case "com.amazonaws.cloudfront#NoSuchContinuousDeploymentPolicy":
            throw await de_NoSuchContinuousDeploymentPolicyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "StagingDistributionInUse":
        case "com.amazonaws.cloudfront#StagingDistributionInUse":
            throw await de_StagingDistributionInUseRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateDistributionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDistributionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Distribution = de_Distribution(data, context);
    return contents;
};
exports.de_UpdateDistributionCommand = de_UpdateDistributionCommand;
const de_UpdateDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await de_CNAMEAlreadyExistsRes(parsedOutput, context);
        case "ContinuousDeploymentPolicyInUse":
        case "com.amazonaws.cloudfront#ContinuousDeploymentPolicyInUse":
            throw await de_ContinuousDeploymentPolicyInUseRes(parsedOutput, context);
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
        case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
            throw await de_IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorRes(parsedOutput, context);
        case "IllegalOriginAccessConfiguration":
        case "com.amazonaws.cloudfront#IllegalOriginAccessConfiguration":
            throw await de_IllegalOriginAccessConfigurationRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidDefaultRootObject":
        case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
            throw await de_InvalidDefaultRootObjectRes(parsedOutput, context);
        case "InvalidDomainNameForOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidDomainNameForOriginAccessControl":
            throw await de_InvalidDomainNameForOriginAccessControlRes(parsedOutput, context);
        case "InvalidErrorCode":
        case "com.amazonaws.cloudfront#InvalidErrorCode":
            throw await de_InvalidErrorCodeRes(parsedOutput, context);
        case "InvalidForwardCookies":
        case "com.amazonaws.cloudfront#InvalidForwardCookies":
            throw await de_InvalidForwardCookiesRes(parsedOutput, context);
        case "InvalidFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidFunctionAssociation":
            throw await de_InvalidFunctionAssociationRes(parsedOutput, context);
        case "InvalidGeoRestrictionParameter":
        case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
            throw await de_InvalidGeoRestrictionParameterRes(parsedOutput, context);
        case "InvalidHeadersForS3Origin":
        case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
            throw await de_InvalidHeadersForS3OriginRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "InvalidLambdaFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
            throw await de_InvalidLambdaFunctionAssociationRes(parsedOutput, context);
        case "InvalidLocationCode":
        case "com.amazonaws.cloudfront#InvalidLocationCode":
            throw await de_InvalidLocationCodeRes(parsedOutput, context);
        case "InvalidMinimumProtocolVersion":
        case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
            throw await de_InvalidMinimumProtocolVersionRes(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await de_InvalidOriginAccessControlRes(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await de_InvalidOriginAccessIdentityRes(parsedOutput, context);
        case "InvalidOriginKeepaliveTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
            throw await de_InvalidOriginKeepaliveTimeoutRes(parsedOutput, context);
        case "InvalidOriginReadTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
            throw await de_InvalidOriginReadTimeoutRes(parsedOutput, context);
        case "InvalidQueryStringParameters":
        case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
            throw await de_InvalidQueryStringParametersRes(parsedOutput, context);
        case "InvalidRelativePath":
        case "com.amazonaws.cloudfront#InvalidRelativePath":
            throw await de_InvalidRelativePathRes(parsedOutput, context);
        case "InvalidRequiredProtocol":
        case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
            throw await de_InvalidRequiredProtocolRes(parsedOutput, context);
        case "InvalidResponseCode":
        case "com.amazonaws.cloudfront#InvalidResponseCode":
            throw await de_InvalidResponseCodeRes(parsedOutput, context);
        case "InvalidTTLOrder":
        case "com.amazonaws.cloudfront#InvalidTTLOrder":
            throw await de_InvalidTTLOrderRes(parsedOutput, context);
        case "InvalidViewerCertificate":
        case "com.amazonaws.cloudfront#InvalidViewerCertificate":
            throw await de_InvalidViewerCertificateRes(parsedOutput, context);
        case "InvalidWebACLId":
        case "com.amazonaws.cloudfront#InvalidWebACLId":
            throw await de_InvalidWebACLIdRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        case "NoSuchContinuousDeploymentPolicy":
        case "com.amazonaws.cloudfront#NoSuchContinuousDeploymentPolicy":
            throw await de_NoSuchContinuousDeploymentPolicyRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await de_NoSuchFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "NoSuchOrigin":
        case "com.amazonaws.cloudfront#NoSuchOrigin":
            throw await de_NoSuchOriginRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await de_NoSuchRealtimeLogConfigRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "RealtimeLogConfigOwnerMismatch":
        case "com.amazonaws.cloudfront#RealtimeLogConfigOwnerMismatch":
            throw await de_RealtimeLogConfigOwnerMismatchRes(parsedOutput, context);
        case "StagingDistributionInUse":
        case "com.amazonaws.cloudfront#StagingDistributionInUse":
            throw await de_StagingDistributionInUseRes(parsedOutput, context);
        case "TooManyCacheBehaviors":
        case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
            throw await de_TooManyCacheBehaviorsRes(parsedOutput, context);
        case "TooManyCertificates":
        case "com.amazonaws.cloudfront#TooManyCertificates":
            throw await de_TooManyCertificatesRes(parsedOutput, context);
        case "TooManyCookieNamesInWhiteList":
        case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
            throw await de_TooManyCookieNamesInWhiteListRes(parsedOutput, context);
        case "TooManyDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
            throw await de_TooManyDistributionCNAMEsRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToCachePolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToCachePolicy":
            throw await de_TooManyDistributionsAssociatedToCachePolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
            throw await de_TooManyDistributionsAssociatedToFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToKeyGroup":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToKeyGroup":
            throw await de_TooManyDistributionsAssociatedToKeyGroupRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginAccessControl":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginAccessControl":
            throw await de_TooManyDistributionsAssociatedToOriginAccessControlRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginRequestPolicy":
            throw await de_TooManyDistributionsAssociatedToOriginRequestPolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToResponseHeadersPolicy":
            throw await de_TooManyDistributionsAssociatedToResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyDistributionsWithFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithFunctionAssociations":
            throw await de_TooManyDistributionsWithFunctionAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithLambdaAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
            throw await de_TooManyDistributionsWithLambdaAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithSingleFunctionARN":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithSingleFunctionARN":
            throw await de_TooManyDistributionsWithSingleFunctionARNRes(parsedOutput, context);
        case "TooManyFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyFunctionAssociations":
            throw await de_TooManyFunctionAssociationsRes(parsedOutput, context);
        case "TooManyHeadersInForwardedValues":
        case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
            throw await de_TooManyHeadersInForwardedValuesRes(parsedOutput, context);
        case "TooManyKeyGroupsAssociatedToDistribution":
        case "com.amazonaws.cloudfront#TooManyKeyGroupsAssociatedToDistribution":
            throw await de_TooManyKeyGroupsAssociatedToDistributionRes(parsedOutput, context);
        case "TooManyLambdaFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
            throw await de_TooManyLambdaFunctionAssociationsRes(parsedOutput, context);
        case "TooManyOriginCustomHeaders":
        case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
            throw await de_TooManyOriginCustomHeadersRes(parsedOutput, context);
        case "TooManyOriginGroupsPerDistribution":
        case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
            throw await de_TooManyOriginGroupsPerDistributionRes(parsedOutput, context);
        case "TooManyOrigins":
        case "com.amazonaws.cloudfront#TooManyOrigins":
            throw await de_TooManyOriginsRes(parsedOutput, context);
        case "TooManyQueryStringParameters":
        case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
            throw await de_TooManyQueryStringParametersRes(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await de_TooManyTrustedSignersRes(parsedOutput, context);
        case "TrustedKeyGroupDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedKeyGroupDoesNotExist":
            throw await de_TrustedKeyGroupDoesNotExistRes(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await de_TrustedSignerDoesNotExistRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateDistributionWithStagingConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDistributionWithStagingConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Distribution = de_Distribution(data, context);
    return contents;
};
exports.de_UpdateDistributionWithStagingConfigCommand = de_UpdateDistributionWithStagingConfigCommand;
const de_UpdateDistributionWithStagingConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await de_CNAMEAlreadyExistsRes(parsedOutput, context);
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
        case "com.amazonaws.cloudfront#IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior":
            throw await de_IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidDefaultRootObject":
        case "com.amazonaws.cloudfront#InvalidDefaultRootObject":
            throw await de_InvalidDefaultRootObjectRes(parsedOutput, context);
        case "InvalidErrorCode":
        case "com.amazonaws.cloudfront#InvalidErrorCode":
            throw await de_InvalidErrorCodeRes(parsedOutput, context);
        case "InvalidForwardCookies":
        case "com.amazonaws.cloudfront#InvalidForwardCookies":
            throw await de_InvalidForwardCookiesRes(parsedOutput, context);
        case "InvalidFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidFunctionAssociation":
            throw await de_InvalidFunctionAssociationRes(parsedOutput, context);
        case "InvalidGeoRestrictionParameter":
        case "com.amazonaws.cloudfront#InvalidGeoRestrictionParameter":
            throw await de_InvalidGeoRestrictionParameterRes(parsedOutput, context);
        case "InvalidHeadersForS3Origin":
        case "com.amazonaws.cloudfront#InvalidHeadersForS3Origin":
            throw await de_InvalidHeadersForS3OriginRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "InvalidLambdaFunctionAssociation":
        case "com.amazonaws.cloudfront#InvalidLambdaFunctionAssociation":
            throw await de_InvalidLambdaFunctionAssociationRes(parsedOutput, context);
        case "InvalidLocationCode":
        case "com.amazonaws.cloudfront#InvalidLocationCode":
            throw await de_InvalidLocationCodeRes(parsedOutput, context);
        case "InvalidMinimumProtocolVersion":
        case "com.amazonaws.cloudfront#InvalidMinimumProtocolVersion":
            throw await de_InvalidMinimumProtocolVersionRes(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await de_InvalidOriginAccessControlRes(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await de_InvalidOriginAccessIdentityRes(parsedOutput, context);
        case "InvalidOriginKeepaliveTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginKeepaliveTimeout":
            throw await de_InvalidOriginKeepaliveTimeoutRes(parsedOutput, context);
        case "InvalidOriginReadTimeout":
        case "com.amazonaws.cloudfront#InvalidOriginReadTimeout":
            throw await de_InvalidOriginReadTimeoutRes(parsedOutput, context);
        case "InvalidQueryStringParameters":
        case "com.amazonaws.cloudfront#InvalidQueryStringParameters":
            throw await de_InvalidQueryStringParametersRes(parsedOutput, context);
        case "InvalidRelativePath":
        case "com.amazonaws.cloudfront#InvalidRelativePath":
            throw await de_InvalidRelativePathRes(parsedOutput, context);
        case "InvalidRequiredProtocol":
        case "com.amazonaws.cloudfront#InvalidRequiredProtocol":
            throw await de_InvalidRequiredProtocolRes(parsedOutput, context);
        case "InvalidResponseCode":
        case "com.amazonaws.cloudfront#InvalidResponseCode":
            throw await de_InvalidResponseCodeRes(parsedOutput, context);
        case "InvalidTTLOrder":
        case "com.amazonaws.cloudfront#InvalidTTLOrder":
            throw await de_InvalidTTLOrderRes(parsedOutput, context);
        case "InvalidViewerCertificate":
        case "com.amazonaws.cloudfront#InvalidViewerCertificate":
            throw await de_InvalidViewerCertificateRes(parsedOutput, context);
        case "InvalidWebACLId":
        case "com.amazonaws.cloudfront#InvalidWebACLId":
            throw await de_InvalidWebACLIdRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "NoSuchCachePolicy":
        case "com.amazonaws.cloudfront#NoSuchCachePolicy":
            throw await de_NoSuchCachePolicyRes(parsedOutput, context);
        case "NoSuchDistribution":
        case "com.amazonaws.cloudfront#NoSuchDistribution":
            throw await de_NoSuchDistributionRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await de_NoSuchFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "NoSuchOrigin":
        case "com.amazonaws.cloudfront#NoSuchOrigin":
            throw await de_NoSuchOriginRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await de_NoSuchRealtimeLogConfigRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "RealtimeLogConfigOwnerMismatch":
        case "com.amazonaws.cloudfront#RealtimeLogConfigOwnerMismatch":
            throw await de_RealtimeLogConfigOwnerMismatchRes(parsedOutput, context);
        case "TooManyCacheBehaviors":
        case "com.amazonaws.cloudfront#TooManyCacheBehaviors":
            throw await de_TooManyCacheBehaviorsRes(parsedOutput, context);
        case "TooManyCertificates":
        case "com.amazonaws.cloudfront#TooManyCertificates":
            throw await de_TooManyCertificatesRes(parsedOutput, context);
        case "TooManyCookieNamesInWhiteList":
        case "com.amazonaws.cloudfront#TooManyCookieNamesInWhiteList":
            throw await de_TooManyCookieNamesInWhiteListRes(parsedOutput, context);
        case "TooManyDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyDistributionCNAMEs":
            throw await de_TooManyDistributionCNAMEsRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToCachePolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToCachePolicy":
            throw await de_TooManyDistributionsAssociatedToCachePolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToFieldLevelEncryptionConfig":
            throw await de_TooManyDistributionsAssociatedToFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToKeyGroup":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToKeyGroup":
            throw await de_TooManyDistributionsAssociatedToKeyGroupRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginAccessControl":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginAccessControl":
            throw await de_TooManyDistributionsAssociatedToOriginAccessControlRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToOriginRequestPolicy":
            throw await de_TooManyDistributionsAssociatedToOriginRequestPolicyRes(parsedOutput, context);
        case "TooManyDistributionsAssociatedToResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyDistributionsAssociatedToResponseHeadersPolicy":
            throw await de_TooManyDistributionsAssociatedToResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyDistributionsWithFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithFunctionAssociations":
            throw await de_TooManyDistributionsWithFunctionAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithLambdaAssociations":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithLambdaAssociations":
            throw await de_TooManyDistributionsWithLambdaAssociationsRes(parsedOutput, context);
        case "TooManyDistributionsWithSingleFunctionARN":
        case "com.amazonaws.cloudfront#TooManyDistributionsWithSingleFunctionARN":
            throw await de_TooManyDistributionsWithSingleFunctionARNRes(parsedOutput, context);
        case "TooManyFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyFunctionAssociations":
            throw await de_TooManyFunctionAssociationsRes(parsedOutput, context);
        case "TooManyHeadersInForwardedValues":
        case "com.amazonaws.cloudfront#TooManyHeadersInForwardedValues":
            throw await de_TooManyHeadersInForwardedValuesRes(parsedOutput, context);
        case "TooManyKeyGroupsAssociatedToDistribution":
        case "com.amazonaws.cloudfront#TooManyKeyGroupsAssociatedToDistribution":
            throw await de_TooManyKeyGroupsAssociatedToDistributionRes(parsedOutput, context);
        case "TooManyLambdaFunctionAssociations":
        case "com.amazonaws.cloudfront#TooManyLambdaFunctionAssociations":
            throw await de_TooManyLambdaFunctionAssociationsRes(parsedOutput, context);
        case "TooManyOriginCustomHeaders":
        case "com.amazonaws.cloudfront#TooManyOriginCustomHeaders":
            throw await de_TooManyOriginCustomHeadersRes(parsedOutput, context);
        case "TooManyOriginGroupsPerDistribution":
        case "com.amazonaws.cloudfront#TooManyOriginGroupsPerDistribution":
            throw await de_TooManyOriginGroupsPerDistributionRes(parsedOutput, context);
        case "TooManyOrigins":
        case "com.amazonaws.cloudfront#TooManyOrigins":
            throw await de_TooManyOriginsRes(parsedOutput, context);
        case "TooManyQueryStringParameters":
        case "com.amazonaws.cloudfront#TooManyQueryStringParameters":
            throw await de_TooManyQueryStringParametersRes(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await de_TooManyTrustedSignersRes(parsedOutput, context);
        case "TrustedKeyGroupDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedKeyGroupDoesNotExist":
            throw await de_TrustedKeyGroupDoesNotExistRes(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await de_TrustedSignerDoesNotExistRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateFieldLevelEncryptionConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateFieldLevelEncryptionConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryption = de_FieldLevelEncryption(data, context);
    return contents;
};
exports.de_UpdateFieldLevelEncryptionConfigCommand = de_UpdateFieldLevelEncryptionConfigCommand;
const de_UpdateFieldLevelEncryptionConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionConfig":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionConfig":
            throw await de_NoSuchFieldLevelEncryptionConfigRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionProfile":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
            throw await de_NoSuchFieldLevelEncryptionProfileRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "QueryArgProfileEmpty":
        case "com.amazonaws.cloudfront#QueryArgProfileEmpty":
            throw await de_QueryArgProfileEmptyRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionContentTypeProfiles":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionContentTypeProfiles":
            throw await de_TooManyFieldLevelEncryptionContentTypeProfilesRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionQueryArgProfiles":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionQueryArgProfiles":
            throw await de_TooManyFieldLevelEncryptionQueryArgProfilesRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateFieldLevelEncryptionProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateFieldLevelEncryptionProfileCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FieldLevelEncryptionProfile = de_FieldLevelEncryptionProfile(data, context);
    return contents;
};
exports.de_UpdateFieldLevelEncryptionProfileCommand = de_UpdateFieldLevelEncryptionProfileCommand;
const de_UpdateFieldLevelEncryptionProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "FieldLevelEncryptionProfileAlreadyExists":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileAlreadyExists":
            throw await de_FieldLevelEncryptionProfileAlreadyExistsRes(parsedOutput, context);
        case "FieldLevelEncryptionProfileSizeExceeded":
        case "com.amazonaws.cloudfront#FieldLevelEncryptionProfileSizeExceeded":
            throw await de_FieldLevelEncryptionProfileSizeExceededRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchFieldLevelEncryptionProfile":
        case "com.amazonaws.cloudfront#NoSuchFieldLevelEncryptionProfile":
            throw await de_NoSuchFieldLevelEncryptionProfileRes(parsedOutput, context);
        case "NoSuchPublicKey":
        case "com.amazonaws.cloudfront#NoSuchPublicKey":
            throw await de_NoSuchPublicKeyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionEncryptionEntities":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionEncryptionEntities":
            throw await de_TooManyFieldLevelEncryptionEncryptionEntitiesRes(parsedOutput, context);
        case "TooManyFieldLevelEncryptionFieldPatterns":
        case "com.amazonaws.cloudfront#TooManyFieldLevelEncryptionFieldPatterns":
            throw await de_TooManyFieldLevelEncryptionFieldPatternsRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateFunctionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateFunctionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_et]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.FunctionSummary = de_FunctionSummary(data, context);
    return contents;
};
exports.de_UpdateFunctionCommand = de_UpdateFunctionCommand;
const de_UpdateFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "FunctionSizeLimitExceeded":
        case "com.amazonaws.cloudfront#FunctionSizeLimitExceeded":
            throw await de_FunctionSizeLimitExceededRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchFunctionExists":
        case "com.amazonaws.cloudfront#NoSuchFunctionExists":
            throw await de_NoSuchFunctionExistsRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.cloudfront#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateKeyGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateKeyGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyGroup = de_KeyGroup(data, context);
    return contents;
};
exports.de_UpdateKeyGroupCommand = de_UpdateKeyGroupCommand;
const de_UpdateKeyGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "KeyGroupAlreadyExists":
        case "com.amazonaws.cloudfront#KeyGroupAlreadyExists":
            throw await de_KeyGroupAlreadyExistsRes(parsedOutput, context);
        case "NoSuchResource":
        case "com.amazonaws.cloudfront#NoSuchResource":
            throw await de_NoSuchResourceRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "TooManyPublicKeysInKeyGroup":
        case "com.amazonaws.cloudfront#TooManyPublicKeysInKeyGroup":
            throw await de_TooManyPublicKeysInKeyGroupRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateKeyValueStoreCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateKeyValueStoreCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.KeyValueStore = de_KeyValueStore(data, context);
    return contents;
};
exports.de_UpdateKeyValueStoreCommand = de_UpdateKeyValueStoreCommand;
const de_UpdateKeyValueStoreCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "EntityNotFound":
        case "com.amazonaws.cloudfront#EntityNotFound":
            throw await de_EntityNotFoundRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateOriginAccessControlCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateOriginAccessControlCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginAccessControl = de_OriginAccessControl(data, context);
    return contents;
};
exports.de_UpdateOriginAccessControlCommand = de_UpdateOriginAccessControlCommand;
const de_UpdateOriginAccessControlCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchOriginAccessControl":
        case "com.amazonaws.cloudfront#NoSuchOriginAccessControl":
            throw await de_NoSuchOriginAccessControlRes(parsedOutput, context);
        case "OriginAccessControlAlreadyExists":
        case "com.amazonaws.cloudfront#OriginAccessControlAlreadyExists":
            throw await de_OriginAccessControlAlreadyExistsRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateOriginRequestPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateOriginRequestPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OriginRequestPolicy = de_OriginRequestPolicy(data, context);
    return contents;
};
exports.de_UpdateOriginRequestPolicyCommand = de_UpdateOriginRequestPolicyCommand;
const de_UpdateOriginRequestPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchOriginRequestPolicy":
        case "com.amazonaws.cloudfront#NoSuchOriginRequestPolicy":
            throw await de_NoSuchOriginRequestPolicyRes(parsedOutput, context);
        case "OriginRequestPolicyAlreadyExists":
        case "com.amazonaws.cloudfront#OriginRequestPolicyAlreadyExists":
            throw await de_OriginRequestPolicyAlreadyExistsRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "TooManyCookiesInOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyCookiesInOriginRequestPolicy":
            throw await de_TooManyCookiesInOriginRequestPolicyRes(parsedOutput, context);
        case "TooManyHeadersInOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyHeadersInOriginRequestPolicy":
            throw await de_TooManyHeadersInOriginRequestPolicyRes(parsedOutput, context);
        case "TooManyQueryStringsInOriginRequestPolicy":
        case "com.amazonaws.cloudfront#TooManyQueryStringsInOriginRequestPolicy":
            throw await de_TooManyQueryStringsInOriginRequestPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdatePublicKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdatePublicKeyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.PublicKey = de_PublicKey(data, context);
    return contents;
};
exports.de_UpdatePublicKeyCommand = de_UpdatePublicKeyCommand;
const de_UpdatePublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CannotChangeImmutablePublicKeyFields":
        case "com.amazonaws.cloudfront#CannotChangeImmutablePublicKeyFields":
            throw await de_CannotChangeImmutablePublicKeyFieldsRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchPublicKey":
        case "com.amazonaws.cloudfront#NoSuchPublicKey":
            throw await de_NoSuchPublicKeyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateRealtimeLogConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateRealtimeLogConfigCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_RLC] != null) {
        contents[_RLC] = de_RealtimeLogConfig(data[_RLC], context);
    }
    return contents;
};
exports.de_UpdateRealtimeLogConfigCommand = de_UpdateRealtimeLogConfigCommand;
const de_UpdateRealtimeLogConfigCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "NoSuchRealtimeLogConfig":
        case "com.amazonaws.cloudfront#NoSuchRealtimeLogConfig":
            throw await de_NoSuchRealtimeLogConfigRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateResponseHeadersPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateResponseHeadersPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ResponseHeadersPolicy = de_ResponseHeadersPolicy(data, context);
    return contents;
};
exports.de_UpdateResponseHeadersPolicyCommand = de_UpdateResponseHeadersPolicyCommand;
const de_UpdateResponseHeadersPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "NoSuchResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#NoSuchResponseHeadersPolicy":
            throw await de_NoSuchResponseHeadersPolicyRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "ResponseHeadersPolicyAlreadyExists":
        case "com.amazonaws.cloudfront#ResponseHeadersPolicyAlreadyExists":
            throw await de_ResponseHeadersPolicyAlreadyExistsRes(parsedOutput, context);
        case "TooLongCSPInResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooLongCSPInResponseHeadersPolicy":
            throw await de_TooLongCSPInResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyCustomHeadersInResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyCustomHeadersInResponseHeadersPolicy":
            throw await de_TooManyCustomHeadersInResponseHeadersPolicyRes(parsedOutput, context);
        case "TooManyRemoveHeadersInResponseHeadersPolicy":
        case "com.amazonaws.cloudfront#TooManyRemoveHeadersInResponseHeadersPolicy":
            throw await de_TooManyRemoveHeadersInResponseHeadersPolicyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UpdateStreamingDistributionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateStreamingDistributionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_ET]: [, output.headers[_e]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.StreamingDistribution = de_StreamingDistribution(data, context);
    return contents;
};
exports.de_UpdateStreamingDistributionCommand = de_UpdateStreamingDistributionCommand;
const de_UpdateStreamingDistributionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDenied":
        case "com.amazonaws.cloudfront#AccessDenied":
            throw await de_AccessDeniedRes(parsedOutput, context);
        case "CNAMEAlreadyExists":
        case "com.amazonaws.cloudfront#CNAMEAlreadyExists":
            throw await de_CNAMEAlreadyExistsRes(parsedOutput, context);
        case "IllegalUpdate":
        case "com.amazonaws.cloudfront#IllegalUpdate":
            throw await de_IllegalUpdateRes(parsedOutput, context);
        case "InconsistentQuantities":
        case "com.amazonaws.cloudfront#InconsistentQuantities":
            throw await de_InconsistentQuantitiesRes(parsedOutput, context);
        case "InvalidArgument":
        case "com.amazonaws.cloudfront#InvalidArgument":
            throw await de_InvalidArgumentRes(parsedOutput, context);
        case "InvalidIfMatchVersion":
        case "com.amazonaws.cloudfront#InvalidIfMatchVersion":
            throw await de_InvalidIfMatchVersionRes(parsedOutput, context);
        case "InvalidOriginAccessControl":
        case "com.amazonaws.cloudfront#InvalidOriginAccessControl":
            throw await de_InvalidOriginAccessControlRes(parsedOutput, context);
        case "InvalidOriginAccessIdentity":
        case "com.amazonaws.cloudfront#InvalidOriginAccessIdentity":
            throw await de_InvalidOriginAccessIdentityRes(parsedOutput, context);
        case "MissingBody":
        case "com.amazonaws.cloudfront#MissingBody":
            throw await de_MissingBodyRes(parsedOutput, context);
        case "NoSuchStreamingDistribution":
        case "com.amazonaws.cloudfront#NoSuchStreamingDistribution":
            throw await de_NoSuchStreamingDistributionRes(parsedOutput, context);
        case "PreconditionFailed":
        case "com.amazonaws.cloudfront#PreconditionFailed":
            throw await de_PreconditionFailedRes(parsedOutput, context);
        case "TooManyStreamingDistributionCNAMEs":
        case "com.amazonaws.cloudfront#TooManyStreamingDistributionCNAMEs":
            throw await de_TooManyStreamingDistributionCNAMEsRes(parsedOutput, context);
        case "TooManyTrustedSigners":
        case "com.amazonaws.cloudfront#TooManyTrustedSigners":
            throw await de_TooManyTrustedSignersRes(parsedOutput, context);
        case "TrustedSignerDoesNotExist":
        case "com.amazonaws.cloudfront#TrustedSignerDoesNotExist":
            throw await de_TrustedSignerDoesNotExistRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const throwDefaultError = (0, smithy_client_1.withBaseException)(CloudFrontServiceException_1.CloudFrontServiceException);
const de_AccessDeniedRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.AccessDenied({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_BatchTooLargeRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.BatchTooLarge({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_CachePolicyAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.CachePolicyAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_CachePolicyInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.CachePolicyInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_CannotChangeImmutablePublicKeyFieldsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.CannotChangeImmutablePublicKeyFields({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_CannotDeleteEntityWhileInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.CannotDeleteEntityWhileInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_CloudFrontOriginAccessIdentityAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.CloudFrontOriginAccessIdentityAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_CloudFrontOriginAccessIdentityInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.CloudFrontOriginAccessIdentityInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_CNAMEAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.CNAMEAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_ContinuousDeploymentPolicyAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.ContinuousDeploymentPolicyAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_ContinuousDeploymentPolicyInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.ContinuousDeploymentPolicyInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_DistributionAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.DistributionAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_DistributionNotDisabledRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.DistributionNotDisabled({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_EntityAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.EntityAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_EntityLimitExceededRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.EntityLimitExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_EntityNotFoundRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.EntityNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_EntitySizeLimitExceededRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.EntitySizeLimitExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_FieldLevelEncryptionConfigAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.FieldLevelEncryptionConfigAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_FieldLevelEncryptionConfigInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.FieldLevelEncryptionConfigInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_FieldLevelEncryptionProfileAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.FieldLevelEncryptionProfileAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_FieldLevelEncryptionProfileInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.FieldLevelEncryptionProfileInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_FieldLevelEncryptionProfileSizeExceededRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.FieldLevelEncryptionProfileSizeExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_FunctionAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.FunctionAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_FunctionInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.FunctionInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_FunctionSizeLimitExceededRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.FunctionSizeLimitExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_IllegalDeleteRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.IllegalDelete({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_IllegalOriginAccessConfigurationRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.IllegalOriginAccessConfiguration({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_IllegalUpdateRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.IllegalUpdate({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InconsistentQuantitiesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InconsistentQuantities({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidArgumentRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidArgument({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidDefaultRootObjectRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidDefaultRootObject({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidDomainNameForOriginAccessControlRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidDomainNameForOriginAccessControl({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidErrorCodeRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidErrorCode({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidForwardCookiesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidForwardCookies({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidFunctionAssociationRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidFunctionAssociation({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidGeoRestrictionParameterRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidGeoRestrictionParameter({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidHeadersForS3OriginRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidHeadersForS3Origin({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidIfMatchVersionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidIfMatchVersion({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidLambdaFunctionAssociationRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidLambdaFunctionAssociation({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidLocationCodeRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidLocationCode({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidMinimumProtocolVersionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidMinimumProtocolVersion({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidOriginRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidOrigin({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidOriginAccessControlRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidOriginAccessControl({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidOriginAccessIdentityRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidOriginAccessIdentity({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidOriginKeepaliveTimeoutRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidOriginKeepaliveTimeout({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidOriginReadTimeoutRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidOriginReadTimeout({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidProtocolSettingsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidProtocolSettings({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidQueryStringParametersRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidQueryStringParameters({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidRelativePathRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidRelativePath({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidRequiredProtocolRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidRequiredProtocol({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidResponseCodeRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidResponseCode({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidTaggingRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidTagging({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidTTLOrderRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidTTLOrder({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidViewerCertificateRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidViewerCertificate({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_InvalidWebACLIdRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.InvalidWebACLId({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_KeyGroupAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.KeyGroupAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_MissingBodyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.MissingBody({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_MonitoringSubscriptionAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.MonitoringSubscriptionAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchCachePolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchCachePolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchCloudFrontOriginAccessIdentityRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.NoSuchCloudFrontOriginAccessIdentity({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchContinuousDeploymentPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchContinuousDeploymentPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchDistributionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchDistribution({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchFieldLevelEncryptionConfigRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchFieldLevelEncryptionConfig({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchFieldLevelEncryptionProfileRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchFieldLevelEncryptionProfile({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchFunctionExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.NoSuchFunctionExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchInvalidationRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.NoSuchInvalidation({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchMonitoringSubscriptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.NoSuchMonitoringSubscription({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchOriginRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchOrigin({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchOriginAccessControlRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.NoSuchOriginAccessControl({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchOriginRequestPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchOriginRequestPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchPublicKeyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchPublicKey({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchRealtimeLogConfigRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchRealtimeLogConfig({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchResourceRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.NoSuchResource({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchResponseHeadersPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.NoSuchResponseHeadersPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_NoSuchStreamingDistributionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.NoSuchStreamingDistribution({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_OriginAccessControlAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.OriginAccessControlAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_OriginAccessControlInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.OriginAccessControlInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_OriginRequestPolicyAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.OriginRequestPolicyAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_OriginRequestPolicyInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.OriginRequestPolicyInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_PreconditionFailedRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.PreconditionFailed({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_PublicKeyAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.PublicKeyAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_PublicKeyInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.PublicKeyInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_QueryArgProfileEmptyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.QueryArgProfileEmpty({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_RealtimeLogConfigAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.RealtimeLogConfigAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_RealtimeLogConfigInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.RealtimeLogConfigInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_RealtimeLogConfigOwnerMismatchRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.RealtimeLogConfigOwnerMismatch({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_ResourceInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.ResourceInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_ResponseHeadersPolicyAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.ResponseHeadersPolicyAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_ResponseHeadersPolicyInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.ResponseHeadersPolicyInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_StagingDistributionInUseRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.StagingDistributionInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_StreamingDistributionAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.StreamingDistributionAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_StreamingDistributionNotDisabledRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.StreamingDistributionNotDisabled({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TestFunctionFailedRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.TestFunctionFailed({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooLongCSPInResponseHeadersPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.TooLongCSPInResponseHeadersPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyCacheBehaviorsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyCacheBehaviors({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyCachePoliciesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyCachePolicies({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyCertificatesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyCertificates({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyCloudFrontOriginAccessIdentitiesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyCloudFrontOriginAccessIdentities({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyContinuousDeploymentPoliciesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyContinuousDeploymentPolicies({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyCookieNamesInWhiteListRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyCookieNamesInWhiteList({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyCookiesInCachePolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyCookiesInCachePolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyCookiesInOriginRequestPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyCookiesInOriginRequestPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyCustomHeadersInResponseHeadersPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.TooManyCustomHeadersInResponseHeadersPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionCNAMEsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionCNAMEs({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributions({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsAssociatedToCachePolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionsAssociatedToCachePolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsAssociatedToFieldLevelEncryptionConfigRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionsAssociatedToFieldLevelEncryptionConfig({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsAssociatedToKeyGroupRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionsAssociatedToKeyGroup({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsAssociatedToOriginAccessControlRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionsAssociatedToOriginAccessControl({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsAssociatedToOriginRequestPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionsAssociatedToOriginRequestPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsAssociatedToResponseHeadersPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionsAssociatedToResponseHeadersPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsWithFunctionAssociationsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionsWithFunctionAssociations({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsWithLambdaAssociationsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionsWithLambdaAssociations({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyDistributionsWithSingleFunctionARNRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyDistributionsWithSingleFunctionARN({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyFieldLevelEncryptionConfigsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyFieldLevelEncryptionConfigs({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyFieldLevelEncryptionContentTypeProfilesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyFieldLevelEncryptionContentTypeProfiles({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyFieldLevelEncryptionEncryptionEntitiesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyFieldLevelEncryptionEncryptionEntities({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyFieldLevelEncryptionFieldPatternsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyFieldLevelEncryptionFieldPatterns({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyFieldLevelEncryptionProfilesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyFieldLevelEncryptionProfiles({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyFieldLevelEncryptionQueryArgProfilesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyFieldLevelEncryptionQueryArgProfiles({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyFunctionAssociationsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyFunctionAssociations({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyFunctionsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyFunctions({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyHeadersInCachePolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyHeadersInCachePolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyHeadersInForwardedValuesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyHeadersInForwardedValues({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyHeadersInOriginRequestPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyHeadersInOriginRequestPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyInvalidationsInProgressRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyInvalidationsInProgress({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyKeyGroupsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyKeyGroups({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyKeyGroupsAssociatedToDistributionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyKeyGroupsAssociatedToDistribution({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyLambdaFunctionAssociationsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyLambdaFunctionAssociations({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyOriginAccessControlsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyOriginAccessControls({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyOriginCustomHeadersRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyOriginCustomHeaders({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyOriginGroupsPerDistributionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyOriginGroupsPerDistribution({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyOriginRequestPoliciesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyOriginRequestPolicies({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyOriginsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyOrigins({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyPublicKeysRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyPublicKeys({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyPublicKeysInKeyGroupRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyPublicKeysInKeyGroup({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyQueryStringParametersRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyQueryStringParameters({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyQueryStringsInCachePolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyQueryStringsInCachePolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyQueryStringsInOriginRequestPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyQueryStringsInOriginRequestPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyRealtimeLogConfigsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyRealtimeLogConfigs({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyRemoveHeadersInResponseHeadersPolicyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.TooManyRemoveHeadersInResponseHeadersPolicy({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyResponseHeadersPoliciesRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.TooManyResponseHeadersPolicies({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyStreamingDistributionCNAMEsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.TooManyStreamingDistributionCNAMEs({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyStreamingDistributionsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_1_1.TooManyStreamingDistributions({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TooManyTrustedSignersRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TooManyTrustedSigners({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TrustedKeyGroupDoesNotExistRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TrustedKeyGroupDoesNotExist({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_TrustedSignerDoesNotExistRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.TrustedSignerDoesNotExist({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const de_UnsupportedOperationRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body.Error;
    if (data[_Me] != null) {
        contents[_Me] = (0, smithy_client_1.expectString)(data[_Me]);
    }
    const exception = new models_0_1.UnsupportedOperation({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body.Error);
};
const se_AccessControlAllowHeadersList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_H);
    });
};
const se_AccessControlAllowMethodsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_RHPACAMV, entry);
        return n.n(_Met);
    });
};
const se_AccessControlAllowOriginsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_Or);
    });
};
const se_AccessControlExposeHeadersList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_H);
    });
};
const se_Aliases = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Al);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_AliasList(input[_It], context));
    return bn;
};
const se_AliasList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_CNAME);
    });
};
const se_AllowedMethods = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_AM);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_MethodsList(input[_It], context));
    if (input[_CM] != null) {
        bn.c(se_CachedMethods(input[_CM], context).n(_CM));
    }
    return bn;
};
const se_AwsAccountNumberList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_AAN);
    });
};
const se_CacheBehavior = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CB);
    if (input[_PP] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_PP]).n(_PP));
    }
    if (input[_TOI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_TOI]).n(_TOI));
    }
    if (input[_TS] != null) {
        bn.c(se_TrustedSigners(input[_TS], context).n(_TS));
    }
    if (input[_TKG] != null) {
        bn.c(se_TrustedKeyGroups(input[_TKG], context).n(_TKG));
    }
    bn.cc(input, _VPP);
    if (input[_AM] != null) {
        bn.c(se_AllowedMethods(input[_AM], context).n(_AM));
    }
    if (input[_SS] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_SS])).n(_SS));
    }
    if (input[_Co] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Co])).n(_Co));
    }
    if (input[_LFA] != null) {
        bn.c(se_LambdaFunctionAssociations(input[_LFA], context).n(_LFA));
    }
    if (input[_FA] != null) {
        bn.c(se_FunctionAssociations(input[_FA], context).n(_FA));
    }
    if (input[_FLEI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_FLEI]).n(_FLEI));
    }
    if (input[_RLCA] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RLCA]).n(_RLCA));
    }
    if (input[_CPI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CPI]).n(_CPI));
    }
    if (input[_ORPI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_ORPI]).n(_ORPI));
    }
    if (input[_RHPI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RHPI]).n(_RHPI));
    }
    if (input[_FV] != null) {
        bn.c(se_ForwardedValues(input[_FV], context).n(_FV));
    }
    if (input[_MTTL] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_MTTL])).n(_MTTL));
    }
    if (input[_DTTL] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_DTTL])).n(_DTTL));
    }
    if (input[_MTTLa] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_MTTLa])).n(_MTTLa));
    }
    return bn;
};
const se_CacheBehaviorList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_CacheBehavior(entry, context);
        return n.n(_CB);
    });
};
const se_CacheBehaviors = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CBa);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_CacheBehaviorList(input[_It], context));
    return bn;
};
const se_CachedMethods = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CM);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_MethodsList(input[_It], context));
    return bn;
};
const se_CachePolicyConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CPC);
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    if (input[_DTTL] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_DTTL])).n(_DTTL));
    }
    if (input[_MTTLa] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_MTTLa])).n(_MTTLa));
    }
    if (input[_MTTL] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_MTTL])).n(_MTTL));
    }
    if (input[_PICKAFTO] != null) {
        bn.c(se_ParametersInCacheKeyAndForwardedToOrigin(input[_PICKAFTO], context).n(_PICKAFTO));
    }
    return bn;
};
const se_CachePolicyCookiesConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CPCC);
    if (input[_CBo] != null) {
        bn.c(xml_builder_1.XmlNode.of(_CPCB, input[_CBo]).n(_CBo));
    }
    if (input[_Coo] != null) {
        bn.c(se_CookieNames(input[_Coo], context).n(_Coo));
    }
    return bn;
};
const se_CachePolicyHeadersConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CPHC);
    if (input[_HB] != null) {
        bn.c(xml_builder_1.XmlNode.of(_CPHB, input[_HB]).n(_HB));
    }
    if (input[_He] != null) {
        bn.c(se_Headers(input[_He], context).n(_He));
    }
    return bn;
};
const se_CachePolicyQueryStringsConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CPQSC);
    if (input[_QSB] != null) {
        bn.c(xml_builder_1.XmlNode.of(_CPQSB, input[_QSB]).n(_QSB));
    }
    if (input[_QS] != null) {
        bn.c(se_QueryStringNames(input[_QS], context).n(_QS));
    }
    return bn;
};
const se_CloudFrontOriginAccessIdentityConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CFOAIC);
    if (input[_CR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CR]).n(_CR));
    }
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    return bn;
};
const se_ContentTypeProfile = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CTP);
    bn.cc(input, _Fo);
    if (input[_PI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_PI]).n(_PI));
    }
    if (input[_CT] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CT]).n(_CT));
    }
    return bn;
};
const se_ContentTypeProfileConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CTPC);
    if (input[_FWCTIU] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_FWCTIU])).n(_FWCTIU));
    }
    if (input[_CTPo] != null) {
        bn.c(se_ContentTypeProfiles(input[_CTPo], context).n(_CTPo));
    }
    return bn;
};
const se_ContentTypeProfileList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_ContentTypeProfile(entry, context);
        return n.n(_CTP);
    });
};
const se_ContentTypeProfiles = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CTPo);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_ContentTypeProfileList(input[_It], context));
    return bn;
};
const se_ContinuousDeploymentPolicyConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CDPC);
    if (input[_SDDN] != null) {
        bn.c(se_StagingDistributionDnsNames(input[_SDDN], context).n(_SDDN));
    }
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    if (input[_TC] != null) {
        bn.c(se_TrafficConfig(input[_TC], context).n(_TC));
    }
    return bn;
};
const se_ContinuousDeploymentSingleHeaderConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CDSHC);
    if (input[_H] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_H]).n(_H));
    }
    if (input[_V] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_V]).n(_V));
    }
    return bn;
};
const se_ContinuousDeploymentSingleWeightConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CDSWC);
    if (input[_W] != null) {
        bn.c(xml_builder_1.XmlNode.of(_f, String(input[_W])).n(_W));
    }
    if (input[_SSC] != null) {
        bn.c(se_SessionStickinessConfig(input[_SSC], context).n(_SSC));
    }
    return bn;
};
const se_CookieNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_N);
    });
};
const se_CookieNames = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CN);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_CookieNameList(input[_It], context));
    return bn;
};
const se_CookiePreference = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CP);
    if (input[_For] != null) {
        bn.c(xml_builder_1.XmlNode.of(_ISt, input[_For]).n(_For));
    }
    if (input[_WN] != null) {
        bn.c(se_CookieNames(input[_WN], context).n(_WN));
    }
    return bn;
};
const se_CustomErrorResponse = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CER);
    if (input[_EC] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_EC])).n(_EC));
    }
    if (input[_RPP] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RPP]).n(_RPP));
    }
    if (input[_RC] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RC]).n(_RC));
    }
    if (input[_ECMTTL] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_ECMTTL])).n(_ECMTTL));
    }
    return bn;
};
const se_CustomErrorResponseList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_CustomErrorResponse(entry, context);
        return n.n(_CER);
    });
};
const se_CustomErrorResponses = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CERu);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_CustomErrorResponseList(input[_It], context));
    return bn;
};
const se_CustomHeaders = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CH);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_OriginCustomHeadersList(input[_It], context));
    return bn;
};
const se_CustomOriginConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_COC);
    if (input[_HTTPP] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_HTTPP])).n(_HTTPP));
    }
    if (input[_HTTPSP] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_HTTPSP])).n(_HTTPSP));
    }
    bn.cc(input, _OPP);
    if (input[_OSP] != null) {
        bn.c(se_OriginSslProtocols(input[_OSP], context).n(_OSP));
    }
    if (input[_ORT] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_ORT])).n(_ORT));
    }
    if (input[_OKT] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_OKT])).n(_OKT));
    }
    return bn;
};
const se_DefaultCacheBehavior = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_DCB);
    if (input[_TOI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_TOI]).n(_TOI));
    }
    if (input[_TS] != null) {
        bn.c(se_TrustedSigners(input[_TS], context).n(_TS));
    }
    if (input[_TKG] != null) {
        bn.c(se_TrustedKeyGroups(input[_TKG], context).n(_TKG));
    }
    bn.cc(input, _VPP);
    if (input[_AM] != null) {
        bn.c(se_AllowedMethods(input[_AM], context).n(_AM));
    }
    if (input[_SS] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_SS])).n(_SS));
    }
    if (input[_Co] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Co])).n(_Co));
    }
    if (input[_LFA] != null) {
        bn.c(se_LambdaFunctionAssociations(input[_LFA], context).n(_LFA));
    }
    if (input[_FA] != null) {
        bn.c(se_FunctionAssociations(input[_FA], context).n(_FA));
    }
    if (input[_FLEI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_FLEI]).n(_FLEI));
    }
    if (input[_RLCA] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RLCA]).n(_RLCA));
    }
    if (input[_CPI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CPI]).n(_CPI));
    }
    if (input[_ORPI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_ORPI]).n(_ORPI));
    }
    if (input[_RHPI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RHPI]).n(_RHPI));
    }
    if (input[_FV] != null) {
        bn.c(se_ForwardedValues(input[_FV], context).n(_FV));
    }
    if (input[_MTTL] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_MTTL])).n(_MTTL));
    }
    if (input[_DTTL] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_DTTL])).n(_DTTL));
    }
    if (input[_MTTLa] != null) {
        bn.c(xml_builder_1.XmlNode.of(_l, String(input[_MTTLa])).n(_MTTLa));
    }
    return bn;
};
const se_DistributionConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_DC);
    if (input[_CR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CR]).n(_CR));
    }
    if (input[_Al] != null) {
        bn.c(se_Aliases(input[_Al], context).n(_Al));
    }
    if (input[_DRO] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_DRO]).n(_DRO));
    }
    if (input[_Ori] != null) {
        bn.c(se_Origins(input[_Ori], context).n(_Ori));
    }
    if (input[_OG] != null) {
        bn.c(se_OriginGroups(input[_OG], context).n(_OG));
    }
    if (input[_DCB] != null) {
        bn.c(se_DefaultCacheBehavior(input[_DCB], context).n(_DCB));
    }
    if (input[_CBa] != null) {
        bn.c(se_CacheBehaviors(input[_CBa], context).n(_CBa));
    }
    if (input[_CERu] != null) {
        bn.c(se_CustomErrorResponses(input[_CERu], context).n(_CERu));
    }
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_CTo, input[_C]).n(_C));
    }
    if (input[_Lo] != null) {
        bn.c(se_LoggingConfig(input[_Lo], context).n(_Lo));
    }
    bn.cc(input, _PC);
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    if (input[_VC] != null) {
        bn.c(se_ViewerCertificate(input[_VC], context).n(_VC));
    }
    if (input[_Re] != null) {
        bn.c(se_Restrictions(input[_Re], context).n(_Re));
    }
    if (input[_WACLI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_WACLI]).n(_WACLI));
    }
    bn.cc(input, _HV);
    if (input[_IIPVE] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_IIPVE])).n(_IIPVE));
    }
    if (input[_CDPI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CDPI]).n(_CDPI));
    }
    if (input[_S] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_S])).n(_S));
    }
    return bn;
};
const se_DistributionConfigWithTags = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_DCWT);
    if (input[_DC] != null) {
        bn.c(se_DistributionConfig(input[_DC], context).n(_DC));
    }
    if (input[_Ta] != null) {
        bn.c(se_Tags(input[_Ta], context).n(_Ta));
    }
    return bn;
};
const se_EncryptionEntities = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_EE);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_EncryptionEntityList(input[_It], context));
    return bn;
};
const se_EncryptionEntity = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_EEn);
    if (input[_PKI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_PKI]).n(_PKI));
    }
    if (input[_PIr] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_PIr]).n(_PIr));
    }
    if (input[_FP] != null) {
        bn.c(se_FieldPatterns(input[_FP], context).n(_FP));
    }
    return bn;
};
const se_EncryptionEntityList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_EncryptionEntity(entry, context);
        return n.n(_EEn);
    });
};
const se_EndPoint = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_EPn);
    if (input[_ST] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_ST]).n(_ST));
    }
    if (input[_KSC] != null) {
        bn.c(se_KinesisStreamConfig(input[_KSC], context).n(_KSC));
    }
    return bn;
};
const se_EndPointList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_EndPoint(entry, context);
        return n.n(_m);
    });
};
const se_FieldLevelEncryptionConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_FLEC);
    if (input[_CR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CR]).n(_CR));
    }
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    if (input[_QAPC] != null) {
        bn.c(se_QueryArgProfileConfig(input[_QAPC], context).n(_QAPC));
    }
    if (input[_CTPC] != null) {
        bn.c(se_ContentTypeProfileConfig(input[_CTPC], context).n(_CTPC));
    }
    return bn;
};
const se_FieldLevelEncryptionProfileConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_FLEPC);
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    if (input[_CR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CR]).n(_CR));
    }
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    if (input[_EE] != null) {
        bn.c(se_EncryptionEntities(input[_EE], context).n(_EE));
    }
    return bn;
};
const se_FieldList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_Fi);
    });
};
const se_FieldPatternList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_FPi);
    });
};
const se_FieldPatterns = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_FP);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_FieldPatternList(input[_It], context));
    return bn;
};
const se_ForwardedValues = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_FV);
    if (input[_QSu] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_QSu])).n(_QSu));
    }
    if (input[_Coo] != null) {
        bn.c(se_CookiePreference(input[_Coo], context).n(_Coo));
    }
    if (input[_He] != null) {
        bn.c(se_Headers(input[_He], context).n(_He));
    }
    if (input[_QSCK] != null) {
        bn.c(se_QueryStringCacheKeys(input[_QSCK], context).n(_QSCK));
    }
    return bn;
};
const se_FunctionAssociation = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_FAu);
    bn.cc(input, _FARN);
    bn.cc(input, _ETv);
    return bn;
};
const se_FunctionAssociationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_FunctionAssociation(entry, context);
        return n.n(_FAu);
    });
};
const se_FunctionAssociations = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_FA);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_FunctionAssociationList(input[_It], context));
    return bn;
};
const se_FunctionConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_FCu);
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    if (input[_Ru] != null) {
        bn.c(xml_builder_1.XmlNode.of(_FR, input[_Ru]).n(_Ru));
    }
    if (input[_KVSA] != null) {
        bn.c(se_KeyValueStoreAssociations(input[_KVSA], context).n(_KVSA));
    }
    return bn;
};
const se_GeoRestriction = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_GR);
    if (input[_RT] != null) {
        bn.c(xml_builder_1.XmlNode.of(_GRT, input[_RT]).n(_RT));
    }
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_LocationList(input[_It], context));
    return bn;
};
const se_HeaderList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_N);
    });
};
const se_Headers = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_He);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_HeaderList(input[_It], context));
    return bn;
};
const se_ImportSource = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_IS);
    if (input[_STo] != null) {
        bn.c(xml_builder_1.XmlNode.of(_IST, input[_STo]).n(_STo));
    }
    if (input[_SARN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_SARN]).n(_SARN));
    }
    return bn;
};
const se_InvalidationBatch = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_IB);
    if (input[_P] != null) {
        bn.c(se_Paths(input[_P], context).n(_P));
    }
    if (input[_CR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CR]).n(_CR));
    }
    return bn;
};
const se_KeyGroupConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_KGC);
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    bn.lc(input, "Items", "Items", () => se_PublicKeyIdList(input[_It], context));
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    return bn;
};
const se_KeyValueStoreAssociation = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_KVSAe);
    bn.cc(input, _KVSARN);
    return bn;
};
const se_KeyValueStoreAssociationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_KeyValueStoreAssociation(entry, context);
        return n.n(_KVSAe);
    });
};
const se_KeyValueStoreAssociations = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_KVSA);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_KeyValueStoreAssociationList(input[_It], context));
    return bn;
};
const se_KinesisStreamConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_KSC);
    if (input[_RARN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RARN]).n(_RARN));
    }
    if (input[_SARNt] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_SARNt]).n(_SARNt));
    }
    return bn;
};
const se_LambdaFunctionAssociation = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_LFAa);
    bn.cc(input, _LFARN);
    bn.cc(input, _ETv);
    if (input[_IBn] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_IBn])).n(_IBn));
    }
    return bn;
};
const se_LambdaFunctionAssociationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_LambdaFunctionAssociation(entry, context);
        return n.n(_LFAa);
    });
};
const se_LambdaFunctionAssociations = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_LFA);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_LambdaFunctionAssociationList(input[_It], context));
    return bn;
};
const se_LocationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_L);
    });
};
const se_LoggingConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_LC);
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    if (input[_IC] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_IC])).n(_IC));
    }
    if (input[_B] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_B]).n(_B));
    }
    if (input[_Pr] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_Pr]).n(_Pr));
    }
    return bn;
};
const se_MethodsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_Met, entry);
        return n.n(_Met);
    });
};
const se_MonitoringSubscription = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_MS);
    if (input[_RMSC] != null) {
        bn.c(se_RealtimeMetricsSubscriptionConfig(input[_RMSC], context).n(_RMSC));
    }
    return bn;
};
const se_Origin = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Or);
    if (input[_Id] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_Id]).n(_Id));
    }
    if (input[_DN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_DN]).n(_DN));
    }
    if (input[_OP] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_OP]).n(_OP));
    }
    if (input[_CH] != null) {
        bn.c(se_CustomHeaders(input[_CH], context).n(_CH));
    }
    if (input[_SOC] != null) {
        bn.c(se_S3OriginConfig(input[_SOC], context).n(_SOC));
    }
    if (input[_COC] != null) {
        bn.c(se_CustomOriginConfig(input[_COC], context).n(_COC));
    }
    if (input[_CA] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_CA])).n(_CA));
    }
    if (input[_CTon] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_CTon])).n(_CTon));
    }
    if (input[_OS] != null) {
        bn.c(se_OriginShield(input[_OS], context).n(_OS));
    }
    if (input[_OACI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_OACI]).n(_OACI));
    }
    return bn;
};
const se_OriginAccessControlConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OACC);
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    if (input[_D] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_D]).n(_D));
    }
    if (input[_SP] != null) {
        bn.c(xml_builder_1.XmlNode.of(_OACSP, input[_SP]).n(_SP));
    }
    if (input[_SB] != null) {
        bn.c(xml_builder_1.XmlNode.of(_OACSB, input[_SB]).n(_SB));
    }
    if (input[_OACOT] != null) {
        bn.c(xml_builder_1.XmlNode.of(_OACOTr, input[_OACOT]).n(_OACOT));
    }
    return bn;
};
const se_OriginCustomHeader = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OCH);
    if (input[_HN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_HN]).n(_HN));
    }
    if (input[_HVe] != null) {
        bn.c(xml_builder_1.XmlNode.of(_sST, input[_HVe]).n(_HVe));
    }
    return bn;
};
const se_OriginCustomHeadersList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_OriginCustomHeader(entry, context);
        return n.n(_OCH);
    });
};
const se_OriginGroup = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OGr);
    if (input[_Id] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_Id]).n(_Id));
    }
    if (input[_FCa] != null) {
        bn.c(se_OriginGroupFailoverCriteria(input[_FCa], context).n(_FCa));
    }
    if (input[_Mem] != null) {
        bn.c(se_OriginGroupMembers(input[_Mem], context).n(_Mem));
    }
    return bn;
};
const se_OriginGroupFailoverCriteria = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OGFC);
    if (input[_SC] != null) {
        bn.c(se_StatusCodes(input[_SC], context).n(_SC));
    }
    return bn;
};
const se_OriginGroupList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_OriginGroup(entry, context);
        return n.n(_OGr);
    });
};
const se_OriginGroupMember = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OGM);
    if (input[_OI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_OI]).n(_OI));
    }
    return bn;
};
const se_OriginGroupMemberList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_OriginGroupMember(entry, context);
        return n.n(_OGM);
    });
};
const se_OriginGroupMembers = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OGMr);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_OriginGroupMemberList(input[_It], context));
    return bn;
};
const se_OriginGroups = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OG);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_OriginGroupList(input[_It], context));
    return bn;
};
const se_OriginList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_Origin(entry, context);
        return n.n(_Or);
    });
};
const se_OriginRequestPolicyConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ORPC);
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    if (input[_HC] != null) {
        bn.c(se_OriginRequestPolicyHeadersConfig(input[_HC], context).n(_HC));
    }
    if (input[_CC] != null) {
        bn.c(se_OriginRequestPolicyCookiesConfig(input[_CC], context).n(_CC));
    }
    if (input[_QSC] != null) {
        bn.c(se_OriginRequestPolicyQueryStringsConfig(input[_QSC], context).n(_QSC));
    }
    return bn;
};
const se_OriginRequestPolicyCookiesConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ORPCC);
    if (input[_CBo] != null) {
        bn.c(xml_builder_1.XmlNode.of(_ORPCB, input[_CBo]).n(_CBo));
    }
    if (input[_Coo] != null) {
        bn.c(se_CookieNames(input[_Coo], context).n(_Coo));
    }
    return bn;
};
const se_OriginRequestPolicyHeadersConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ORPHC);
    if (input[_HB] != null) {
        bn.c(xml_builder_1.XmlNode.of(_ORPHB, input[_HB]).n(_HB));
    }
    if (input[_He] != null) {
        bn.c(se_Headers(input[_He], context).n(_He));
    }
    return bn;
};
const se_OriginRequestPolicyQueryStringsConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ORPQSC);
    if (input[_QSB] != null) {
        bn.c(xml_builder_1.XmlNode.of(_ORPQSB, input[_QSB]).n(_QSB));
    }
    if (input[_QS] != null) {
        bn.c(se_QueryStringNames(input[_QS], context).n(_QS));
    }
    return bn;
};
const se_Origins = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Ori);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_OriginList(input[_It], context));
    return bn;
};
const se_OriginShield = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OS);
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    bn.cc(input, _OSR);
    return bn;
};
const se_OriginSslProtocols = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OSP);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_SslProtocolsList(input[_It], context));
    return bn;
};
const se_ParametersInCacheKeyAndForwardedToOrigin = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_PICKAFTO);
    if (input[_EAEG] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_EAEG])).n(_EAEG));
    }
    if (input[_EAEB] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_EAEB])).n(_EAEB));
    }
    if (input[_HC] != null) {
        bn.c(se_CachePolicyHeadersConfig(input[_HC], context).n(_HC));
    }
    if (input[_CC] != null) {
        bn.c(se_CachePolicyCookiesConfig(input[_CC], context).n(_CC));
    }
    if (input[_QSC] != null) {
        bn.c(se_CachePolicyQueryStringsConfig(input[_QSC], context).n(_QSC));
    }
    return bn;
};
const se_PathList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_Pa);
    });
};
const se_Paths = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_P);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_PathList(input[_It], context));
    return bn;
};
const se_PublicKeyConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_PKC);
    if (input[_CR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CR]).n(_CR));
    }
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    if (input[_EK] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_EK]).n(_EK));
    }
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    return bn;
};
const se_PublicKeyIdList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_PK);
    });
};
const se_QueryArgProfile = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_QAP);
    if (input[_QA] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_QA]).n(_QA));
    }
    if (input[_PI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_PI]).n(_PI));
    }
    return bn;
};
const se_QueryArgProfileConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_QAPC);
    if (input[_FWQAPIU] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_FWQAPIU])).n(_FWQAPIU));
    }
    if (input[_QAPu] != null) {
        bn.c(se_QueryArgProfiles(input[_QAPu], context).n(_QAPu));
    }
    return bn;
};
const se_QueryArgProfileList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_QueryArgProfile(entry, context);
        return n.n(_QAP);
    });
};
const se_QueryArgProfiles = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_QAPu);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_QueryArgProfileList(input[_It], context));
    return bn;
};
const se_QueryStringCacheKeys = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_QSCK);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_QueryStringCacheKeysList(input[_It], context));
    return bn;
};
const se_QueryStringCacheKeysList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_N);
    });
};
const se_QueryStringNames = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_QSN);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_QueryStringNamesList(input[_It], context));
    return bn;
};
const se_QueryStringNamesList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_N);
    });
};
const se_RealtimeMetricsSubscriptionConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RMSC);
    bn.cc(input, _RMSS);
    return bn;
};
const se_ResponseHeadersPolicyAccessControlAllowHeaders = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPACAH);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_AccessControlAllowHeadersList(input[_It], context));
    return bn;
};
const se_ResponseHeadersPolicyAccessControlAllowMethods = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPACAM);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_AccessControlAllowMethodsList(input[_It], context));
    return bn;
};
const se_ResponseHeadersPolicyAccessControlAllowOrigins = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPACAO);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_AccessControlAllowOriginsList(input[_It], context));
    return bn;
};
const se_ResponseHeadersPolicyAccessControlExposeHeaders = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPACEH);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_AccessControlExposeHeadersList(input[_It], context));
    return bn;
};
const se_ResponseHeadersPolicyConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPC);
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_N]).n(_N));
    }
    if (input[_CCo] != null) {
        bn.c(se_ResponseHeadersPolicyCorsConfig(input[_CCo], context).n(_CCo));
    }
    if (input[_SHC] != null) {
        bn.c(se_ResponseHeadersPolicySecurityHeadersConfig(input[_SHC], context).n(_SHC));
    }
    if (input[_STHC] != null) {
        bn.c(se_ResponseHeadersPolicyServerTimingHeadersConfig(input[_STHC], context).n(_STHC));
    }
    if (input[_CHC] != null) {
        bn.c(se_ResponseHeadersPolicyCustomHeadersConfig(input[_CHC], context).n(_CHC));
    }
    if (input[_RHC] != null) {
        bn.c(se_ResponseHeadersPolicyRemoveHeadersConfig(input[_RHC], context).n(_RHC));
    }
    return bn;
};
const se_ResponseHeadersPolicyContentSecurityPolicy = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPCSP);
    if (input[_Ov] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Ov])).n(_Ov));
    }
    if (input[_CSP] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CSP]).n(_CSP));
    }
    return bn;
};
const se_ResponseHeadersPolicyContentTypeOptions = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPCTO);
    if (input[_Ov] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Ov])).n(_Ov));
    }
    return bn;
};
const se_ResponseHeadersPolicyCorsConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPCC);
    if (input[_ACAO] != null) {
        bn.c(se_ResponseHeadersPolicyAccessControlAllowOrigins(input[_ACAO], context).n(_ACAO));
    }
    if (input[_ACAH] != null) {
        bn.c(se_ResponseHeadersPolicyAccessControlAllowHeaders(input[_ACAH], context).n(_ACAH));
    }
    if (input[_ACAM] != null) {
        bn.c(se_ResponseHeadersPolicyAccessControlAllowMethods(input[_ACAM], context).n(_ACAM));
    }
    if (input[_ACAC] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_ACAC])).n(_ACAC));
    }
    if (input[_ACEH] != null) {
        bn.c(se_ResponseHeadersPolicyAccessControlExposeHeaders(input[_ACEH], context).n(_ACEH));
    }
    if (input[_ACMAS] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_ACMAS])).n(_ACMAS));
    }
    if (input[_OO] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_OO])).n(_OO));
    }
    return bn;
};
const se_ResponseHeadersPolicyCustomHeader = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPCH);
    if (input[_H] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_H]).n(_H));
    }
    if (input[_V] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_V]).n(_V));
    }
    if (input[_Ov] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Ov])).n(_Ov));
    }
    return bn;
};
const se_ResponseHeadersPolicyCustomHeaderList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_ResponseHeadersPolicyCustomHeader(entry, context);
        return n.n(_RHPCH);
    });
};
const se_ResponseHeadersPolicyCustomHeadersConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPCHC);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_ResponseHeadersPolicyCustomHeaderList(input[_It], context));
    return bn;
};
const se_ResponseHeadersPolicyFrameOptions = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPFO);
    if (input[_Ov] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Ov])).n(_Ov));
    }
    if (input[_FO] != null) {
        bn.c(xml_builder_1.XmlNode.of(_FOL, input[_FO]).n(_FO));
    }
    return bn;
};
const se_ResponseHeadersPolicyReferrerPolicy = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPRP);
    if (input[_Ov] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Ov])).n(_Ov));
    }
    if (input[_RP] != null) {
        bn.c(xml_builder_1.XmlNode.of(_RPL, input[_RP]).n(_RP));
    }
    return bn;
};
const se_ResponseHeadersPolicyRemoveHeader = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPRH);
    if (input[_H] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_H]).n(_H));
    }
    return bn;
};
const se_ResponseHeadersPolicyRemoveHeaderList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_ResponseHeadersPolicyRemoveHeader(entry, context);
        return n.n(_RHPRH);
    });
};
const se_ResponseHeadersPolicyRemoveHeadersConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPRHC);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_ResponseHeadersPolicyRemoveHeaderList(input[_It], context));
    return bn;
};
const se_ResponseHeadersPolicySecurityHeadersConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPSHC);
    if (input[_XSSP] != null) {
        bn.c(se_ResponseHeadersPolicyXSSProtection(input[_XSSP], context).n(_XSSP));
    }
    if (input[_FOr] != null) {
        bn.c(se_ResponseHeadersPolicyFrameOptions(input[_FOr], context).n(_FOr));
    }
    if (input[_RP] != null) {
        bn.c(se_ResponseHeadersPolicyReferrerPolicy(input[_RP], context).n(_RP));
    }
    if (input[_CSP] != null) {
        bn.c(se_ResponseHeadersPolicyContentSecurityPolicy(input[_CSP], context).n(_CSP));
    }
    if (input[_CTO] != null) {
        bn.c(se_ResponseHeadersPolicyContentTypeOptions(input[_CTO], context).n(_CTO));
    }
    if (input[_STS] != null) {
        bn.c(se_ResponseHeadersPolicyStrictTransportSecurity(input[_STS], context).n(_STS));
    }
    return bn;
};
const se_ResponseHeadersPolicyServerTimingHeadersConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPSTHC);
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    if (input[_SR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_SR, String(input[_SR])).n(_SR));
    }
    return bn;
};
const se_ResponseHeadersPolicyStrictTransportSecurity = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPSTS);
    if (input[_Ov] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Ov])).n(_Ov));
    }
    if (input[_ISn] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_ISn])).n(_ISn));
    }
    if (input[_Pre] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Pre])).n(_Pre));
    }
    if (input[_ACMAS] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_ACMAS])).n(_ACMAS));
    }
    return bn;
};
const se_ResponseHeadersPolicyXSSProtection = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RHPXSSP);
    if (input[_Ov] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Ov])).n(_Ov));
    }
    if (input[_Pro] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_Pro])).n(_Pro));
    }
    if (input[_MB] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_MB])).n(_MB));
    }
    if (input[_RU] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_RU]).n(_RU));
    }
    return bn;
};
const se_Restrictions = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Re);
    if (input[_GR] != null) {
        bn.c(se_GeoRestriction(input[_GR], context).n(_GR));
    }
    return bn;
};
const se_S3Origin = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SO);
    if (input[_DN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_DN]).n(_DN));
    }
    if (input[_OAI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_OAI]).n(_OAI));
    }
    return bn;
};
const se_S3OriginConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SOC);
    if (input[_OAI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_OAI]).n(_OAI));
    }
    return bn;
};
const se_SessionStickinessConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SSC);
    if (input[_ITTL] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_ITTL])).n(_ITTL));
    }
    if (input[_MTTLax] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_MTTLax])).n(_MTTLax));
    }
    return bn;
};
const se_SslProtocolsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_SPs, entry);
        return n.n(_SPs);
    });
};
const se_StagingDistributionDnsNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_DNn);
    });
};
const se_StagingDistributionDnsNames = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SDDN);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_StagingDistributionDnsNameList(input[_It], context));
    return bn;
};
const se_StatusCodeList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_i, String(entry));
        return n.n(_SCt);
    });
};
const se_StatusCodes = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SC);
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_StatusCodeList(input[_It], context));
    return bn;
};
const se_StreamingDistributionConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SDC);
    if (input[_CR] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_CR]).n(_CR));
    }
    if (input[_SO] != null) {
        bn.c(se_S3Origin(input[_SO], context).n(_SO));
    }
    if (input[_Al] != null) {
        bn.c(se_Aliases(input[_Al], context).n(_Al));
    }
    if (input[_C] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_C]).n(_C));
    }
    if (input[_Lo] != null) {
        bn.c(se_StreamingLoggingConfig(input[_Lo], context).n(_Lo));
    }
    if (input[_TS] != null) {
        bn.c(se_TrustedSigners(input[_TS], context).n(_TS));
    }
    bn.cc(input, _PC);
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    return bn;
};
const se_StreamingDistributionConfigWithTags = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SDCWT);
    if (input[_SDC] != null) {
        bn.c(se_StreamingDistributionConfig(input[_SDC], context).n(_SDC));
    }
    if (input[_Ta] != null) {
        bn.c(se_Tags(input[_Ta], context).n(_Ta));
    }
    return bn;
};
const se_StreamingLoggingConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SLC);
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    if (input[_B] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_B]).n(_B));
    }
    if (input[_Pr] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_Pr]).n(_Pr));
    }
    return bn;
};
const se_Tag = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Tag);
    if (input[_K] != null) {
        bn.c(xml_builder_1.XmlNode.of(_TK, input[_K]).n(_K));
    }
    if (input[_V] != null) {
        bn.c(xml_builder_1.XmlNode.of(_TV, input[_V]).n(_V));
    }
    return bn;
};
const se_TagKeyList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_TK, entry);
        return n.n(_K);
    });
};
const se_TagKeys = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_TKa);
    bn.lc(input, "Items", "Items", () => se_TagKeyList(input[_It], context));
    return bn;
};
const se_TagList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_Tag(entry, context);
        return n.n(_Tag);
    });
};
const se_Tags = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Ta);
    bn.lc(input, "Items", "Items", () => se_TagList(input[_It], context));
    return bn;
};
const se_TrafficConfig = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_TC);
    if (input[_SWC] != null) {
        bn.c(se_ContinuousDeploymentSingleWeightConfig(input[_SWC], context).n(_SWC));
    }
    if (input[_SHCi] != null) {
        bn.c(se_ContinuousDeploymentSingleHeaderConfig(input[_SHCi], context).n(_SHCi));
    }
    if (input[_T] != null) {
        bn.c(xml_builder_1.XmlNode.of(_CDPT, input[_T]).n(_T));
    }
    return bn;
};
const se_TrustedKeyGroupIdList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_st, entry);
        return n.n(_KG);
    });
};
const se_TrustedKeyGroups = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_TKG);
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_TrustedKeyGroupIdList(input[_It], context));
    return bn;
};
const se_TrustedSigners = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_TS);
    if (input[_E] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_E])).n(_E));
    }
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_i, String(input[_Q])).n(_Q));
    }
    bn.lc(input, "Items", "Items", () => se_AwsAccountNumberList(input[_It], context));
    return bn;
};
const se_ViewerCertificate = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_VC);
    if (input[_CFDC] != null) {
        bn.c(xml_builder_1.XmlNode.of(_b, String(input[_CFDC])).n(_CFDC));
    }
    if (input[_IAMCI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_IAMCI]).n(_IAMCI));
    }
    if (input[_ACMCA] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_ACMCA]).n(_ACMCA));
    }
    bn.cc(input, _SSLSM);
    bn.cc(input, _MPV);
    if (input[_Ce] != null) {
        bn.c(xml_builder_1.XmlNode.of(_st, input[_Ce]).n(_Ce));
    }
    bn.cc(input, _CS);
    return bn;
};
const de_AccessControlAllowHeadersList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_AccessControlAllowMethodsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_AccessControlAllowOriginsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_AccessControlExposeHeadersList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_ActiveTrustedKeyGroups = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_KG] != null) {
        contents[_It] = de_KGKeyPairIdsList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_KG]), context);
    }
    return contents;
};
const de_ActiveTrustedSigners = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_Si] != null) {
        contents[_It] = de_SignerList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_Si]), context);
    }
    return contents;
};
const de_Aliases = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_CNAME] != null) {
        contents[_It] = de_AliasList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_CNAME]), context);
    }
    return contents;
};
const de_AliasICPRecordal = (output, context) => {
    const contents = {};
    if (output[_CNAME] != null) {
        contents[_CNAME] = (0, smithy_client_1.expectString)(output[_CNAME]);
    }
    if (output[_ICPRS] != null) {
        contents[_ICPRS] = (0, smithy_client_1.expectString)(output[_ICPRS]);
    }
    return contents;
};
const de_AliasICPRecordals = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AliasICPRecordal(entry, context);
    });
};
const de_AliasList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_AllowedMethods = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_Met] != null) {
        contents[_It] = de_MethodsList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_Met]), context);
    }
    if (output[_CM] != null) {
        contents[_CM] = de_CachedMethods(output[_CM], context);
    }
    return contents;
};
const de_AwsAccountNumberList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_CacheBehavior = (output, context) => {
    const contents = {};
    if (output[_PP] != null) {
        contents[_PP] = (0, smithy_client_1.expectString)(output[_PP]);
    }
    if (output[_TOI] != null) {
        contents[_TOI] = (0, smithy_client_1.expectString)(output[_TOI]);
    }
    if (output[_TS] != null) {
        contents[_TS] = de_TrustedSigners(output[_TS], context);
    }
    if (output[_TKG] != null) {
        contents[_TKG] = de_TrustedKeyGroups(output[_TKG], context);
    }
    if (output[_VPP] != null) {
        contents[_VPP] = (0, smithy_client_1.expectString)(output[_VPP]);
    }
    if (output[_AM] != null) {
        contents[_AM] = de_AllowedMethods(output[_AM], context);
    }
    if (output[_SS] != null) {
        contents[_SS] = (0, smithy_client_1.parseBoolean)(output[_SS]);
    }
    if (output[_Co] != null) {
        contents[_Co] = (0, smithy_client_1.parseBoolean)(output[_Co]);
    }
    if (output[_LFA] != null) {
        contents[_LFA] = de_LambdaFunctionAssociations(output[_LFA], context);
    }
    if (output[_FA] != null) {
        contents[_FA] = de_FunctionAssociations(output[_FA], context);
    }
    if (output[_FLEI] != null) {
        contents[_FLEI] = (0, smithy_client_1.expectString)(output[_FLEI]);
    }
    if (output[_RLCA] != null) {
        contents[_RLCA] = (0, smithy_client_1.expectString)(output[_RLCA]);
    }
    if (output[_CPI] != null) {
        contents[_CPI] = (0, smithy_client_1.expectString)(output[_CPI]);
    }
    if (output[_ORPI] != null) {
        contents[_ORPI] = (0, smithy_client_1.expectString)(output[_ORPI]);
    }
    if (output[_RHPI] != null) {
        contents[_RHPI] = (0, smithy_client_1.expectString)(output[_RHPI]);
    }
    if (output[_FV] != null) {
        contents[_FV] = de_ForwardedValues(output[_FV], context);
    }
    if (output[_MTTL] != null) {
        contents[_MTTL] = (0, smithy_client_1.strictParseLong)(output[_MTTL]);
    }
    if (output[_DTTL] != null) {
        contents[_DTTL] = (0, smithy_client_1.strictParseLong)(output[_DTTL]);
    }
    if (output[_MTTLa] != null) {
        contents[_MTTLa] = (0, smithy_client_1.strictParseLong)(output[_MTTLa]);
    }
    return contents;
};
const de_CacheBehaviorList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CacheBehavior(entry, context);
    });
};
const de_CacheBehaviors = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_CB] != null) {
        contents[_It] = de_CacheBehaviorList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_CB]), context);
    }
    return contents;
};
const de_CachedMethods = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_Met] != null) {
        contents[_It] = de_MethodsList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_Met]), context);
    }
    return contents;
};
const de_CachePolicy = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_CPC] != null) {
        contents[_CPC] = de_CachePolicyConfig(output[_CPC], context);
    }
    return contents;
};
const de_CachePolicyConfig = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_DTTL] != null) {
        contents[_DTTL] = (0, smithy_client_1.strictParseLong)(output[_DTTL]);
    }
    if (output[_MTTLa] != null) {
        contents[_MTTLa] = (0, smithy_client_1.strictParseLong)(output[_MTTLa]);
    }
    if (output[_MTTL] != null) {
        contents[_MTTL] = (0, smithy_client_1.strictParseLong)(output[_MTTL]);
    }
    if (output[_PICKAFTO] != null) {
        contents[_PICKAFTO] = de_ParametersInCacheKeyAndForwardedToOrigin(output[_PICKAFTO], context);
    }
    return contents;
};
const de_CachePolicyCookiesConfig = (output, context) => {
    const contents = {};
    if (output[_CBo] != null) {
        contents[_CBo] = (0, smithy_client_1.expectString)(output[_CBo]);
    }
    if (output[_Coo] != null) {
        contents[_Coo] = de_CookieNames(output[_Coo], context);
    }
    return contents;
};
const de_CachePolicyHeadersConfig = (output, context) => {
    const contents = {};
    if (output[_HB] != null) {
        contents[_HB] = (0, smithy_client_1.expectString)(output[_HB]);
    }
    if (output[_He] != null) {
        contents[_He] = de_Headers(output[_He], context);
    }
    return contents;
};
const de_CachePolicyList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_CPS] != null) {
        contents[_It] = de_CachePolicySummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_CPS]), context);
    }
    return contents;
};
const de_CachePolicyQueryStringsConfig = (output, context) => {
    const contents = {};
    if (output[_QSB] != null) {
        contents[_QSB] = (0, smithy_client_1.expectString)(output[_QSB]);
    }
    if (output[_QS] != null) {
        contents[_QS] = de_QueryStringNames(output[_QS], context);
    }
    return contents;
};
const de_CachePolicySummary = (output, context) => {
    const contents = {};
    if (output[_T] != null) {
        contents[_T] = (0, smithy_client_1.expectString)(output[_T]);
    }
    if (output[_CPa] != null) {
        contents[_CPa] = de_CachePolicy(output[_CPa], context);
    }
    return contents;
};
const de_CachePolicySummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CachePolicySummary(entry, context);
    });
};
const de_CloudFrontOriginAccessIdentity = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_SCUI] != null) {
        contents[_SCUI] = (0, smithy_client_1.expectString)(output[_SCUI]);
    }
    if (output[_CFOAIC] != null) {
        contents[_CFOAIC] = de_CloudFrontOriginAccessIdentityConfig(output[_CFOAIC], context);
    }
    return contents;
};
const de_CloudFrontOriginAccessIdentityConfig = (output, context) => {
    const contents = {};
    if (output[_CR] != null) {
        contents[_CR] = (0, smithy_client_1.expectString)(output[_CR]);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    return contents;
};
const de_CloudFrontOriginAccessIdentityList = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = (0, smithy_client_1.expectString)(output[_M]);
    }
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(output[_IT]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_CFOAIS] != null) {
        contents[_It] = de_CloudFrontOriginAccessIdentitySummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_CFOAIS]), context);
    }
    return contents;
};
const de_CloudFrontOriginAccessIdentitySummary = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_SCUI] != null) {
        contents[_SCUI] = (0, smithy_client_1.expectString)(output[_SCUI]);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    return contents;
};
const de_CloudFrontOriginAccessIdentitySummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CloudFrontOriginAccessIdentitySummary(entry, context);
    });
};
const de_ConflictingAlias = (output, context) => {
    const contents = {};
    if (output[_A] != null) {
        contents[_A] = (0, smithy_client_1.expectString)(output[_A]);
    }
    if (output[_DI] != null) {
        contents[_DI] = (0, smithy_client_1.expectString)(output[_DI]);
    }
    if (output[_AI] != null) {
        contents[_AI] = (0, smithy_client_1.expectString)(output[_AI]);
    }
    return contents;
};
const de_ConflictingAliases = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ConflictingAlias(entry, context);
    });
};
const de_ConflictingAliasesList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_CAo] != null) {
        contents[_It] = de_ConflictingAliases((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_CAo]), context);
    }
    return contents;
};
const de_ContentTypeProfile = (output, context) => {
    const contents = {};
    if (output[_Fo] != null) {
        contents[_Fo] = (0, smithy_client_1.expectString)(output[_Fo]);
    }
    if (output[_PI] != null) {
        contents[_PI] = (0, smithy_client_1.expectString)(output[_PI]);
    }
    if (output[_CT] != null) {
        contents[_CT] = (0, smithy_client_1.expectString)(output[_CT]);
    }
    return contents;
};
const de_ContentTypeProfileConfig = (output, context) => {
    const contents = {};
    if (output[_FWCTIU] != null) {
        contents[_FWCTIU] = (0, smithy_client_1.parseBoolean)(output[_FWCTIU]);
    }
    if (output[_CTPo] != null) {
        contents[_CTPo] = de_ContentTypeProfiles(output[_CTPo], context);
    }
    return contents;
};
const de_ContentTypeProfileList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ContentTypeProfile(entry, context);
    });
};
const de_ContentTypeProfiles = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_CTP] != null) {
        contents[_It] = de_ContentTypeProfileList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_CTP]), context);
    }
    return contents;
};
const de_ContinuousDeploymentPolicy = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_CDPC] != null) {
        contents[_CDPC] = de_ContinuousDeploymentPolicyConfig(output[_CDPC], context);
    }
    return contents;
};
const de_ContinuousDeploymentPolicyConfig = (output, context) => {
    const contents = {};
    if (output[_SDDN] != null) {
        contents[_SDDN] = de_StagingDistributionDnsNames(output[_SDDN], context);
    }
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_TC] != null) {
        contents[_TC] = de_TrafficConfig(output[_TC], context);
    }
    return contents;
};
const de_ContinuousDeploymentPolicyList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_CDPS] != null) {
        contents[_It] = de_ContinuousDeploymentPolicySummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_CDPS]), context);
    }
    return contents;
};
const de_ContinuousDeploymentPolicySummary = (output, context) => {
    const contents = {};
    if (output[_CDP] != null) {
        contents[_CDP] = de_ContinuousDeploymentPolicy(output[_CDP], context);
    }
    return contents;
};
const de_ContinuousDeploymentPolicySummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ContinuousDeploymentPolicySummary(entry, context);
    });
};
const de_ContinuousDeploymentSingleHeaderConfig = (output, context) => {
    const contents = {};
    if (output[_H] != null) {
        contents[_H] = (0, smithy_client_1.expectString)(output[_H]);
    }
    if (output[_V] != null) {
        contents[_V] = (0, smithy_client_1.expectString)(output[_V]);
    }
    return contents;
};
const de_ContinuousDeploymentSingleWeightConfig = (output, context) => {
    const contents = {};
    if (output[_W] != null) {
        contents[_W] = (0, smithy_client_1.strictParseFloat)(output[_W]);
    }
    if (output[_SSC] != null) {
        contents[_SSC] = de_SessionStickinessConfig(output[_SSC], context);
    }
    return contents;
};
const de_CookieNameList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_CookieNames = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_N] != null) {
        contents[_It] = de_CookieNameList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_N]), context);
    }
    return contents;
};
const de_CookiePreference = (output, context) => {
    const contents = {};
    if (output[_For] != null) {
        contents[_For] = (0, smithy_client_1.expectString)(output[_For]);
    }
    if (output[_WN] != null) {
        contents[_WN] = de_CookieNames(output[_WN], context);
    }
    return contents;
};
const de_CustomErrorResponse = (output, context) => {
    const contents = {};
    if (output[_EC] != null) {
        contents[_EC] = (0, smithy_client_1.strictParseInt32)(output[_EC]);
    }
    if (output[_RPP] != null) {
        contents[_RPP] = (0, smithy_client_1.expectString)(output[_RPP]);
    }
    if (output[_RC] != null) {
        contents[_RC] = (0, smithy_client_1.expectString)(output[_RC]);
    }
    if (output[_ECMTTL] != null) {
        contents[_ECMTTL] = (0, smithy_client_1.strictParseLong)(output[_ECMTTL]);
    }
    return contents;
};
const de_CustomErrorResponseList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CustomErrorResponse(entry, context);
    });
};
const de_CustomErrorResponses = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_CER] != null) {
        contents[_It] = de_CustomErrorResponseList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_CER]), context);
    }
    return contents;
};
const de_CustomHeaders = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_OCH] != null) {
        contents[_It] = de_OriginCustomHeadersList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_OCH]), context);
    }
    return contents;
};
const de_CustomOriginConfig = (output, context) => {
    const contents = {};
    if (output[_HTTPP] != null) {
        contents[_HTTPP] = (0, smithy_client_1.strictParseInt32)(output[_HTTPP]);
    }
    if (output[_HTTPSP] != null) {
        contents[_HTTPSP] = (0, smithy_client_1.strictParseInt32)(output[_HTTPSP]);
    }
    if (output[_OPP] != null) {
        contents[_OPP] = (0, smithy_client_1.expectString)(output[_OPP]);
    }
    if (output[_OSP] != null) {
        contents[_OSP] = de_OriginSslProtocols(output[_OSP], context);
    }
    if (output[_ORT] != null) {
        contents[_ORT] = (0, smithy_client_1.strictParseInt32)(output[_ORT]);
    }
    if (output[_OKT] != null) {
        contents[_OKT] = (0, smithy_client_1.strictParseInt32)(output[_OKT]);
    }
    return contents;
};
const de_DefaultCacheBehavior = (output, context) => {
    const contents = {};
    if (output[_TOI] != null) {
        contents[_TOI] = (0, smithy_client_1.expectString)(output[_TOI]);
    }
    if (output[_TS] != null) {
        contents[_TS] = de_TrustedSigners(output[_TS], context);
    }
    if (output[_TKG] != null) {
        contents[_TKG] = de_TrustedKeyGroups(output[_TKG], context);
    }
    if (output[_VPP] != null) {
        contents[_VPP] = (0, smithy_client_1.expectString)(output[_VPP]);
    }
    if (output[_AM] != null) {
        contents[_AM] = de_AllowedMethods(output[_AM], context);
    }
    if (output[_SS] != null) {
        contents[_SS] = (0, smithy_client_1.parseBoolean)(output[_SS]);
    }
    if (output[_Co] != null) {
        contents[_Co] = (0, smithy_client_1.parseBoolean)(output[_Co]);
    }
    if (output[_LFA] != null) {
        contents[_LFA] = de_LambdaFunctionAssociations(output[_LFA], context);
    }
    if (output[_FA] != null) {
        contents[_FA] = de_FunctionAssociations(output[_FA], context);
    }
    if (output[_FLEI] != null) {
        contents[_FLEI] = (0, smithy_client_1.expectString)(output[_FLEI]);
    }
    if (output[_RLCA] != null) {
        contents[_RLCA] = (0, smithy_client_1.expectString)(output[_RLCA]);
    }
    if (output[_CPI] != null) {
        contents[_CPI] = (0, smithy_client_1.expectString)(output[_CPI]);
    }
    if (output[_ORPI] != null) {
        contents[_ORPI] = (0, smithy_client_1.expectString)(output[_ORPI]);
    }
    if (output[_RHPI] != null) {
        contents[_RHPI] = (0, smithy_client_1.expectString)(output[_RHPI]);
    }
    if (output[_FV] != null) {
        contents[_FV] = de_ForwardedValues(output[_FV], context);
    }
    if (output[_MTTL] != null) {
        contents[_MTTL] = (0, smithy_client_1.strictParseLong)(output[_MTTL]);
    }
    if (output[_DTTL] != null) {
        contents[_DTTL] = (0, smithy_client_1.strictParseLong)(output[_DTTL]);
    }
    if (output[_MTTLa] != null) {
        contents[_MTTLa] = (0, smithy_client_1.strictParseLong)(output[_MTTLa]);
    }
    return contents;
};
const de_Distribution = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = (0, smithy_client_1.expectString)(output[_ARN]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = (0, smithy_client_1.expectString)(output[_Sta]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_IPIB] != null) {
        contents[_IPIB] = (0, smithy_client_1.strictParseInt32)(output[_IPIB]);
    }
    if (output[_DN] != null) {
        contents[_DN] = (0, smithy_client_1.expectString)(output[_DN]);
    }
    if (output[_ATS] != null) {
        contents[_ATS] = de_ActiveTrustedSigners(output[_ATS], context);
    }
    if (output[_ATKG] != null) {
        contents[_ATKG] = de_ActiveTrustedKeyGroups(output[_ATKG], context);
    }
    if (output[_DC] != null) {
        contents[_DC] = de_DistributionConfig(output[_DC], context);
    }
    if (output.AliasICPRecordals === "") {
        contents[_AICPR] = [];
    }
    else if (output[_AICPR] != null && output[_AICPR][_AICPRl] != null) {
        contents[_AICPR] = de_AliasICPRecordals((0, smithy_client_1.getArrayIfSingleItem)(output[_AICPR][_AICPRl]), context);
    }
    return contents;
};
const de_DistributionConfig = (output, context) => {
    const contents = {};
    if (output[_CR] != null) {
        contents[_CR] = (0, smithy_client_1.expectString)(output[_CR]);
    }
    if (output[_Al] != null) {
        contents[_Al] = de_Aliases(output[_Al], context);
    }
    if (output[_DRO] != null) {
        contents[_DRO] = (0, smithy_client_1.expectString)(output[_DRO]);
    }
    if (output[_Ori] != null) {
        contents[_Ori] = de_Origins(output[_Ori], context);
    }
    if (output[_OG] != null) {
        contents[_OG] = de_OriginGroups(output[_OG], context);
    }
    if (output[_DCB] != null) {
        contents[_DCB] = de_DefaultCacheBehavior(output[_DCB], context);
    }
    if (output[_CBa] != null) {
        contents[_CBa] = de_CacheBehaviors(output[_CBa], context);
    }
    if (output[_CERu] != null) {
        contents[_CERu] = de_CustomErrorResponses(output[_CERu], context);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_Lo] != null) {
        contents[_Lo] = de_LoggingConfig(output[_Lo], context);
    }
    if (output[_PC] != null) {
        contents[_PC] = (0, smithy_client_1.expectString)(output[_PC]);
    }
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_VC] != null) {
        contents[_VC] = de_ViewerCertificate(output[_VC], context);
    }
    if (output[_Re] != null) {
        contents[_Re] = de_Restrictions(output[_Re], context);
    }
    if (output[_WACLI] != null) {
        contents[_WACLI] = (0, smithy_client_1.expectString)(output[_WACLI]);
    }
    if (output[_HV] != null) {
        contents[_HV] = (0, smithy_client_1.expectString)(output[_HV]);
    }
    if (output[_IIPVE] != null) {
        contents[_IIPVE] = (0, smithy_client_1.parseBoolean)(output[_IIPVE]);
    }
    if (output[_CDPI] != null) {
        contents[_CDPI] = (0, smithy_client_1.expectString)(output[_CDPI]);
    }
    if (output[_S] != null) {
        contents[_S] = (0, smithy_client_1.parseBoolean)(output[_S]);
    }
    return contents;
};
const de_DistributionIdList = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = (0, smithy_client_1.expectString)(output[_M]);
    }
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(output[_IT]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_DI] != null) {
        contents[_It] = de_DistributionIdListSummary((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_DI]), context);
    }
    return contents;
};
const de_DistributionIdListSummary = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_DistributionList = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = (0, smithy_client_1.expectString)(output[_M]);
    }
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(output[_IT]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_DS] != null) {
        contents[_It] = de_DistributionSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_DS]), context);
    }
    return contents;
};
const de_DistributionSummary = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = (0, smithy_client_1.expectString)(output[_ARN]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = (0, smithy_client_1.expectString)(output[_Sta]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_DN] != null) {
        contents[_DN] = (0, smithy_client_1.expectString)(output[_DN]);
    }
    if (output[_Al] != null) {
        contents[_Al] = de_Aliases(output[_Al], context);
    }
    if (output[_Ori] != null) {
        contents[_Ori] = de_Origins(output[_Ori], context);
    }
    if (output[_OG] != null) {
        contents[_OG] = de_OriginGroups(output[_OG], context);
    }
    if (output[_DCB] != null) {
        contents[_DCB] = de_DefaultCacheBehavior(output[_DCB], context);
    }
    if (output[_CBa] != null) {
        contents[_CBa] = de_CacheBehaviors(output[_CBa], context);
    }
    if (output[_CERu] != null) {
        contents[_CERu] = de_CustomErrorResponses(output[_CERu], context);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_PC] != null) {
        contents[_PC] = (0, smithy_client_1.expectString)(output[_PC]);
    }
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_VC] != null) {
        contents[_VC] = de_ViewerCertificate(output[_VC], context);
    }
    if (output[_Re] != null) {
        contents[_Re] = de_Restrictions(output[_Re], context);
    }
    if (output[_WACLI] != null) {
        contents[_WACLI] = (0, smithy_client_1.expectString)(output[_WACLI]);
    }
    if (output[_HV] != null) {
        contents[_HV] = (0, smithy_client_1.expectString)(output[_HV]);
    }
    if (output[_IIPVE] != null) {
        contents[_IIPVE] = (0, smithy_client_1.parseBoolean)(output[_IIPVE]);
    }
    if (output.AliasICPRecordals === "") {
        contents[_AICPR] = [];
    }
    else if (output[_AICPR] != null && output[_AICPR][_AICPRl] != null) {
        contents[_AICPR] = de_AliasICPRecordals((0, smithy_client_1.getArrayIfSingleItem)(output[_AICPR][_AICPRl]), context);
    }
    if (output[_S] != null) {
        contents[_S] = (0, smithy_client_1.parseBoolean)(output[_S]);
    }
    return contents;
};
const de_DistributionSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DistributionSummary(entry, context);
    });
};
const de_EncryptionEntities = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_EEn] != null) {
        contents[_It] = de_EncryptionEntityList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_EEn]), context);
    }
    return contents;
};
const de_EncryptionEntity = (output, context) => {
    const contents = {};
    if (output[_PKI] != null) {
        contents[_PKI] = (0, smithy_client_1.expectString)(output[_PKI]);
    }
    if (output[_PIr] != null) {
        contents[_PIr] = (0, smithy_client_1.expectString)(output[_PIr]);
    }
    if (output[_FP] != null) {
        contents[_FP] = de_FieldPatterns(output[_FP], context);
    }
    return contents;
};
const de_EncryptionEntityList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EncryptionEntity(entry, context);
    });
};
const de_EndPoint = (output, context) => {
    const contents = {};
    if (output[_ST] != null) {
        contents[_ST] = (0, smithy_client_1.expectString)(output[_ST]);
    }
    if (output[_KSC] != null) {
        contents[_KSC] = de_KinesisStreamConfig(output[_KSC], context);
    }
    return contents;
};
const de_EndPointList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EndPoint(entry, context);
    });
};
const de_FieldLevelEncryption = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_FLEC] != null) {
        contents[_FLEC] = de_FieldLevelEncryptionConfig(output[_FLEC], context);
    }
    return contents;
};
const de_FieldLevelEncryptionConfig = (output, context) => {
    const contents = {};
    if (output[_CR] != null) {
        contents[_CR] = (0, smithy_client_1.expectString)(output[_CR]);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_QAPC] != null) {
        contents[_QAPC] = de_QueryArgProfileConfig(output[_QAPC], context);
    }
    if (output[_CTPC] != null) {
        contents[_CTPC] = de_ContentTypeProfileConfig(output[_CTPC], context);
    }
    return contents;
};
const de_FieldLevelEncryptionList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_FLES] != null) {
        contents[_It] = de_FieldLevelEncryptionSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_FLES]), context);
    }
    return contents;
};
const de_FieldLevelEncryptionProfile = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_FLEPC] != null) {
        contents[_FLEPC] = de_FieldLevelEncryptionProfileConfig(output[_FLEPC], context);
    }
    return contents;
};
const de_FieldLevelEncryptionProfileConfig = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_CR] != null) {
        contents[_CR] = (0, smithy_client_1.expectString)(output[_CR]);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_EE] != null) {
        contents[_EE] = de_EncryptionEntities(output[_EE], context);
    }
    return contents;
};
const de_FieldLevelEncryptionProfileList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_FLEPS] != null) {
        contents[_It] = de_FieldLevelEncryptionProfileSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_FLEPS]), context);
    }
    return contents;
};
const de_FieldLevelEncryptionProfileSummary = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_EE] != null) {
        contents[_EE] = de_EncryptionEntities(output[_EE], context);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    return contents;
};
const de_FieldLevelEncryptionProfileSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FieldLevelEncryptionProfileSummary(entry, context);
    });
};
const de_FieldLevelEncryptionSummary = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_QAPC] != null) {
        contents[_QAPC] = de_QueryArgProfileConfig(output[_QAPC], context);
    }
    if (output[_CTPC] != null) {
        contents[_CTPC] = de_ContentTypeProfileConfig(output[_CTPC], context);
    }
    return contents;
};
const de_FieldLevelEncryptionSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FieldLevelEncryptionSummary(entry, context);
    });
};
const de_FieldList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_FieldPatternList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_FieldPatterns = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_FPi] != null) {
        contents[_It] = de_FieldPatternList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_FPi]), context);
    }
    return contents;
};
const de_ForwardedValues = (output, context) => {
    const contents = {};
    if (output[_QSu] != null) {
        contents[_QSu] = (0, smithy_client_1.parseBoolean)(output[_QSu]);
    }
    if (output[_Coo] != null) {
        contents[_Coo] = de_CookiePreference(output[_Coo], context);
    }
    if (output[_He] != null) {
        contents[_He] = de_Headers(output[_He], context);
    }
    if (output[_QSCK] != null) {
        contents[_QSCK] = de_QueryStringCacheKeys(output[_QSCK], context);
    }
    return contents;
};
const de_FunctionAssociation = (output, context) => {
    const contents = {};
    if (output[_FARN] != null) {
        contents[_FARN] = (0, smithy_client_1.expectString)(output[_FARN]);
    }
    if (output[_ETv] != null) {
        contents[_ETv] = (0, smithy_client_1.expectString)(output[_ETv]);
    }
    return contents;
};
const de_FunctionAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FunctionAssociation(entry, context);
    });
};
const de_FunctionAssociations = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_FAu] != null) {
        contents[_It] = de_FunctionAssociationList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_FAu]), context);
    }
    return contents;
};
const de_FunctionConfig = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_Ru] != null) {
        contents[_Ru] = (0, smithy_client_1.expectString)(output[_Ru]);
    }
    if (output[_KVSA] != null) {
        contents[_KVSA] = de_KeyValueStoreAssociations(output[_KVSA], context);
    }
    return contents;
};
const de_FunctionExecutionLogList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_FunctionList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_FSu] != null) {
        contents[_It] = de_FunctionSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_FSu]), context);
    }
    return contents;
};
const de_FunctionMetadata = (output, context) => {
    const contents = {};
    if (output[_FARN] != null) {
        contents[_FARN] = (0, smithy_client_1.expectString)(output[_FARN]);
    }
    if (output[_St] != null) {
        contents[_St] = (0, smithy_client_1.expectString)(output[_St]);
    }
    if (output[_CTr] != null) {
        contents[_CTr] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_CTr]));
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    return contents;
};
const de_FunctionSummary = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = (0, smithy_client_1.expectString)(output[_Sta]);
    }
    if (output[_FCu] != null) {
        contents[_FCu] = de_FunctionConfig(output[_FCu], context);
    }
    if (output[_FM] != null) {
        contents[_FM] = de_FunctionMetadata(output[_FM], context);
    }
    return contents;
};
const de_FunctionSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FunctionSummary(entry, context);
    });
};
const de_GeoRestriction = (output, context) => {
    const contents = {};
    if (output[_RT] != null) {
        contents[_RT] = (0, smithy_client_1.expectString)(output[_RT]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_L] != null) {
        contents[_It] = de_LocationList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_L]), context);
    }
    return contents;
};
const de_HeaderList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_Headers = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_N] != null) {
        contents[_It] = de_HeaderList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_N]), context);
    }
    return contents;
};
const de_Invalidation = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = (0, smithy_client_1.expectString)(output[_Sta]);
    }
    if (output[_CTre] != null) {
        contents[_CTre] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_CTre]));
    }
    if (output[_IB] != null) {
        contents[_IB] = de_InvalidationBatch(output[_IB], context);
    }
    return contents;
};
const de_InvalidationBatch = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = de_Paths(output[_P], context);
    }
    if (output[_CR] != null) {
        contents[_CR] = (0, smithy_client_1.expectString)(output[_CR]);
    }
    return contents;
};
const de_InvalidationList = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = (0, smithy_client_1.expectString)(output[_M]);
    }
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(output[_IT]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_ISnv] != null) {
        contents[_It] = de_InvalidationSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_ISnv]), context);
    }
    return contents;
};
const de_InvalidationSummary = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_CTre] != null) {
        contents[_CTre] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_CTre]));
    }
    if (output[_Sta] != null) {
        contents[_Sta] = (0, smithy_client_1.expectString)(output[_Sta]);
    }
    return contents;
};
const de_InvalidationSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InvalidationSummary(entry, context);
    });
};
const de_KeyGroup = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_KGC] != null) {
        contents[_KGC] = de_KeyGroupConfig(output[_KGC], context);
    }
    return contents;
};
const de_KeyGroupConfig = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_PK] != null) {
        contents[_It] = de_PublicKeyIdList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_PK]), context);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    return contents;
};
const de_KeyGroupList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_KGS] != null) {
        contents[_It] = de_KeyGroupSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_KGS]), context);
    }
    return contents;
};
const de_KeyGroupSummary = (output, context) => {
    const contents = {};
    if (output[_KG] != null) {
        contents[_KG] = de_KeyGroup(output[_KG], context);
    }
    return contents;
};
const de_KeyGroupSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KeyGroupSummary(entry, context);
    });
};
const de_KeyPairIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_KeyPairIds = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_KPI] != null) {
        contents[_It] = de_KeyPairIdList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_KPI]), context);
    }
    return contents;
};
const de_KeyValueStore = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = (0, smithy_client_1.expectString)(output[_ARN]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = (0, smithy_client_1.expectString)(output[_Sta]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    return contents;
};
const de_KeyValueStoreAssociation = (output, context) => {
    const contents = {};
    if (output[_KVSARN] != null) {
        contents[_KVSARN] = (0, smithy_client_1.expectString)(output[_KVSARN]);
    }
    return contents;
};
const de_KeyValueStoreAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KeyValueStoreAssociation(entry, context);
    });
};
const de_KeyValueStoreAssociations = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_KVSAe] != null) {
        contents[_It] = de_KeyValueStoreAssociationList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_KVSAe]), context);
    }
    return contents;
};
const de_KeyValueStoreList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_KVS] != null) {
        contents[_It] = de_KeyValueStoreSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_KVS]), context);
    }
    return contents;
};
const de_KeyValueStoreSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KeyValueStore(entry, context);
    });
};
const de_KGKeyPairIds = (output, context) => {
    const contents = {};
    if (output[_KGI] != null) {
        contents[_KGI] = (0, smithy_client_1.expectString)(output[_KGI]);
    }
    if (output[_KPIe] != null) {
        contents[_KPIe] = de_KeyPairIds(output[_KPIe], context);
    }
    return contents;
};
const de_KGKeyPairIdsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KGKeyPairIds(entry, context);
    });
};
const de_KinesisStreamConfig = (output, context) => {
    const contents = {};
    if (output[_RARN] != null) {
        contents[_RARN] = (0, smithy_client_1.expectString)(output[_RARN]);
    }
    if (output[_SARNt] != null) {
        contents[_SARNt] = (0, smithy_client_1.expectString)(output[_SARNt]);
    }
    return contents;
};
const de_LambdaFunctionAssociation = (output, context) => {
    const contents = {};
    if (output[_LFARN] != null) {
        contents[_LFARN] = (0, smithy_client_1.expectString)(output[_LFARN]);
    }
    if (output[_ETv] != null) {
        contents[_ETv] = (0, smithy_client_1.expectString)(output[_ETv]);
    }
    if (output[_IBn] != null) {
        contents[_IBn] = (0, smithy_client_1.parseBoolean)(output[_IBn]);
    }
    return contents;
};
const de_LambdaFunctionAssociationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LambdaFunctionAssociation(entry, context);
    });
};
const de_LambdaFunctionAssociations = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_LFAa] != null) {
        contents[_It] = de_LambdaFunctionAssociationList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_LFAa]), context);
    }
    return contents;
};
const de_LocationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_LoggingConfig = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_IC] != null) {
        contents[_IC] = (0, smithy_client_1.parseBoolean)(output[_IC]);
    }
    if (output[_B] != null) {
        contents[_B] = (0, smithy_client_1.expectString)(output[_B]);
    }
    if (output[_Pr] != null) {
        contents[_Pr] = (0, smithy_client_1.expectString)(output[_Pr]);
    }
    return contents;
};
const de_MethodsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_MonitoringSubscription = (output, context) => {
    const contents = {};
    if (output[_RMSC] != null) {
        contents[_RMSC] = de_RealtimeMetricsSubscriptionConfig(output[_RMSC], context);
    }
    return contents;
};
const de_Origin = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_DN] != null) {
        contents[_DN] = (0, smithy_client_1.expectString)(output[_DN]);
    }
    if (output[_OP] != null) {
        contents[_OP] = (0, smithy_client_1.expectString)(output[_OP]);
    }
    if (output[_CH] != null) {
        contents[_CH] = de_CustomHeaders(output[_CH], context);
    }
    if (output[_SOC] != null) {
        contents[_SOC] = de_S3OriginConfig(output[_SOC], context);
    }
    if (output[_COC] != null) {
        contents[_COC] = de_CustomOriginConfig(output[_COC], context);
    }
    if (output[_CA] != null) {
        contents[_CA] = (0, smithy_client_1.strictParseInt32)(output[_CA]);
    }
    if (output[_CTon] != null) {
        contents[_CTon] = (0, smithy_client_1.strictParseInt32)(output[_CTon]);
    }
    if (output[_OS] != null) {
        contents[_OS] = de_OriginShield(output[_OS], context);
    }
    if (output[_OACI] != null) {
        contents[_OACI] = (0, smithy_client_1.expectString)(output[_OACI]);
    }
    return contents;
};
const de_OriginAccessControl = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_OACC] != null) {
        contents[_OACC] = de_OriginAccessControlConfig(output[_OACC], context);
    }
    return contents;
};
const de_OriginAccessControlConfig = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_D] != null) {
        contents[_D] = (0, smithy_client_1.expectString)(output[_D]);
    }
    if (output[_SP] != null) {
        contents[_SP] = (0, smithy_client_1.expectString)(output[_SP]);
    }
    if (output[_SB] != null) {
        contents[_SB] = (0, smithy_client_1.expectString)(output[_SB]);
    }
    if (output[_OACOT] != null) {
        contents[_OACOT] = (0, smithy_client_1.expectString)(output[_OACOT]);
    }
    return contents;
};
const de_OriginAccessControlList = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = (0, smithy_client_1.expectString)(output[_M]);
    }
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(output[_IT]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_OACS] != null) {
        contents[_It] = de_OriginAccessControlSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_OACS]), context);
    }
    return contents;
};
const de_OriginAccessControlSummary = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_D] != null) {
        contents[_D] = (0, smithy_client_1.expectString)(output[_D]);
    }
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_SP] != null) {
        contents[_SP] = (0, smithy_client_1.expectString)(output[_SP]);
    }
    if (output[_SB] != null) {
        contents[_SB] = (0, smithy_client_1.expectString)(output[_SB]);
    }
    if (output[_OACOT] != null) {
        contents[_OACOT] = (0, smithy_client_1.expectString)(output[_OACOT]);
    }
    return contents;
};
const de_OriginAccessControlSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OriginAccessControlSummary(entry, context);
    });
};
const de_OriginCustomHeader = (output, context) => {
    const contents = {};
    if (output[_HN] != null) {
        contents[_HN] = (0, smithy_client_1.expectString)(output[_HN]);
    }
    if (output[_HVe] != null) {
        contents[_HVe] = (0, smithy_client_1.expectString)(output[_HVe]);
    }
    return contents;
};
const de_OriginCustomHeadersList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OriginCustomHeader(entry, context);
    });
};
const de_OriginGroup = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_FCa] != null) {
        contents[_FCa] = de_OriginGroupFailoverCriteria(output[_FCa], context);
    }
    if (output[_Mem] != null) {
        contents[_Mem] = de_OriginGroupMembers(output[_Mem], context);
    }
    return contents;
};
const de_OriginGroupFailoverCriteria = (output, context) => {
    const contents = {};
    if (output[_SC] != null) {
        contents[_SC] = de_StatusCodes(output[_SC], context);
    }
    return contents;
};
const de_OriginGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OriginGroup(entry, context);
    });
};
const de_OriginGroupMember = (output, context) => {
    const contents = {};
    if (output[_OI] != null) {
        contents[_OI] = (0, smithy_client_1.expectString)(output[_OI]);
    }
    return contents;
};
const de_OriginGroupMemberList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OriginGroupMember(entry, context);
    });
};
const de_OriginGroupMembers = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_OGM] != null) {
        contents[_It] = de_OriginGroupMemberList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_OGM]), context);
    }
    return contents;
};
const de_OriginGroups = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_OGr] != null) {
        contents[_It] = de_OriginGroupList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_OGr]), context);
    }
    return contents;
};
const de_OriginList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Origin(entry, context);
    });
};
const de_OriginRequestPolicy = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_ORPC] != null) {
        contents[_ORPC] = de_OriginRequestPolicyConfig(output[_ORPC], context);
    }
    return contents;
};
const de_OriginRequestPolicyConfig = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_HC] != null) {
        contents[_HC] = de_OriginRequestPolicyHeadersConfig(output[_HC], context);
    }
    if (output[_CC] != null) {
        contents[_CC] = de_OriginRequestPolicyCookiesConfig(output[_CC], context);
    }
    if (output[_QSC] != null) {
        contents[_QSC] = de_OriginRequestPolicyQueryStringsConfig(output[_QSC], context);
    }
    return contents;
};
const de_OriginRequestPolicyCookiesConfig = (output, context) => {
    const contents = {};
    if (output[_CBo] != null) {
        contents[_CBo] = (0, smithy_client_1.expectString)(output[_CBo]);
    }
    if (output[_Coo] != null) {
        contents[_Coo] = de_CookieNames(output[_Coo], context);
    }
    return contents;
};
const de_OriginRequestPolicyHeadersConfig = (output, context) => {
    const contents = {};
    if (output[_HB] != null) {
        contents[_HB] = (0, smithy_client_1.expectString)(output[_HB]);
    }
    if (output[_He] != null) {
        contents[_He] = de_Headers(output[_He], context);
    }
    return contents;
};
const de_OriginRequestPolicyList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_ORPS] != null) {
        contents[_It] = de_OriginRequestPolicySummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_ORPS]), context);
    }
    return contents;
};
const de_OriginRequestPolicyQueryStringsConfig = (output, context) => {
    const contents = {};
    if (output[_QSB] != null) {
        contents[_QSB] = (0, smithy_client_1.expectString)(output[_QSB]);
    }
    if (output[_QS] != null) {
        contents[_QS] = de_QueryStringNames(output[_QS], context);
    }
    return contents;
};
const de_OriginRequestPolicySummary = (output, context) => {
    const contents = {};
    if (output[_T] != null) {
        contents[_T] = (0, smithy_client_1.expectString)(output[_T]);
    }
    if (output[_ORP] != null) {
        contents[_ORP] = de_OriginRequestPolicy(output[_ORP], context);
    }
    return contents;
};
const de_OriginRequestPolicySummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OriginRequestPolicySummary(entry, context);
    });
};
const de_Origins = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_Or] != null) {
        contents[_It] = de_OriginList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_Or]), context);
    }
    return contents;
};
const de_OriginShield = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_OSR] != null) {
        contents[_OSR] = (0, smithy_client_1.expectString)(output[_OSR]);
    }
    return contents;
};
const de_OriginSslProtocols = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_SPs] != null) {
        contents[_It] = de_SslProtocolsList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_SPs]), context);
    }
    return contents;
};
const de_ParametersInCacheKeyAndForwardedToOrigin = (output, context) => {
    const contents = {};
    if (output[_EAEG] != null) {
        contents[_EAEG] = (0, smithy_client_1.parseBoolean)(output[_EAEG]);
    }
    if (output[_EAEB] != null) {
        contents[_EAEB] = (0, smithy_client_1.parseBoolean)(output[_EAEB]);
    }
    if (output[_HC] != null) {
        contents[_HC] = de_CachePolicyHeadersConfig(output[_HC], context);
    }
    if (output[_CC] != null) {
        contents[_CC] = de_CachePolicyCookiesConfig(output[_CC], context);
    }
    if (output[_QSC] != null) {
        contents[_QSC] = de_CachePolicyQueryStringsConfig(output[_QSC], context);
    }
    return contents;
};
const de_PathList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_Paths = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_Pa] != null) {
        contents[_It] = de_PathList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_Pa]), context);
    }
    return contents;
};
const de_PublicKey = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_CTr] != null) {
        contents[_CTr] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_CTr]));
    }
    if (output[_PKC] != null) {
        contents[_PKC] = de_PublicKeyConfig(output[_PKC], context);
    }
    return contents;
};
const de_PublicKeyConfig = (output, context) => {
    const contents = {};
    if (output[_CR] != null) {
        contents[_CR] = (0, smithy_client_1.expectString)(output[_CR]);
    }
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_EK] != null) {
        contents[_EK] = (0, smithy_client_1.expectString)(output[_EK]);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    return contents;
};
const de_PublicKeyIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_PublicKeyList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_PKS] != null) {
        contents[_It] = de_PublicKeySummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_PKS]), context);
    }
    return contents;
};
const de_PublicKeySummary = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_CTr] != null) {
        contents[_CTr] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_CTr]));
    }
    if (output[_EK] != null) {
        contents[_EK] = (0, smithy_client_1.expectString)(output[_EK]);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    return contents;
};
const de_PublicKeySummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PublicKeySummary(entry, context);
    });
};
const de_QueryArgProfile = (output, context) => {
    const contents = {};
    if (output[_QA] != null) {
        contents[_QA] = (0, smithy_client_1.expectString)(output[_QA]);
    }
    if (output[_PI] != null) {
        contents[_PI] = (0, smithy_client_1.expectString)(output[_PI]);
    }
    return contents;
};
const de_QueryArgProfileConfig = (output, context) => {
    const contents = {};
    if (output[_FWQAPIU] != null) {
        contents[_FWQAPIU] = (0, smithy_client_1.parseBoolean)(output[_FWQAPIU]);
    }
    if (output[_QAPu] != null) {
        contents[_QAPu] = de_QueryArgProfiles(output[_QAPu], context);
    }
    return contents;
};
const de_QueryArgProfileList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_QueryArgProfile(entry, context);
    });
};
const de_QueryArgProfiles = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_QAP] != null) {
        contents[_It] = de_QueryArgProfileList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_QAP]), context);
    }
    return contents;
};
const de_QueryStringCacheKeys = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_N] != null) {
        contents[_It] = de_QueryStringCacheKeysList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_N]), context);
    }
    return contents;
};
const de_QueryStringCacheKeysList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_QueryStringNames = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_N] != null) {
        contents[_It] = de_QueryStringNamesList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_N]), context);
    }
    return contents;
};
const de_QueryStringNamesList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_RealtimeLogConfig = (output, context) => {
    const contents = {};
    if (output[_ARN] != null) {
        contents[_ARN] = (0, smithy_client_1.expectString)(output[_ARN]);
    }
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_SR] != null) {
        contents[_SR] = (0, smithy_client_1.strictParseLong)(output[_SR]);
    }
    if (output.EndPoints === "") {
        contents[_EP] = [];
    }
    else if (output[_EP] != null && output[_EP][_m] != null) {
        contents[_EP] = de_EndPointList((0, smithy_client_1.getArrayIfSingleItem)(output[_EP][_m]), context);
    }
    if (output.Fields === "") {
        contents[_F] = [];
    }
    else if (output[_F] != null && output[_F][_Fi] != null) {
        contents[_F] = de_FieldList((0, smithy_client_1.getArrayIfSingleItem)(output[_F][_Fi]), context);
    }
    return contents;
};
const de_RealtimeLogConfigList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RealtimeLogConfig(entry, context);
    });
};
const de_RealtimeLogConfigs = (output, context) => {
    const contents = {};
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_m] != null) {
        contents[_It] = de_RealtimeLogConfigList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_m]), context);
    }
    if (output[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(output[_IT]);
    }
    if (output[_M] != null) {
        contents[_M] = (0, smithy_client_1.expectString)(output[_M]);
    }
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    return contents;
};
const de_RealtimeMetricsSubscriptionConfig = (output, context) => {
    const contents = {};
    if (output[_RMSS] != null) {
        contents[_RMSS] = (0, smithy_client_1.expectString)(output[_RMSS]);
    }
    return contents;
};
const de_ResponseHeadersPolicy = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_RHPC] != null) {
        contents[_RHPC] = de_ResponseHeadersPolicyConfig(output[_RHPC], context);
    }
    return contents;
};
const de_ResponseHeadersPolicyAccessControlAllowHeaders = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_H] != null) {
        contents[_It] = de_AccessControlAllowHeadersList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_H]), context);
    }
    return contents;
};
const de_ResponseHeadersPolicyAccessControlAllowMethods = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_Met] != null) {
        contents[_It] = de_AccessControlAllowMethodsList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_Met]), context);
    }
    return contents;
};
const de_ResponseHeadersPolicyAccessControlAllowOrigins = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_Or] != null) {
        contents[_It] = de_AccessControlAllowOriginsList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_Or]), context);
    }
    return contents;
};
const de_ResponseHeadersPolicyAccessControlExposeHeaders = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_H] != null) {
        contents[_It] = de_AccessControlExposeHeadersList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_H]), context);
    }
    return contents;
};
const de_ResponseHeadersPolicyConfig = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_CCo] != null) {
        contents[_CCo] = de_ResponseHeadersPolicyCorsConfig(output[_CCo], context);
    }
    if (output[_SHC] != null) {
        contents[_SHC] = de_ResponseHeadersPolicySecurityHeadersConfig(output[_SHC], context);
    }
    if (output[_STHC] != null) {
        contents[_STHC] = de_ResponseHeadersPolicyServerTimingHeadersConfig(output[_STHC], context);
    }
    if (output[_CHC] != null) {
        contents[_CHC] = de_ResponseHeadersPolicyCustomHeadersConfig(output[_CHC], context);
    }
    if (output[_RHC] != null) {
        contents[_RHC] = de_ResponseHeadersPolicyRemoveHeadersConfig(output[_RHC], context);
    }
    return contents;
};
const de_ResponseHeadersPolicyContentSecurityPolicy = (output, context) => {
    const contents = {};
    if (output[_Ov] != null) {
        contents[_Ov] = (0, smithy_client_1.parseBoolean)(output[_Ov]);
    }
    if (output[_CSP] != null) {
        contents[_CSP] = (0, smithy_client_1.expectString)(output[_CSP]);
    }
    return contents;
};
const de_ResponseHeadersPolicyContentTypeOptions = (output, context) => {
    const contents = {};
    if (output[_Ov] != null) {
        contents[_Ov] = (0, smithy_client_1.parseBoolean)(output[_Ov]);
    }
    return contents;
};
const de_ResponseHeadersPolicyCorsConfig = (output, context) => {
    const contents = {};
    if (output[_ACAO] != null) {
        contents[_ACAO] = de_ResponseHeadersPolicyAccessControlAllowOrigins(output[_ACAO], context);
    }
    if (output[_ACAH] != null) {
        contents[_ACAH] = de_ResponseHeadersPolicyAccessControlAllowHeaders(output[_ACAH], context);
    }
    if (output[_ACAM] != null) {
        contents[_ACAM] = de_ResponseHeadersPolicyAccessControlAllowMethods(output[_ACAM], context);
    }
    if (output[_ACAC] != null) {
        contents[_ACAC] = (0, smithy_client_1.parseBoolean)(output[_ACAC]);
    }
    if (output[_ACEH] != null) {
        contents[_ACEH] = de_ResponseHeadersPolicyAccessControlExposeHeaders(output[_ACEH], context);
    }
    if (output[_ACMAS] != null) {
        contents[_ACMAS] = (0, smithy_client_1.strictParseInt32)(output[_ACMAS]);
    }
    if (output[_OO] != null) {
        contents[_OO] = (0, smithy_client_1.parseBoolean)(output[_OO]);
    }
    return contents;
};
const de_ResponseHeadersPolicyCustomHeader = (output, context) => {
    const contents = {};
    if (output[_H] != null) {
        contents[_H] = (0, smithy_client_1.expectString)(output[_H]);
    }
    if (output[_V] != null) {
        contents[_V] = (0, smithy_client_1.expectString)(output[_V]);
    }
    if (output[_Ov] != null) {
        contents[_Ov] = (0, smithy_client_1.parseBoolean)(output[_Ov]);
    }
    return contents;
};
const de_ResponseHeadersPolicyCustomHeaderList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResponseHeadersPolicyCustomHeader(entry, context);
    });
};
const de_ResponseHeadersPolicyCustomHeadersConfig = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_RHPCH] != null) {
        contents[_It] = de_ResponseHeadersPolicyCustomHeaderList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_RHPCH]), context);
    }
    return contents;
};
const de_ResponseHeadersPolicyFrameOptions = (output, context) => {
    const contents = {};
    if (output[_Ov] != null) {
        contents[_Ov] = (0, smithy_client_1.parseBoolean)(output[_Ov]);
    }
    if (output[_FO] != null) {
        contents[_FO] = (0, smithy_client_1.expectString)(output[_FO]);
    }
    return contents;
};
const de_ResponseHeadersPolicyList = (output, context) => {
    const contents = {};
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_RHPS] != null) {
        contents[_It] = de_ResponseHeadersPolicySummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_RHPS]), context);
    }
    return contents;
};
const de_ResponseHeadersPolicyReferrerPolicy = (output, context) => {
    const contents = {};
    if (output[_Ov] != null) {
        contents[_Ov] = (0, smithy_client_1.parseBoolean)(output[_Ov]);
    }
    if (output[_RP] != null) {
        contents[_RP] = (0, smithy_client_1.expectString)(output[_RP]);
    }
    return contents;
};
const de_ResponseHeadersPolicyRemoveHeader = (output, context) => {
    const contents = {};
    if (output[_H] != null) {
        contents[_H] = (0, smithy_client_1.expectString)(output[_H]);
    }
    return contents;
};
const de_ResponseHeadersPolicyRemoveHeaderList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResponseHeadersPolicyRemoveHeader(entry, context);
    });
};
const de_ResponseHeadersPolicyRemoveHeadersConfig = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_RHPRH] != null) {
        contents[_It] = de_ResponseHeadersPolicyRemoveHeaderList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_RHPRH]), context);
    }
    return contents;
};
const de_ResponseHeadersPolicySecurityHeadersConfig = (output, context) => {
    const contents = {};
    if (output[_XSSP] != null) {
        contents[_XSSP] = de_ResponseHeadersPolicyXSSProtection(output[_XSSP], context);
    }
    if (output[_FOr] != null) {
        contents[_FOr] = de_ResponseHeadersPolicyFrameOptions(output[_FOr], context);
    }
    if (output[_RP] != null) {
        contents[_RP] = de_ResponseHeadersPolicyReferrerPolicy(output[_RP], context);
    }
    if (output[_CSP] != null) {
        contents[_CSP] = de_ResponseHeadersPolicyContentSecurityPolicy(output[_CSP], context);
    }
    if (output[_CTO] != null) {
        contents[_CTO] = de_ResponseHeadersPolicyContentTypeOptions(output[_CTO], context);
    }
    if (output[_STS] != null) {
        contents[_STS] = de_ResponseHeadersPolicyStrictTransportSecurity(output[_STS], context);
    }
    return contents;
};
const de_ResponseHeadersPolicyServerTimingHeadersConfig = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_SR] != null) {
        contents[_SR] = (0, smithy_client_1.strictParseFloat)(output[_SR]);
    }
    return contents;
};
const de_ResponseHeadersPolicyStrictTransportSecurity = (output, context) => {
    const contents = {};
    if (output[_Ov] != null) {
        contents[_Ov] = (0, smithy_client_1.parseBoolean)(output[_Ov]);
    }
    if (output[_ISn] != null) {
        contents[_ISn] = (0, smithy_client_1.parseBoolean)(output[_ISn]);
    }
    if (output[_Pre] != null) {
        contents[_Pre] = (0, smithy_client_1.parseBoolean)(output[_Pre]);
    }
    if (output[_ACMAS] != null) {
        contents[_ACMAS] = (0, smithy_client_1.strictParseInt32)(output[_ACMAS]);
    }
    return contents;
};
const de_ResponseHeadersPolicySummary = (output, context) => {
    const contents = {};
    if (output[_T] != null) {
        contents[_T] = (0, smithy_client_1.expectString)(output[_T]);
    }
    if (output[_RHP] != null) {
        contents[_RHP] = de_ResponseHeadersPolicy(output[_RHP], context);
    }
    return contents;
};
const de_ResponseHeadersPolicySummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResponseHeadersPolicySummary(entry, context);
    });
};
const de_ResponseHeadersPolicyXSSProtection = (output, context) => {
    const contents = {};
    if (output[_Ov] != null) {
        contents[_Ov] = (0, smithy_client_1.parseBoolean)(output[_Ov]);
    }
    if (output[_Pro] != null) {
        contents[_Pro] = (0, smithy_client_1.parseBoolean)(output[_Pro]);
    }
    if (output[_MB] != null) {
        contents[_MB] = (0, smithy_client_1.parseBoolean)(output[_MB]);
    }
    if (output[_RU] != null) {
        contents[_RU] = (0, smithy_client_1.expectString)(output[_RU]);
    }
    return contents;
};
const de_Restrictions = (output, context) => {
    const contents = {};
    if (output[_GR] != null) {
        contents[_GR] = de_GeoRestriction(output[_GR], context);
    }
    return contents;
};
const de_S3Origin = (output, context) => {
    const contents = {};
    if (output[_DN] != null) {
        contents[_DN] = (0, smithy_client_1.expectString)(output[_DN]);
    }
    if (output[_OAI] != null) {
        contents[_OAI] = (0, smithy_client_1.expectString)(output[_OAI]);
    }
    return contents;
};
const de_S3OriginConfig = (output, context) => {
    const contents = {};
    if (output[_OAI] != null) {
        contents[_OAI] = (0, smithy_client_1.expectString)(output[_OAI]);
    }
    return contents;
};
const de_SessionStickinessConfig = (output, context) => {
    const contents = {};
    if (output[_ITTL] != null) {
        contents[_ITTL] = (0, smithy_client_1.strictParseInt32)(output[_ITTL]);
    }
    if (output[_MTTLax] != null) {
        contents[_MTTLax] = (0, smithy_client_1.strictParseInt32)(output[_MTTLax]);
    }
    return contents;
};
const de_Signer = (output, context) => {
    const contents = {};
    if (output[_AAN] != null) {
        contents[_AAN] = (0, smithy_client_1.expectString)(output[_AAN]);
    }
    if (output[_KPIe] != null) {
        contents[_KPIe] = de_KeyPairIds(output[_KPIe], context);
    }
    return contents;
};
const de_SignerList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Signer(entry, context);
    });
};
const de_SslProtocolsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_StagingDistributionDnsNameList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_StagingDistributionDnsNames = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_DNn] != null) {
        contents[_It] = de_StagingDistributionDnsNameList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_DNn]), context);
    }
    return contents;
};
const de_StatusCodeList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.strictParseInt32)(entry);
    });
};
const de_StatusCodes = (output, context) => {
    const contents = {};
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_SCt] != null) {
        contents[_It] = de_StatusCodeList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_SCt]), context);
    }
    return contents;
};
const de_StreamingDistribution = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = (0, smithy_client_1.expectString)(output[_ARN]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = (0, smithy_client_1.expectString)(output[_Sta]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_DN] != null) {
        contents[_DN] = (0, smithy_client_1.expectString)(output[_DN]);
    }
    if (output[_ATS] != null) {
        contents[_ATS] = de_ActiveTrustedSigners(output[_ATS], context);
    }
    if (output[_SDC] != null) {
        contents[_SDC] = de_StreamingDistributionConfig(output[_SDC], context);
    }
    return contents;
};
const de_StreamingDistributionConfig = (output, context) => {
    const contents = {};
    if (output[_CR] != null) {
        contents[_CR] = (0, smithy_client_1.expectString)(output[_CR]);
    }
    if (output[_SO] != null) {
        contents[_SO] = de_S3Origin(output[_SO], context);
    }
    if (output[_Al] != null) {
        contents[_Al] = de_Aliases(output[_Al], context);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_Lo] != null) {
        contents[_Lo] = de_StreamingLoggingConfig(output[_Lo], context);
    }
    if (output[_TS] != null) {
        contents[_TS] = de_TrustedSigners(output[_TS], context);
    }
    if (output[_PC] != null) {
        contents[_PC] = (0, smithy_client_1.expectString)(output[_PC]);
    }
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    return contents;
};
const de_StreamingDistributionList = (output, context) => {
    const contents = {};
    if (output[_M] != null) {
        contents[_M] = (0, smithy_client_1.expectString)(output[_M]);
    }
    if (output[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(output[_NM]);
    }
    if (output[_MI] != null) {
        contents[_MI] = (0, smithy_client_1.strictParseInt32)(output[_MI]);
    }
    if (output[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(output[_IT]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_SDS] != null) {
        contents[_It] = de_StreamingDistributionSummaryList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_SDS]), context);
    }
    return contents;
};
const de_StreamingDistributionSummary = (output, context) => {
    const contents = {};
    if (output[_Id] != null) {
        contents[_Id] = (0, smithy_client_1.expectString)(output[_Id]);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = (0, smithy_client_1.expectString)(output[_ARN]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = (0, smithy_client_1.expectString)(output[_Sta]);
    }
    if (output[_LMT] != null) {
        contents[_LMT] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LMT]));
    }
    if (output[_DN] != null) {
        contents[_DN] = (0, smithy_client_1.expectString)(output[_DN]);
    }
    if (output[_SO] != null) {
        contents[_SO] = de_S3Origin(output[_SO], context);
    }
    if (output[_Al] != null) {
        contents[_Al] = de_Aliases(output[_Al], context);
    }
    if (output[_TS] != null) {
        contents[_TS] = de_TrustedSigners(output[_TS], context);
    }
    if (output[_C] != null) {
        contents[_C] = (0, smithy_client_1.expectString)(output[_C]);
    }
    if (output[_PC] != null) {
        contents[_PC] = (0, smithy_client_1.expectString)(output[_PC]);
    }
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    return contents;
};
const de_StreamingDistributionSummaryList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_StreamingDistributionSummary(entry, context);
    });
};
const de_StreamingLoggingConfig = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_B] != null) {
        contents[_B] = (0, smithy_client_1.expectString)(output[_B]);
    }
    if (output[_Pr] != null) {
        contents[_Pr] = (0, smithy_client_1.expectString)(output[_Pr]);
    }
    return contents;
};
const de_Tag = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = (0, smithy_client_1.expectString)(output[_K]);
    }
    if (output[_V] != null) {
        contents[_V] = (0, smithy_client_1.expectString)(output[_V]);
    }
    return contents;
};
const de_TagList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Tag(entry, context);
    });
};
const de_Tags = (output, context) => {
    const contents = {};
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_Tag] != null) {
        contents[_It] = de_TagList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_Tag]), context);
    }
    return contents;
};
const de_TestResult = (output, context) => {
    const contents = {};
    if (output[_FSu] != null) {
        contents[_FSu] = de_FunctionSummary(output[_FSu], context);
    }
    if (output[_CU] != null) {
        contents[_CU] = (0, smithy_client_1.expectString)(output[_CU]);
    }
    if (output.FunctionExecutionLogs === "") {
        contents[_FEL] = [];
    }
    else if (output[_FEL] != null && output[_FEL][_m] != null) {
        contents[_FEL] = de_FunctionExecutionLogList((0, smithy_client_1.getArrayIfSingleItem)(output[_FEL][_m]), context);
    }
    if (output[_FEM] != null) {
        contents[_FEM] = (0, smithy_client_1.expectString)(output[_FEM]);
    }
    if (output[_FOu] != null) {
        contents[_FOu] = (0, smithy_client_1.expectString)(output[_FOu]);
    }
    return contents;
};
const de_TrafficConfig = (output, context) => {
    const contents = {};
    if (output[_SWC] != null) {
        contents[_SWC] = de_ContinuousDeploymentSingleWeightConfig(output[_SWC], context);
    }
    if (output[_SHCi] != null) {
        contents[_SHCi] = de_ContinuousDeploymentSingleHeaderConfig(output[_SHCi], context);
    }
    if (output[_T] != null) {
        contents[_T] = (0, smithy_client_1.expectString)(output[_T]);
    }
    return contents;
};
const de_TrustedKeyGroupIdList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_TrustedKeyGroups = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_KG] != null) {
        contents[_It] = de_TrustedKeyGroupIdList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_KG]), context);
    }
    return contents;
};
const de_TrustedSigners = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.parseBoolean)(output[_E]);
    }
    if (output[_Q] != null) {
        contents[_Q] = (0, smithy_client_1.strictParseInt32)(output[_Q]);
    }
    if (output.Items === "") {
        contents[_It] = [];
    }
    else if (output[_It] != null && output[_It][_AAN] != null) {
        contents[_It] = de_AwsAccountNumberList((0, smithy_client_1.getArrayIfSingleItem)(output[_It][_AAN]), context);
    }
    return contents;
};
const de_ViewerCertificate = (output, context) => {
    const contents = {};
    if (output[_CFDC] != null) {
        contents[_CFDC] = (0, smithy_client_1.parseBoolean)(output[_CFDC]);
    }
    if (output[_IAMCI] != null) {
        contents[_IAMCI] = (0, smithy_client_1.expectString)(output[_IAMCI]);
    }
    if (output[_ACMCA] != null) {
        contents[_ACMCA] = (0, smithy_client_1.expectString)(output[_ACMCA]);
    }
    if (output[_SSLSM] != null) {
        contents[_SSLSM] = (0, smithy_client_1.expectString)(output[_SSLSM]);
    }
    if (output[_MPV] != null) {
        contents[_MPV] = (0, smithy_client_1.expectString)(output[_MPV]);
    }
    if (output[_Ce] != null) {
        contents[_Ce] = (0, smithy_client_1.expectString)(output[_Ce]);
    }
    if (output[_CS] != null) {
        contents[_CS] = (0, smithy_client_1.expectString)(output[_CS]);
    }
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _A = "Alias";
const _AAN = "AwsAccountNumber";
const _ACAC = "AccessControlAllowCredentials";
const _ACAH = "AccessControlAllowHeaders";
const _ACAM = "AccessControlAllowMethods";
const _ACAO = "AccessControlAllowOrigins";
const _ACEH = "AccessControlExposeHeaders";
const _ACMAS = "AccessControlMaxAgeSec";
const _ACMCA = "ACMCertificateArn";
const _AI = "AccountId";
const _AICPR = "AliasICPRecordals";
const _AICPRl = "AliasICPRecordal";
const _AM = "AllowedMethods";
const _ARN = "ARN";
const _ATKG = "ActiveTrustedKeyGroups";
const _ATS = "ActiveTrustedSigners";
const _Al = "Aliases";
const _B = "Bucket";
const _C = "Comment";
const _CA = "ConnectionAttempts";
const _CAo = "ConflictingAlias";
const _CB = "CacheBehavior";
const _CBa = "CacheBehaviors";
const _CBo = "CookieBehavior";
const _CC = "CookiesConfig";
const _CCo = "CorsConfig";
const _CDP = "ContinuousDeploymentPolicy";
const _CDPC = "ContinuousDeploymentPolicyConfig";
const _CDPI = "ContinuousDeploymentPolicyId";
const _CDPS = "ContinuousDeploymentPolicySummary";
const _CDPT = "ContinuousDeploymentPolicyType";
const _CDR = "CopyDistributionRequest";
const _CDSHC = "ContinuousDeploymentSingleHeaderConfig";
const _CDSWC = "ContinuousDeploymentSingleWeightConfig";
const _CER = "CustomErrorResponse";
const _CERu = "CustomErrorResponses";
const _CFDC = "CloudFrontDefaultCertificate";
const _CFOAIC = "CloudFrontOriginAccessIdentityConfig";
const _CFOAIS = "CloudFrontOriginAccessIdentitySummary";
const _CFR = "CreateFunctionRequest";
const _CH = "CustomHeaders";
const _CHC = "CustomHeadersConfig";
const _CKVSR = "CreateKeyValueStoreRequest";
const _CM = "CachedMethods";
const _CN = "CookieNames";
const _CNAME = "CNAME";
const _COC = "CustomOriginConfig";
const _CP = "CookiePreference";
const _CPC = "CachePolicyConfig";
const _CPCB = "CachePolicyCookieBehavior";
const _CPCC = "CachePolicyCookiesConfig";
const _CPHB = "CachePolicyHeaderBehavior";
const _CPHC = "CachePolicyHeadersConfig";
const _CPI = "CachePolicyId";
const _CPQSB = "CachePolicyQueryStringBehavior";
const _CPQSC = "CachePolicyQueryStringsConfig";
const _CPS = "CachePolicySummary";
const _CPa = "CachePolicy";
const _CR = "CallerReference";
const _CRLCR = "CreateRealtimeLogConfigRequest";
const _CS = "CertificateSource";
const _CSP = "ContentSecurityPolicy";
const _CT = "ContentType";
const _CTO = "ContentTypeOptions";
const _CTP = "ContentTypeProfile";
const _CTPC = "ContentTypeProfileConfig";
const _CTPo = "ContentTypeProfiles";
const _CTo = "CommentType";
const _CTon = "ConnectionTimeout";
const _CTr = "CreatedTime";
const _CTre = "CreateTime";
const _CU = "ComputeUtilization";
const _Ce = "Certificate";
const _Co = "Compress";
const _Coo = "Cookies";
const _D = "Description";
const _DC = "DistributionConfig";
const _DCB = "DefaultCacheBehavior";
const _DCWT = "DistributionConfigWithTags";
const _DI = "DistributionId";
const _DN = "DomainName";
const _DNn = "DnsName";
const _DRLCR = "DeleteRealtimeLogConfigRequest";
const _DRO = "DefaultRootObject";
const _DS = "DistributionSummary";
const _DTTL = "DefaultTTL";
const _E = "Enabled";
const _EAEB = "EnableAcceptEncodingBrotli";
const _EAEG = "EnableAcceptEncodingGzip";
const _EC = "ErrorCode";
const _ECMTTL = "ErrorCachingMinTTL";
const _EE = "EncryptionEntities";
const _EEn = "EncryptionEntity";
const _EK = "EncodedKey";
const _EO = "EventObject";
const _EP = "EndPoints";
const _EPn = "EndPoint";
const _ET = "ETag";
const _ETv = "EventType";
const _F = "Fields";
const _FA = "FunctionAssociations";
const _FARN = "FunctionARN";
const _FAu = "FunctionAssociation";
const _FB = "FunctionBlob";
const _FC = "FunctionCode";
const _FCa = "FailoverCriteria";
const _FCu = "FunctionConfig";
const _FEL = "FunctionExecutionLogs";
const _FEM = "FunctionErrorMessage";
const _FEO = "FunctionEventObject";
const _FLEC = "FieldLevelEncryptionConfig";
const _FLEI = "FieldLevelEncryptionId";
const _FLEPC = "FieldLevelEncryptionProfileConfig";
const _FLEPS = "FieldLevelEncryptionProfileSummary";
const _FLES = "FieldLevelEncryptionSummary";
const _FM = "FunctionMetadata";
const _FN = "FunctionName";
const _FO = "FrameOption";
const _FOL = "FrameOptionsList";
const _FOr = "FrameOptions";
const _FOu = "FunctionOutput";
const _FP = "FieldPatterns";
const _FPi = "FieldPattern";
const _FR = "FunctionRuntime";
const _FS = "FunctionStage";
const _FSu = "FunctionSummary";
const _FV = "ForwardedValues";
const _FWCTIU = "ForwardWhenContentTypeIsUnknown";
const _FWQAPIU = "ForwardWhenQueryArgProfileIsUnknown";
const _Fi = "Field";
const _Fo = "Format";
const _For = "Forward";
const _GR = "GeoRestriction";
const _GRLCR = "GetRealtimeLogConfigRequest";
const _GRT = "GeoRestrictionType";
const _H = "Header";
const _HB = "HeaderBehavior";
const _HC = "HeadersConfig";
const _HN = "HeaderName";
const _HTTPP = "HTTPPort";
const _HTTPSP = "HTTPSPort";
const _HV = "HttpVersion";
const _HVe = "HeaderValue";
const _He = "Headers";
const _I = "Integer";
const _IAMCI = "IAMCertificateId";
const _IB = "InvalidationBatch";
const _IBn = "IncludeBody";
const _IC = "IncludeCookies";
const _ICPRS = "ICPRecordalStatus";
const _IIPVE = "IsIPV6Enabled";
const _IM = "IfMatch";
const _IPIB = "InProgressInvalidationBatches";
const _IS = "ImportSource";
const _IST = "ImportSourceType";
const _ISn = "IncludeSubdomains";
const _ISnv = "InvalidationSummary";
const _ISt = "ItemSelection";
const _IT = "IsTruncated";
const _ITTL = "IdleTTL";
const _Id = "Id";
const _It = "Items";
const _K = "Key";
const _KG = "KeyGroup";
const _KGC = "KeyGroupConfig";
const _KGI = "KeyGroupId";
const _KGS = "KeyGroupSummary";
const _KPI = "KeyPairId";
const _KPIe = "KeyPairIds";
const _KSC = "KinesisStreamConfig";
const _KVS = "KeyValueStore";
const _KVSA = "KeyValueStoreAssociations";
const _KVSARN = "KeyValueStoreARN";
const _KVSAe = "KeyValueStoreAssociation";
const _KVSC = "KeyValueStoreComment";
const _KVSN = "KeyValueStoreName";
const _L = "Location";
const _LC = "LoggingConfig";
const _LDBRLCR = "ListDistributionsByRealtimeLogConfigRequest";
const _LFA = "LambdaFunctionAssociations";
const _LFARN = "LambdaFunctionARN";
const _LFAa = "LambdaFunctionAssociation";
const _LMT = "LastModifiedTime";
const _Lo = "Logging";
const _M = "Marker";
const _MB = "ModeBlock";
const _MI = "MaxItems";
const _MPV = "MinimumProtocolVersion";
const _MS = "MonitoringSubscription";
const _MTTL = "MinTTL";
const _MTTLa = "MaxTTL";
const _MTTLax = "MaximumTTL";
const _Me = "Message";
const _Mem = "Members";
const _Met = "Method";
const _N = "Name";
const _NM = "NextMarker";
const _O = "Operation";
const _OACC = "OriginAccessControlConfig";
const _OACI = "OriginAccessControlId";
const _OACOT = "OriginAccessControlOriginType";
const _OACOTr = "OriginAccessControlOriginTypes";
const _OACS = "OriginAccessControlSummary";
const _OACSB = "OriginAccessControlSigningBehaviors";
const _OACSP = "OriginAccessControlSigningProtocols";
const _OAI = "OriginAccessIdentity";
const _OCH = "OriginCustomHeader";
const _OG = "OriginGroups";
const _OGFC = "OriginGroupFailoverCriteria";
const _OGM = "OriginGroupMember";
const _OGMr = "OriginGroupMembers";
const _OGr = "OriginGroup";
const _OI = "OriginId";
const _OKT = "OriginKeepaliveTimeout";
const _OO = "OriginOverride";
const _OP = "OriginPath";
const _OPP = "OriginProtocolPolicy";
const _ORP = "OriginRequestPolicy";
const _ORPC = "OriginRequestPolicyConfig";
const _ORPCB = "OriginRequestPolicyCookieBehavior";
const _ORPCC = "OriginRequestPolicyCookiesConfig";
const _ORPHB = "OriginRequestPolicyHeaderBehavior";
const _ORPHC = "OriginRequestPolicyHeadersConfig";
const _ORPI = "OriginRequestPolicyId";
const _ORPQSB = "OriginRequestPolicyQueryStringBehavior";
const _ORPQSC = "OriginRequestPolicyQueryStringsConfig";
const _ORPS = "OriginRequestPolicySummary";
const _ORT = "OriginReadTimeout";
const _OS = "OriginShield";
const _OSP = "OriginSslProtocols";
const _OSR = "OriginShieldRegion";
const _Or = "Origin";
const _Ori = "Origins";
const _Ov = "Override";
const _P = "Paths";
const _PC = "PriceClass";
const _PI = "ProfileId";
const _PICKAFTO = "ParametersInCacheKeyAndForwardedToOrigin";
const _PIr = "ProviderId";
const _PK = "PublicKey";
const _PKC = "PublicKeyConfig";
const _PKI = "PublicKeyId";
const _PKS = "PublicKeySummary";
const _PP = "PathPattern";
const _Pa = "Path";
const _Pr = "Prefix";
const _Pre = "Preload";
const _Pro = "Protection";
const _Q = "Quantity";
const _QA = "QueryArg";
const _QAP = "QueryArgProfile";
const _QAPC = "QueryArgProfileConfig";
const _QAPu = "QueryArgProfiles";
const _QS = "QueryStrings";
const _QSB = "QueryStringBehavior";
const _QSC = "QueryStringsConfig";
const _QSCK = "QueryStringCacheKeys";
const _QSN = "QueryStringNames";
const _QSu = "QueryString";
const _R = "Resource";
const _RARN = "RoleARN";
const _RC = "ResponseCode";
const _RHC = "RemoveHeadersConfig";
const _RHP = "ResponseHeadersPolicy";
const _RHPACAH = "ResponseHeadersPolicyAccessControlAllowHeaders";
const _RHPACAM = "ResponseHeadersPolicyAccessControlAllowMethods";
const _RHPACAMV = "ResponseHeadersPolicyAccessControlAllowMethodsValues";
const _RHPACAO = "ResponseHeadersPolicyAccessControlAllowOrigins";
const _RHPACEH = "ResponseHeadersPolicyAccessControlExposeHeaders";
const _RHPC = "ResponseHeadersPolicyConfig";
const _RHPCC = "ResponseHeadersPolicyCorsConfig";
const _RHPCH = "ResponseHeadersPolicyCustomHeader";
const _RHPCHC = "ResponseHeadersPolicyCustomHeadersConfig";
const _RHPCSP = "ResponseHeadersPolicyContentSecurityPolicy";
const _RHPCTO = "ResponseHeadersPolicyContentTypeOptions";
const _RHPFO = "ResponseHeadersPolicyFrameOptions";
const _RHPI = "ResponseHeadersPolicyId";
const _RHPRH = "ResponseHeadersPolicyRemoveHeader";
const _RHPRHC = "ResponseHeadersPolicyRemoveHeadersConfig";
const _RHPRP = "ResponseHeadersPolicyReferrerPolicy";
const _RHPS = "ResponseHeadersPolicySummary";
const _RHPSHC = "ResponseHeadersPolicySecurityHeadersConfig";
const _RHPSTHC = "ResponseHeadersPolicyServerTimingHeadersConfig";
const _RHPSTS = "ResponseHeadersPolicyStrictTransportSecurity";
const _RHPXSSP = "ResponseHeadersPolicyXSSProtection";
const _RLC = "RealtimeLogConfig";
const _RLCA = "RealtimeLogConfigArn";
const _RLCN = "RealtimeLogConfigName";
const _RMSC = "RealtimeMetricsSubscriptionConfig";
const _RMSS = "RealtimeMetricsSubscriptionStatus";
const _RP = "ReferrerPolicy";
const _RPL = "ReferrerPolicyList";
const _RPP = "ResponsePagePath";
const _RT = "RestrictionType";
const _RU = "ReportUri";
const _Re = "Restrictions";
const _Ru = "Runtime";
const _S = "Staging";
const _SARN = "SourceARN";
const _SARNt = "StreamARN";
const _SB = "SigningBehavior";
const _SC = "StatusCodes";
const _SCUI = "S3CanonicalUserId";
const _SCt = "StatusCode";
const _SDC = "StreamingDistributionConfig";
const _SDCWT = "StreamingDistributionConfigWithTags";
const _SDDN = "StagingDistributionDnsNames";
const _SDI = "StagingDistributionId";
const _SDS = "StreamingDistributionSummary";
const _SHC = "SecurityHeadersConfig";
const _SHCi = "SingleHeaderConfig";
const _SLC = "StreamingLoggingConfig";
const _SO = "S3Origin";
const _SOC = "S3OriginConfig";
const _SP = "SigningProtocol";
const _SPs = "SslProtocol";
const _SR = "SamplingRate";
const _SS = "SmoothStreaming";
const _SSC = "SessionStickinessConfig";
const _SSLSM = "SSLSupportMethod";
const _ST = "StreamType";
const _STHC = "ServerTimingHeadersConfig";
const _STS = "StrictTransportSecurity";
const _STo = "SourceType";
const _SWC = "SingleWeightConfig";
const _Si = "Signer";
const _St = "Stage";
const _Sta = "Status";
const _T = "Type";
const _TC = "TrafficConfig";
const _TFR = "TestFunctionRequest";
const _TK = "TagKey";
const _TKG = "TrustedKeyGroups";
const _TKa = "TagKeys";
const _TOI = "TargetOriginId";
const _TS = "TrustedSigners";
const _TV = "TagValue";
const _Ta = "Tags";
const _Tag = "Tag";
const _UFR = "UpdateFunctionRequest";
const _UKVSR = "UpdateKeyValueStoreRequest";
const _URLCR = "UpdateRealtimeLogConfigRequest";
const _V = "Value";
const _VC = "ViewerCertificate";
const _VPP = "ViewerProtocolPolicy";
const _W = "Weight";
const _WACLI = "WebACLId";
const _WN = "WhitelistedNames";
const _WT = "WithTags";
const _XSSP = "XSSProtection";
const _b = "boolean";
const _ct = "content-type";
const _e = "etag";
const _et = "ettag";
const _f = "float";
const _i = "integer";
const _im = "if-match";
const _l = "long";
const _lo = "location";
const _m = "member";
const _s = "staging";
const _sST = "sensitiveStringType";
const _st = "string";
const _ve = '<?xml version="1.0" encoding="UTF-8"?>';
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new fast_xml_parser_1.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        const parsedObj = parser.parse(encoded);
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return (0, smithy_client_1.getValueFromTextNode)(parsedObjToReturn);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const loadRestXmlErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};


/***/ }),

/***/ 49895:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const tslib_1 = __nccwpck_require__(4351);
const package_json_1 = tslib_1.__importDefault(__nccwpck_require__(10273));
const client_sts_1 = __nccwpck_require__(52209);
const core_1 = __nccwpck_require__(59963);
const credential_provider_node_1 = __nccwpck_require__(75531);
const util_user_agent_node_1 = __nccwpck_require__(98095);
const config_resolver_1 = __nccwpck_require__(53098);
const hash_node_1 = __nccwpck_require__(3081);
const middleware_retry_1 = __nccwpck_require__(96039);
const node_config_provider_1 = __nccwpck_require__(33461);
const node_http_handler_1 = __nccwpck_require__(20258);
const util_body_length_node_1 = __nccwpck_require__(68075);
const util_retry_1 = __nccwpck_require__(84902);
const runtimeConfig_shared_1 = __nccwpck_require__(5553);
const smithy_client_1 = __nccwpck_require__(63570);
const util_defaults_mode_node_1 = __nccwpck_require__(72429);
const smithy_client_2 = __nccwpck_require__(63570);
const getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? (0, client_sts_1.decorateDefaultCredentialProvider)(credential_provider_node_1.defaultProvider),
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0, node_config_provider_1.loadConfig)({
                ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 5553:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const url_parser_1 = __nccwpck_require__(14681);
const util_base64_1 = __nccwpck_require__(75600);
const util_utf8_1 = __nccwpck_require__(41895);
const endpointResolver_1 = __nccwpck_require__(34887);
const getRuntimeConfig = (config) => {
    return {
        apiVersion: "2020-05-31",
        base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
        base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
        serviceId: config?.serviceId ?? "CloudFront",
        urlParser: config?.urlParser ?? url_parser_1.parseUrl,
        utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8,
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 44124:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveRuntimeExtensions = void 0;
const region_config_resolver_1 = __nccwpck_require__(18156);
const protocol_http_1 = __nccwpck_require__(64418);
const smithy_client_1 = __nccwpck_require__(63570);
const asPartial = (t) => t;
const resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
        ...asPartial((0, region_config_resolver_1.getAwsRegionExtensionConfiguration)(runtimeConfig)),
        ...asPartial((0, smithy_client_1.getDefaultExtensionConfiguration)(runtimeConfig)),
        ...asPartial((0, protocol_http_1.getHttpHandlerExtensionConfiguration)(runtimeConfig)),
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...(0, region_config_resolver_1.resolveAwsRegionExtensionConfiguration)(extensionConfiguration),
        ...(0, smithy_client_1.resolveDefaultRuntimeConfig)(extensionConfiguration),
        ...(0, protocol_http_1.resolveHttpHandlerRuntimeConfig)(extensionConfiguration),
    };
};
exports.resolveRuntimeExtensions = resolveRuntimeExtensions;


/***/ }),

/***/ 41467:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(16953), exports);
tslib_1.__exportStar(__nccwpck_require__(87835), exports);
tslib_1.__exportStar(__nccwpck_require__(95736), exports);


/***/ }),

/***/ 16953:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitUntilDistributionDeployed = exports.waitForDistributionDeployed = void 0;
const util_waiter_1 = __nccwpck_require__(78011);
const GetDistributionCommand_1 = __nccwpck_require__(13290);
const checkState = async (client, input) => {
    let reason;
    try {
        const result = await client.send(new GetDistributionCommand_1.GetDistributionCommand(input));
        reason = result;
        try {
            const returnComparator = () => {
                return result.Distribution.Status;
            };
            if (returnComparator() === "Deployed") {
                return { state: util_waiter_1.WaiterState.SUCCESS, reason };
            }
        }
        catch (e) { }
    }
    catch (exception) {
        reason = exception;
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
};
const waitForDistributionDeployed = async (params, input) => {
    const serviceDefaults = { minDelay: 60, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
};
exports.waitForDistributionDeployed = waitForDistributionDeployed;
const waitUntilDistributionDeployed = async (params, input) => {
    const serviceDefaults = { minDelay: 60, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
};
exports.waitUntilDistributionDeployed = waitUntilDistributionDeployed;


/***/ }),

/***/ 87835:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitUntilInvalidationCompleted = exports.waitForInvalidationCompleted = void 0;
const util_waiter_1 = __nccwpck_require__(78011);
const GetInvalidationCommand_1 = __nccwpck_require__(93931);
const checkState = async (client, input) => {
    let reason;
    try {
        const result = await client.send(new GetInvalidationCommand_1.GetInvalidationCommand(input));
        reason = result;
        try {
            const returnComparator = () => {
                return result.Invalidation.Status;
            };
            if (returnComparator() === "Completed") {
                return { state: util_waiter_1.WaiterState.SUCCESS, reason };
            }
        }
        catch (e) { }
    }
    catch (exception) {
        reason = exception;
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
};
const waitForInvalidationCompleted = async (params, input) => {
    const serviceDefaults = { minDelay: 20, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
};
exports.waitForInvalidationCompleted = waitForInvalidationCompleted;
const waitUntilInvalidationCompleted = async (params, input) => {
    const serviceDefaults = { minDelay: 20, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
};
exports.waitUntilInvalidationCompleted = waitUntilInvalidationCompleted;


/***/ }),

/***/ 95736:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitUntilStreamingDistributionDeployed = exports.waitForStreamingDistributionDeployed = void 0;
const util_waiter_1 = __nccwpck_require__(78011);
const GetStreamingDistributionCommand_1 = __nccwpck_require__(23846);
const checkState = async (client, input) => {
    let reason;
    try {
        const result = await client.send(new GetStreamingDistributionCommand_1.GetStreamingDistributionCommand(input));
        reason = result;
        try {
            const returnComparator = () => {
                return result.StreamingDistribution.Status;
            };
            if (returnComparator() === "Deployed") {
                return { state: util_waiter_1.WaiterState.SUCCESS, reason };
            }
        }
        catch (e) { }
    }
    catch (exception) {
        reason = exception;
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
};
const waitForStreamingDistributionDeployed = async (params, input) => {
    const serviceDefaults = { minDelay: 60, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
};
exports.waitForStreamingDistributionDeployed = waitForStreamingDistributionDeployed;
const waitUntilStreamingDistributionDeployed = async (params, input) => {
    const serviceDefaults = { minDelay: 60, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
};
exports.waitUntilStreamingDistributionDeployed = waitUntilStreamingDistributionDeployed;


/***/ }),

/***/ 67862:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.S3 = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const AbortMultipartUploadCommand_1 = __nccwpck_require__(99430);
const CompleteMultipartUploadCommand_1 = __nccwpck_require__(67313);
const CopyObjectCommand_1 = __nccwpck_require__(12953);
const CreateBucketCommand_1 = __nccwpck_require__(16512);
const CreateMultipartUploadCommand_1 = __nccwpck_require__(26994);
const CreateSessionCommand_1 = __nccwpck_require__(99162);
const DeleteBucketAnalyticsConfigurationCommand_1 = __nccwpck_require__(25909);
const DeleteBucketCommand_1 = __nccwpck_require__(67926);
const DeleteBucketCorsCommand_1 = __nccwpck_require__(85665);
const DeleteBucketEncryptionCommand_1 = __nccwpck_require__(65051);
const DeleteBucketIntelligentTieringConfigurationCommand_1 = __nccwpck_require__(16473);
const DeleteBucketInventoryConfigurationCommand_1 = __nccwpck_require__(68850);
const DeleteBucketLifecycleCommand_1 = __nccwpck_require__(36164);
const DeleteBucketMetricsConfigurationCommand_1 = __nccwpck_require__(17966);
const DeleteBucketOwnershipControlsCommand_1 = __nccwpck_require__(52476);
const DeleteBucketPolicyCommand_1 = __nccwpck_require__(55750);
const DeleteBucketReplicationCommand_1 = __nccwpck_require__(52572);
const DeleteBucketTaggingCommand_1 = __nccwpck_require__(36657);
const DeleteBucketWebsiteCommand_1 = __nccwpck_require__(45145);
const DeleteObjectCommand_1 = __nccwpck_require__(74256);
const DeleteObjectsCommand_1 = __nccwpck_require__(49614);
const DeleteObjectTaggingCommand_1 = __nccwpck_require__(73722);
const DeletePublicAccessBlockCommand_1 = __nccwpck_require__(72164);
const GetBucketAccelerateConfigurationCommand_1 = __nccwpck_require__(42101);
const GetBucketAclCommand_1 = __nccwpck_require__(7182);
const GetBucketAnalyticsConfigurationCommand_1 = __nccwpck_require__(16291);
const GetBucketCorsCommand_1 = __nccwpck_require__(98380);
const GetBucketEncryptionCommand_1 = __nccwpck_require__(57638);
const GetBucketIntelligentTieringConfigurationCommand_1 = __nccwpck_require__(84802);
const GetBucketInventoryConfigurationCommand_1 = __nccwpck_require__(54695);
const GetBucketLifecycleConfigurationCommand_1 = __nccwpck_require__(31335);
const GetBucketLocationCommand_1 = __nccwpck_require__(58353);
const GetBucketLoggingCommand_1 = __nccwpck_require__(22694);
const GetBucketMetricsConfigurationCommand_1 = __nccwpck_require__(62416);
const GetBucketNotificationConfigurationCommand_1 = __nccwpck_require__(41578);
const GetBucketOwnershipControlsCommand_1 = __nccwpck_require__(89515);
const GetBucketPolicyCommand_1 = __nccwpck_require__(50009);
const GetBucketPolicyStatusCommand_1 = __nccwpck_require__(99905);
const GetBucketReplicationCommand_1 = __nccwpck_require__(57194);
const GetBucketRequestPaymentCommand_1 = __nccwpck_require__(60199);
const GetBucketTaggingCommand_1 = __nccwpck_require__(38464);
const GetBucketVersioningCommand_1 = __nccwpck_require__(99497);
const GetBucketWebsiteCommand_1 = __nccwpck_require__(28346);
const GetObjectAclCommand_1 = __nccwpck_require__(31091);
const GetObjectAttributesCommand_1 = __nccwpck_require__(26888);
const GetObjectCommand_1 = __nccwpck_require__(34155);
const GetObjectLegalHoldCommand_1 = __nccwpck_require__(20141);
const GetObjectLockConfigurationCommand_1 = __nccwpck_require__(39079);
const GetObjectRetentionCommand_1 = __nccwpck_require__(75230);
const GetObjectTaggingCommand_1 = __nccwpck_require__(98360);
const GetObjectTorrentCommand_1 = __nccwpck_require__(11127);
const GetPublicAccessBlockCommand_1 = __nccwpck_require__(18158);
const HeadBucketCommand_1 = __nccwpck_require__(62121);
const HeadObjectCommand_1 = __nccwpck_require__(82375);
const ListBucketAnalyticsConfigurationsCommand_1 = __nccwpck_require__(85135);
const ListBucketIntelligentTieringConfigurationsCommand_1 = __nccwpck_require__(49557);
const ListBucketInventoryConfigurationsCommand_1 = __nccwpck_require__(70339);
const ListBucketMetricsConfigurationsCommand_1 = __nccwpck_require__(72760);
const ListBucketsCommand_1 = __nccwpck_require__(40175);
const ListDirectoryBucketsCommand_1 = __nccwpck_require__(68430);
const ListMultipartUploadsCommand_1 = __nccwpck_require__(92182);
const ListObjectsCommand_1 = __nccwpck_require__(2341);
const ListObjectsV2Command_1 = __nccwpck_require__(89368);
const ListObjectVersionsCommand_1 = __nccwpck_require__(44112);
const ListPartsCommand_1 = __nccwpck_require__(90896);
const PutBucketAccelerateConfigurationCommand_1 = __nccwpck_require__(66800);
const PutBucketAclCommand_1 = __nccwpck_require__(8231);
const PutBucketAnalyticsConfigurationCommand_1 = __nccwpck_require__(61183);
const PutBucketCorsCommand_1 = __nccwpck_require__(58803);
const PutBucketEncryptionCommand_1 = __nccwpck_require__(22761);
const PutBucketIntelligentTieringConfigurationCommand_1 = __nccwpck_require__(55516);
const PutBucketInventoryConfigurationCommand_1 = __nccwpck_require__(50738);
const PutBucketLifecycleConfigurationCommand_1 = __nccwpck_require__(954);
const PutBucketLoggingCommand_1 = __nccwpck_require__(35211);
const PutBucketMetricsConfigurationCommand_1 = __nccwpck_require__(18413);
const PutBucketNotificationConfigurationCommand_1 = __nccwpck_require__(19196);
const PutBucketOwnershipControlsCommand_1 = __nccwpck_require__(74396);
const PutBucketPolicyCommand_1 = __nccwpck_require__(27496);
const PutBucketReplicationCommand_1 = __nccwpck_require__(2219);
const PutBucketRequestPaymentCommand_1 = __nccwpck_require__(62481);
const PutBucketTaggingCommand_1 = __nccwpck_require__(4480);
const PutBucketVersioningCommand_1 = __nccwpck_require__(40327);
const PutBucketWebsiteCommand_1 = __nccwpck_require__(4317);
const PutObjectAclCommand_1 = __nccwpck_require__(75724);
const PutObjectCommand_1 = __nccwpck_require__(90825);
const PutObjectLegalHoldCommand_1 = __nccwpck_require__(27290);
const PutObjectLockConfigurationCommand_1 = __nccwpck_require__(164);
const PutObjectRetentionCommand_1 = __nccwpck_require__(79112);
const PutObjectTaggingCommand_1 = __nccwpck_require__(53236);
const PutPublicAccessBlockCommand_1 = __nccwpck_require__(40863);
const RestoreObjectCommand_1 = __nccwpck_require__(52613);
const SelectObjectContentCommand_1 = __nccwpck_require__(17980);
const UploadPartCommand_1 = __nccwpck_require__(49623);
const UploadPartCopyCommand_1 = __nccwpck_require__(63225);
const WriteGetObjectResponseCommand_1 = __nccwpck_require__(4107);
const S3Client_1 = __nccwpck_require__(22034);
const commands = {
    AbortMultipartUploadCommand: AbortMultipartUploadCommand_1.AbortMultipartUploadCommand,
    CompleteMultipartUploadCommand: CompleteMultipartUploadCommand_1.CompleteMultipartUploadCommand,
    CopyObjectCommand: CopyObjectCommand_1.CopyObjectCommand,
    CreateBucketCommand: CreateBucketCommand_1.CreateBucketCommand,
    CreateMultipartUploadCommand: CreateMultipartUploadCommand_1.CreateMultipartUploadCommand,
    CreateSessionCommand: CreateSessionCommand_1.CreateSessionCommand,
    DeleteBucketCommand: DeleteBucketCommand_1.DeleteBucketCommand,
    DeleteBucketAnalyticsConfigurationCommand: DeleteBucketAnalyticsConfigurationCommand_1.DeleteBucketAnalyticsConfigurationCommand,
    DeleteBucketCorsCommand: DeleteBucketCorsCommand_1.DeleteBucketCorsCommand,
    DeleteBucketEncryptionCommand: DeleteBucketEncryptionCommand_1.DeleteBucketEncryptionCommand,
    DeleteBucketIntelligentTieringConfigurationCommand: DeleteBucketIntelligentTieringConfigurationCommand_1.DeleteBucketIntelligentTieringConfigurationCommand,
    DeleteBucketInventoryConfigurationCommand: DeleteBucketInventoryConfigurationCommand_1.DeleteBucketInventoryConfigurationCommand,
    DeleteBucketLifecycleCommand: DeleteBucketLifecycleCommand_1.DeleteBucketLifecycleCommand,
    DeleteBucketMetricsConfigurationCommand: DeleteBucketMetricsConfigurationCommand_1.DeleteBucketMetricsConfigurationCommand,
    DeleteBucketOwnershipControlsCommand: DeleteBucketOwnershipControlsCommand_1.DeleteBucketOwnershipControlsCommand,
    DeleteBucketPolicyCommand: DeleteBucketPolicyCommand_1.DeleteBucketPolicyCommand,
    DeleteBucketReplicationCommand: DeleteBucketReplicationCommand_1.DeleteBucketReplicationCommand,
    DeleteBucketTaggingCommand: DeleteBucketTaggingCommand_1.DeleteBucketTaggingCommand,
    DeleteBucketWebsiteCommand: DeleteBucketWebsiteCommand_1.DeleteBucketWebsiteCommand,
    DeleteObjectCommand: DeleteObjectCommand_1.DeleteObjectCommand,
    DeleteObjectsCommand: DeleteObjectsCommand_1.DeleteObjectsCommand,
    DeleteObjectTaggingCommand: DeleteObjectTaggingCommand_1.DeleteObjectTaggingCommand,
    DeletePublicAccessBlockCommand: DeletePublicAccessBlockCommand_1.DeletePublicAccessBlockCommand,
    GetBucketAccelerateConfigurationCommand: GetBucketAccelerateConfigurationCommand_1.GetBucketAccelerateConfigurationCommand,
    GetBucketAclCommand: GetBucketAclCommand_1.GetBucketAclCommand,
    GetBucketAnalyticsConfigurationCommand: GetBucketAnalyticsConfigurationCommand_1.GetBucketAnalyticsConfigurationCommand,
    GetBucketCorsCommand: GetBucketCorsCommand_1.GetBucketCorsCommand,
    GetBucketEncryptionCommand: GetBucketEncryptionCommand_1.GetBucketEncryptionCommand,
    GetBucketIntelligentTieringConfigurationCommand: GetBucketIntelligentTieringConfigurationCommand_1.GetBucketIntelligentTieringConfigurationCommand,
    GetBucketInventoryConfigurationCommand: GetBucketInventoryConfigurationCommand_1.GetBucketInventoryConfigurationCommand,
    GetBucketLifecycleConfigurationCommand: GetBucketLifecycleConfigurationCommand_1.GetBucketLifecycleConfigurationCommand,
    GetBucketLocationCommand: GetBucketLocationCommand_1.GetBucketLocationCommand,
    GetBucketLoggingCommand: GetBucketLoggingCommand_1.GetBucketLoggingCommand,
    GetBucketMetricsConfigurationCommand: GetBucketMetricsConfigurationCommand_1.GetBucketMetricsConfigurationCommand,
    GetBucketNotificationConfigurationCommand: GetBucketNotificationConfigurationCommand_1.GetBucketNotificationConfigurationCommand,
    GetBucketOwnershipControlsCommand: GetBucketOwnershipControlsCommand_1.GetBucketOwnershipControlsCommand,
    GetBucketPolicyCommand: GetBucketPolicyCommand_1.GetBucketPolicyCommand,
    GetBucketPolicyStatusCommand: GetBucketPolicyStatusCommand_1.GetBucketPolicyStatusCommand,
    GetBucketReplicationCommand: GetBucketReplicationCommand_1.GetBucketReplicationCommand,
    GetBucketRequestPaymentCommand: GetBucketRequestPaymentCommand_1.GetBucketRequestPaymentCommand,
    GetBucketTaggingCommand: GetBucketTaggingCommand_1.GetBucketTaggingCommand,
    GetBucketVersioningCommand: GetBucketVersioningCommand_1.GetBucketVersioningCommand,
    GetBucketWebsiteCommand: GetBucketWebsiteCommand_1.GetBucketWebsiteCommand,
    GetObjectCommand: GetObjectCommand_1.GetObjectCommand,
    GetObjectAclCommand: GetObjectAclCommand_1.GetObjectAclCommand,
    GetObjectAttributesCommand: GetObjectAttributesCommand_1.GetObjectAttributesCommand,
    GetObjectLegalHoldCommand: GetObjectLegalHoldCommand_1.GetObjectLegalHoldCommand,
    GetObjectLockConfigurationCommand: GetObjectLockConfigurationCommand_1.GetObjectLockConfigurationCommand,
    GetObjectRetentionCommand: GetObjectRetentionCommand_1.GetObjectRetentionCommand,
    GetObjectTaggingCommand: GetObjectTaggingCommand_1.GetObjectTaggingCommand,
    GetObjectTorrentCommand: GetObjectTorrentCommand_1.GetObjectTorrentCommand,
    GetPublicAccessBlockCommand: GetPublicAccessBlockCommand_1.GetPublicAccessBlockCommand,
    HeadBucketCommand: HeadBucketCommand_1.HeadBucketCommand,
    HeadObjectCommand: HeadObjectCommand_1.HeadObjectCommand,
    ListBucketAnalyticsConfigurationsCommand: ListBucketAnalyticsConfigurationsCommand_1.ListBucketAnalyticsConfigurationsCommand,
    ListBucketIntelligentTieringConfigurationsCommand: ListBucketIntelligentTieringConfigurationsCommand_1.ListBucketIntelligentTieringConfigurationsCommand,
    ListBucketInventoryConfigurationsCommand: ListBucketInventoryConfigurationsCommand_1.ListBucketInventoryConfigurationsCommand,
    ListBucketMetricsConfigurationsCommand: ListBucketMetricsConfigurationsCommand_1.ListBucketMetricsConfigurationsCommand,
    ListBucketsCommand: ListBucketsCommand_1.ListBucketsCommand,
    ListDirectoryBucketsCommand: ListDirectoryBucketsCommand_1.ListDirectoryBucketsCommand,
    ListMultipartUploadsCommand: ListMultipartUploadsCommand_1.ListMultipartUploadsCommand,
    ListObjectsCommand: ListObjectsCommand_1.ListObjectsCommand,
    ListObjectsV2Command: ListObjectsV2Command_1.ListObjectsV2Command,
    ListObjectVersionsCommand: ListObjectVersionsCommand_1.ListObjectVersionsCommand,
    ListPartsCommand: ListPartsCommand_1.ListPartsCommand,
    PutBucketAccelerateConfigurationCommand: PutBucketAccelerateConfigurationCommand_1.PutBucketAccelerateConfigurationCommand,
    PutBucketAclCommand: PutBucketAclCommand_1.PutBucketAclCommand,
    PutBucketAnalyticsConfigurationCommand: PutBucketAnalyticsConfigurationCommand_1.PutBucketAnalyticsConfigurationCommand,
    PutBucketCorsCommand: PutBucketCorsCommand_1.PutBucketCorsCommand,
    PutBucketEncryptionCommand: PutBucketEncryptionCommand_1.PutBucketEncryptionCommand,
    PutBucketIntelligentTieringConfigurationCommand: PutBucketIntelligentTieringConfigurationCommand_1.PutBucketIntelligentTieringConfigurationCommand,
    PutBucketInventoryConfigurationCommand: PutBucketInventoryConfigurationCommand_1.PutBucketInventoryConfigurationCommand,
    PutBucketLifecycleConfigurationCommand: PutBucketLifecycleConfigurationCommand_1.PutBucketLifecycleConfigurationCommand,
    PutBucketLoggingCommand: PutBucketLoggingCommand_1.PutBucketLoggingCommand,
    PutBucketMetricsConfigurationCommand: PutBucketMetricsConfigurationCommand_1.PutBucketMetricsConfigurationCommand,
    PutBucketNotificationConfigurationCommand: PutBucketNotificationConfigurationCommand_1.PutBucketNotificationConfigurationCommand,
    PutBucketOwnershipControlsCommand: PutBucketOwnershipControlsCommand_1.PutBucketOwnershipControlsCommand,
    PutBucketPolicyCommand: PutBucketPolicyCommand_1.PutBucketPolicyCommand,
    PutBucketReplicationCommand: PutBucketReplicationCommand_1.PutBucketReplicationCommand,
    PutBucketRequestPaymentCommand: PutBucketRequestPaymentCommand_1.PutBucketRequestPaymentCommand,
    PutBucketTaggingCommand: PutBucketTaggingCommand_1.PutBucketTaggingCommand,
    PutBucketVersioningCommand: PutBucketVersioningCommand_1.PutBucketVersioningCommand,
    PutBucketWebsiteCommand: PutBucketWebsiteCommand_1.PutBucketWebsiteCommand,
    PutObjectCommand: PutObjectCommand_1.PutObjectCommand,
    PutObjectAclCommand: PutObjectAclCommand_1.PutObjectAclCommand,
    PutObjectLegalHoldCommand: PutObjectLegalHoldCommand_1.PutObjectLegalHoldCommand,
    PutObjectLockConfigurationCommand: PutObjectLockConfigurationCommand_1.PutObjectLockConfigurationCommand,
    PutObjectRetentionCommand: PutObjectRetentionCommand_1.PutObjectRetentionCommand,
    PutObjectTaggingCommand: PutObjectTaggingCommand_1.PutObjectTaggingCommand,
    PutPublicAccessBlockCommand: PutPublicAccessBlockCommand_1.PutPublicAccessBlockCommand,
    RestoreObjectCommand: RestoreObjectCommand_1.RestoreObjectCommand,
    SelectObjectContentCommand: SelectObjectContentCommand_1.SelectObjectContentCommand,
    UploadPartCommand: UploadPartCommand_1.UploadPartCommand,
    UploadPartCopyCommand: UploadPartCopyCommand_1.UploadPartCopyCommand,
    WriteGetObjectResponseCommand: WriteGetObjectResponseCommand_1.WriteGetObjectResponseCommand,
};
class S3 extends S3Client_1.S3Client {
}
exports.S3 = S3;
(0, smithy_client_1.createAggregatedClient)(commands, S3);


/***/ }),

/***/ 22034:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.S3Client = exports.__Client = void 0;
const middleware_expect_continue_1 = __nccwpck_require__(81990);
const middleware_host_header_1 = __nccwpck_require__(22545);
const middleware_logger_1 = __nccwpck_require__(20014);
const middleware_recursion_detection_1 = __nccwpck_require__(85525);
const middleware_sdk_s3_1 = __nccwpck_require__(81139);
const middleware_signing_1 = __nccwpck_require__(14935);
const middleware_user_agent_1 = __nccwpck_require__(64688);
const config_resolver_1 = __nccwpck_require__(53098);
const eventstream_serde_config_resolver_1 = __nccwpck_require__(16181);
const middleware_content_length_1 = __nccwpck_require__(82800);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_retry_1 = __nccwpck_require__(96039);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "__Client", ({ enumerable: true, get: function () { return smithy_client_1.Client; } }));
const CreateSessionCommand_1 = __nccwpck_require__(99162);
const EndpointParameters_1 = __nccwpck_require__(15122);
const runtimeConfig_1 = __nccwpck_require__(12714);
const runtimeExtensions_1 = __nccwpck_require__(44875);
class S3Client extends smithy_client_1.Client {
    constructor(...[configuration]) {
        const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration || {});
        const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_signing_1.resolveAwsAuthConfig)(_config_5);
        const _config_7 = (0, middleware_sdk_s3_1.resolveS3Config)(_config_6, { session: [() => this, CreateSessionCommand_1.CreateSessionCommand] });
        const _config_8 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_7);
        const _config_9 = (0, eventstream_serde_config_resolver_1.resolveEventStreamSerdeConfig)(_config_8);
        const _config_10 = (0, runtimeExtensions_1.resolveRuntimeExtensions)(_config_9, configuration?.extensions || []);
        super(_config_10);
        this.config = _config_10;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_sdk_s3_1.getValidateBucketNamePlugin)(this.config));
        this.middlewareStack.use((0, middleware_expect_continue_1.getAddExpectContinuePlugin)(this.config));
        this.middlewareStack.use((0, middleware_sdk_s3_1.getRegionRedirectMiddlewarePlugin)(this.config));
        this.middlewareStack.use((0, middleware_sdk_s3_1.getS3ExpressPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}
exports.S3Client = S3Client;


/***/ }),

/***/ 99430:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbortMultipartUploadCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class AbortMultipartUploadCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "AbortMultipartUpload", {})
    .n("S3Client", "AbortMultipartUploadCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_AbortMultipartUploadCommand)
    .de(Aws_restXml_1.de_AbortMultipartUploadCommand)
    .build() {
}
exports.AbortMultipartUploadCommand = AbortMultipartUploadCommand;


/***/ }),

/***/ 67313:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompleteMultipartUploadCommand = exports.$Command = void 0;
const middleware_sdk_s3_1 = __nccwpck_require__(81139);
const middleware_ssec_1 = __nccwpck_require__(49718);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_0_1 = __nccwpck_require__(51628);
const Aws_restXml_1 = __nccwpck_require__(39809);
class CompleteMultipartUploadCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_sdk_s3_1.getThrow200ExceptionsPlugin)(config),
        (0, middleware_ssec_1.getSsecPlugin)(config),
    ];
})
    .s("AmazonS3", "CompleteMultipartUpload", {})
    .n("S3Client", "CompleteMultipartUploadCommand")
    .f(models_0_1.CompleteMultipartUploadRequestFilterSensitiveLog, models_0_1.CompleteMultipartUploadOutputFilterSensitiveLog)
    .ser(Aws_restXml_1.se_CompleteMultipartUploadCommand)
    .de(Aws_restXml_1.de_CompleteMultipartUploadCommand)
    .build() {
}
exports.CompleteMultipartUploadCommand = CompleteMultipartUploadCommand;


/***/ }),

/***/ 12953:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CopyObjectCommand = exports.$Command = void 0;
const middleware_sdk_s3_1 = __nccwpck_require__(81139);
const middleware_ssec_1 = __nccwpck_require__(49718);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_0_1 = __nccwpck_require__(51628);
const Aws_restXml_1 = __nccwpck_require__(39809);
class CopyObjectCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_sdk_s3_1.getThrow200ExceptionsPlugin)(config),
        (0, middleware_ssec_1.getSsecPlugin)(config),
    ];
})
    .s("AmazonS3", "CopyObject", {})
    .n("S3Client", "CopyObjectCommand")
    .f(models_0_1.CopyObjectRequestFilterSensitiveLog, models_0_1.CopyObjectOutputFilterSensitiveLog)
    .ser(Aws_restXml_1.se_CopyObjectCommand)
    .de(Aws_restXml_1.de_CopyObjectCommand)
    .build() {
}
exports.CopyObjectCommand = CopyObjectCommand;


/***/ }),

/***/ 16512:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateBucketCommand = exports.$Command = void 0;
const middleware_location_constraint_1 = __nccwpck_require__(42098);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class CreateBucketCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    DisableAccessPoints: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_location_constraint_1.getLocationConstraintPlugin)(config),
    ];
})
    .s("AmazonS3", "CreateBucket", {})
    .n("S3Client", "CreateBucketCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_CreateBucketCommand)
    .de(Aws_restXml_1.de_CreateBucketCommand)
    .build() {
}
exports.CreateBucketCommand = CreateBucketCommand;


/***/ }),

/***/ 26994:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateMultipartUploadCommand = exports.$Command = void 0;
const middleware_ssec_1 = __nccwpck_require__(49718);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_0_1 = __nccwpck_require__(51628);
const Aws_restXml_1 = __nccwpck_require__(39809);
class CreateMultipartUploadCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_ssec_1.getSsecPlugin)(config),
    ];
})
    .s("AmazonS3", "CreateMultipartUpload", {})
    .n("S3Client", "CreateMultipartUploadCommand")
    .f(models_0_1.CreateMultipartUploadRequestFilterSensitiveLog, models_0_1.CreateMultipartUploadOutputFilterSensitiveLog)
    .ser(Aws_restXml_1.se_CreateMultipartUploadCommand)
    .de(Aws_restXml_1.de_CreateMultipartUploadCommand)
    .build() {
}
exports.CreateMultipartUploadCommand = CreateMultipartUploadCommand;


/***/ }),

/***/ 99162:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateSessionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_0_1 = __nccwpck_require__(51628);
const Aws_restXml_1 = __nccwpck_require__(39809);
class CreateSessionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "CreateSession", {})
    .n("S3Client", "CreateSessionCommand")
    .f(void 0, models_0_1.CreateSessionOutputFilterSensitiveLog)
    .ser(Aws_restXml_1.se_CreateSessionCommand)
    .de(Aws_restXml_1.de_CreateSessionCommand)
    .build() {
}
exports.CreateSessionCommand = CreateSessionCommand;


/***/ }),

/***/ 25909:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteBucketAnalyticsConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class DeleteBucketAnalyticsConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "DeleteBucketAnalyticsConfiguration", {})
    .n("S3Client", "DeleteBucketAnalyticsConfigurationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteBucketAnalyticsConfigurationCommand)
    .de(Aws_restXml_1.de_DeleteBucketAnalyticsConfigurationCommand)
    .build() {
}
exports.DeleteBucketAnalyticsConfigurationCommand = DeleteBucketAnalyticsConfigurationCommand;


/***/ }),

/***/ 67926:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteBucketCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class DeleteBucketCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "DeleteBucket", {})
    .n("S3Client", "DeleteBucketCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteBucketCommand)
    .de(Aws_restXml_1.de_DeleteBucketCommand)
    .build() {
}
exports.DeleteBucketCommand = DeleteBucketCommand;


/***/ }),

/***/ 85665:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteBucketCorsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class DeleteBucketCorsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "DeleteBucketCors", {})
    .n("S3Client", "DeleteBucketCorsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteBucketCorsCommand)
    .de(Aws_restXml_1.de_DeleteBucketCorsCommand)
    .build() {
}
exports.DeleteBucketCorsCommand = DeleteBucketCorsCommand;


/***/ }),

/***/ 65051:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteBucketEncryptionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class DeleteBucketEncryptionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "DeleteBucketEncryption", {})
    .n("S3Client", "DeleteBucketEncryptionCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteBucketEncryptionCommand)
    .de(Aws_restXml_1.de_DeleteBucketEncryptionCommand)
    .build() {
}
exports.DeleteBucketEncryptionCommand = DeleteBucketEncryptionCommand;


/***/ }),

/***/ 16473:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteBucketIntelligentTieringConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class DeleteBucketIntelligentTieringConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "DeleteBucketIntelligentTieringConfiguration", {})
    .n("S3Client", "DeleteBucketIntelligentTieringConfigurationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteBucketIntelligentTieringConfigurationCommand)
    .de(Aws_restXml_1.de_DeleteBucketIntelligentTieringConfigurationCommand)
    .build() {
}
exports.DeleteBucketIntelligentTieringConfigurationCommand = DeleteBucketIntelligentTieringConfigurationCommand;


/***/ }),

/***/ 68850:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteBucketInventoryConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class DeleteBucketInventoryConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "DeleteBucketInventoryConfiguration", {})
    .n("S3Client", "DeleteBucketInventoryConfigurationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteBucketInventoryConfigurationCommand)
    .de(Aws_restXml_1.de_DeleteBucketInventoryConfigurationCommand)
    .build() {
}
exports.DeleteBucketInventoryConfigurationCommand = DeleteBucketInventoryConfigurationCommand;


/***/ }),

/***/ 36164:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteBucketLifecycleCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class DeleteBucketLifecycleCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "DeleteBucketLifecycle", {})
    .n("S3Client", "DeleteBucketLifecycleCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteBucketLifecycleCommand)
    .de(Aws_restXml_1.de_DeleteBucketLifecycleCommand)
    .build() {
}
exports.DeleteBucketLifecycleCommand = DeleteBucketLifecycleCommand;


/***/ }),

/***/ 17966:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteBucketMetricsConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class DeleteBucketMetricsConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "DeleteBucketMetricsConfiguration", {})
    .n("S3Client", "DeleteBucketMetricsConfigurationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteBucketMetricsConfigurationCommand)
    .de(Aws_restXml_1.de_DeleteBucketMetricsConfigurationCommand)
    .build() {
}
exports.DeleteBucketMetricsConfigurationCommand = DeleteBucketMetricsConfigurationCommand;


/***/ }),

/***/ 52476:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteBucketOwnershipControlsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class DeleteBucketOwnershipControlsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "DeleteBucketOwnershipControls", {})
    .n("S3Client", "DeleteBucketOwnershipControlsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteBucketOwnershipControlsCommand)
    .de(Aws_restXml_1.de_DeleteBucketOwnershipControlsCommand)
    .build() {
}
exports.DeleteBucketOwnershipControlsCommand = DeleteBucketOwnershipControlsCommand;


/***/ }),

/***/ 55750:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteBucketPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class DeleteBucketPolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "DeleteBucketPolicy", {})
    .n("S3Client", "DeleteBucketPolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteBucketPolicyCommand)
    .de(Aws_restXml_1.de_DeleteBucketPolicyCommand)
    .build() {
}
exports.DeleteBucketPolicyCommand = DeleteBucketPolicyCommand;


/***/ }),

/***/ 52572:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteBucketReplicationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class DeleteBucketReplicationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "DeleteBucketReplication", {})
    .n("S3Client", "DeleteBucketReplicationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteBucketReplicationCommand)
    .de(Aws_restXml_1.de_DeleteBucketReplicationCommand)
    .build() {
}
exports.DeleteBucketReplicationCommand = DeleteBucketReplicationCommand;


/***/ }),

/***/ 36657:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteBucketTaggingCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class DeleteBucketTaggingCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "DeleteBucketTagging", {})
    .n("S3Client", "DeleteBucketTaggingCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteBucketTaggingCommand)
    .de(Aws_restXml_1.de_DeleteBucketTaggingCommand)
    .build() {
}
exports.DeleteBucketTaggingCommand = DeleteBucketTaggingCommand;


/***/ }),

/***/ 45145:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteBucketWebsiteCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class DeleteBucketWebsiteCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "DeleteBucketWebsite", {})
    .n("S3Client", "DeleteBucketWebsiteCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteBucketWebsiteCommand)
    .de(Aws_restXml_1.de_DeleteBucketWebsiteCommand)
    .build() {
}
exports.DeleteBucketWebsiteCommand = DeleteBucketWebsiteCommand;


/***/ }),

/***/ 74256:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteObjectCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class DeleteObjectCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "DeleteObject", {})
    .n("S3Client", "DeleteObjectCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteObjectCommand)
    .de(Aws_restXml_1.de_DeleteObjectCommand)
    .build() {
}
exports.DeleteObjectCommand = DeleteObjectCommand;


/***/ }),

/***/ 73722:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteObjectTaggingCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class DeleteObjectTaggingCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "DeleteObjectTagging", {})
    .n("S3Client", "DeleteObjectTaggingCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteObjectTaggingCommand)
    .de(Aws_restXml_1.de_DeleteObjectTaggingCommand)
    .build() {
}
exports.DeleteObjectTaggingCommand = DeleteObjectTaggingCommand;


/***/ }),

/***/ 49614:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteObjectsCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class DeleteObjectsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true,
        }),
    ];
})
    .s("AmazonS3", "DeleteObjects", {})
    .n("S3Client", "DeleteObjectsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeleteObjectsCommand)
    .de(Aws_restXml_1.de_DeleteObjectsCommand)
    .build() {
}
exports.DeleteObjectsCommand = DeleteObjectsCommand;


/***/ }),

/***/ 72164:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeletePublicAccessBlockCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class DeletePublicAccessBlockCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "DeletePublicAccessBlock", {})
    .n("S3Client", "DeletePublicAccessBlockCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_DeletePublicAccessBlockCommand)
    .de(Aws_restXml_1.de_DeletePublicAccessBlockCommand)
    .build() {
}
exports.DeletePublicAccessBlockCommand = DeletePublicAccessBlockCommand;


/***/ }),

/***/ 42101:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketAccelerateConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketAccelerateConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketAccelerateConfiguration", {})
    .n("S3Client", "GetBucketAccelerateConfigurationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetBucketAccelerateConfigurationCommand)
    .de(Aws_restXml_1.de_GetBucketAccelerateConfigurationCommand)
    .build() {
}
exports.GetBucketAccelerateConfigurationCommand = GetBucketAccelerateConfigurationCommand;


/***/ }),

/***/ 7182:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketAclCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketAclCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketAcl", {})
    .n("S3Client", "GetBucketAclCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetBucketAclCommand)
    .de(Aws_restXml_1.de_GetBucketAclCommand)
    .build() {
}
exports.GetBucketAclCommand = GetBucketAclCommand;


/***/ }),

/***/ 16291:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketAnalyticsConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketAnalyticsConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketAnalyticsConfiguration", {})
    .n("S3Client", "GetBucketAnalyticsConfigurationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetBucketAnalyticsConfigurationCommand)
    .de(Aws_restXml_1.de_GetBucketAnalyticsConfigurationCommand)
    .build() {
}
exports.GetBucketAnalyticsConfigurationCommand = GetBucketAnalyticsConfigurationCommand;


/***/ }),

/***/ 98380:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketCorsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketCorsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketCors", {})
    .n("S3Client", "GetBucketCorsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetBucketCorsCommand)
    .de(Aws_restXml_1.de_GetBucketCorsCommand)
    .build() {
}
exports.GetBucketCorsCommand = GetBucketCorsCommand;


/***/ }),

/***/ 57638:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketEncryptionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_0_1 = __nccwpck_require__(51628);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketEncryptionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketEncryption", {})
    .n("S3Client", "GetBucketEncryptionCommand")
    .f(void 0, models_0_1.GetBucketEncryptionOutputFilterSensitiveLog)
    .ser(Aws_restXml_1.se_GetBucketEncryptionCommand)
    .de(Aws_restXml_1.de_GetBucketEncryptionCommand)
    .build() {
}
exports.GetBucketEncryptionCommand = GetBucketEncryptionCommand;


/***/ }),

/***/ 84802:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketIntelligentTieringConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketIntelligentTieringConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketIntelligentTieringConfiguration", {})
    .n("S3Client", "GetBucketIntelligentTieringConfigurationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetBucketIntelligentTieringConfigurationCommand)
    .de(Aws_restXml_1.de_GetBucketIntelligentTieringConfigurationCommand)
    .build() {
}
exports.GetBucketIntelligentTieringConfigurationCommand = GetBucketIntelligentTieringConfigurationCommand;


/***/ }),

/***/ 54695:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketInventoryConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_0_1 = __nccwpck_require__(51628);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketInventoryConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketInventoryConfiguration", {})
    .n("S3Client", "GetBucketInventoryConfigurationCommand")
    .f(void 0, models_0_1.GetBucketInventoryConfigurationOutputFilterSensitiveLog)
    .ser(Aws_restXml_1.se_GetBucketInventoryConfigurationCommand)
    .de(Aws_restXml_1.de_GetBucketInventoryConfigurationCommand)
    .build() {
}
exports.GetBucketInventoryConfigurationCommand = GetBucketInventoryConfigurationCommand;


/***/ }),

/***/ 31335:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketLifecycleConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketLifecycleConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketLifecycleConfiguration", {})
    .n("S3Client", "GetBucketLifecycleConfigurationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetBucketLifecycleConfigurationCommand)
    .de(Aws_restXml_1.de_GetBucketLifecycleConfigurationCommand)
    .build() {
}
exports.GetBucketLifecycleConfigurationCommand = GetBucketLifecycleConfigurationCommand;


/***/ }),

/***/ 58353:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketLocationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketLocationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketLocation", {})
    .n("S3Client", "GetBucketLocationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetBucketLocationCommand)
    .de(Aws_restXml_1.de_GetBucketLocationCommand)
    .build() {
}
exports.GetBucketLocationCommand = GetBucketLocationCommand;


/***/ }),

/***/ 22694:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketLoggingCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketLoggingCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketLogging", {})
    .n("S3Client", "GetBucketLoggingCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetBucketLoggingCommand)
    .de(Aws_restXml_1.de_GetBucketLoggingCommand)
    .build() {
}
exports.GetBucketLoggingCommand = GetBucketLoggingCommand;


/***/ }),

/***/ 62416:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketMetricsConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketMetricsConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketMetricsConfiguration", {})
    .n("S3Client", "GetBucketMetricsConfigurationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetBucketMetricsConfigurationCommand)
    .de(Aws_restXml_1.de_GetBucketMetricsConfigurationCommand)
    .build() {
}
exports.GetBucketMetricsConfigurationCommand = GetBucketMetricsConfigurationCommand;


/***/ }),

/***/ 41578:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketNotificationConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketNotificationConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketNotificationConfiguration", {})
    .n("S3Client", "GetBucketNotificationConfigurationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetBucketNotificationConfigurationCommand)
    .de(Aws_restXml_1.de_GetBucketNotificationConfigurationCommand)
    .build() {
}
exports.GetBucketNotificationConfigurationCommand = GetBucketNotificationConfigurationCommand;


/***/ }),

/***/ 89515:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketOwnershipControlsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketOwnershipControlsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketOwnershipControls", {})
    .n("S3Client", "GetBucketOwnershipControlsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetBucketOwnershipControlsCommand)
    .de(Aws_restXml_1.de_GetBucketOwnershipControlsCommand)
    .build() {
}
exports.GetBucketOwnershipControlsCommand = GetBucketOwnershipControlsCommand;


/***/ }),

/***/ 50009:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketPolicyCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketPolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketPolicy", {})
    .n("S3Client", "GetBucketPolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetBucketPolicyCommand)
    .de(Aws_restXml_1.de_GetBucketPolicyCommand)
    .build() {
}
exports.GetBucketPolicyCommand = GetBucketPolicyCommand;


/***/ }),

/***/ 99905:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketPolicyStatusCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketPolicyStatusCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketPolicyStatus", {})
    .n("S3Client", "GetBucketPolicyStatusCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetBucketPolicyStatusCommand)
    .de(Aws_restXml_1.de_GetBucketPolicyStatusCommand)
    .build() {
}
exports.GetBucketPolicyStatusCommand = GetBucketPolicyStatusCommand;


/***/ }),

/***/ 57194:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketReplicationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketReplicationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketReplication", {})
    .n("S3Client", "GetBucketReplicationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetBucketReplicationCommand)
    .de(Aws_restXml_1.de_GetBucketReplicationCommand)
    .build() {
}
exports.GetBucketReplicationCommand = GetBucketReplicationCommand;


/***/ }),

/***/ 60199:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketRequestPaymentCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketRequestPaymentCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketRequestPayment", {})
    .n("S3Client", "GetBucketRequestPaymentCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetBucketRequestPaymentCommand)
    .de(Aws_restXml_1.de_GetBucketRequestPaymentCommand)
    .build() {
}
exports.GetBucketRequestPaymentCommand = GetBucketRequestPaymentCommand;


/***/ }),

/***/ 38464:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketTaggingCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketTaggingCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketTagging", {})
    .n("S3Client", "GetBucketTaggingCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetBucketTaggingCommand)
    .de(Aws_restXml_1.de_GetBucketTaggingCommand)
    .build() {
}
exports.GetBucketTaggingCommand = GetBucketTaggingCommand;


/***/ }),

/***/ 99497:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketVersioningCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketVersioningCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketVersioning", {})
    .n("S3Client", "GetBucketVersioningCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetBucketVersioningCommand)
    .de(Aws_restXml_1.de_GetBucketVersioningCommand)
    .build() {
}
exports.GetBucketVersioningCommand = GetBucketVersioningCommand;


/***/ }),

/***/ 28346:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBucketWebsiteCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetBucketWebsiteCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetBucketWebsite", {})
    .n("S3Client", "GetBucketWebsiteCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetBucketWebsiteCommand)
    .de(Aws_restXml_1.de_GetBucketWebsiteCommand)
    .build() {
}
exports.GetBucketWebsiteCommand = GetBucketWebsiteCommand;


/***/ }),

/***/ 31091:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetObjectAclCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetObjectAclCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetObjectAcl", {})
    .n("S3Client", "GetObjectAclCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetObjectAclCommand)
    .de(Aws_restXml_1.de_GetObjectAclCommand)
    .build() {
}
exports.GetObjectAclCommand = GetObjectAclCommand;


/***/ }),

/***/ 26888:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetObjectAttributesCommand = exports.$Command = void 0;
const middleware_ssec_1 = __nccwpck_require__(49718);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_0_1 = __nccwpck_require__(51628);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetObjectAttributesCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_ssec_1.getSsecPlugin)(config),
    ];
})
    .s("AmazonS3", "GetObjectAttributes", {})
    .n("S3Client", "GetObjectAttributesCommand")
    .f(models_0_1.GetObjectAttributesRequestFilterSensitiveLog, void 0)
    .ser(Aws_restXml_1.se_GetObjectAttributesCommand)
    .de(Aws_restXml_1.de_GetObjectAttributesCommand)
    .build() {
}
exports.GetObjectAttributesCommand = GetObjectAttributesCommand;


/***/ }),

/***/ 34155:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetObjectCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_ssec_1 = __nccwpck_require__(49718);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_0_1 = __nccwpck_require__(51628);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetObjectCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_ssec_1.getSsecPlugin)(config),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestChecksumRequired: false,
            requestValidationModeMember: "ChecksumMode",
            responseAlgorithms: ["CRC32", "CRC32C", "SHA256", "SHA1"],
        }),
    ];
})
    .s("AmazonS3", "GetObject", {})
    .n("S3Client", "GetObjectCommand")
    .f(models_0_1.GetObjectRequestFilterSensitiveLog, models_0_1.GetObjectOutputFilterSensitiveLog)
    .ser(Aws_restXml_1.se_GetObjectCommand)
    .de(Aws_restXml_1.de_GetObjectCommand)
    .build() {
}
exports.GetObjectCommand = GetObjectCommand;


/***/ }),

/***/ 20141:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetObjectLegalHoldCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetObjectLegalHoldCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetObjectLegalHold", {})
    .n("S3Client", "GetObjectLegalHoldCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetObjectLegalHoldCommand)
    .de(Aws_restXml_1.de_GetObjectLegalHoldCommand)
    .build() {
}
exports.GetObjectLegalHoldCommand = GetObjectLegalHoldCommand;


/***/ }),

/***/ 39079:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetObjectLockConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetObjectLockConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetObjectLockConfiguration", {})
    .n("S3Client", "GetObjectLockConfigurationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetObjectLockConfigurationCommand)
    .de(Aws_restXml_1.de_GetObjectLockConfigurationCommand)
    .build() {
}
exports.GetObjectLockConfigurationCommand = GetObjectLockConfigurationCommand;


/***/ }),

/***/ 75230:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetObjectRetentionCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetObjectRetentionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetObjectRetention", {})
    .n("S3Client", "GetObjectRetentionCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetObjectRetentionCommand)
    .de(Aws_restXml_1.de_GetObjectRetentionCommand)
    .build() {
}
exports.GetObjectRetentionCommand = GetObjectRetentionCommand;


/***/ }),

/***/ 98360:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetObjectTaggingCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetObjectTaggingCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetObjectTagging", {})
    .n("S3Client", "GetObjectTaggingCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetObjectTaggingCommand)
    .de(Aws_restXml_1.de_GetObjectTaggingCommand)
    .build() {
}
exports.GetObjectTaggingCommand = GetObjectTaggingCommand;


/***/ }),

/***/ 11127:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetObjectTorrentCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_0_1 = __nccwpck_require__(51628);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetObjectTorrentCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetObjectTorrent", {})
    .n("S3Client", "GetObjectTorrentCommand")
    .f(void 0, models_0_1.GetObjectTorrentOutputFilterSensitiveLog)
    .ser(Aws_restXml_1.se_GetObjectTorrentCommand)
    .de(Aws_restXml_1.de_GetObjectTorrentCommand)
    .build() {
}
exports.GetObjectTorrentCommand = GetObjectTorrentCommand;


/***/ }),

/***/ 18158:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetPublicAccessBlockCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class GetPublicAccessBlockCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "GetPublicAccessBlock", {})
    .n("S3Client", "GetPublicAccessBlockCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_GetPublicAccessBlockCommand)
    .de(Aws_restXml_1.de_GetPublicAccessBlockCommand)
    .build() {
}
exports.GetPublicAccessBlockCommand = GetPublicAccessBlockCommand;


/***/ }),

/***/ 62121:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeadBucketCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class HeadBucketCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "HeadBucket", {})
    .n("S3Client", "HeadBucketCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_HeadBucketCommand)
    .de(Aws_restXml_1.de_HeadBucketCommand)
    .build() {
}
exports.HeadBucketCommand = HeadBucketCommand;


/***/ }),

/***/ 82375:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeadObjectCommand = exports.$Command = void 0;
const middleware_ssec_1 = __nccwpck_require__(49718);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_0_1 = __nccwpck_require__(51628);
const Aws_restXml_1 = __nccwpck_require__(39809);
class HeadObjectCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_ssec_1.getSsecPlugin)(config),
    ];
})
    .s("AmazonS3", "HeadObject", {})
    .n("S3Client", "HeadObjectCommand")
    .f(models_0_1.HeadObjectRequestFilterSensitiveLog, models_0_1.HeadObjectOutputFilterSensitiveLog)
    .ser(Aws_restXml_1.se_HeadObjectCommand)
    .de(Aws_restXml_1.de_HeadObjectCommand)
    .build() {
}
exports.HeadObjectCommand = HeadObjectCommand;


/***/ }),

/***/ 85135:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListBucketAnalyticsConfigurationsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class ListBucketAnalyticsConfigurationsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "ListBucketAnalyticsConfigurations", {})
    .n("S3Client", "ListBucketAnalyticsConfigurationsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListBucketAnalyticsConfigurationsCommand)
    .de(Aws_restXml_1.de_ListBucketAnalyticsConfigurationsCommand)
    .build() {
}
exports.ListBucketAnalyticsConfigurationsCommand = ListBucketAnalyticsConfigurationsCommand;


/***/ }),

/***/ 49557:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListBucketIntelligentTieringConfigurationsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class ListBucketIntelligentTieringConfigurationsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "ListBucketIntelligentTieringConfigurations", {})
    .n("S3Client", "ListBucketIntelligentTieringConfigurationsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListBucketIntelligentTieringConfigurationsCommand)
    .de(Aws_restXml_1.de_ListBucketIntelligentTieringConfigurationsCommand)
    .build() {
}
exports.ListBucketIntelligentTieringConfigurationsCommand = ListBucketIntelligentTieringConfigurationsCommand;


/***/ }),

/***/ 70339:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListBucketInventoryConfigurationsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_0_1 = __nccwpck_require__(51628);
const Aws_restXml_1 = __nccwpck_require__(39809);
class ListBucketInventoryConfigurationsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "ListBucketInventoryConfigurations", {})
    .n("S3Client", "ListBucketInventoryConfigurationsCommand")
    .f(void 0, models_0_1.ListBucketInventoryConfigurationsOutputFilterSensitiveLog)
    .ser(Aws_restXml_1.se_ListBucketInventoryConfigurationsCommand)
    .de(Aws_restXml_1.de_ListBucketInventoryConfigurationsCommand)
    .build() {
}
exports.ListBucketInventoryConfigurationsCommand = ListBucketInventoryConfigurationsCommand;


/***/ }),

/***/ 72760:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListBucketMetricsConfigurationsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class ListBucketMetricsConfigurationsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "ListBucketMetricsConfigurations", {})
    .n("S3Client", "ListBucketMetricsConfigurationsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListBucketMetricsConfigurationsCommand)
    .de(Aws_restXml_1.de_ListBucketMetricsConfigurationsCommand)
    .build() {
}
exports.ListBucketMetricsConfigurationsCommand = ListBucketMetricsConfigurationsCommand;


/***/ }),

/***/ 40175:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListBucketsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class ListBucketsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "ListBuckets", {})
    .n("S3Client", "ListBucketsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListBucketsCommand)
    .de(Aws_restXml_1.de_ListBucketsCommand)
    .build() {
}
exports.ListBucketsCommand = ListBucketsCommand;


/***/ }),

/***/ 68430:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListDirectoryBucketsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class ListDirectoryBucketsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "ListDirectoryBuckets", {})
    .n("S3Client", "ListDirectoryBucketsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListDirectoryBucketsCommand)
    .de(Aws_restXml_1.de_ListDirectoryBucketsCommand)
    .build() {
}
exports.ListDirectoryBucketsCommand = ListDirectoryBucketsCommand;


/***/ }),

/***/ 92182:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListMultipartUploadsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class ListMultipartUploadsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Prefix: { type: "contextParams", name: "Prefix" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "ListMultipartUploads", {})
    .n("S3Client", "ListMultipartUploadsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListMultipartUploadsCommand)
    .de(Aws_restXml_1.de_ListMultipartUploadsCommand)
    .build() {
}
exports.ListMultipartUploadsCommand = ListMultipartUploadsCommand;


/***/ }),

/***/ 44112:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListObjectVersionsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class ListObjectVersionsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Prefix: { type: "contextParams", name: "Prefix" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "ListObjectVersions", {})
    .n("S3Client", "ListObjectVersionsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListObjectVersionsCommand)
    .de(Aws_restXml_1.de_ListObjectVersionsCommand)
    .build() {
}
exports.ListObjectVersionsCommand = ListObjectVersionsCommand;


/***/ }),

/***/ 2341:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListObjectsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class ListObjectsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Prefix: { type: "contextParams", name: "Prefix" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "ListObjects", {})
    .n("S3Client", "ListObjectsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListObjectsCommand)
    .de(Aws_restXml_1.de_ListObjectsCommand)
    .build() {
}
exports.ListObjectsCommand = ListObjectsCommand;


/***/ }),

/***/ 89368:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListObjectsV2Command = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class ListObjectsV2Command extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Prefix: { type: "contextParams", name: "Prefix" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "ListObjectsV2", {})
    .n("S3Client", "ListObjectsV2Command")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_ListObjectsV2Command)
    .de(Aws_restXml_1.de_ListObjectsV2Command)
    .build() {
}
exports.ListObjectsV2Command = ListObjectsV2Command;


/***/ }),

/***/ 90896:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListPartsCommand = exports.$Command = void 0;
const middleware_ssec_1 = __nccwpck_require__(49718);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_0_1 = __nccwpck_require__(51628);
const Aws_restXml_1 = __nccwpck_require__(39809);
class ListPartsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_ssec_1.getSsecPlugin)(config),
    ];
})
    .s("AmazonS3", "ListParts", {})
    .n("S3Client", "ListPartsCommand")
    .f(models_0_1.ListPartsRequestFilterSensitiveLog, void 0)
    .ser(Aws_restXml_1.se_ListPartsCommand)
    .de(Aws_restXml_1.de_ListPartsCommand)
    .build() {
}
exports.ListPartsCommand = ListPartsCommand;


/***/ }),

/***/ 66800:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutBucketAccelerateConfigurationCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutBucketAccelerateConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: false,
        }),
    ];
})
    .s("AmazonS3", "PutBucketAccelerateConfiguration", {})
    .n("S3Client", "PutBucketAccelerateConfigurationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutBucketAccelerateConfigurationCommand)
    .de(Aws_restXml_1.de_PutBucketAccelerateConfigurationCommand)
    .build() {
}
exports.PutBucketAccelerateConfigurationCommand = PutBucketAccelerateConfigurationCommand;


/***/ }),

/***/ 8231:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutBucketAclCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutBucketAclCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true,
        }),
    ];
})
    .s("AmazonS3", "PutBucketAcl", {})
    .n("S3Client", "PutBucketAclCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutBucketAclCommand)
    .de(Aws_restXml_1.de_PutBucketAclCommand)
    .build() {
}
exports.PutBucketAclCommand = PutBucketAclCommand;


/***/ }),

/***/ 61183:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutBucketAnalyticsConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutBucketAnalyticsConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "PutBucketAnalyticsConfiguration", {})
    .n("S3Client", "PutBucketAnalyticsConfigurationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutBucketAnalyticsConfigurationCommand)
    .de(Aws_restXml_1.de_PutBucketAnalyticsConfigurationCommand)
    .build() {
}
exports.PutBucketAnalyticsConfigurationCommand = PutBucketAnalyticsConfigurationCommand;


/***/ }),

/***/ 58803:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutBucketCorsCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutBucketCorsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true,
        }),
    ];
})
    .s("AmazonS3", "PutBucketCors", {})
    .n("S3Client", "PutBucketCorsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutBucketCorsCommand)
    .de(Aws_restXml_1.de_PutBucketCorsCommand)
    .build() {
}
exports.PutBucketCorsCommand = PutBucketCorsCommand;


/***/ }),

/***/ 22761:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutBucketEncryptionCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_0_1 = __nccwpck_require__(51628);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutBucketEncryptionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true,
        }),
    ];
})
    .s("AmazonS3", "PutBucketEncryption", {})
    .n("S3Client", "PutBucketEncryptionCommand")
    .f(models_0_1.PutBucketEncryptionRequestFilterSensitiveLog, void 0)
    .ser(Aws_restXml_1.se_PutBucketEncryptionCommand)
    .de(Aws_restXml_1.de_PutBucketEncryptionCommand)
    .build() {
}
exports.PutBucketEncryptionCommand = PutBucketEncryptionCommand;


/***/ }),

/***/ 55516:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutBucketIntelligentTieringConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutBucketIntelligentTieringConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "PutBucketIntelligentTieringConfiguration", {})
    .n("S3Client", "PutBucketIntelligentTieringConfigurationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutBucketIntelligentTieringConfigurationCommand)
    .de(Aws_restXml_1.de_PutBucketIntelligentTieringConfigurationCommand)
    .build() {
}
exports.PutBucketIntelligentTieringConfigurationCommand = PutBucketIntelligentTieringConfigurationCommand;


/***/ }),

/***/ 50738:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutBucketInventoryConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_0_1 = __nccwpck_require__(51628);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutBucketInventoryConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "PutBucketInventoryConfiguration", {})
    .n("S3Client", "PutBucketInventoryConfigurationCommand")
    .f(models_0_1.PutBucketInventoryConfigurationRequestFilterSensitiveLog, void 0)
    .ser(Aws_restXml_1.se_PutBucketInventoryConfigurationCommand)
    .de(Aws_restXml_1.de_PutBucketInventoryConfigurationCommand)
    .build() {
}
exports.PutBucketInventoryConfigurationCommand = PutBucketInventoryConfigurationCommand;


/***/ }),

/***/ 954:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutBucketLifecycleConfigurationCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutBucketLifecycleConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true,
        }),
    ];
})
    .s("AmazonS3", "PutBucketLifecycleConfiguration", {})
    .n("S3Client", "PutBucketLifecycleConfigurationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutBucketLifecycleConfigurationCommand)
    .de(Aws_restXml_1.de_PutBucketLifecycleConfigurationCommand)
    .build() {
}
exports.PutBucketLifecycleConfigurationCommand = PutBucketLifecycleConfigurationCommand;


/***/ }),

/***/ 35211:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutBucketLoggingCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutBucketLoggingCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true,
        }),
    ];
})
    .s("AmazonS3", "PutBucketLogging", {})
    .n("S3Client", "PutBucketLoggingCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutBucketLoggingCommand)
    .de(Aws_restXml_1.de_PutBucketLoggingCommand)
    .build() {
}
exports.PutBucketLoggingCommand = PutBucketLoggingCommand;


/***/ }),

/***/ 18413:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutBucketMetricsConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutBucketMetricsConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "PutBucketMetricsConfiguration", {})
    .n("S3Client", "PutBucketMetricsConfigurationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutBucketMetricsConfigurationCommand)
    .de(Aws_restXml_1.de_PutBucketMetricsConfigurationCommand)
    .build() {
}
exports.PutBucketMetricsConfigurationCommand = PutBucketMetricsConfigurationCommand;


/***/ }),

/***/ 19196:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutBucketNotificationConfigurationCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutBucketNotificationConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "PutBucketNotificationConfiguration", {})
    .n("S3Client", "PutBucketNotificationConfigurationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutBucketNotificationConfigurationCommand)
    .de(Aws_restXml_1.de_PutBucketNotificationConfigurationCommand)
    .build() {
}
exports.PutBucketNotificationConfigurationCommand = PutBucketNotificationConfigurationCommand;


/***/ }),

/***/ 74396:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutBucketOwnershipControlsCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutBucketOwnershipControlsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, { input: this.input, requestChecksumRequired: true }),
    ];
})
    .s("AmazonS3", "PutBucketOwnershipControls", {})
    .n("S3Client", "PutBucketOwnershipControlsCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutBucketOwnershipControlsCommand)
    .de(Aws_restXml_1.de_PutBucketOwnershipControlsCommand)
    .build() {
}
exports.PutBucketOwnershipControlsCommand = PutBucketOwnershipControlsCommand;


/***/ }),

/***/ 27496:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutBucketPolicyCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutBucketPolicyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true,
        }),
    ];
})
    .s("AmazonS3", "PutBucketPolicy", {})
    .n("S3Client", "PutBucketPolicyCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutBucketPolicyCommand)
    .de(Aws_restXml_1.de_PutBucketPolicyCommand)
    .build() {
}
exports.PutBucketPolicyCommand = PutBucketPolicyCommand;


/***/ }),

/***/ 2219:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutBucketReplicationCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutBucketReplicationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true,
        }),
    ];
})
    .s("AmazonS3", "PutBucketReplication", {})
    .n("S3Client", "PutBucketReplicationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutBucketReplicationCommand)
    .de(Aws_restXml_1.de_PutBucketReplicationCommand)
    .build() {
}
exports.PutBucketReplicationCommand = PutBucketReplicationCommand;


/***/ }),

/***/ 62481:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutBucketRequestPaymentCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutBucketRequestPaymentCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true,
        }),
    ];
})
    .s("AmazonS3", "PutBucketRequestPayment", {})
    .n("S3Client", "PutBucketRequestPaymentCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutBucketRequestPaymentCommand)
    .de(Aws_restXml_1.de_PutBucketRequestPaymentCommand)
    .build() {
}
exports.PutBucketRequestPaymentCommand = PutBucketRequestPaymentCommand;


/***/ }),

/***/ 4480:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutBucketTaggingCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutBucketTaggingCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true,
        }),
    ];
})
    .s("AmazonS3", "PutBucketTagging", {})
    .n("S3Client", "PutBucketTaggingCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutBucketTaggingCommand)
    .de(Aws_restXml_1.de_PutBucketTaggingCommand)
    .build() {
}
exports.PutBucketTaggingCommand = PutBucketTaggingCommand;


/***/ }),

/***/ 40327:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutBucketVersioningCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutBucketVersioningCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true,
        }),
    ];
})
    .s("AmazonS3", "PutBucketVersioning", {})
    .n("S3Client", "PutBucketVersioningCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutBucketVersioningCommand)
    .de(Aws_restXml_1.de_PutBucketVersioningCommand)
    .build() {
}
exports.PutBucketVersioningCommand = PutBucketVersioningCommand;


/***/ }),

/***/ 4317:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutBucketWebsiteCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutBucketWebsiteCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true,
        }),
    ];
})
    .s("AmazonS3", "PutBucketWebsite", {})
    .n("S3Client", "PutBucketWebsiteCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutBucketWebsiteCommand)
    .de(Aws_restXml_1.de_PutBucketWebsiteCommand)
    .build() {
}
exports.PutBucketWebsiteCommand = PutBucketWebsiteCommand;


/***/ }),

/***/ 75724:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutObjectAclCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutObjectAclCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true,
        }),
    ];
})
    .s("AmazonS3", "PutObjectAcl", {})
    .n("S3Client", "PutObjectAclCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutObjectAclCommand)
    .de(Aws_restXml_1.de_PutObjectAclCommand)
    .build() {
}
exports.PutObjectAclCommand = PutObjectAclCommand;


/***/ }),

/***/ 90825:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutObjectCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_sdk_s3_1 = __nccwpck_require__(81139);
const middleware_ssec_1 = __nccwpck_require__(49718);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_1_1 = __nccwpck_require__(6958);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutObjectCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_sdk_s3_1.getCheckContentLengthHeaderPlugin)(config),
        (0, middleware_ssec_1.getSsecPlugin)(config),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: false,
        }),
    ];
})
    .s("AmazonS3", "PutObject", {})
    .n("S3Client", "PutObjectCommand")
    .f(models_1_1.PutObjectRequestFilterSensitiveLog, models_1_1.PutObjectOutputFilterSensitiveLog)
    .ser(Aws_restXml_1.se_PutObjectCommand)
    .de(Aws_restXml_1.de_PutObjectCommand)
    .build() {
}
exports.PutObjectCommand = PutObjectCommand;


/***/ }),

/***/ 27290:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutObjectLegalHoldCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutObjectLegalHoldCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true,
        }),
    ];
})
    .s("AmazonS3", "PutObjectLegalHold", {})
    .n("S3Client", "PutObjectLegalHoldCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutObjectLegalHoldCommand)
    .de(Aws_restXml_1.de_PutObjectLegalHoldCommand)
    .build() {
}
exports.PutObjectLegalHoldCommand = PutObjectLegalHoldCommand;


/***/ }),

/***/ 164:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutObjectLockConfigurationCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutObjectLockConfigurationCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true,
        }),
    ];
})
    .s("AmazonS3", "PutObjectLockConfiguration", {})
    .n("S3Client", "PutObjectLockConfigurationCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutObjectLockConfigurationCommand)
    .de(Aws_restXml_1.de_PutObjectLockConfigurationCommand)
    .build() {
}
exports.PutObjectLockConfigurationCommand = PutObjectLockConfigurationCommand;


/***/ }),

/***/ 79112:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutObjectRetentionCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutObjectRetentionCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true,
        }),
    ];
})
    .s("AmazonS3", "PutObjectRetention", {})
    .n("S3Client", "PutObjectRetentionCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutObjectRetentionCommand)
    .de(Aws_restXml_1.de_PutObjectRetentionCommand)
    .build() {
}
exports.PutObjectRetentionCommand = PutObjectRetentionCommand;


/***/ }),

/***/ 53236:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutObjectTaggingCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutObjectTaggingCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true,
        }),
    ];
})
    .s("AmazonS3", "PutObjectTagging", {})
    .n("S3Client", "PutObjectTaggingCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutObjectTaggingCommand)
    .de(Aws_restXml_1.de_PutObjectTaggingCommand)
    .build() {
}
exports.PutObjectTaggingCommand = PutObjectTaggingCommand;


/***/ }),

/***/ 40863:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PutPublicAccessBlockCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const Aws_restXml_1 = __nccwpck_require__(39809);
class PutPublicAccessBlockCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true,
        }),
    ];
})
    .s("AmazonS3", "PutPublicAccessBlock", {})
    .n("S3Client", "PutPublicAccessBlockCommand")
    .f(void 0, void 0)
    .ser(Aws_restXml_1.se_PutPublicAccessBlockCommand)
    .de(Aws_restXml_1.de_PutPublicAccessBlockCommand)
    .build() {
}
exports.PutPublicAccessBlockCommand = PutPublicAccessBlockCommand;


/***/ }),

/***/ 52613:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RestoreObjectCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_1_1 = __nccwpck_require__(6958);
const Aws_restXml_1 = __nccwpck_require__(39809);
class RestoreObjectCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: false,
        }),
    ];
})
    .s("AmazonS3", "RestoreObject", {})
    .n("S3Client", "RestoreObjectCommand")
    .f(models_1_1.RestoreObjectRequestFilterSensitiveLog, void 0)
    .ser(Aws_restXml_1.se_RestoreObjectCommand)
    .de(Aws_restXml_1.de_RestoreObjectCommand)
    .build() {
}
exports.RestoreObjectCommand = RestoreObjectCommand;


/***/ }),

/***/ 17980:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectObjectContentCommand = exports.$Command = void 0;
const middleware_ssec_1 = __nccwpck_require__(49718);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_1_1 = __nccwpck_require__(6958);
const Aws_restXml_1 = __nccwpck_require__(39809);
class SelectObjectContentCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_ssec_1.getSsecPlugin)(config),
    ];
})
    .s("AmazonS3", "SelectObjectContent", {
    eventStream: {
        output: true,
    },
})
    .n("S3Client", "SelectObjectContentCommand")
    .f(models_1_1.SelectObjectContentRequestFilterSensitiveLog, models_1_1.SelectObjectContentOutputFilterSensitiveLog)
    .ser(Aws_restXml_1.se_SelectObjectContentCommand)
    .de(Aws_restXml_1.de_SelectObjectContentCommand)
    .build() {
}
exports.SelectObjectContentCommand = SelectObjectContentCommand;


/***/ }),

/***/ 49623:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UploadPartCommand = exports.$Command = void 0;
const middleware_flexible_checksums_1 = __nccwpck_require__(13799);
const middleware_ssec_1 = __nccwpck_require__(49718);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_1_1 = __nccwpck_require__(6958);
const Aws_restXml_1 = __nccwpck_require__(39809);
class UploadPartCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    Bucket: { type: "contextParams", name: "Bucket" },
    Key: { type: "contextParams", name: "Key" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_ssec_1.getSsecPlugin)(config),
        (0, middleware_flexible_checksums_1.getFlexibleChecksumsPlugin)(config, {
            input: this.input,
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: false,
        }),
    ];
})
    .s("AmazonS3", "UploadPart", {})
    .n("S3Client", "UploadPartCommand")
    .f(models_1_1.UploadPartRequestFilterSensitiveLog, models_1_1.UploadPartOutputFilterSensitiveLog)
    .ser(Aws_restXml_1.se_UploadPartCommand)
    .de(Aws_restXml_1.de_UploadPartCommand)
    .build() {
}
exports.UploadPartCommand = UploadPartCommand;


/***/ }),

/***/ 63225:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UploadPartCopyCommand = exports.$Command = void 0;
const middleware_sdk_s3_1 = __nccwpck_require__(81139);
const middleware_ssec_1 = __nccwpck_require__(49718);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_1_1 = __nccwpck_require__(6958);
const Aws_restXml_1 = __nccwpck_require__(39809);
class UploadPartCopyCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
    Bucket: { type: "contextParams", name: "Bucket" },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
        (0, middleware_sdk_s3_1.getThrow200ExceptionsPlugin)(config),
        (0, middleware_ssec_1.getSsecPlugin)(config),
    ];
})
    .s("AmazonS3", "UploadPartCopy", {})
    .n("S3Client", "UploadPartCopyCommand")
    .f(models_1_1.UploadPartCopyRequestFilterSensitiveLog, models_1_1.UploadPartCopyOutputFilterSensitiveLog)
    .ser(Aws_restXml_1.se_UploadPartCopyCommand)
    .de(Aws_restXml_1.de_UploadPartCopyCommand)
    .build() {
}
exports.UploadPartCopyCommand = UploadPartCopyCommand;


/***/ }),

/***/ 4107:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WriteGetObjectResponseCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(15122);
const models_1_1 = __nccwpck_require__(6958);
const Aws_restXml_1 = __nccwpck_require__(39809);
class WriteGetObjectResponseCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
    UseObjectLambdaEndpoint: { type: "staticContextParams", value: true },
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AmazonS3", "WriteGetObjectResponse", {})
    .n("S3Client", "WriteGetObjectResponseCommand")
    .f(models_1_1.WriteGetObjectResponseRequestFilterSensitiveLog, void 0)
    .ser(Aws_restXml_1.se_WriteGetObjectResponseCommand)
    .de(Aws_restXml_1.de_WriteGetObjectResponseCommand)
    .build() {
}
exports.WriteGetObjectResponseCommand = WriteGetObjectResponseCommand;


/***/ }),

/***/ 73706:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(99430), exports);
tslib_1.__exportStar(__nccwpck_require__(67313), exports);
tslib_1.__exportStar(__nccwpck_require__(12953), exports);
tslib_1.__exportStar(__nccwpck_require__(16512), exports);
tslib_1.__exportStar(__nccwpck_require__(26994), exports);
tslib_1.__exportStar(__nccwpck_require__(99162), exports);
tslib_1.__exportStar(__nccwpck_require__(25909), exports);
tslib_1.__exportStar(__nccwpck_require__(67926), exports);
tslib_1.__exportStar(__nccwpck_require__(85665), exports);
tslib_1.__exportStar(__nccwpck_require__(65051), exports);
tslib_1.__exportStar(__nccwpck_require__(16473), exports);
tslib_1.__exportStar(__nccwpck_require__(68850), exports);
tslib_1.__exportStar(__nccwpck_require__(36164), exports);
tslib_1.__exportStar(__nccwpck_require__(17966), exports);
tslib_1.__exportStar(__nccwpck_require__(52476), exports);
tslib_1.__exportStar(__nccwpck_require__(55750), exports);
tslib_1.__exportStar(__nccwpck_require__(52572), exports);
tslib_1.__exportStar(__nccwpck_require__(36657), exports);
tslib_1.__exportStar(__nccwpck_require__(45145), exports);
tslib_1.__exportStar(__nccwpck_require__(74256), exports);
tslib_1.__exportStar(__nccwpck_require__(73722), exports);
tslib_1.__exportStar(__nccwpck_require__(49614), exports);
tslib_1.__exportStar(__nccwpck_require__(72164), exports);
tslib_1.__exportStar(__nccwpck_require__(42101), exports);
tslib_1.__exportStar(__nccwpck_require__(7182), exports);
tslib_1.__exportStar(__nccwpck_require__(16291), exports);
tslib_1.__exportStar(__nccwpck_require__(98380), exports);
tslib_1.__exportStar(__nccwpck_require__(57638), exports);
tslib_1.__exportStar(__nccwpck_require__(84802), exports);
tslib_1.__exportStar(__nccwpck_require__(54695), exports);
tslib_1.__exportStar(__nccwpck_require__(31335), exports);
tslib_1.__exportStar(__nccwpck_require__(58353), exports);
tslib_1.__exportStar(__nccwpck_require__(22694), exports);
tslib_1.__exportStar(__nccwpck_require__(62416), exports);
tslib_1.__exportStar(__nccwpck_require__(41578), exports);
tslib_1.__exportStar(__nccwpck_require__(89515), exports);
tslib_1.__exportStar(__nccwpck_require__(50009), exports);
tslib_1.__exportStar(__nccwpck_require__(99905), exports);
tslib_1.__exportStar(__nccwpck_require__(57194), exports);
tslib_1.__exportStar(__nccwpck_require__(60199), exports);
tslib_1.__exportStar(__nccwpck_require__(38464), exports);
tslib_1.__exportStar(__nccwpck_require__(99497), exports);
tslib_1.__exportStar(__nccwpck_require__(28346), exports);
tslib_1.__exportStar(__nccwpck_require__(31091), exports);
tslib_1.__exportStar(__nccwpck_require__(26888), exports);
tslib_1.__exportStar(__nccwpck_require__(34155), exports);
tslib_1.__exportStar(__nccwpck_require__(20141), exports);
tslib_1.__exportStar(__nccwpck_require__(39079), exports);
tslib_1.__exportStar(__nccwpck_require__(75230), exports);
tslib_1.__exportStar(__nccwpck_require__(98360), exports);
tslib_1.__exportStar(__nccwpck_require__(11127), exports);
tslib_1.__exportStar(__nccwpck_require__(18158), exports);
tslib_1.__exportStar(__nccwpck_require__(62121), exports);
tslib_1.__exportStar(__nccwpck_require__(82375), exports);
tslib_1.__exportStar(__nccwpck_require__(85135), exports);
tslib_1.__exportStar(__nccwpck_require__(49557), exports);
tslib_1.__exportStar(__nccwpck_require__(70339), exports);
tslib_1.__exportStar(__nccwpck_require__(72760), exports);
tslib_1.__exportStar(__nccwpck_require__(40175), exports);
tslib_1.__exportStar(__nccwpck_require__(68430), exports);
tslib_1.__exportStar(__nccwpck_require__(92182), exports);
tslib_1.__exportStar(__nccwpck_require__(44112), exports);
tslib_1.__exportStar(__nccwpck_require__(2341), exports);
tslib_1.__exportStar(__nccwpck_require__(89368), exports);
tslib_1.__exportStar(__nccwpck_require__(90896), exports);
tslib_1.__exportStar(__nccwpck_require__(66800), exports);
tslib_1.__exportStar(__nccwpck_require__(8231), exports);
tslib_1.__exportStar(__nccwpck_require__(61183), exports);
tslib_1.__exportStar(__nccwpck_require__(58803), exports);
tslib_1.__exportStar(__nccwpck_require__(22761), exports);
tslib_1.__exportStar(__nccwpck_require__(55516), exports);
tslib_1.__exportStar(__nccwpck_require__(50738), exports);
tslib_1.__exportStar(__nccwpck_require__(954), exports);
tslib_1.__exportStar(__nccwpck_require__(35211), exports);
tslib_1.__exportStar(__nccwpck_require__(18413), exports);
tslib_1.__exportStar(__nccwpck_require__(19196), exports);
tslib_1.__exportStar(__nccwpck_require__(74396), exports);
tslib_1.__exportStar(__nccwpck_require__(27496), exports);
tslib_1.__exportStar(__nccwpck_require__(2219), exports);
tslib_1.__exportStar(__nccwpck_require__(62481), exports);
tslib_1.__exportStar(__nccwpck_require__(4480), exports);
tslib_1.__exportStar(__nccwpck_require__(40327), exports);
tslib_1.__exportStar(__nccwpck_require__(4317), exports);
tslib_1.__exportStar(__nccwpck_require__(75724), exports);
tslib_1.__exportStar(__nccwpck_require__(90825), exports);
tslib_1.__exportStar(__nccwpck_require__(27290), exports);
tslib_1.__exportStar(__nccwpck_require__(164), exports);
tslib_1.__exportStar(__nccwpck_require__(79112), exports);
tslib_1.__exportStar(__nccwpck_require__(53236), exports);
tslib_1.__exportStar(__nccwpck_require__(40863), exports);
tslib_1.__exportStar(__nccwpck_require__(52613), exports);
tslib_1.__exportStar(__nccwpck_require__(17980), exports);
tslib_1.__exportStar(__nccwpck_require__(49623), exports);
tslib_1.__exportStar(__nccwpck_require__(63225), exports);
tslib_1.__exportStar(__nccwpck_require__(4107), exports);


/***/ }),

/***/ 15122:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.commonParams = exports.resolveClientEndpointParameters = void 0;
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        forcePathStyle: options.forcePathStyle ?? false,
        useAccelerateEndpoint: options.useAccelerateEndpoint ?? false,
        useGlobalEndpoint: options.useGlobalEndpoint ?? false,
        disableMultiregionAccessPoints: options.disableMultiregionAccessPoints ?? false,
        defaultSigningName: "s3",
    };
};
exports.resolveClientEndpointParameters = resolveClientEndpointParameters;
exports.commonParams = {
    ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
    UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
    DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
    Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
    DisableS3ExpressSessionAuth: { type: "clientContextParams", name: "disableS3ExpressSessionAuth" },
    UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
};


/***/ }),

/***/ 3722:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __nccwpck_require__(45473);
const ruleset_1 = __nccwpck_require__(76114);
const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
exports.defaultEndpointResolver = defaultEndpointResolver;


/***/ }),

/***/ 76114:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ruleSet = void 0;
const cc = "required", cd = "type", ce = "conditions", cf = "fn", cg = "argv", ch = "ref", ci = "assign", cj = "url", ck = "properties", cl = "backend", cm = "authSchemes", cn = "disableDoubleEncoding", co = "signingName", cp = "signingRegion", cq = "headers";
const a = false, b = true, c = "isSet", d = "booleanEquals", e = "error", f = "aws.partition", g = "stringEquals", h = "getAttr", i = "name", j = "substring", k = "bucketSuffix", l = "parseURL", m = "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}", n = "endpoint", o = "tree", p = "aws.isVirtualHostableS3Bucket", q = "{url#scheme}://{Bucket}.{url#authority}{url#path}", r = "not", s = "{url#scheme}://{url#authority}{url#path}", t = "hardwareType", u = "regionPrefix", v = "bucketAliasSuffix", w = "outpostId", x = "isValidHostLabel", y = "s3-outposts", z = "s3", A = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}", B = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}", C = "https://{Bucket}.s3.{partitionResult#dnsSuffix}", D = "aws.parseArn", E = "bucketArn", F = "arnType", G = "", H = "s3-object-lambda", I = "accesspoint", J = "accessPointName", K = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}", L = "mrapPartition", M = "outpostType", N = "arnPrefix", O = "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", P = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", Q = "https://s3.{partitionResult#dnsSuffix}", R = { [cc]: false, [cd]: "String" }, S = { [cc]: true, "default": false, [cd]: "Boolean" }, T = { [cc]: false, [cd]: "Boolean" }, U = { [cf]: d, [cg]: [{ [ch]: "Accelerate" }, true] }, V = { [cf]: d, [cg]: [{ [ch]: "UseFIPS" }, true] }, W = { [cf]: d, [cg]: [{ [ch]: "UseDualStack" }, true] }, X = { [cf]: c, [cg]: [{ [ch]: "Endpoint" }] }, Y = { [cf]: f, [cg]: [{ [ch]: "Region" }], [ci]: "partitionResult" }, Z = { [cf]: g, [cg]: [{ [cf]: h, [cg]: [{ [ch]: "partitionResult" }, i] }, "aws-cn"] }, aa = { [cf]: c, [cg]: [{ [ch]: "Bucket" }] }, ab = { [ch]: "Bucket" }, ac = { [cf]: l, [cg]: [{ [ch]: "Endpoint" }], [ci]: "url" }, ad = { [cf]: d, [cg]: [{ [cf]: h, [cg]: [{ [ch]: "url" }, "isIp"] }, true] }, ae = { [ch]: "url" }, af = { [cf]: "uriEncode", [cg]: [ab], [ci]: "uri_encoded_bucket" }, ag = { [cl]: "S3Express", [cm]: [{ [cn]: true, [i]: "sigv4", [co]: "s3express", [cp]: "{Region}" }] }, ah = {}, ai = { [cf]: p, [cg]: [ab, false] }, aj = { [e]: "S3Express bucket name is not a valid virtual hostable name.", [cd]: e }, ak = { [cl]: "S3Express", [cm]: [{ [cn]: true, [i]: "sigv4-s3express", [co]: "s3express", [cp]: "{Region}" }] }, al = { [cf]: c, [cg]: [{ [ch]: "UseS3ExpressControlEndpoint" }] }, am = { [cf]: d, [cg]: [{ [ch]: "UseS3ExpressControlEndpoint" }, true] }, an = { [cf]: r, [cg]: [X] }, ao = { [e]: "Unrecognized S3Express bucket name format.", [cd]: e }, ap = { [cf]: r, [cg]: [aa] }, aq = { [ch]: t }, ar = { [ce]: [an], [e]: "Expected a endpoint to be specified but no endpoint was found", [cd]: e }, as = { [cm]: [{ [cn]: true, [i]: "sigv4", [co]: y, [cp]: "{Region}" }] }, at = { [cf]: d, [cg]: [{ [ch]: "ForcePathStyle" }, false] }, au = { [ch]: "ForcePathStyle" }, av = { [cf]: d, [cg]: [{ [ch]: "Accelerate" }, false] }, aw = { [cf]: g, [cg]: [{ [ch]: "Region" }, "aws-global"] }, ax = { [cm]: [{ [cn]: true, [i]: "sigv4", [co]: z, [cp]: "us-east-1" }] }, ay = { [cf]: r, [cg]: [aw] }, az = { [cf]: d, [cg]: [{ [ch]: "UseGlobalEndpoint" }, true] }, aA = { [cj]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [ck]: { [cm]: [{ [cn]: true, [i]: "sigv4", [co]: z, [cp]: "{Region}" }] }, [cq]: {} }, aB = { [cm]: [{ [cn]: true, [i]: "sigv4", [co]: z, [cp]: "{Region}" }] }, aC = { [cf]: d, [cg]: [{ [ch]: "UseGlobalEndpoint" }, false] }, aD = { [cf]: d, [cg]: [{ [ch]: "UseDualStack" }, false] }, aE = { [cj]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [ck]: aB, [cq]: {} }, aF = { [cf]: d, [cg]: [{ [ch]: "UseFIPS" }, false] }, aG = { [cj]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [ck]: aB, [cq]: {} }, aH = { [cj]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [ck]: aB, [cq]: {} }, aI = { [cf]: d, [cg]: [{ [cf]: h, [cg]: [ae, "isIp"] }, false] }, aJ = { [cj]: A, [ck]: aB, [cq]: {} }, aK = { [cj]: q, [ck]: aB, [cq]: {} }, aL = { [n]: aK, [cd]: n }, aM = { [cj]: B, [ck]: aB, [cq]: {} }, aN = { [cj]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [ck]: aB, [cq]: {} }, aO = { [e]: "Invalid region: region was not a valid DNS name.", [cd]: e }, aP = { [ch]: E }, aQ = { [ch]: F }, aR = { [cf]: h, [cg]: [aP, "service"] }, aS = { [ch]: J }, aT = { [ce]: [W], [e]: "S3 Object Lambda does not support Dual-stack", [cd]: e }, aU = { [ce]: [U], [e]: "S3 Object Lambda does not support S3 Accelerate", [cd]: e }, aV = { [ce]: [{ [cf]: c, [cg]: [{ [ch]: "DisableAccessPoints" }] }, { [cf]: d, [cg]: [{ [ch]: "DisableAccessPoints" }, true] }], [e]: "Access points are not supported for this operation", [cd]: e }, aW = { [ce]: [{ [cf]: c, [cg]: [{ [ch]: "UseArnRegion" }] }, { [cf]: d, [cg]: [{ [ch]: "UseArnRegion" }, false] }, { [cf]: r, [cg]: [{ [cf]: g, [cg]: [{ [cf]: h, [cg]: [aP, "region"] }, "{Region}"] }] }], [e]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [cd]: e }, aX = { [cf]: h, [cg]: [{ [ch]: "bucketPartition" }, i] }, aY = { [cf]: h, [cg]: [aP, "accountId"] }, aZ = { [cm]: [{ [cn]: true, [i]: "sigv4", [co]: H, [cp]: "{bucketArn#region}" }] }, ba = { [e]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [cd]: e }, bb = { [e]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [cd]: e }, bc = { [e]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [cd]: e }, bd = { [e]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [cd]: e }, be = { [e]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [cd]: e }, bf = { [e]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [cd]: e }, bg = { [cm]: [{ [cn]: true, [i]: "sigv4", [co]: z, [cp]: "{bucketArn#region}" }] }, bh = { [cm]: [{ [cn]: true, [i]: "sigv4", [co]: y, [cp]: "{bucketArn#region}" }] }, bi = { [cf]: D, [cg]: [ab] }, bj = { [cj]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ck]: aB, [cq]: {} }, bk = { [cj]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ck]: aB, [cq]: {} }, bl = { [cj]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ck]: aB, [cq]: {} }, bm = { [cj]: O, [ck]: aB, [cq]: {} }, bn = { [cj]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ck]: aB, [cq]: {} }, bo = { [ch]: "UseObjectLambdaEndpoint" }, bp = { [cm]: [{ [cn]: true, [i]: "sigv4", [co]: H, [cp]: "{Region}" }] }, bq = { [cj]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [ck]: aB, [cq]: {} }, br = { [cj]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [ck]: aB, [cq]: {} }, bs = { [cj]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [ck]: aB, [cq]: {} }, bt = { [cj]: s, [ck]: aB, [cq]: {} }, bu = { [cj]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [ck]: aB, [cq]: {} }, bv = [{ [ch]: "Region" }], bw = [{ [ch]: "Endpoint" }], bx = [ab], by = [W], bz = [U], bA = [X, ac], bB = [{ [cf]: c, [cg]: [{ [ch]: "DisableS3ExpressSessionAuth" }] }, { [cf]: d, [cg]: [{ [ch]: "DisableS3ExpressSessionAuth" }, true] }], bC = [ad], bD = [af], bE = [ai], bF = [V], bG = [{ [cf]: j, [cg]: [ab, 6, 14, true], [ci]: "s3expressAvailabilityZoneId" }, { [cf]: j, [cg]: [ab, 14, 16, true], [ci]: "s3expressAvailabilityZoneDelim" }, { [cf]: g, [cg]: [{ [ch]: "s3expressAvailabilityZoneDelim" }, "--"] }], bH = [{ [ce]: [V], [n]: { [cj]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [ck]: ag, [cq]: {} }, [cd]: n }, { [n]: { [cj]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [ck]: ag, [cq]: {} }, [cd]: n }], bI = [{ [cf]: j, [cg]: [ab, 6, 15, true], [ci]: "s3expressAvailabilityZoneId" }, { [cf]: j, [cg]: [ab, 15, 17, true], [ci]: "s3expressAvailabilityZoneDelim" }, { [cf]: g, [cg]: [{ [ch]: "s3expressAvailabilityZoneDelim" }, "--"] }], bJ = [{ [ce]: [V], [n]: { [cj]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [ck]: ak, [cq]: {} }, [cd]: n }, { [n]: { [cj]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [ck]: ak, [cq]: {} }, [cd]: n }], bK = [aa], bL = [{ [cf]: x, [cg]: [{ [ch]: w }, false] }], bM = [{ [cf]: g, [cg]: [{ [ch]: u }, "beta"] }], bN = [Y], bO = [{ [cf]: x, [cg]: [{ [ch]: "Region" }, false] }], bP = [{ [cf]: g, [cg]: [{ [ch]: "Region" }, "us-east-1"] }], bQ = [{ [cf]: g, [cg]: [aQ, I] }], bR = [{ [cf]: h, [cg]: [aP, "resourceId[1]"], [ci]: J }, { [cf]: r, [cg]: [{ [cf]: g, [cg]: [aS, G] }] }], bS = [aP, "resourceId[1]"], bT = [{ [cf]: r, [cg]: [{ [cf]: g, [cg]: [{ [cf]: h, [cg]: [aP, "region"] }, G] }] }], bU = [{ [cf]: r, [cg]: [{ [cf]: c, [cg]: [{ [cf]: h, [cg]: [aP, "resourceId[2]"] }] }] }], bV = [aP, "resourceId[2]"], bW = [{ [cf]: f, [cg]: [{ [cf]: h, [cg]: [aP, "region"] }], [ci]: "bucketPartition" }], bX = [{ [cf]: g, [cg]: [aX, { [cf]: h, [cg]: [{ [ch]: "partitionResult" }, i] }] }], bY = [{ [cf]: x, [cg]: [{ [cf]: h, [cg]: [aP, "region"] }, true] }], bZ = [{ [cf]: x, [cg]: [aY, false] }], ca = [{ [cf]: x, [cg]: [aS, false] }], cb = [{ [cf]: x, [cg]: [{ [ch]: "Region" }, true] }];
const _data = { version: "1.0", parameters: { Bucket: R, Region: R, UseFIPS: S, UseDualStack: S, Endpoint: R, ForcePathStyle: S, Accelerate: S, UseGlobalEndpoint: S, UseObjectLambdaEndpoint: T, Key: R, Prefix: R, DisableAccessPoints: T, DisableMultiRegionAccessPoints: S, UseArnRegion: T, UseS3ExpressControlEndpoint: T, DisableS3ExpressSessionAuth: T }, rules: [{ [ce]: [{ [cf]: c, [cg]: bv }], rules: [{ [ce]: [U, V], error: "Accelerate cannot be used with FIPS", [cd]: e }, { [ce]: [W, X], error: "Cannot set dual-stack in combination with a custom endpoint.", [cd]: e }, { [ce]: [X, V], error: "A custom endpoint cannot be combined with FIPS", [cd]: e }, { [ce]: [X, U], error: "A custom endpoint cannot be combined with S3 Accelerate", [cd]: e }, { [ce]: [V, Y, Z], error: "Partition does not support FIPS", [cd]: e }, { [ce]: [aa, { [cf]: j, [cg]: [ab, 0, 6, b], [ci]: k }, { [cf]: g, [cg]: [{ [ch]: k }, "--x-s3"] }], rules: [{ [ce]: by, error: "S3Express does not support Dual-stack.", [cd]: e }, { [ce]: bz, error: "S3Express does not support S3 Accelerate.", [cd]: e }, { [ce]: bA, rules: [{ [ce]: bB, rules: [{ [ce]: bC, rules: [{ [ce]: bD, rules: [{ endpoint: { [cj]: m, [ck]: ag, [cq]: ah }, [cd]: n }], [cd]: o }], [cd]: o }, { [ce]: bE, rules: [{ endpoint: { [cj]: q, [ck]: ag, [cq]: ah }, [cd]: n }], [cd]: o }, aj], [cd]: o }, { [ce]: bC, rules: [{ [ce]: bD, rules: [{ endpoint: { [cj]: m, [ck]: ak, [cq]: ah }, [cd]: n }], [cd]: o }], [cd]: o }, { [ce]: bE, rules: [{ endpoint: { [cj]: q, [ck]: ak, [cq]: ah }, [cd]: n }], [cd]: o }, aj], [cd]: o }, { [ce]: [al, am], rules: [{ [ce]: [af, an], rules: [{ [ce]: bF, endpoint: { [cj]: "https://s3express-control-fips.{Region}.amazonaws.com/{uri_encoded_bucket}", [ck]: ag, [cq]: ah }, [cd]: n }, { endpoint: { [cj]: "https://s3express-control.{Region}.amazonaws.com/{uri_encoded_bucket}", [ck]: ag, [cq]: ah }, [cd]: n }], [cd]: o }], [cd]: o }, { [ce]: bE, rules: [{ [ce]: bB, rules: [{ [ce]: bG, rules: bH, [cd]: o }, { [ce]: bI, rules: bH, [cd]: o }, ao], [cd]: o }, { [ce]: bG, rules: bJ, [cd]: o }, { [ce]: bI, rules: bJ, [cd]: o }, ao], [cd]: o }, aj], [cd]: o }, { [ce]: [ap, al, am], rules: [{ [ce]: bA, endpoint: { [cj]: s, [ck]: ag, [cq]: ah }, [cd]: n }, { [ce]: bF, endpoint: { [cj]: "https://s3express-control-fips.{Region}.amazonaws.com", [ck]: ag, [cq]: ah }, [cd]: n }, { endpoint: { [cj]: "https://s3express-control.{Region}.amazonaws.com", [ck]: ag, [cq]: ah }, [cd]: n }], [cd]: o }, { [ce]: [aa, { [cf]: j, [cg]: [ab, 49, 50, b], [ci]: t }, { [cf]: j, [cg]: [ab, 8, 12, b], [ci]: u }, { [cf]: j, [cg]: [ab, 0, 7, b], [ci]: v }, { [cf]: j, [cg]: [ab, 32, 49, b], [ci]: w }, { [cf]: f, [cg]: bv, [ci]: "regionPartition" }, { [cf]: g, [cg]: [{ [ch]: v }, "--op-s3"] }], rules: [{ [ce]: bL, rules: [{ [ce]: [{ [cf]: g, [cg]: [aq, "e"] }], rules: [{ [ce]: bM, rules: [ar, { [ce]: bA, endpoint: { [cj]: "https://{Bucket}.ec2.{url#authority}", [ck]: as, [cq]: ah }, [cd]: n }], [cd]: o }, { endpoint: { [cj]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [ck]: as, [cq]: ah }, [cd]: n }], [cd]: o }, { [ce]: [{ [cf]: g, [cg]: [aq, "o"] }], rules: [{ [ce]: bM, rules: [ar, { [ce]: bA, endpoint: { [cj]: "https://{Bucket}.op-{outpostId}.{url#authority}", [ck]: as, [cq]: ah }, [cd]: n }], [cd]: o }, { endpoint: { [cj]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [ck]: as, [cq]: ah }, [cd]: n }], [cd]: o }, { error: "Unrecognized hardware type: \"Expected hardware type o or e but got {hardwareType}\"", [cd]: e }], [cd]: o }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [cd]: e }], [cd]: o }, { [ce]: bK, rules: [{ [ce]: [X, { [cf]: r, [cg]: [{ [cf]: c, [cg]: [{ [cf]: l, [cg]: bw }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [cd]: e }, { [ce]: [at, ai], rules: [{ [ce]: bN, rules: [{ [ce]: bO, rules: [{ [ce]: [U, Z], error: "S3 Accelerate cannot be used in this region", [cd]: e }, { [ce]: [W, V, av, an, aw], endpoint: { [cj]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ck]: ax, [cq]: ah }, [cd]: n }, { [ce]: [W, V, av, an, ay, az], rules: [{ endpoint: aA, [cd]: n }], [cd]: o }, { [ce]: [W, V, av, an, ay, aC], endpoint: aA, [cd]: n }, { [ce]: [aD, V, av, an, aw], endpoint: { [cj]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [ck]: ax, [cq]: ah }, [cd]: n }, { [ce]: [aD, V, av, an, ay, az], rules: [{ endpoint: aE, [cd]: n }], [cd]: o }, { [ce]: [aD, V, av, an, ay, aC], endpoint: aE, [cd]: n }, { [ce]: [W, aF, U, an, aw], endpoint: { [cj]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ck]: ax, [cq]: ah }, [cd]: n }, { [ce]: [W, aF, U, an, ay, az], rules: [{ endpoint: aG, [cd]: n }], [cd]: o }, { [ce]: [W, aF, U, an, ay, aC], endpoint: aG, [cd]: n }, { [ce]: [W, aF, av, an, aw], endpoint: { [cj]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ck]: ax, [cq]: ah }, [cd]: n }, { [ce]: [W, aF, av, an, ay, az], rules: [{ endpoint: aH, [cd]: n }], [cd]: o }, { [ce]: [W, aF, av, an, ay, aC], endpoint: aH, [cd]: n }, { [ce]: [aD, aF, av, X, ac, ad, aw], endpoint: { [cj]: A, [ck]: ax, [cq]: ah }, [cd]: n }, { [ce]: [aD, aF, av, X, ac, aI, aw], endpoint: { [cj]: q, [ck]: ax, [cq]: ah }, [cd]: n }, { [ce]: [aD, aF, av, X, ac, ad, ay, az], rules: [{ [ce]: bP, endpoint: aJ, [cd]: n }, { endpoint: aJ, [cd]: n }], [cd]: o }, { [ce]: [aD, aF, av, X, ac, aI, ay, az], rules: [{ [ce]: bP, endpoint: aK, [cd]: n }, aL], [cd]: o }, { [ce]: [aD, aF, av, X, ac, ad, ay, aC], endpoint: aJ, [cd]: n }, { [ce]: [aD, aF, av, X, ac, aI, ay, aC], endpoint: aK, [cd]: n }, { [ce]: [aD, aF, U, an, aw], endpoint: { [cj]: B, [ck]: ax, [cq]: ah }, [cd]: n }, { [ce]: [aD, aF, U, an, ay, az], rules: [{ [ce]: bP, endpoint: aM, [cd]: n }, { endpoint: aM, [cd]: n }], [cd]: o }, { [ce]: [aD, aF, U, an, ay, aC], endpoint: aM, [cd]: n }, { [ce]: [aD, aF, av, an, aw], endpoint: { [cj]: C, [ck]: ax, [cq]: ah }, [cd]: n }, { [ce]: [aD, aF, av, an, ay, az], rules: [{ [ce]: bP, endpoint: { [cj]: C, [ck]: aB, [cq]: ah }, [cd]: n }, { endpoint: aN, [cd]: n }], [cd]: o }, { [ce]: [aD, aF, av, an, ay, aC], endpoint: aN, [cd]: n }], [cd]: o }, aO], [cd]: o }], [cd]: o }, { [ce]: [X, ac, { [cf]: g, [cg]: [{ [cf]: h, [cg]: [ae, "scheme"] }, "http"] }, { [cf]: p, [cg]: [ab, b] }, at, aF, aD, av], rules: [{ [ce]: bN, rules: [{ [ce]: bO, rules: [aL], [cd]: o }, aO], [cd]: o }], [cd]: o }, { [ce]: [at, { [cf]: D, [cg]: bx, [ci]: E }], rules: [{ [ce]: [{ [cf]: h, [cg]: [aP, "resourceId[0]"], [ci]: F }, { [cf]: r, [cg]: [{ [cf]: g, [cg]: [aQ, G] }] }], rules: [{ [ce]: [{ [cf]: g, [cg]: [aR, H] }], rules: [{ [ce]: bQ, rules: [{ [ce]: bR, rules: [aT, aU, { [ce]: bT, rules: [aV, { [ce]: bU, rules: [aW, { [ce]: bW, rules: [{ [ce]: bN, rules: [{ [ce]: bX, rules: [{ [ce]: bY, rules: [{ [ce]: [{ [cf]: g, [cg]: [aY, G] }], error: "Invalid ARN: Missing account id", [cd]: e }, { [ce]: bZ, rules: [{ [ce]: ca, rules: [{ [ce]: bA, endpoint: { [cj]: K, [ck]: aZ, [cq]: ah }, [cd]: n }, { [ce]: bF, endpoint: { [cj]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ck]: aZ, [cq]: ah }, [cd]: n }, { endpoint: { [cj]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ck]: aZ, [cq]: ah }, [cd]: n }], [cd]: o }, ba], [cd]: o }, bb], [cd]: o }, bc], [cd]: o }, bd], [cd]: o }], [cd]: o }], [cd]: o }, be], [cd]: o }, { error: "Invalid ARN: bucket ARN is missing a region", [cd]: e }], [cd]: o }, bf], [cd]: o }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [cd]: e }], [cd]: o }, { [ce]: bQ, rules: [{ [ce]: bR, rules: [{ [ce]: bT, rules: [{ [ce]: bQ, rules: [{ [ce]: bT, rules: [aV, { [ce]: bU, rules: [aW, { [ce]: bW, rules: [{ [ce]: bN, rules: [{ [ce]: [{ [cf]: g, [cg]: [aX, "{partitionResult#name}"] }], rules: [{ [ce]: bY, rules: [{ [ce]: [{ [cf]: g, [cg]: [aR, z] }], rules: [{ [ce]: bZ, rules: [{ [ce]: ca, rules: [{ [ce]: bz, error: "Access Points do not support S3 Accelerate", [cd]: e }, { [ce]: [V, W], endpoint: { [cj]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ck]: bg, [cq]: ah }, [cd]: n }, { [ce]: [V, aD], endpoint: { [cj]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ck]: bg, [cq]: ah }, [cd]: n }, { [ce]: [aF, W], endpoint: { [cj]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ck]: bg, [cq]: ah }, [cd]: n }, { [ce]: [aF, aD, X, ac], endpoint: { [cj]: K, [ck]: bg, [cq]: ah }, [cd]: n }, { [ce]: [aF, aD], endpoint: { [cj]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ck]: bg, [cq]: ah }, [cd]: n }], [cd]: o }, ba], [cd]: o }, bb], [cd]: o }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [cd]: e }], [cd]: o }, bc], [cd]: o }, bd], [cd]: o }], [cd]: o }], [cd]: o }, be], [cd]: o }], [cd]: o }], [cd]: o }, { [ce]: [{ [cf]: x, [cg]: [aS, b] }], rules: [{ [ce]: by, error: "S3 MRAP does not support dual-stack", [cd]: e }, { [ce]: bF, error: "S3 MRAP does not support FIPS", [cd]: e }, { [ce]: bz, error: "S3 MRAP does not support S3 Accelerate", [cd]: e }, { [ce]: [{ [cf]: d, [cg]: [{ [ch]: "DisableMultiRegionAccessPoints" }, b] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [cd]: e }, { [ce]: [{ [cf]: f, [cg]: bv, [ci]: L }], rules: [{ [ce]: [{ [cf]: g, [cg]: [{ [cf]: h, [cg]: [{ [ch]: L }, i] }, { [cf]: h, [cg]: [aP, "partition"] }] }], rules: [{ endpoint: { [cj]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [ck]: { [cm]: [{ [cn]: b, name: "sigv4a", [co]: z, signingRegionSet: ["*"] }] }, [cq]: ah }, [cd]: n }], [cd]: o }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [cd]: e }], [cd]: o }], [cd]: o }, { error: "Invalid Access Point Name", [cd]: e }], [cd]: o }, bf], [cd]: o }, { [ce]: [{ [cf]: g, [cg]: [aR, y] }], rules: [{ [ce]: by, error: "S3 Outposts does not support Dual-stack", [cd]: e }, { [ce]: bF, error: "S3 Outposts does not support FIPS", [cd]: e }, { [ce]: bz, error: "S3 Outposts does not support S3 Accelerate", [cd]: e }, { [ce]: [{ [cf]: c, [cg]: [{ [cf]: h, [cg]: [aP, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [cd]: e }, { [ce]: [{ [cf]: h, [cg]: bS, [ci]: w }], rules: [{ [ce]: bL, rules: [aW, { [ce]: bW, rules: [{ [ce]: bN, rules: [{ [ce]: bX, rules: [{ [ce]: bY, rules: [{ [ce]: bZ, rules: [{ [ce]: [{ [cf]: h, [cg]: bV, [ci]: M }], rules: [{ [ce]: [{ [cf]: h, [cg]: [aP, "resourceId[3]"], [ci]: J }], rules: [{ [ce]: [{ [cf]: g, [cg]: [{ [ch]: M }, I] }], rules: [{ [ce]: bA, endpoint: { [cj]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [ck]: bh, [cq]: ah }, [cd]: n }, { endpoint: { [cj]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [ck]: bh, [cq]: ah }, [cd]: n }], [cd]: o }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [cd]: e }], [cd]: o }, { error: "Invalid ARN: expected an access point name", [cd]: e }], [cd]: o }, { error: "Invalid ARN: Expected a 4-component resource", [cd]: e }], [cd]: o }, bb], [cd]: o }, bc], [cd]: o }, bd], [cd]: o }], [cd]: o }], [cd]: o }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [cd]: e }], [cd]: o }, { error: "Invalid ARN: The Outpost Id was not set", [cd]: e }], [cd]: o }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [cd]: e }], [cd]: o }, { error: "Invalid ARN: No ARN type specified", [cd]: e }], [cd]: o }, { [ce]: [{ [cf]: j, [cg]: [ab, 0, 4, a], [ci]: N }, { [cf]: g, [cg]: [{ [ch]: N }, "arn:"] }, { [cf]: r, [cg]: [{ [cf]: c, [cg]: [bi] }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [cd]: e }, { [ce]: [{ [cf]: d, [cg]: [au, b] }, bi], error: "Path-style addressing cannot be used with ARN buckets", [cd]: e }, { [ce]: bD, rules: [{ [ce]: bN, rules: [{ [ce]: [av], rules: [{ [ce]: [W, an, V, aw], endpoint: { [cj]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ck]: ax, [cq]: ah }, [cd]: n }, { [ce]: [W, an, V, ay, az], rules: [{ endpoint: bj, [cd]: n }], [cd]: o }, { [ce]: [W, an, V, ay, aC], endpoint: bj, [cd]: n }, { [ce]: [aD, an, V, aw], endpoint: { [cj]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ck]: ax, [cq]: ah }, [cd]: n }, { [ce]: [aD, an, V, ay, az], rules: [{ endpoint: bk, [cd]: n }], [cd]: o }, { [ce]: [aD, an, V, ay, aC], endpoint: bk, [cd]: n }, { [ce]: [W, an, aF, aw], endpoint: { [cj]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [ck]: ax, [cq]: ah }, [cd]: n }, { [ce]: [W, an, aF, ay, az], rules: [{ endpoint: bl, [cd]: n }], [cd]: o }, { [ce]: [W, an, aF, ay, aC], endpoint: bl, [cd]: n }, { [ce]: [aD, X, ac, aF, aw], endpoint: { [cj]: O, [ck]: ax, [cq]: ah }, [cd]: n }, { [ce]: [aD, X, ac, aF, ay, az], rules: [{ [ce]: bP, endpoint: bm, [cd]: n }, { endpoint: bm, [cd]: n }], [cd]: o }, { [ce]: [aD, X, ac, aF, ay, aC], endpoint: bm, [cd]: n }, { [ce]: [aD, an, aF, aw], endpoint: { [cj]: P, [ck]: ax, [cq]: ah }, [cd]: n }, { [ce]: [aD, an, aF, ay, az], rules: [{ [ce]: bP, endpoint: { [cj]: P, [ck]: aB, [cq]: ah }, [cd]: n }, { endpoint: bn, [cd]: n }], [cd]: o }, { [ce]: [aD, an, aF, ay, aC], endpoint: bn, [cd]: n }], [cd]: o }, { error: "Path-style addressing cannot be used with S3 Accelerate", [cd]: e }], [cd]: o }], [cd]: o }], [cd]: o }, { [ce]: [{ [cf]: c, [cg]: [bo] }, { [cf]: d, [cg]: [bo, b] }], rules: [{ [ce]: bN, rules: [{ [ce]: cb, rules: [aT, aU, { [ce]: bA, endpoint: { [cj]: s, [ck]: bp, [cq]: ah }, [cd]: n }, { [ce]: bF, endpoint: { [cj]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [ck]: bp, [cq]: ah }, [cd]: n }, { endpoint: { [cj]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [ck]: bp, [cq]: ah }, [cd]: n }], [cd]: o }, aO], [cd]: o }], [cd]: o }, { [ce]: [ap], rules: [{ [ce]: bN, rules: [{ [ce]: cb, rules: [{ [ce]: [V, W, an, aw], endpoint: { [cj]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ck]: ax, [cq]: ah }, [cd]: n }, { [ce]: [V, W, an, ay, az], rules: [{ endpoint: bq, [cd]: n }], [cd]: o }, { [ce]: [V, W, an, ay, aC], endpoint: bq, [cd]: n }, { [ce]: [V, aD, an, aw], endpoint: { [cj]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [ck]: ax, [cq]: ah }, [cd]: n }, { [ce]: [V, aD, an, ay, az], rules: [{ endpoint: br, [cd]: n }], [cd]: o }, { [ce]: [V, aD, an, ay, aC], endpoint: br, [cd]: n }, { [ce]: [aF, W, an, aw], endpoint: { [cj]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [ck]: ax, [cq]: ah }, [cd]: n }, { [ce]: [aF, W, an, ay, az], rules: [{ endpoint: bs, [cd]: n }], [cd]: o }, { [ce]: [aF, W, an, ay, aC], endpoint: bs, [cd]: n }, { [ce]: [aF, aD, X, ac, aw], endpoint: { [cj]: s, [ck]: ax, [cq]: ah }, [cd]: n }, { [ce]: [aF, aD, X, ac, ay, az], rules: [{ [ce]: bP, endpoint: bt, [cd]: n }, { endpoint: bt, [cd]: n }], [cd]: o }, { [ce]: [aF, aD, X, ac, ay, aC], endpoint: bt, [cd]: n }, { [ce]: [aF, aD, an, aw], endpoint: { [cj]: Q, [ck]: ax, [cq]: ah }, [cd]: n }, { [ce]: [aF, aD, an, ay, az], rules: [{ [ce]: bP, endpoint: { [cj]: Q, [ck]: aB, [cq]: ah }, [cd]: n }, { endpoint: bu, [cd]: n }], [cd]: o }, { [ce]: [aF, aD, an, ay, aC], endpoint: bu, [cd]: n }], [cd]: o }, aO], [cd]: o }], [cd]: o }], [cd]: o }, { error: "A region must be set when sending requests to S3.", [cd]: e }] };
exports.ruleSet = _data;


/***/ }),

/***/ 19250:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.S3ServiceException = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(22034), exports);
tslib_1.__exportStar(__nccwpck_require__(67862), exports);
tslib_1.__exportStar(__nccwpck_require__(73706), exports);
tslib_1.__exportStar(__nccwpck_require__(4448), exports);
tslib_1.__exportStar(__nccwpck_require__(6908), exports);
tslib_1.__exportStar(__nccwpck_require__(56684), exports);
__nccwpck_require__(13350);
var S3ServiceException_1 = __nccwpck_require__(37614);
Object.defineProperty(exports, "S3ServiceException", ({ enumerable: true, get: function () { return S3ServiceException_1.S3ServiceException; } }));


/***/ }),

/***/ 37614:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.S3ServiceException = exports.__ServiceException = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "__ServiceException", ({ enumerable: true, get: function () { return smithy_client_1.ServiceException; } }));
class S3ServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, S3ServiceException.prototype);
    }
}
exports.S3ServiceException = S3ServiceException;


/***/ }),

/***/ 56684:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(51628), exports);
tslib_1.__exportStar(__nccwpck_require__(6958), exports);


/***/ }),

/***/ 51628:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SseKmsEncryptedObjectsStatus = exports.ReplicaModificationsStatus = exports.ReplicationRuleFilter = exports.ExistingObjectReplicationStatus = exports.ReplicationTimeStatus = exports.MetricsStatus = exports.DeleteMarkerReplicationStatus = exports.FilterRuleName = exports.Event = exports.MetricsFilter = exports.PartitionDateSource = exports.BucketLogsPermission = exports.ExpirationStatus = exports.TransitionStorageClass = exports.LifecycleRuleFilter = exports.InventoryFrequency = exports.InventoryOptionalField = exports.InventoryIncludedObjectVersions = exports.InventoryFormat = exports.IntelligentTieringAccessTier = exports.IntelligentTieringStatus = exports.StorageClassAnalysisSchemaVersion = exports.AnalyticsS3ExportFileFormat = exports.AnalyticsFilter = exports.NoSuchBucket = exports.SessionMode = exports.ObjectOwnership = exports.BucketLocationConstraint = exports.LocationType = exports.BucketType = exports.DataRedundancy = exports.BucketCannedACL = exports.BucketAlreadyOwnedByYou = exports.BucketAlreadyExists = exports.ObjectNotInActiveTierError = exports.TaggingDirective = exports.StorageClass = exports.ObjectLockMode = exports.ObjectLockLegalHoldStatus = exports.MetadataDirective = exports.ChecksumAlgorithm = exports.ObjectCannedACL = exports.ServerSideEncryption = exports.OwnerOverride = exports.Permission = exports.Type = exports.BucketAccelerateStatus = exports.NoSuchUpload = exports.RequestPayer = exports.RequestCharged = void 0;
exports.PutBucketInventoryConfigurationRequestFilterSensitiveLog = exports.PutBucketEncryptionRequestFilterSensitiveLog = exports.ListPartsRequestFilterSensitiveLog = exports.ListBucketInventoryConfigurationsOutputFilterSensitiveLog = exports.HeadObjectRequestFilterSensitiveLog = exports.HeadObjectOutputFilterSensitiveLog = exports.GetObjectTorrentOutputFilterSensitiveLog = exports.GetObjectAttributesRequestFilterSensitiveLog = exports.GetObjectRequestFilterSensitiveLog = exports.GetObjectOutputFilterSensitiveLog = exports.GetBucketInventoryConfigurationOutputFilterSensitiveLog = exports.InventoryConfigurationFilterSensitiveLog = exports.InventoryDestinationFilterSensitiveLog = exports.InventoryS3BucketDestinationFilterSensitiveLog = exports.InventoryEncryptionFilterSensitiveLog = exports.SSEKMSFilterSensitiveLog = exports.GetBucketEncryptionOutputFilterSensitiveLog = exports.ServerSideEncryptionConfigurationFilterSensitiveLog = exports.ServerSideEncryptionRuleFilterSensitiveLog = exports.ServerSideEncryptionByDefaultFilterSensitiveLog = exports.CreateSessionOutputFilterSensitiveLog = exports.SessionCredentialsFilterSensitiveLog = exports.CreateMultipartUploadRequestFilterSensitiveLog = exports.CreateMultipartUploadOutputFilterSensitiveLog = exports.CopyObjectRequestFilterSensitiveLog = exports.CopyObjectOutputFilterSensitiveLog = exports.CompleteMultipartUploadRequestFilterSensitiveLog = exports.CompleteMultipartUploadOutputFilterSensitiveLog = exports.ObjectVersionStorageClass = exports.OptionalObjectAttributes = exports.ObjectStorageClass = exports.EncodingType = exports.ArchiveStatus = exports.NotFound = exports.ObjectLockRetentionMode = exports.ObjectLockEnabled = exports.ObjectAttributes = exports.NoSuchKey = exports.InvalidObjectState = exports.ChecksumMode = exports.ReplicationStatus = exports.Protocol = exports.BucketVersioningStatus = exports.MFADeleteStatus = exports.Payer = exports.ReplicationRuleStatus = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const S3ServiceException_1 = __nccwpck_require__(37614);
exports.RequestCharged = {
    requester: "requester",
};
exports.RequestPayer = {
    requester: "requester",
};
class NoSuchUpload extends S3ServiceException_1.S3ServiceException {
    constructor(opts) {
        super({
            name: "NoSuchUpload",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchUpload";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchUpload.prototype);
    }
}
exports.NoSuchUpload = NoSuchUpload;
exports.BucketAccelerateStatus = {
    Enabled: "Enabled",
    Suspended: "Suspended",
};
exports.Type = {
    AmazonCustomerByEmail: "AmazonCustomerByEmail",
    CanonicalUser: "CanonicalUser",
    Group: "Group",
};
exports.Permission = {
    FULL_CONTROL: "FULL_CONTROL",
    READ: "READ",
    READ_ACP: "READ_ACP",
    WRITE: "WRITE",
    WRITE_ACP: "WRITE_ACP",
};
exports.OwnerOverride = {
    Destination: "Destination",
};
exports.ServerSideEncryption = {
    AES256: "AES256",
    aws_kms: "aws:kms",
    aws_kms_dsse: "aws:kms:dsse",
};
exports.ObjectCannedACL = {
    authenticated_read: "authenticated-read",
    aws_exec_read: "aws-exec-read",
    bucket_owner_full_control: "bucket-owner-full-control",
    bucket_owner_read: "bucket-owner-read",
    private: "private",
    public_read: "public-read",
    public_read_write: "public-read-write",
};
exports.ChecksumAlgorithm = {
    CRC32: "CRC32",
    CRC32C: "CRC32C",
    SHA1: "SHA1",
    SHA256: "SHA256",
};
exports.MetadataDirective = {
    COPY: "COPY",
    REPLACE: "REPLACE",
};
exports.ObjectLockLegalHoldStatus = {
    OFF: "OFF",
    ON: "ON",
};
exports.ObjectLockMode = {
    COMPLIANCE: "COMPLIANCE",
    GOVERNANCE: "GOVERNANCE",
};
exports.StorageClass = {
    DEEP_ARCHIVE: "DEEP_ARCHIVE",
    EXPRESS_ONEZONE: "EXPRESS_ONEZONE",
    GLACIER: "GLACIER",
    GLACIER_IR: "GLACIER_IR",
    INTELLIGENT_TIERING: "INTELLIGENT_TIERING",
    ONEZONE_IA: "ONEZONE_IA",
    OUTPOSTS: "OUTPOSTS",
    REDUCED_REDUNDANCY: "REDUCED_REDUNDANCY",
    SNOW: "SNOW",
    STANDARD: "STANDARD",
    STANDARD_IA: "STANDARD_IA",
};
exports.TaggingDirective = {
    COPY: "COPY",
    REPLACE: "REPLACE",
};
class ObjectNotInActiveTierError extends S3ServiceException_1.S3ServiceException {
    constructor(opts) {
        super({
            name: "ObjectNotInActiveTierError",
            $fault: "client",
            ...opts,
        });
        this.name = "ObjectNotInActiveTierError";
        this.$fault = "client";
        Object.setPrototypeOf(this, ObjectNotInActiveTierError.prototype);
    }
}
exports.ObjectNotInActiveTierError = ObjectNotInActiveTierError;
class BucketAlreadyExists extends S3ServiceException_1.S3ServiceException {
    constructor(opts) {
        super({
            name: "BucketAlreadyExists",
            $fault: "client",
            ...opts,
        });
        this.name = "BucketAlreadyExists";
        this.$fault = "client";
        Object.setPrototypeOf(this, BucketAlreadyExists.prototype);
    }
}
exports.BucketAlreadyExists = BucketAlreadyExists;
class BucketAlreadyOwnedByYou extends S3ServiceException_1.S3ServiceException {
    constructor(opts) {
        super({
            name: "BucketAlreadyOwnedByYou",
            $fault: "client",
            ...opts,
        });
        this.name = "BucketAlreadyOwnedByYou";
        this.$fault = "client";
        Object.setPrototypeOf(this, BucketAlreadyOwnedByYou.prototype);
    }
}
exports.BucketAlreadyOwnedByYou = BucketAlreadyOwnedByYou;
exports.BucketCannedACL = {
    authenticated_read: "authenticated-read",
    private: "private",
    public_read: "public-read",
    public_read_write: "public-read-write",
};
exports.DataRedundancy = {
    SingleAvailabilityZone: "SingleAvailabilityZone",
};
exports.BucketType = {
    Directory: "Directory",
};
exports.LocationType = {
    AvailabilityZone: "AvailabilityZone",
};
exports.BucketLocationConstraint = {
    EU: "EU",
    af_south_1: "af-south-1",
    ap_east_1: "ap-east-1",
    ap_northeast_1: "ap-northeast-1",
    ap_northeast_2: "ap-northeast-2",
    ap_northeast_3: "ap-northeast-3",
    ap_south_1: "ap-south-1",
    ap_south_2: "ap-south-2",
    ap_southeast_1: "ap-southeast-1",
    ap_southeast_2: "ap-southeast-2",
    ap_southeast_3: "ap-southeast-3",
    ca_central_1: "ca-central-1",
    cn_north_1: "cn-north-1",
    cn_northwest_1: "cn-northwest-1",
    eu_central_1: "eu-central-1",
    eu_north_1: "eu-north-1",
    eu_south_1: "eu-south-1",
    eu_south_2: "eu-south-2",
    eu_west_1: "eu-west-1",
    eu_west_2: "eu-west-2",
    eu_west_3: "eu-west-3",
    me_south_1: "me-south-1",
    sa_east_1: "sa-east-1",
    us_east_2: "us-east-2",
    us_gov_east_1: "us-gov-east-1",
    us_gov_west_1: "us-gov-west-1",
    us_west_1: "us-west-1",
    us_west_2: "us-west-2",
};
exports.ObjectOwnership = {
    BucketOwnerEnforced: "BucketOwnerEnforced",
    BucketOwnerPreferred: "BucketOwnerPreferred",
    ObjectWriter: "ObjectWriter",
};
exports.SessionMode = {
    ReadOnly: "ReadOnly",
    ReadWrite: "ReadWrite",
};
class NoSuchBucket extends S3ServiceException_1.S3ServiceException {
    constructor(opts) {
        super({
            name: "NoSuchBucket",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchBucket";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchBucket.prototype);
    }
}
exports.NoSuchBucket = NoSuchBucket;
var AnalyticsFilter;
(function (AnalyticsFilter) {
    AnalyticsFilter.visit = (value, visitor) => {
        if (value.Prefix !== undefined)
            return visitor.Prefix(value.Prefix);
        if (value.Tag !== undefined)
            return visitor.Tag(value.Tag);
        if (value.And !== undefined)
            return visitor.And(value.And);
        return visitor._(value.$unknown[0], value.$unknown[1]);
    };
})(AnalyticsFilter = exports.AnalyticsFilter || (exports.AnalyticsFilter = {}));
exports.AnalyticsS3ExportFileFormat = {
    CSV: "CSV",
};
exports.StorageClassAnalysisSchemaVersion = {
    V_1: "V_1",
};
exports.IntelligentTieringStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled",
};
exports.IntelligentTieringAccessTier = {
    ARCHIVE_ACCESS: "ARCHIVE_ACCESS",
    DEEP_ARCHIVE_ACCESS: "DEEP_ARCHIVE_ACCESS",
};
exports.InventoryFormat = {
    CSV: "CSV",
    ORC: "ORC",
    Parquet: "Parquet",
};
exports.InventoryIncludedObjectVersions = {
    All: "All",
    Current: "Current",
};
exports.InventoryOptionalField = {
    BucketKeyStatus: "BucketKeyStatus",
    ChecksumAlgorithm: "ChecksumAlgorithm",
    ETag: "ETag",
    EncryptionStatus: "EncryptionStatus",
    IntelligentTieringAccessTier: "IntelligentTieringAccessTier",
    IsMultipartUploaded: "IsMultipartUploaded",
    LastModifiedDate: "LastModifiedDate",
    ObjectAccessControlList: "ObjectAccessControlList",
    ObjectLockLegalHoldStatus: "ObjectLockLegalHoldStatus",
    ObjectLockMode: "ObjectLockMode",
    ObjectLockRetainUntilDate: "ObjectLockRetainUntilDate",
    ObjectOwner: "ObjectOwner",
    ReplicationStatus: "ReplicationStatus",
    Size: "Size",
    StorageClass: "StorageClass",
};
exports.InventoryFrequency = {
    Daily: "Daily",
    Weekly: "Weekly",
};
var LifecycleRuleFilter;
(function (LifecycleRuleFilter) {
    LifecycleRuleFilter.visit = (value, visitor) => {
        if (value.Prefix !== undefined)
            return visitor.Prefix(value.Prefix);
        if (value.Tag !== undefined)
            return visitor.Tag(value.Tag);
        if (value.ObjectSizeGreaterThan !== undefined)
            return visitor.ObjectSizeGreaterThan(value.ObjectSizeGreaterThan);
        if (value.ObjectSizeLessThan !== undefined)
            return visitor.ObjectSizeLessThan(value.ObjectSizeLessThan);
        if (value.And !== undefined)
            return visitor.And(value.And);
        return visitor._(value.$unknown[0], value.$unknown[1]);
    };
})(LifecycleRuleFilter = exports.LifecycleRuleFilter || (exports.LifecycleRuleFilter = {}));
exports.TransitionStorageClass = {
    DEEP_ARCHIVE: "DEEP_ARCHIVE",
    GLACIER: "GLACIER",
    GLACIER_IR: "GLACIER_IR",
    INTELLIGENT_TIERING: "INTELLIGENT_TIERING",
    ONEZONE_IA: "ONEZONE_IA",
    STANDARD_IA: "STANDARD_IA",
};
exports.ExpirationStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled",
};
exports.BucketLogsPermission = {
    FULL_CONTROL: "FULL_CONTROL",
    READ: "READ",
    WRITE: "WRITE",
};
exports.PartitionDateSource = {
    DeliveryTime: "DeliveryTime",
    EventTime: "EventTime",
};
var MetricsFilter;
(function (MetricsFilter) {
    MetricsFilter.visit = (value, visitor) => {
        if (value.Prefix !== undefined)
            return visitor.Prefix(value.Prefix);
        if (value.Tag !== undefined)
            return visitor.Tag(value.Tag);
        if (value.AccessPointArn !== undefined)
            return visitor.AccessPointArn(value.AccessPointArn);
        if (value.And !== undefined)
            return visitor.And(value.And);
        return visitor._(value.$unknown[0], value.$unknown[1]);
    };
})(MetricsFilter = exports.MetricsFilter || (exports.MetricsFilter = {}));
exports.Event = {
    s3_IntelligentTiering: "s3:IntelligentTiering",
    s3_LifecycleExpiration_: "s3:LifecycleExpiration:*",
    s3_LifecycleExpiration_Delete: "s3:LifecycleExpiration:Delete",
    s3_LifecycleExpiration_DeleteMarkerCreated: "s3:LifecycleExpiration:DeleteMarkerCreated",
    s3_LifecycleTransition: "s3:LifecycleTransition",
    s3_ObjectAcl_Put: "s3:ObjectAcl:Put",
    s3_ObjectCreated_: "s3:ObjectCreated:*",
    s3_ObjectCreated_CompleteMultipartUpload: "s3:ObjectCreated:CompleteMultipartUpload",
    s3_ObjectCreated_Copy: "s3:ObjectCreated:Copy",
    s3_ObjectCreated_Post: "s3:ObjectCreated:Post",
    s3_ObjectCreated_Put: "s3:ObjectCreated:Put",
    s3_ObjectRemoved_: "s3:ObjectRemoved:*",
    s3_ObjectRemoved_Delete: "s3:ObjectRemoved:Delete",
    s3_ObjectRemoved_DeleteMarkerCreated: "s3:ObjectRemoved:DeleteMarkerCreated",
    s3_ObjectRestore_: "s3:ObjectRestore:*",
    s3_ObjectRestore_Completed: "s3:ObjectRestore:Completed",
    s3_ObjectRestore_Delete: "s3:ObjectRestore:Delete",
    s3_ObjectRestore_Post: "s3:ObjectRestore:Post",
    s3_ObjectTagging_: "s3:ObjectTagging:*",
    s3_ObjectTagging_Delete: "s3:ObjectTagging:Delete",
    s3_ObjectTagging_Put: "s3:ObjectTagging:Put",
    s3_ReducedRedundancyLostObject: "s3:ReducedRedundancyLostObject",
    s3_Replication_: "s3:Replication:*",
    s3_Replication_OperationFailedReplication: "s3:Replication:OperationFailedReplication",
    s3_Replication_OperationMissedThreshold: "s3:Replication:OperationMissedThreshold",
    s3_Replication_OperationNotTracked: "s3:Replication:OperationNotTracked",
    s3_Replication_OperationReplicatedAfterThreshold: "s3:Replication:OperationReplicatedAfterThreshold",
};
exports.FilterRuleName = {
    prefix: "prefix",
    suffix: "suffix",
};
exports.DeleteMarkerReplicationStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled",
};
exports.MetricsStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled",
};
exports.ReplicationTimeStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled",
};
exports.ExistingObjectReplicationStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled",
};
var ReplicationRuleFilter;
(function (ReplicationRuleFilter) {
    ReplicationRuleFilter.visit = (value, visitor) => {
        if (value.Prefix !== undefined)
            return visitor.Prefix(value.Prefix);
        if (value.Tag !== undefined)
            return visitor.Tag(value.Tag);
        if (value.And !== undefined)
            return visitor.And(value.And);
        return visitor._(value.$unknown[0], value.$unknown[1]);
    };
})(ReplicationRuleFilter = exports.ReplicationRuleFilter || (exports.ReplicationRuleFilter = {}));
exports.ReplicaModificationsStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled",
};
exports.SseKmsEncryptedObjectsStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled",
};
exports.ReplicationRuleStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled",
};
exports.Payer = {
    BucketOwner: "BucketOwner",
    Requester: "Requester",
};
exports.MFADeleteStatus = {
    Disabled: "Disabled",
    Enabled: "Enabled",
};
exports.BucketVersioningStatus = {
    Enabled: "Enabled",
    Suspended: "Suspended",
};
exports.Protocol = {
    http: "http",
    https: "https",
};
exports.ReplicationStatus = {
    COMPLETE: "COMPLETE",
    COMPLETED: "COMPLETED",
    FAILED: "FAILED",
    PENDING: "PENDING",
    REPLICA: "REPLICA",
};
exports.ChecksumMode = {
    ENABLED: "ENABLED",
};
class InvalidObjectState extends S3ServiceException_1.S3ServiceException {
    constructor(opts) {
        super({
            name: "InvalidObjectState",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidObjectState";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidObjectState.prototype);
        this.StorageClass = opts.StorageClass;
        this.AccessTier = opts.AccessTier;
    }
}
exports.InvalidObjectState = InvalidObjectState;
class NoSuchKey extends S3ServiceException_1.S3ServiceException {
    constructor(opts) {
        super({
            name: "NoSuchKey",
            $fault: "client",
            ...opts,
        });
        this.name = "NoSuchKey";
        this.$fault = "client";
        Object.setPrototypeOf(this, NoSuchKey.prototype);
    }
}
exports.NoSuchKey = NoSuchKey;
exports.ObjectAttributes = {
    CHECKSUM: "Checksum",
    ETAG: "ETag",
    OBJECT_PARTS: "ObjectParts",
    OBJECT_SIZE: "ObjectSize",
    STORAGE_CLASS: "StorageClass",
};
exports.ObjectLockEnabled = {
    Enabled: "Enabled",
};
exports.ObjectLockRetentionMode = {
    COMPLIANCE: "COMPLIANCE",
    GOVERNANCE: "GOVERNANCE",
};
class NotFound extends S3ServiceException_1.S3ServiceException {
    constructor(opts) {
        super({
            name: "NotFound",
            $fault: "client",
            ...opts,
        });
        this.name = "NotFound";
        this.$fault = "client";
        Object.setPrototypeOf(this, NotFound.prototype);
    }
}
exports.NotFound = NotFound;
exports.ArchiveStatus = {
    ARCHIVE_ACCESS: "ARCHIVE_ACCESS",
    DEEP_ARCHIVE_ACCESS: "DEEP_ARCHIVE_ACCESS",
};
exports.EncodingType = {
    url: "url",
};
exports.ObjectStorageClass = {
    DEEP_ARCHIVE: "DEEP_ARCHIVE",
    EXPRESS_ONEZONE: "EXPRESS_ONEZONE",
    GLACIER: "GLACIER",
    GLACIER_IR: "GLACIER_IR",
    INTELLIGENT_TIERING: "INTELLIGENT_TIERING",
    ONEZONE_IA: "ONEZONE_IA",
    OUTPOSTS: "OUTPOSTS",
    REDUCED_REDUNDANCY: "REDUCED_REDUNDANCY",
    SNOW: "SNOW",
    STANDARD: "STANDARD",
    STANDARD_IA: "STANDARD_IA",
};
exports.OptionalObjectAttributes = {
    RESTORE_STATUS: "RestoreStatus",
};
exports.ObjectVersionStorageClass = {
    STANDARD: "STANDARD",
};
const CompleteMultipartUploadOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING }),
});
exports.CompleteMultipartUploadOutputFilterSensitiveLog = CompleteMultipartUploadOutputFilterSensitiveLog;
const CompleteMultipartUploadRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING }),
});
exports.CompleteMultipartUploadRequestFilterSensitiveLog = CompleteMultipartUploadRequestFilterSensitiveLog;
const CopyObjectOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: smithy_client_1.SENSITIVE_STRING }),
});
exports.CopyObjectOutputFilterSensitiveLog = CopyObjectOutputFilterSensitiveLog;
const CopyObjectRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.CopySourceSSECustomerKey && { CopySourceSSECustomerKey: smithy_client_1.SENSITIVE_STRING }),
});
exports.CopyObjectRequestFilterSensitiveLog = CopyObjectRequestFilterSensitiveLog;
const CreateMultipartUploadOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: smithy_client_1.SENSITIVE_STRING }),
});
exports.CreateMultipartUploadOutputFilterSensitiveLog = CreateMultipartUploadOutputFilterSensitiveLog;
const CreateMultipartUploadRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: smithy_client_1.SENSITIVE_STRING }),
});
exports.CreateMultipartUploadRequestFilterSensitiveLog = CreateMultipartUploadRequestFilterSensitiveLog;
const SessionCredentialsFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SecretAccessKey && { SecretAccessKey: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.SessionToken && { SessionToken: smithy_client_1.SENSITIVE_STRING }),
});
exports.SessionCredentialsFilterSensitiveLog = SessionCredentialsFilterSensitiveLog;
const CreateSessionOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Credentials && { Credentials: (0, exports.SessionCredentialsFilterSensitiveLog)(obj.Credentials) }),
});
exports.CreateSessionOutputFilterSensitiveLog = CreateSessionOutputFilterSensitiveLog;
const ServerSideEncryptionByDefaultFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.KMSMasterKeyID && { KMSMasterKeyID: smithy_client_1.SENSITIVE_STRING }),
});
exports.ServerSideEncryptionByDefaultFilterSensitiveLog = ServerSideEncryptionByDefaultFilterSensitiveLog;
const ServerSideEncryptionRuleFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.ApplyServerSideEncryptionByDefault && {
        ApplyServerSideEncryptionByDefault: (0, exports.ServerSideEncryptionByDefaultFilterSensitiveLog)(obj.ApplyServerSideEncryptionByDefault),
    }),
});
exports.ServerSideEncryptionRuleFilterSensitiveLog = ServerSideEncryptionRuleFilterSensitiveLog;
const ServerSideEncryptionConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Rules && { Rules: obj.Rules.map((item) => (0, exports.ServerSideEncryptionRuleFilterSensitiveLog)(item)) }),
});
exports.ServerSideEncryptionConfigurationFilterSensitiveLog = ServerSideEncryptionConfigurationFilterSensitiveLog;
const GetBucketEncryptionOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.ServerSideEncryptionConfiguration && {
        ServerSideEncryptionConfiguration: (0, exports.ServerSideEncryptionConfigurationFilterSensitiveLog)(obj.ServerSideEncryptionConfiguration),
    }),
});
exports.GetBucketEncryptionOutputFilterSensitiveLog = GetBucketEncryptionOutputFilterSensitiveLog;
const SSEKMSFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.KeyId && { KeyId: smithy_client_1.SENSITIVE_STRING }),
});
exports.SSEKMSFilterSensitiveLog = SSEKMSFilterSensitiveLog;
const InventoryEncryptionFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSEKMS && { SSEKMS: (0, exports.SSEKMSFilterSensitiveLog)(obj.SSEKMS) }),
});
exports.InventoryEncryptionFilterSensitiveLog = InventoryEncryptionFilterSensitiveLog;
const InventoryS3BucketDestinationFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Encryption && { Encryption: (0, exports.InventoryEncryptionFilterSensitiveLog)(obj.Encryption) }),
});
exports.InventoryS3BucketDestinationFilterSensitiveLog = InventoryS3BucketDestinationFilterSensitiveLog;
const InventoryDestinationFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.S3BucketDestination && {
        S3BucketDestination: (0, exports.InventoryS3BucketDestinationFilterSensitiveLog)(obj.S3BucketDestination),
    }),
});
exports.InventoryDestinationFilterSensitiveLog = InventoryDestinationFilterSensitiveLog;
const InventoryConfigurationFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Destination && { Destination: (0, exports.InventoryDestinationFilterSensitiveLog)(obj.Destination) }),
});
exports.InventoryConfigurationFilterSensitiveLog = InventoryConfigurationFilterSensitiveLog;
const GetBucketInventoryConfigurationOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.InventoryConfiguration && {
        InventoryConfiguration: (0, exports.InventoryConfigurationFilterSensitiveLog)(obj.InventoryConfiguration),
    }),
});
exports.GetBucketInventoryConfigurationOutputFilterSensitiveLog = GetBucketInventoryConfigurationOutputFilterSensitiveLog;
const GetObjectOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING }),
});
exports.GetObjectOutputFilterSensitiveLog = GetObjectOutputFilterSensitiveLog;
const GetObjectRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING }),
});
exports.GetObjectRequestFilterSensitiveLog = GetObjectRequestFilterSensitiveLog;
const GetObjectAttributesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING }),
});
exports.GetObjectAttributesRequestFilterSensitiveLog = GetObjectAttributesRequestFilterSensitiveLog;
const GetObjectTorrentOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});
exports.GetObjectTorrentOutputFilterSensitiveLog = GetObjectTorrentOutputFilterSensitiveLog;
const HeadObjectOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING }),
});
exports.HeadObjectOutputFilterSensitiveLog = HeadObjectOutputFilterSensitiveLog;
const HeadObjectRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING }),
});
exports.HeadObjectRequestFilterSensitiveLog = HeadObjectRequestFilterSensitiveLog;
const ListBucketInventoryConfigurationsOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.InventoryConfigurationList && {
        InventoryConfigurationList: obj.InventoryConfigurationList.map((item) => (0, exports.InventoryConfigurationFilterSensitiveLog)(item)),
    }),
});
exports.ListBucketInventoryConfigurationsOutputFilterSensitiveLog = ListBucketInventoryConfigurationsOutputFilterSensitiveLog;
const ListPartsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING }),
});
exports.ListPartsRequestFilterSensitiveLog = ListPartsRequestFilterSensitiveLog;
const PutBucketEncryptionRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.ServerSideEncryptionConfiguration && {
        ServerSideEncryptionConfiguration: (0, exports.ServerSideEncryptionConfigurationFilterSensitiveLog)(obj.ServerSideEncryptionConfiguration),
    }),
});
exports.PutBucketEncryptionRequestFilterSensitiveLog = PutBucketEncryptionRequestFilterSensitiveLog;
const PutBucketInventoryConfigurationRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.InventoryConfiguration && {
        InventoryConfiguration: (0, exports.InventoryConfigurationFilterSensitiveLog)(obj.InventoryConfiguration),
    }),
});
exports.PutBucketInventoryConfigurationRequestFilterSensitiveLog = PutBucketInventoryConfigurationRequestFilterSensitiveLog;


/***/ }),

/***/ 6958:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WriteGetObjectResponseRequestFilterSensitiveLog = exports.UploadPartCopyRequestFilterSensitiveLog = exports.UploadPartCopyOutputFilterSensitiveLog = exports.UploadPartRequestFilterSensitiveLog = exports.UploadPartOutputFilterSensitiveLog = exports.SelectObjectContentRequestFilterSensitiveLog = exports.SelectObjectContentOutputFilterSensitiveLog = exports.SelectObjectContentEventStreamFilterSensitiveLog = exports.RestoreObjectRequestFilterSensitiveLog = exports.RestoreRequestFilterSensitiveLog = exports.OutputLocationFilterSensitiveLog = exports.S3LocationFilterSensitiveLog = exports.EncryptionFilterSensitiveLog = exports.PutObjectRequestFilterSensitiveLog = exports.PutObjectOutputFilterSensitiveLog = exports.SelectObjectContentEventStream = exports.RestoreRequestType = exports.QuoteFields = exports.JSONType = exports.FileHeaderInfo = exports.CompressionType = exports.ExpressionType = exports.Tier = exports.ObjectAlreadyInActiveTierError = exports.MFADelete = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const S3ServiceException_1 = __nccwpck_require__(37614);
exports.MFADelete = {
    Disabled: "Disabled",
    Enabled: "Enabled",
};
class ObjectAlreadyInActiveTierError extends S3ServiceException_1.S3ServiceException {
    constructor(opts) {
        super({
            name: "ObjectAlreadyInActiveTierError",
            $fault: "client",
            ...opts,
        });
        this.name = "ObjectAlreadyInActiveTierError";
        this.$fault = "client";
        Object.setPrototypeOf(this, ObjectAlreadyInActiveTierError.prototype);
    }
}
exports.ObjectAlreadyInActiveTierError = ObjectAlreadyInActiveTierError;
exports.Tier = {
    Bulk: "Bulk",
    Expedited: "Expedited",
    Standard: "Standard",
};
exports.ExpressionType = {
    SQL: "SQL",
};
exports.CompressionType = {
    BZIP2: "BZIP2",
    GZIP: "GZIP",
    NONE: "NONE",
};
exports.FileHeaderInfo = {
    IGNORE: "IGNORE",
    NONE: "NONE",
    USE: "USE",
};
exports.JSONType = {
    DOCUMENT: "DOCUMENT",
    LINES: "LINES",
};
exports.QuoteFields = {
    ALWAYS: "ALWAYS",
    ASNEEDED: "ASNEEDED",
};
exports.RestoreRequestType = {
    SELECT: "SELECT",
};
var SelectObjectContentEventStream;
(function (SelectObjectContentEventStream) {
    SelectObjectContentEventStream.visit = (value, visitor) => {
        if (value.Records !== undefined)
            return visitor.Records(value.Records);
        if (value.Stats !== undefined)
            return visitor.Stats(value.Stats);
        if (value.Progress !== undefined)
            return visitor.Progress(value.Progress);
        if (value.Cont !== undefined)
            return visitor.Cont(value.Cont);
        if (value.End !== undefined)
            return visitor.End(value.End);
        return visitor._(value.$unknown[0], value.$unknown[1]);
    };
})(SelectObjectContentEventStream = exports.SelectObjectContentEventStream || (exports.SelectObjectContentEventStream = {}));
const PutObjectOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: smithy_client_1.SENSITIVE_STRING }),
});
exports.PutObjectOutputFilterSensitiveLog = PutObjectOutputFilterSensitiveLog;
const PutObjectRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: smithy_client_1.SENSITIVE_STRING }),
});
exports.PutObjectRequestFilterSensitiveLog = PutObjectRequestFilterSensitiveLog;
const EncryptionFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.KMSKeyId && { KMSKeyId: smithy_client_1.SENSITIVE_STRING }),
});
exports.EncryptionFilterSensitiveLog = EncryptionFilterSensitiveLog;
const S3LocationFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Encryption && { Encryption: (0, exports.EncryptionFilterSensitiveLog)(obj.Encryption) }),
});
exports.S3LocationFilterSensitiveLog = S3LocationFilterSensitiveLog;
const OutputLocationFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.S3 && { S3: (0, exports.S3LocationFilterSensitiveLog)(obj.S3) }),
});
exports.OutputLocationFilterSensitiveLog = OutputLocationFilterSensitiveLog;
const RestoreRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.OutputLocation && { OutputLocation: (0, exports.OutputLocationFilterSensitiveLog)(obj.OutputLocation) }),
});
exports.RestoreRequestFilterSensitiveLog = RestoreRequestFilterSensitiveLog;
const RestoreObjectRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.RestoreRequest && { RestoreRequest: (0, exports.RestoreRequestFilterSensitiveLog)(obj.RestoreRequest) }),
});
exports.RestoreObjectRequestFilterSensitiveLog = RestoreObjectRequestFilterSensitiveLog;
const SelectObjectContentEventStreamFilterSensitiveLog = (obj) => {
    if (obj.Records !== undefined)
        return { Records: obj.Records };
    if (obj.Stats !== undefined)
        return { Stats: obj.Stats };
    if (obj.Progress !== undefined)
        return { Progress: obj.Progress };
    if (obj.Cont !== undefined)
        return { Cont: obj.Cont };
    if (obj.End !== undefined)
        return { End: obj.End };
    if (obj.$unknown !== undefined)
        return { [obj.$unknown[0]]: "UNKNOWN" };
};
exports.SelectObjectContentEventStreamFilterSensitiveLog = SelectObjectContentEventStreamFilterSensitiveLog;
const SelectObjectContentOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Payload && { Payload: "STREAMING_CONTENT" }),
});
exports.SelectObjectContentOutputFilterSensitiveLog = SelectObjectContentOutputFilterSensitiveLog;
const SelectObjectContentRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING }),
});
exports.SelectObjectContentRequestFilterSensitiveLog = SelectObjectContentRequestFilterSensitiveLog;
const UploadPartOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING }),
});
exports.UploadPartOutputFilterSensitiveLog = UploadPartOutputFilterSensitiveLog;
const UploadPartRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING }),
});
exports.UploadPartRequestFilterSensitiveLog = UploadPartRequestFilterSensitiveLog;
const UploadPartCopyOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING }),
});
exports.UploadPartCopyOutputFilterSensitiveLog = UploadPartCopyOutputFilterSensitiveLog;
const UploadPartCopyRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSECustomerKey && { SSECustomerKey: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.CopySourceSSECustomerKey && { CopySourceSSECustomerKey: smithy_client_1.SENSITIVE_STRING }),
});
exports.UploadPartCopyRequestFilterSensitiveLog = UploadPartCopyRequestFilterSensitiveLog;
const WriteGetObjectResponseRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SSEKMSKeyId && { SSEKMSKeyId: smithy_client_1.SENSITIVE_STRING }),
});
exports.WriteGetObjectResponseRequestFilterSensitiveLog = WriteGetObjectResponseRequestFilterSensitiveLog;


/***/ }),

/***/ 27356:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 30532:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListDirectoryBuckets = void 0;
const core_1 = __nccwpck_require__(55829);
const ListDirectoryBucketsCommand_1 = __nccwpck_require__(68430);
const S3Client_1 = __nccwpck_require__(22034);
exports.paginateListDirectoryBuckets = (0, core_1.createPaginator)(S3Client_1.S3Client, ListDirectoryBucketsCommand_1.ListDirectoryBucketsCommand, "ContinuationToken", "ContinuationToken", "MaxDirectoryBuckets");


/***/ }),

/***/ 45491:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListObjectsV2 = void 0;
const core_1 = __nccwpck_require__(55829);
const ListObjectsV2Command_1 = __nccwpck_require__(89368);
const S3Client_1 = __nccwpck_require__(22034);
exports.paginateListObjectsV2 = (0, core_1.createPaginator)(S3Client_1.S3Client, ListObjectsV2Command_1.ListObjectsV2Command, "ContinuationToken", "NextContinuationToken", "MaxKeys");


/***/ }),

/***/ 82064:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListParts = void 0;
const core_1 = __nccwpck_require__(55829);
const ListPartsCommand_1 = __nccwpck_require__(90896);
const S3Client_1 = __nccwpck_require__(22034);
exports.paginateListParts = (0, core_1.createPaginator)(S3Client_1.S3Client, ListPartsCommand_1.ListPartsCommand, "PartNumberMarker", "NextPartNumberMarker", "MaxParts");


/***/ }),

/***/ 4448:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(27356), exports);
tslib_1.__exportStar(__nccwpck_require__(30532), exports);
tslib_1.__exportStar(__nccwpck_require__(45491), exports);
tslib_1.__exportStar(__nccwpck_require__(82064), exports);


/***/ }),

/***/ 39809:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.se_GetObjectTaggingCommand = exports.se_GetObjectRetentionCommand = exports.se_GetObjectLockConfigurationCommand = exports.se_GetObjectLegalHoldCommand = exports.se_GetObjectAttributesCommand = exports.se_GetObjectAclCommand = exports.se_GetObjectCommand = exports.se_GetBucketWebsiteCommand = exports.se_GetBucketVersioningCommand = exports.se_GetBucketTaggingCommand = exports.se_GetBucketRequestPaymentCommand = exports.se_GetBucketReplicationCommand = exports.se_GetBucketPolicyStatusCommand = exports.se_GetBucketPolicyCommand = exports.se_GetBucketOwnershipControlsCommand = exports.se_GetBucketNotificationConfigurationCommand = exports.se_GetBucketMetricsConfigurationCommand = exports.se_GetBucketLoggingCommand = exports.se_GetBucketLocationCommand = exports.se_GetBucketLifecycleConfigurationCommand = exports.se_GetBucketInventoryConfigurationCommand = exports.se_GetBucketIntelligentTieringConfigurationCommand = exports.se_GetBucketEncryptionCommand = exports.se_GetBucketCorsCommand = exports.se_GetBucketAnalyticsConfigurationCommand = exports.se_GetBucketAclCommand = exports.se_GetBucketAccelerateConfigurationCommand = exports.se_DeletePublicAccessBlockCommand = exports.se_DeleteObjectTaggingCommand = exports.se_DeleteObjectsCommand = exports.se_DeleteObjectCommand = exports.se_DeleteBucketWebsiteCommand = exports.se_DeleteBucketTaggingCommand = exports.se_DeleteBucketReplicationCommand = exports.se_DeleteBucketPolicyCommand = exports.se_DeleteBucketOwnershipControlsCommand = exports.se_DeleteBucketMetricsConfigurationCommand = exports.se_DeleteBucketLifecycleCommand = exports.se_DeleteBucketInventoryConfigurationCommand = exports.se_DeleteBucketIntelligentTieringConfigurationCommand = exports.se_DeleteBucketEncryptionCommand = exports.se_DeleteBucketCorsCommand = exports.se_DeleteBucketAnalyticsConfigurationCommand = exports.se_DeleteBucketCommand = exports.se_CreateSessionCommand = exports.se_CreateMultipartUploadCommand = exports.se_CreateBucketCommand = exports.se_CopyObjectCommand = exports.se_CompleteMultipartUploadCommand = exports.se_AbortMultipartUploadCommand = void 0;
exports.de_CreateMultipartUploadCommand = exports.de_CreateBucketCommand = exports.de_CopyObjectCommand = exports.de_CompleteMultipartUploadCommand = exports.de_AbortMultipartUploadCommand = exports.se_WriteGetObjectResponseCommand = exports.se_UploadPartCopyCommand = exports.se_UploadPartCommand = exports.se_SelectObjectContentCommand = exports.se_RestoreObjectCommand = exports.se_PutPublicAccessBlockCommand = exports.se_PutObjectTaggingCommand = exports.se_PutObjectRetentionCommand = exports.se_PutObjectLockConfigurationCommand = exports.se_PutObjectLegalHoldCommand = exports.se_PutObjectAclCommand = exports.se_PutObjectCommand = exports.se_PutBucketWebsiteCommand = exports.se_PutBucketVersioningCommand = exports.se_PutBucketTaggingCommand = exports.se_PutBucketRequestPaymentCommand = exports.se_PutBucketReplicationCommand = exports.se_PutBucketPolicyCommand = exports.se_PutBucketOwnershipControlsCommand = exports.se_PutBucketNotificationConfigurationCommand = exports.se_PutBucketMetricsConfigurationCommand = exports.se_PutBucketLoggingCommand = exports.se_PutBucketLifecycleConfigurationCommand = exports.se_PutBucketInventoryConfigurationCommand = exports.se_PutBucketIntelligentTieringConfigurationCommand = exports.se_PutBucketEncryptionCommand = exports.se_PutBucketCorsCommand = exports.se_PutBucketAnalyticsConfigurationCommand = exports.se_PutBucketAclCommand = exports.se_PutBucketAccelerateConfigurationCommand = exports.se_ListPartsCommand = exports.se_ListObjectVersionsCommand = exports.se_ListObjectsV2Command = exports.se_ListObjectsCommand = exports.se_ListMultipartUploadsCommand = exports.se_ListDirectoryBucketsCommand = exports.se_ListBucketsCommand = exports.se_ListBucketMetricsConfigurationsCommand = exports.se_ListBucketInventoryConfigurationsCommand = exports.se_ListBucketIntelligentTieringConfigurationsCommand = exports.se_ListBucketAnalyticsConfigurationsCommand = exports.se_HeadObjectCommand = exports.se_HeadBucketCommand = exports.se_GetPublicAccessBlockCommand = exports.se_GetObjectTorrentCommand = void 0;
exports.de_ListBucketAnalyticsConfigurationsCommand = exports.de_HeadObjectCommand = exports.de_HeadBucketCommand = exports.de_GetPublicAccessBlockCommand = exports.de_GetObjectTorrentCommand = exports.de_GetObjectTaggingCommand = exports.de_GetObjectRetentionCommand = exports.de_GetObjectLockConfigurationCommand = exports.de_GetObjectLegalHoldCommand = exports.de_GetObjectAttributesCommand = exports.de_GetObjectAclCommand = exports.de_GetObjectCommand = exports.de_GetBucketWebsiteCommand = exports.de_GetBucketVersioningCommand = exports.de_GetBucketTaggingCommand = exports.de_GetBucketRequestPaymentCommand = exports.de_GetBucketReplicationCommand = exports.de_GetBucketPolicyStatusCommand = exports.de_GetBucketPolicyCommand = exports.de_GetBucketOwnershipControlsCommand = exports.de_GetBucketNotificationConfigurationCommand = exports.de_GetBucketMetricsConfigurationCommand = exports.de_GetBucketLoggingCommand = exports.de_GetBucketLocationCommand = exports.de_GetBucketLifecycleConfigurationCommand = exports.de_GetBucketInventoryConfigurationCommand = exports.de_GetBucketIntelligentTieringConfigurationCommand = exports.de_GetBucketEncryptionCommand = exports.de_GetBucketCorsCommand = exports.de_GetBucketAnalyticsConfigurationCommand = exports.de_GetBucketAclCommand = exports.de_GetBucketAccelerateConfigurationCommand = exports.de_DeletePublicAccessBlockCommand = exports.de_DeleteObjectTaggingCommand = exports.de_DeleteObjectsCommand = exports.de_DeleteObjectCommand = exports.de_DeleteBucketWebsiteCommand = exports.de_DeleteBucketTaggingCommand = exports.de_DeleteBucketReplicationCommand = exports.de_DeleteBucketPolicyCommand = exports.de_DeleteBucketOwnershipControlsCommand = exports.de_DeleteBucketMetricsConfigurationCommand = exports.de_DeleteBucketLifecycleCommand = exports.de_DeleteBucketInventoryConfigurationCommand = exports.de_DeleteBucketIntelligentTieringConfigurationCommand = exports.de_DeleteBucketEncryptionCommand = exports.de_DeleteBucketCorsCommand = exports.de_DeleteBucketAnalyticsConfigurationCommand = exports.de_DeleteBucketCommand = exports.de_CreateSessionCommand = void 0;
exports.de_WriteGetObjectResponseCommand = exports.de_UploadPartCopyCommand = exports.de_UploadPartCommand = exports.de_SelectObjectContentCommand = exports.de_RestoreObjectCommand = exports.de_PutPublicAccessBlockCommand = exports.de_PutObjectTaggingCommand = exports.de_PutObjectRetentionCommand = exports.de_PutObjectLockConfigurationCommand = exports.de_PutObjectLegalHoldCommand = exports.de_PutObjectAclCommand = exports.de_PutObjectCommand = exports.de_PutBucketWebsiteCommand = exports.de_PutBucketVersioningCommand = exports.de_PutBucketTaggingCommand = exports.de_PutBucketRequestPaymentCommand = exports.de_PutBucketReplicationCommand = exports.de_PutBucketPolicyCommand = exports.de_PutBucketOwnershipControlsCommand = exports.de_PutBucketNotificationConfigurationCommand = exports.de_PutBucketMetricsConfigurationCommand = exports.de_PutBucketLoggingCommand = exports.de_PutBucketLifecycleConfigurationCommand = exports.de_PutBucketInventoryConfigurationCommand = exports.de_PutBucketIntelligentTieringConfigurationCommand = exports.de_PutBucketEncryptionCommand = exports.de_PutBucketCorsCommand = exports.de_PutBucketAnalyticsConfigurationCommand = exports.de_PutBucketAclCommand = exports.de_PutBucketAccelerateConfigurationCommand = exports.de_ListPartsCommand = exports.de_ListObjectVersionsCommand = exports.de_ListObjectsV2Command = exports.de_ListObjectsCommand = exports.de_ListMultipartUploadsCommand = exports.de_ListDirectoryBucketsCommand = exports.de_ListBucketsCommand = exports.de_ListBucketMetricsConfigurationsCommand = exports.de_ListBucketInventoryConfigurationsCommand = exports.de_ListBucketIntelligentTieringConfigurationsCommand = void 0;
const xml_builder_1 = __nccwpck_require__(42329);
const core_1 = __nccwpck_require__(55829);
const protocol_http_1 = __nccwpck_require__(64418);
const smithy_client_1 = __nccwpck_require__(63570);
const fast_xml_parser_1 = __nccwpck_require__(12603);
const models_0_1 = __nccwpck_require__(51628);
const models_1_1 = __nccwpck_require__(6958);
const S3ServiceException_1 = __nccwpck_require__(37614);
const se_AbortMultipartUploadCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_xi]: [, "AbortMultipartUpload"],
        [_uI]: [, (0, smithy_client_1.expectNonNull)(input[_UI], `UploadId`)],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
exports.se_AbortMultipartUploadCommand = se_AbortMultipartUploadCommand;
const se_CompleteMultipartUploadCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xacc]: input[_CCRC],
        [_xacc_]: input[_CCRCC],
        [_xacs]: input[_CSHA],
        [_xacs_]: input[_CSHAh],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_xi]: [, "CompleteMultipartUpload"],
        [_uI]: [, (0, smithy_client_1.expectNonNull)(input[_UI], `UploadId`)],
    });
    let body;
    let contents;
    if (input.MultipartUpload !== undefined) {
        contents = se_CompletedMultipartUpload(input.MultipartUpload, context);
        contents = contents.n("CompleteMultipartUpload");
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_CompleteMultipartUploadCommand = se_CompleteMultipartUploadCommand;
const se_CopyObjectCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaa]: input[_ACL],
        [_cc]: input[_CC],
        [_xaca]: input[_CA],
        [_cd]: input[_CD],
        [_ce]: input[_CE],
        [_cl]: input[_CL],
        [_ct]: input[_CT],
        [_xacs__]: input[_CS],
        [_xacsim]: input[_CSIM],
        [_xacsims]: [() => isSerializableHeaderValue(input[_CSIMS]), () => (0, smithy_client_1.dateToUtcString)(input[_CSIMS]).toString()],
        [_xacsinm]: input[_CSINM],
        [_xacsius]: [() => isSerializableHeaderValue(input[_CSIUS]), () => (0, smithy_client_1.dateToUtcString)(input[_CSIUS]).toString()],
        [_e]: [() => isSerializableHeaderValue(input[_E]), () => (0, smithy_client_1.dateToUtcString)(input[_E]).toString()],
        [_xagfc]: input[_GFC],
        [_xagr]: input[_GR],
        [_xagra]: input[_GRACP],
        [_xagwa]: input[_GWACP],
        [_xamd]: input[_MD],
        [_xatd]: input[_TD],
        [_xasse]: input[_SSE],
        [_xasc]: input[_SC],
        [_xawrl]: input[_WRL],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xasseakki]: input[_SSEKMSKI],
        [_xassec]: input[_SSEKMSEC],
        [_xassebke]: [() => isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()],
        [_xacssseca]: input[_CSSSECA],
        [_xacssseck]: input[_CSSSECK],
        [_xacssseckm]: input[_CSSSECKMD],
        [_xarp]: input[_RP],
        [_xat]: input[_T],
        [_xaolm]: input[_OLM],
        [_xaolrud]: [
            () => isSerializableHeaderValue(input[_OLRUD]),
            () => (input[_OLRUD].toISOString().split(".")[0] + "Z").toString(),
        ],
        [_xaollh]: input[_OLLHS],
        [_xaebo]: input[_EBO],
        [_xasebo]: input[_ESBO],
        ...(input.Metadata !== undefined &&
            Object.keys(input.Metadata).reduce((acc, suffix) => {
                acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
                return acc;
            }, {})),
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_xi]: [, "CopyObject"],
    });
    let body;
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_CopyObjectCommand = se_CopyObjectCommand;
const se_CreateBucketCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaa]: input[_ACL],
        [_xagfc]: input[_GFC],
        [_xagr]: input[_GR],
        [_xagra]: input[_GRACP],
        [_xagw]: input[_GW],
        [_xagwa]: input[_GWACP],
        [_xabole]: [() => isSerializableHeaderValue(input[_OLEFB]), () => input[_OLEFB].toString()],
        [_xaoo]: input[_OO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    let contents;
    if (input.CreateBucketConfiguration !== undefined) {
        contents = se_CreateBucketConfiguration(input.CreateBucketConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).b(body);
    return b.build();
};
exports.se_CreateBucketCommand = se_CreateBucketCommand;
const se_CreateMultipartUploadCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaa]: input[_ACL],
        [_cc]: input[_CC],
        [_cd]: input[_CD],
        [_ce]: input[_CE],
        [_cl]: input[_CL],
        [_ct]: input[_CT],
        [_e]: [() => isSerializableHeaderValue(input[_E]), () => (0, smithy_client_1.dateToUtcString)(input[_E]).toString()],
        [_xagfc]: input[_GFC],
        [_xagr]: input[_GR],
        [_xagra]: input[_GRACP],
        [_xagwa]: input[_GWACP],
        [_xasse]: input[_SSE],
        [_xasc]: input[_SC],
        [_xawrl]: input[_WRL],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xasseakki]: input[_SSEKMSKI],
        [_xassec]: input[_SSEKMSEC],
        [_xassebke]: [() => isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()],
        [_xarp]: input[_RP],
        [_xat]: input[_T],
        [_xaolm]: input[_OLM],
        [_xaolrud]: [
            () => isSerializableHeaderValue(input[_OLRUD]),
            () => (input[_OLRUD].toISOString().split(".")[0] + "Z").toString(),
        ],
        [_xaollh]: input[_OLLHS],
        [_xaebo]: input[_EBO],
        [_xaca]: input[_CA],
        ...(input.Metadata !== undefined &&
            Object.keys(input.Metadata).reduce((acc, suffix) => {
                acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
                return acc;
            }, {})),
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_u]: [, ""],
        [_xi]: [, "CreateMultipartUpload"],
    });
    let body;
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_CreateMultipartUploadCommand = se_CreateMultipartUploadCommand;
const se_CreateSessionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xacsm]: input[_SM],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_s]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_CreateSessionCommand = se_CreateSessionCommand;
const se_DeleteBucketCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
exports.se_DeleteBucketCommand = se_DeleteBucketCommand;
const se_DeleteBucketAnalyticsConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_a]: [, ""],
        [_i]: [, (0, smithy_client_1.expectNonNull)(input[_I], `Id`)],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
exports.se_DeleteBucketAnalyticsConfigurationCommand = se_DeleteBucketAnalyticsConfigurationCommand;
const se_DeleteBucketCorsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_c]: [, ""],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
exports.se_DeleteBucketCorsCommand = se_DeleteBucketCorsCommand;
const se_DeleteBucketEncryptionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_en]: [, ""],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
exports.se_DeleteBucketEncryptionCommand = se_DeleteBucketEncryptionCommand;
const se_DeleteBucketIntelligentTieringConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_it]: [, ""],
        [_i]: [, (0, smithy_client_1.expectNonNull)(input[_I], `Id`)],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
exports.se_DeleteBucketIntelligentTieringConfigurationCommand = se_DeleteBucketIntelligentTieringConfigurationCommand;
const se_DeleteBucketInventoryConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_in]: [, ""],
        [_i]: [, (0, smithy_client_1.expectNonNull)(input[_I], `Id`)],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
exports.se_DeleteBucketInventoryConfigurationCommand = se_DeleteBucketInventoryConfigurationCommand;
const se_DeleteBucketLifecycleCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_l]: [, ""],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
exports.se_DeleteBucketLifecycleCommand = se_DeleteBucketLifecycleCommand;
const se_DeleteBucketMetricsConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_m]: [, ""],
        [_i]: [, (0, smithy_client_1.expectNonNull)(input[_I], `Id`)],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
exports.se_DeleteBucketMetricsConfigurationCommand = se_DeleteBucketMetricsConfigurationCommand;
const se_DeleteBucketOwnershipControlsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_oC]: [, ""],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
exports.se_DeleteBucketOwnershipControlsCommand = se_DeleteBucketOwnershipControlsCommand;
const se_DeleteBucketPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_p]: [, ""],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
exports.se_DeleteBucketPolicyCommand = se_DeleteBucketPolicyCommand;
const se_DeleteBucketReplicationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_r]: [, ""],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
exports.se_DeleteBucketReplicationCommand = se_DeleteBucketReplicationCommand;
const se_DeleteBucketTaggingCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_t]: [, ""],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
exports.se_DeleteBucketTaggingCommand = se_DeleteBucketTaggingCommand;
const se_DeleteBucketWebsiteCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_w]: [, ""],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
exports.se_DeleteBucketWebsiteCommand = se_DeleteBucketWebsiteCommand;
const se_DeleteObjectCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xam]: input[_MFA],
        [_xarp]: input[_RP],
        [_xabgr]: [() => isSerializableHeaderValue(input[_BGR]), () => input[_BGR].toString()],
        [_xaebo]: input[_EBO],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_xi]: [, "DeleteObject"],
        [_vI]: [, input[_VI]],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
exports.se_DeleteObjectCommand = se_DeleteObjectCommand;
const se_DeleteObjectsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xam]: input[_MFA],
        [_xarp]: input[_RP],
        [_xabgr]: [() => isSerializableHeaderValue(input[_BGR]), () => input[_BGR].toString()],
        [_xaebo]: input[_EBO],
        [_xasca]: input[_CA],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_d]: [, ""],
        [_xi]: [, "DeleteObjects"],
    });
    let body;
    let contents;
    if (input.Delete !== undefined) {
        contents = se_Delete(input.Delete, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_DeleteObjectsCommand = se_DeleteObjectsCommand;
const se_DeleteObjectTaggingCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_t]: [, ""],
        [_vI]: [, input[_VI]],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
exports.se_DeleteObjectTaggingCommand = se_DeleteObjectTaggingCommand;
const se_DeletePublicAccessBlockCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_pAB]: [, ""],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
exports.se_DeletePublicAccessBlockCommand = se_DeletePublicAccessBlockCommand;
const se_GetBucketAccelerateConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
        [_xarp]: input[_RP],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_ac]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketAccelerateConfigurationCommand = se_GetBucketAccelerateConfigurationCommand;
const se_GetBucketAclCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_acl]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketAclCommand = se_GetBucketAclCommand;
const se_GetBucketAnalyticsConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_a]: [, ""],
        [_xi]: [, "GetBucketAnalyticsConfiguration"],
        [_i]: [, (0, smithy_client_1.expectNonNull)(input[_I], `Id`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketAnalyticsConfigurationCommand = se_GetBucketAnalyticsConfigurationCommand;
const se_GetBucketCorsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_c]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketCorsCommand = se_GetBucketCorsCommand;
const se_GetBucketEncryptionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_en]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketEncryptionCommand = se_GetBucketEncryptionCommand;
const se_GetBucketIntelligentTieringConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_it]: [, ""],
        [_xi]: [, "GetBucketIntelligentTieringConfiguration"],
        [_i]: [, (0, smithy_client_1.expectNonNull)(input[_I], `Id`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketIntelligentTieringConfigurationCommand = se_GetBucketIntelligentTieringConfigurationCommand;
const se_GetBucketInventoryConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_in]: [, ""],
        [_xi]: [, "GetBucketInventoryConfiguration"],
        [_i]: [, (0, smithy_client_1.expectNonNull)(input[_I], `Id`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketInventoryConfigurationCommand = se_GetBucketInventoryConfigurationCommand;
const se_GetBucketLifecycleConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_l]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketLifecycleConfigurationCommand = se_GetBucketLifecycleConfigurationCommand;
const se_GetBucketLocationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_lo]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketLocationCommand = se_GetBucketLocationCommand;
const se_GetBucketLoggingCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_log]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketLoggingCommand = se_GetBucketLoggingCommand;
const se_GetBucketMetricsConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_m]: [, ""],
        [_xi]: [, "GetBucketMetricsConfiguration"],
        [_i]: [, (0, smithy_client_1.expectNonNull)(input[_I], `Id`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketMetricsConfigurationCommand = se_GetBucketMetricsConfigurationCommand;
const se_GetBucketNotificationConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_n]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketNotificationConfigurationCommand = se_GetBucketNotificationConfigurationCommand;
const se_GetBucketOwnershipControlsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_oC]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketOwnershipControlsCommand = se_GetBucketOwnershipControlsCommand;
const se_GetBucketPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_p]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketPolicyCommand = se_GetBucketPolicyCommand;
const se_GetBucketPolicyStatusCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_pS]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketPolicyStatusCommand = se_GetBucketPolicyStatusCommand;
const se_GetBucketReplicationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_r]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketReplicationCommand = se_GetBucketReplicationCommand;
const se_GetBucketRequestPaymentCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_rP]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketRequestPaymentCommand = se_GetBucketRequestPaymentCommand;
const se_GetBucketTaggingCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_t]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketTaggingCommand = se_GetBucketTaggingCommand;
const se_GetBucketVersioningCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_v]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketVersioningCommand = se_GetBucketVersioningCommand;
const se_GetBucketWebsiteCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_w]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetBucketWebsiteCommand = se_GetBucketWebsiteCommand;
const se_GetObjectCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
        [_ims]: [() => isSerializableHeaderValue(input[_IMS]), () => (0, smithy_client_1.dateToUtcString)(input[_IMS]).toString()],
        [_inm]: input[_INM],
        [_ius]: [() => isSerializableHeaderValue(input[_IUS]), () => (0, smithy_client_1.dateToUtcString)(input[_IUS]).toString()],
        [_ra]: input[_R],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xacm]: input[_CM],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_xi]: [, "GetObject"],
        [_rcc]: [, input[_RCC]],
        [_rcd]: [, input[_RCD]],
        [_rce]: [, input[_RCE]],
        [_rcl]: [, input[_RCL]],
        [_rct]: [, input[_RCT]],
        [_re]: [() => input.ResponseExpires !== void 0, () => (0, smithy_client_1.dateToUtcString)(input[_RE]).toString()],
        [_vI]: [, input[_VI]],
        [_pN]: [() => input.PartNumber !== void 0, () => input[_PN].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetObjectCommand = se_GetObjectCommand;
const se_GetObjectAclCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_acl]: [, ""],
        [_vI]: [, input[_VI]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetObjectAclCommand = se_GetObjectAclCommand;
const se_GetObjectAttributesCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xamp]: [() => isSerializableHeaderValue(input[_MP]), () => input[_MP].toString()],
        [_xapnm]: input[_PNM],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xaoa]: [
            () => isSerializableHeaderValue(input[_OA]),
            () => (input[_OA] || []).map((_entry) => _entry).join(", "),
        ],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_at]: [, ""],
        [_vI]: [, input[_VI]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetObjectAttributesCommand = se_GetObjectAttributesCommand;
const se_GetObjectLegalHoldCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_lh]: [, ""],
        [_vI]: [, input[_VI]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetObjectLegalHoldCommand = se_GetObjectLegalHoldCommand;
const se_GetObjectLockConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_ol]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetObjectLockConfigurationCommand = se_GetObjectLockConfigurationCommand;
const se_GetObjectRetentionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_ret]: [, ""],
        [_vI]: [, input[_VI]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetObjectRetentionCommand = se_GetObjectRetentionCommand;
const se_GetObjectTaggingCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
        [_xarp]: input[_RP],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_t]: [, ""],
        [_vI]: [, input[_VI]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetObjectTaggingCommand = se_GetObjectTaggingCommand;
const se_GetObjectTorrentCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_to]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetObjectTorrentCommand = se_GetObjectTorrentCommand;
const se_GetPublicAccessBlockCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_pAB]: [, ""],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetPublicAccessBlockCommand = se_GetPublicAccessBlockCommand;
const se_HeadBucketCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    let body;
    b.m("HEAD").h(headers).b(body);
    return b.build();
};
exports.se_HeadBucketCommand = se_HeadBucketCommand;
const se_HeadObjectCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_im]: input[_IM],
        [_ims]: [() => isSerializableHeaderValue(input[_IMS]), () => (0, smithy_client_1.dateToUtcString)(input[_IMS]).toString()],
        [_inm]: input[_INM],
        [_ius]: [() => isSerializableHeaderValue(input[_IUS]), () => (0, smithy_client_1.dateToUtcString)(input[_IUS]).toString()],
        [_ra]: input[_R],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xacm]: input[_CM],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_vI]: [, input[_VI]],
        [_pN]: [() => input.PartNumber !== void 0, () => input[_PN].toString()],
    });
    let body;
    b.m("HEAD").h(headers).q(query).b(body);
    return b.build();
};
exports.se_HeadObjectCommand = se_HeadObjectCommand;
const se_ListBucketAnalyticsConfigurationsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_a]: [, ""],
        [_xi]: [, "ListBucketAnalyticsConfigurations"],
        [_ct_]: [, input[_CTo]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListBucketAnalyticsConfigurationsCommand = se_ListBucketAnalyticsConfigurationsCommand;
const se_ListBucketIntelligentTieringConfigurationsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_it]: [, ""],
        [_xi]: [, "ListBucketIntelligentTieringConfigurations"],
        [_ct_]: [, input[_CTo]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListBucketIntelligentTieringConfigurationsCommand = se_ListBucketIntelligentTieringConfigurationsCommand;
const se_ListBucketInventoryConfigurationsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_in]: [, ""],
        [_xi]: [, "ListBucketInventoryConfigurations"],
        [_ct_]: [, input[_CTo]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListBucketInventoryConfigurationsCommand = se_ListBucketInventoryConfigurationsCommand;
const se_ListBucketMetricsConfigurationsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_m]: [, ""],
        [_xi]: [, "ListBucketMetricsConfigurations"],
        [_ct_]: [, input[_CTo]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListBucketMetricsConfigurationsCommand = se_ListBucketMetricsConfigurationsCommand;
const se_ListBucketsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/");
    const query = (0, smithy_client_1.map)({
        [_xi]: [, "ListBuckets"],
    });
    let body;
    body = "";
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListBucketsCommand = se_ListBucketsCommand;
const se_ListDirectoryBucketsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {};
    b.bp("/");
    const query = (0, smithy_client_1.map)({
        [_xi]: [, "ListDirectoryBuckets"],
        [_ct_]: [, input[_CTo]],
        [_mdb]: [() => input.MaxDirectoryBuckets !== void 0, () => input[_MDB].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListDirectoryBucketsCommand = se_ListDirectoryBucketsCommand;
const se_ListMultipartUploadsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
        [_xarp]: input[_RP],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_u]: [, ""],
        [_de]: [, input[_D]],
        [_et]: [, input[_ET]],
        [_km]: [, input[_KM]],
        [_mu]: [() => input.MaxUploads !== void 0, () => input[_MU].toString()],
        [_pr]: [, input[_P]],
        [_uim]: [, input[_UIM]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListMultipartUploadsCommand = se_ListMultipartUploadsCommand;
const se_ListObjectsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xaooa]: [
            () => isSerializableHeaderValue(input[_OOA]),
            () => (input[_OOA] || []).map((_entry) => _entry).join(", "),
        ],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_de]: [, input[_D]],
        [_et]: [, input[_ET]],
        [_ma]: [, input[_M]],
        [_mk]: [() => input.MaxKeys !== void 0, () => input[_MK].toString()],
        [_pr]: [, input[_P]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListObjectsCommand = se_ListObjectsCommand;
const se_ListObjectsV2Command = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xaooa]: [
            () => isSerializableHeaderValue(input[_OOA]),
            () => (input[_OOA] || []).map((_entry) => _entry).join(", "),
        ],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_lt]: [, "2"],
        [_de]: [, input[_D]],
        [_et]: [, input[_ET]],
        [_mk]: [() => input.MaxKeys !== void 0, () => input[_MK].toString()],
        [_pr]: [, input[_P]],
        [_ct_]: [, input[_CTo]],
        [_fo]: [() => input.FetchOwner !== void 0, () => input[_FO].toString()],
        [_sa]: [, input[_SA]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListObjectsV2Command = se_ListObjectsV2Command;
const se_ListObjectVersionsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xaebo]: input[_EBO],
        [_xarp]: input[_RP],
        [_xaooa]: [
            () => isSerializableHeaderValue(input[_OOA]),
            () => (input[_OOA] || []).map((_entry) => _entry).join(", "),
        ],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_ver]: [, ""],
        [_de]: [, input[_D]],
        [_et]: [, input[_ET]],
        [_km]: [, input[_KM]],
        [_mk]: [() => input.MaxKeys !== void 0, () => input[_MK].toString()],
        [_pr]: [, input[_P]],
        [_vim]: [, input[_VIM]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListObjectVersionsCommand = se_ListObjectVersionsCommand;
const se_ListPartsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_xi]: [, "ListParts"],
        [_mp]: [() => input.MaxParts !== void 0, () => input[_MP].toString()],
        [_pnm]: [, input[_PNM]],
        [_uI]: [, (0, smithy_client_1.expectNonNull)(input[_UI], `UploadId`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListPartsCommand = se_ListPartsCommand;
const se_PutBucketAccelerateConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaebo]: input[_EBO],
        [_xasca]: input[_CA],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_ac]: [, ""],
    });
    let body;
    let contents;
    if (input.AccelerateConfiguration !== undefined) {
        contents = se_AccelerateConfiguration(input.AccelerateConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutBucketAccelerateConfigurationCommand = se_PutBucketAccelerateConfigurationCommand;
const se_PutBucketAclCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaa]: input[_ACL],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xagfc]: input[_GFC],
        [_xagr]: input[_GR],
        [_xagra]: input[_GRACP],
        [_xagw]: input[_GW],
        [_xagwa]: input[_GWACP],
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_acl]: [, ""],
    });
    let body;
    let contents;
    if (input.AccessControlPolicy !== undefined) {
        contents = se_AccessControlPolicy(input.AccessControlPolicy, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutBucketAclCommand = se_PutBucketAclCommand;
const se_PutBucketAnalyticsConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_a]: [, ""],
        [_i]: [, (0, smithy_client_1.expectNonNull)(input[_I], `Id`)],
    });
    let body;
    let contents;
    if (input.AnalyticsConfiguration !== undefined) {
        contents = se_AnalyticsConfiguration(input.AnalyticsConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutBucketAnalyticsConfigurationCommand = se_PutBucketAnalyticsConfigurationCommand;
const se_PutBucketCorsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_c]: [, ""],
    });
    let body;
    let contents;
    if (input.CORSConfiguration !== undefined) {
        contents = se_CORSConfiguration(input.CORSConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutBucketCorsCommand = se_PutBucketCorsCommand;
const se_PutBucketEncryptionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_en]: [, ""],
    });
    let body;
    let contents;
    if (input.ServerSideEncryptionConfiguration !== undefined) {
        contents = se_ServerSideEncryptionConfiguration(input.ServerSideEncryptionConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutBucketEncryptionCommand = se_PutBucketEncryptionCommand;
const se_PutBucketIntelligentTieringConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = {
        "content-type": "application/xml",
    };
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_it]: [, ""],
        [_i]: [, (0, smithy_client_1.expectNonNull)(input[_I], `Id`)],
    });
    let body;
    let contents;
    if (input.IntelligentTieringConfiguration !== undefined) {
        contents = se_IntelligentTieringConfiguration(input.IntelligentTieringConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutBucketIntelligentTieringConfigurationCommand = se_PutBucketIntelligentTieringConfigurationCommand;
const se_PutBucketInventoryConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_in]: [, ""],
        [_i]: [, (0, smithy_client_1.expectNonNull)(input[_I], `Id`)],
    });
    let body;
    let contents;
    if (input.InventoryConfiguration !== undefined) {
        contents = se_InventoryConfiguration(input.InventoryConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutBucketInventoryConfigurationCommand = se_PutBucketInventoryConfigurationCommand;
const se_PutBucketLifecycleConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_l]: [, ""],
    });
    let body;
    let contents;
    if (input.LifecycleConfiguration !== undefined) {
        contents = se_BucketLifecycleConfiguration(input.LifecycleConfiguration, context);
        contents = contents.n("LifecycleConfiguration");
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutBucketLifecycleConfigurationCommand = se_PutBucketLifecycleConfigurationCommand;
const se_PutBucketLoggingCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_log]: [, ""],
    });
    let body;
    let contents;
    if (input.BucketLoggingStatus !== undefined) {
        contents = se_BucketLoggingStatus(input.BucketLoggingStatus, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutBucketLoggingCommand = se_PutBucketLoggingCommand;
const se_PutBucketMetricsConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_m]: [, ""],
        [_i]: [, (0, smithy_client_1.expectNonNull)(input[_I], `Id`)],
    });
    let body;
    let contents;
    if (input.MetricsConfiguration !== undefined) {
        contents = se_MetricsConfiguration(input.MetricsConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutBucketMetricsConfigurationCommand = se_PutBucketMetricsConfigurationCommand;
const se_PutBucketNotificationConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaebo]: input[_EBO],
        [_xasdv]: [() => isSerializableHeaderValue(input[_SDV]), () => input[_SDV].toString()],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_n]: [, ""],
    });
    let body;
    let contents;
    if (input.NotificationConfiguration !== undefined) {
        contents = se_NotificationConfiguration(input.NotificationConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutBucketNotificationConfigurationCommand = se_PutBucketNotificationConfigurationCommand;
const se_PutBucketOwnershipControlsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_oC]: [, ""],
    });
    let body;
    let contents;
    if (input.OwnershipControls !== undefined) {
        contents = se_OwnershipControls(input.OwnershipControls, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutBucketOwnershipControlsCommand = se_PutBucketOwnershipControlsCommand;
const se_PutBucketPolicyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "text/plain",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xacrsba]: [() => isSerializableHeaderValue(input[_CRSBA]), () => input[_CRSBA].toString()],
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_p]: [, ""],
    });
    let body;
    let contents;
    if (input.Policy !== undefined) {
        contents = input.Policy;
        body = contents;
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutBucketPolicyCommand = se_PutBucketPolicyCommand;
const se_PutBucketReplicationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xabolt]: input[_To],
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_r]: [, ""],
    });
    let body;
    let contents;
    if (input.ReplicationConfiguration !== undefined) {
        contents = se_ReplicationConfiguration(input.ReplicationConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutBucketReplicationCommand = se_PutBucketReplicationCommand;
const se_PutBucketRequestPaymentCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_rP]: [, ""],
    });
    let body;
    let contents;
    if (input.RequestPaymentConfiguration !== undefined) {
        contents = se_RequestPaymentConfiguration(input.RequestPaymentConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutBucketRequestPaymentCommand = se_PutBucketRequestPaymentCommand;
const se_PutBucketTaggingCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_t]: [, ""],
    });
    let body;
    let contents;
    if (input.Tagging !== undefined) {
        contents = se_Tagging(input.Tagging, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutBucketTaggingCommand = se_PutBucketTaggingCommand;
const se_PutBucketVersioningCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xam]: input[_MFA],
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_v]: [, ""],
    });
    let body;
    let contents;
    if (input.VersioningConfiguration !== undefined) {
        contents = se_VersioningConfiguration(input.VersioningConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutBucketVersioningCommand = se_PutBucketVersioningCommand;
const se_PutBucketWebsiteCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_w]: [, ""],
    });
    let body;
    let contents;
    if (input.WebsiteConfiguration !== undefined) {
        contents = se_WebsiteConfiguration(input.WebsiteConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutBucketWebsiteCommand = se_PutBucketWebsiteCommand;
const se_PutObjectCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_ct]: input[_CT] || "application/octet-stream",
        [_xaa]: input[_ACL],
        [_cc]: input[_CC],
        [_cd]: input[_CD],
        [_ce]: input[_CE],
        [_cl]: input[_CL],
        [_cl_]: [() => isSerializableHeaderValue(input[_CLo]), () => input[_CLo].toString()],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xacc]: input[_CCRC],
        [_xacc_]: input[_CCRCC],
        [_xacs]: input[_CSHA],
        [_xacs_]: input[_CSHAh],
        [_e]: [() => isSerializableHeaderValue(input[_E]), () => (0, smithy_client_1.dateToUtcString)(input[_E]).toString()],
        [_xagfc]: input[_GFC],
        [_xagr]: input[_GR],
        [_xagra]: input[_GRACP],
        [_xagwa]: input[_GWACP],
        [_xasse]: input[_SSE],
        [_xasc]: input[_SC],
        [_xawrl]: input[_WRL],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xasseakki]: input[_SSEKMSKI],
        [_xassec]: input[_SSEKMSEC],
        [_xassebke]: [() => isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()],
        [_xarp]: input[_RP],
        [_xat]: input[_T],
        [_xaolm]: input[_OLM],
        [_xaolrud]: [
            () => isSerializableHeaderValue(input[_OLRUD]),
            () => (input[_OLRUD].toISOString().split(".")[0] + "Z").toString(),
        ],
        [_xaollh]: input[_OLLHS],
        [_xaebo]: input[_EBO],
        ...(input.Metadata !== undefined &&
            Object.keys(input.Metadata).reduce((acc, suffix) => {
                acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
                return acc;
            }, {})),
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_xi]: [, "PutObject"],
    });
    let body;
    let contents;
    if (input.Body !== undefined) {
        contents = input.Body;
        body = contents;
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutObjectCommand = se_PutObjectCommand;
const se_PutObjectAclCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xaa]: input[_ACL],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xagfc]: input[_GFC],
        [_xagr]: input[_GR],
        [_xagra]: input[_GRACP],
        [_xagw]: input[_GW],
        [_xagwa]: input[_GWACP],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_acl]: [, ""],
        [_vI]: [, input[_VI]],
    });
    let body;
    let contents;
    if (input.AccessControlPolicy !== undefined) {
        contents = se_AccessControlPolicy(input.AccessControlPolicy, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutObjectAclCommand = se_PutObjectAclCommand;
const se_PutObjectLegalHoldCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xarp]: input[_RP],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_lh]: [, ""],
        [_vI]: [, input[_VI]],
    });
    let body;
    let contents;
    if (input.LegalHold !== undefined) {
        contents = se_ObjectLockLegalHold(input.LegalHold, context);
        contents = contents.n("LegalHold");
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutObjectLegalHoldCommand = se_PutObjectLegalHoldCommand;
const se_PutObjectLockConfigurationCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xarp]: input[_RP],
        [_xabolt]: input[_To],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_ol]: [, ""],
    });
    let body;
    let contents;
    if (input.ObjectLockConfiguration !== undefined) {
        contents = se_ObjectLockConfiguration(input.ObjectLockConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutObjectLockConfigurationCommand = se_PutObjectLockConfigurationCommand;
const se_PutObjectRetentionCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xarp]: input[_RP],
        [_xabgr]: [() => isSerializableHeaderValue(input[_BGR]), () => input[_BGR].toString()],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_ret]: [, ""],
        [_vI]: [, input[_VI]],
    });
    let body;
    let contents;
    if (input.Retention !== undefined) {
        contents = se_ObjectLockRetention(input.Retention, context);
        contents = contents.n("Retention");
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutObjectRetentionCommand = se_PutObjectRetentionCommand;
const se_PutObjectTaggingCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO],
        [_xarp]: input[_RP],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_t]: [, ""],
        [_vI]: [, input[_VI]],
    });
    let body;
    let contents;
    if (input.Tagging !== undefined) {
        contents = se_Tagging(input.Tagging, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutObjectTaggingCommand = se_PutObjectTaggingCommand;
const se_PutPublicAccessBlockCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO],
    });
    b.bp("/");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    const query = (0, smithy_client_1.map)({
        [_pAB]: [, ""],
    });
    let body;
    let contents;
    if (input.PublicAccessBlockConfiguration !== undefined) {
        contents = se_PublicAccessBlockConfiguration(input.PublicAccessBlockConfiguration, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_PutPublicAccessBlockCommand = se_PutPublicAccessBlockCommand;
const se_RestoreObjectCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xarp]: input[_RP],
        [_xasca]: input[_CA],
        [_xaebo]: input[_EBO],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_res]: [, ""],
        [_xi]: [, "RestoreObject"],
        [_vI]: [, input[_VI]],
    });
    let body;
    let contents;
    if (input.RestoreRequest !== undefined) {
        contents = se_RestoreRequest(input.RestoreRequest, context);
        body = _ve;
        contents.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
        body += contents.toString();
    }
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_RestoreObjectCommand = se_RestoreObjectCommand;
const se_SelectObjectContentCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/xml",
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xaebo]: input[_EBO],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_se]: [, ""],
        [_st]: [, "2"],
        [_xi]: [, "SelectObjectContent"],
    });
    let body;
    body = _ve;
    const bn = new xml_builder_1.XmlNode(_SOCR);
    bn.a("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    bn.cc(input, _Ex);
    bn.cc(input, _ETx);
    if (input[_IS] != null) {
        bn.c(se_InputSerialization(input[_IS], context).n(_IS));
    }
    if (input[_OS] != null) {
        bn.c(se_OutputSerialization(input[_OS], context).n(_OS));
    }
    if (input[_RPe] != null) {
        bn.c(se_RequestProgress(input[_RPe], context).n(_RPe));
    }
    if (input[_SR] != null) {
        bn.c(se_ScanRange(input[_SR], context).n(_SR));
    }
    body += bn.toString();
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_SelectObjectContentCommand = se_SelectObjectContentCommand;
const se_UploadPartCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/octet-stream",
        [_cl_]: [() => isSerializableHeaderValue(input[_CLo]), () => input[_CLo].toString()],
        [_cm]: input[_CMD],
        [_xasca]: input[_CA],
        [_xacc]: input[_CCRC],
        [_xacc_]: input[_CCRCC],
        [_xacs]: input[_CSHA],
        [_xacs_]: input[_CSHAh],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_xi]: [, "UploadPart"],
        [_pN]: [(0, smithy_client_1.expectNonNull)(input.PartNumber, `PartNumber`) != null, () => input[_PN].toString()],
        [_uI]: [, (0, smithy_client_1.expectNonNull)(input[_UI], `UploadId`)],
    });
    let body;
    let contents;
    if (input.Body !== undefined) {
        contents = input.Body;
        body = contents;
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_UploadPartCommand = se_UploadPartCommand;
const se_UploadPartCopyCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xacs__]: input[_CS],
        [_xacsim]: input[_CSIM],
        [_xacsims]: [() => isSerializableHeaderValue(input[_CSIMS]), () => (0, smithy_client_1.dateToUtcString)(input[_CSIMS]).toString()],
        [_xacsinm]: input[_CSINM],
        [_xacsius]: [() => isSerializableHeaderValue(input[_CSIUS]), () => (0, smithy_client_1.dateToUtcString)(input[_CSIUS]).toString()],
        [_xacsr]: input[_CSR],
        [_xasseca]: input[_SSECA],
        [_xasseck]: input[_SSECK],
        [_xasseckm]: input[_SSECKMD],
        [_xacssseca]: input[_CSSSECA],
        [_xacssseck]: input[_CSSSECK],
        [_xacssseckm]: input[_CSSSECKMD],
        [_xarp]: input[_RP],
        [_xaebo]: input[_EBO],
        [_xasebo]: input[_ESBO],
    });
    b.bp("/{Key+}");
    b.p("Bucket", () => input.Bucket, "{Bucket}", false);
    b.p("Key", () => input.Key, "{Key+}", true);
    const query = (0, smithy_client_1.map)({
        [_xi]: [, "UploadPartCopy"],
        [_pN]: [(0, smithy_client_1.expectNonNull)(input.PartNumber, `PartNumber`) != null, () => input[_PN].toString()],
        [_uI]: [, (0, smithy_client_1.expectNonNull)(input[_UI], `UploadId`)],
    });
    let body;
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
exports.se_UploadPartCopyCommand = se_UploadPartCopyCommand;
const se_WriteGetObjectResponseCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "x-amz-content-sha256": "UNSIGNED-PAYLOAD",
        "content-type": "application/octet-stream",
        [_xarr]: input[_RR],
        [_xart]: input[_RT],
        [_xafs]: [() => isSerializableHeaderValue(input[_SCt]), () => input[_SCt].toString()],
        [_xafec]: input[_EC],
        [_xafem]: input[_EM],
        [_xafhar]: input[_AR],
        [_xafhcc]: input[_CC],
        [_xafhcd]: input[_CD],
        [_xafhce]: input[_CE],
        [_xafhcl]: input[_CL],
        [_cl_]: [() => isSerializableHeaderValue(input[_CLo]), () => input[_CLo].toString()],
        [_xafhcr]: input[_CR],
        [_xafhct]: input[_CT],
        [_xafhxacc]: input[_CCRC],
        [_xafhxacc_]: input[_CCRCC],
        [_xafhxacs]: input[_CSHA],
        [_xafhxacs_]: input[_CSHAh],
        [_xafhxadm]: [() => isSerializableHeaderValue(input[_DM]), () => input[_DM].toString()],
        [_xafhe]: input[_ETa],
        [_xafhe_]: [() => isSerializableHeaderValue(input[_E]), () => (0, smithy_client_1.dateToUtcString)(input[_E]).toString()],
        [_xafhxae]: input[_Exp],
        [_xafhlm]: [() => isSerializableHeaderValue(input[_LM]), () => (0, smithy_client_1.dateToUtcString)(input[_LM]).toString()],
        [_xafhxamm]: [() => isSerializableHeaderValue(input[_MM]), () => input[_MM].toString()],
        [_xafhxaolm]: input[_OLM],
        [_xafhxaollh]: input[_OLLHS],
        [_xafhxaolrud]: [
            () => isSerializableHeaderValue(input[_OLRUD]),
            () => (input[_OLRUD].toISOString().split(".")[0] + "Z").toString(),
        ],
        [_xafhxampc]: [() => isSerializableHeaderValue(input[_PC]), () => input[_PC].toString()],
        [_xafhxars]: input[_RS],
        [_xafhxarc]: input[_RC],
        [_xafhxar]: input[_Re],
        [_xafhxasse]: input[_SSE],
        [_xafhxasseca]: input[_SSECA],
        [_xafhxasseakki]: input[_SSEKMSKI],
        [_xafhxasseckm]: input[_SSECKMD],
        [_xafhxasc]: input[_SC],
        [_xafhxatc]: [() => isSerializableHeaderValue(input[_TC]), () => input[_TC].toString()],
        [_xafhxavi]: input[_VI],
        [_xafhxassebke]: [() => isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()],
        ...(input.Metadata !== undefined &&
            Object.keys(input.Metadata).reduce((acc, suffix) => {
                acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
                return acc;
            }, {})),
    });
    b.bp("/WriteGetObjectResponse");
    const query = (0, smithy_client_1.map)({
        [_xi]: [, "WriteGetObjectResponse"],
    });
    let body;
    let contents;
    if (input.Body !== undefined) {
        contents = input.Body;
        body = contents;
    }
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "{RequestRoute}." + resolvedHostname;
        if (input.RequestRoute === undefined) {
            throw new Error("Empty value provided for input host prefix: RequestRoute.");
        }
        resolvedHostname = resolvedHostname.replace("{RequestRoute}", input.RequestRoute);
        if (!(0, protocol_http_1.isValidHostname)(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
exports.se_WriteGetObjectResponseCommand = se_WriteGetObjectResponseCommand;
const de_AbortMultipartUploadCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_AbortMultipartUploadCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_RC]: [, output.headers[_xarc]],
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_AbortMultipartUploadCommand = de_AbortMultipartUploadCommand;
const de_AbortMultipartUploadCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchUpload":
        case "com.amazonaws.s3#NoSuchUpload":
            throw await de_NoSuchUploadRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CompleteMultipartUploadCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CompleteMultipartUploadCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_Exp]: [, output.headers[_xae]],
        [_SSE]: [, output.headers[_xasse]],
        [_VI]: [, output.headers[_xavi]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => (0, smithy_client_1.parseBoolean)(output.headers[_xassebke])],
        [_RC]: [, output.headers[_xarc]],
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_B] != null) {
        contents[_B] = (0, smithy_client_1.expectString)(data[_B]);
    }
    if (data[_CCRC] != null) {
        contents[_CCRC] = (0, smithy_client_1.expectString)(data[_CCRC]);
    }
    if (data[_CCRCC] != null) {
        contents[_CCRCC] = (0, smithy_client_1.expectString)(data[_CCRCC]);
    }
    if (data[_CSHA] != null) {
        contents[_CSHA] = (0, smithy_client_1.expectString)(data[_CSHA]);
    }
    if (data[_CSHAh] != null) {
        contents[_CSHAh] = (0, smithy_client_1.expectString)(data[_CSHAh]);
    }
    if (data[_ETa] != null) {
        contents[_ETa] = (0, smithy_client_1.expectString)(data[_ETa]);
    }
    if (data[_K] != null) {
        contents[_K] = (0, smithy_client_1.expectString)(data[_K]);
    }
    if (data[_L] != null) {
        contents[_L] = (0, smithy_client_1.expectString)(data[_L]);
    }
    return contents;
};
exports.de_CompleteMultipartUploadCommand = de_CompleteMultipartUploadCommand;
const de_CompleteMultipartUploadCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_CopyObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CopyObjectCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_Exp]: [, output.headers[_xae]],
        [_CSVI]: [, output.headers[_xacsvi]],
        [_VI]: [, output.headers[_xavi]],
        [_SSE]: [, output.headers[_xasse]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_SSEKMSEC]: [, output.headers[_xassec]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => (0, smithy_client_1.parseBoolean)(output.headers[_xassebke])],
        [_RC]: [, output.headers[_xarc]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CopyObjectResult = de_CopyObjectResult(data, context);
    return contents;
};
exports.de_CopyObjectCommand = de_CopyObjectCommand;
const de_CopyObjectCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ObjectNotInActiveTierError":
        case "com.amazonaws.s3#ObjectNotInActiveTierError":
            throw await de_ObjectNotInActiveTierErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateBucketCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateBucketCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_L]: [, output.headers[_lo]],
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_CreateBucketCommand = de_CreateBucketCommand;
const de_CreateBucketCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BucketAlreadyExists":
        case "com.amazonaws.s3#BucketAlreadyExists":
            throw await de_BucketAlreadyExistsRes(parsedOutput, context);
        case "BucketAlreadyOwnedByYou":
        case "com.amazonaws.s3#BucketAlreadyOwnedByYou":
            throw await de_BucketAlreadyOwnedByYouRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateMultipartUploadCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateMultipartUploadCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_AD]: [
            () => void 0 !== output.headers[_xaad],
            () => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc7231DateTime)(output.headers[_xaad])),
        ],
        [_ARI]: [, output.headers[_xaari]],
        [_SSE]: [, output.headers[_xasse]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_SSEKMSEC]: [, output.headers[_xassec]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => (0, smithy_client_1.parseBoolean)(output.headers[_xassebke])],
        [_RC]: [, output.headers[_xarc]],
        [_CA]: [, output.headers[_xaca]],
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_B] != null) {
        contents[_B] = (0, smithy_client_1.expectString)(data[_B]);
    }
    if (data[_K] != null) {
        contents[_K] = (0, smithy_client_1.expectString)(data[_K]);
    }
    if (data[_UI] != null) {
        contents[_UI] = (0, smithy_client_1.expectString)(data[_UI]);
    }
    return contents;
};
exports.de_CreateMultipartUploadCommand = de_CreateMultipartUploadCommand;
const de_CreateMultipartUploadCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_CreateSessionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateSessionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_C] != null) {
        contents[_C] = de_SessionCredentials(data[_C], context);
    }
    return contents;
};
exports.de_CreateSessionCommand = de_CreateSessionCommand;
const de_CreateSessionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchBucket":
        case "com.amazonaws.s3#NoSuchBucket":
            throw await de_NoSuchBucketRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteBucketCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteBucketCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteBucketCommand = de_DeleteBucketCommand;
const de_DeleteBucketCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_DeleteBucketAnalyticsConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteBucketAnalyticsConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteBucketAnalyticsConfigurationCommand = de_DeleteBucketAnalyticsConfigurationCommand;
const de_DeleteBucketAnalyticsConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_DeleteBucketCorsCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteBucketCorsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteBucketCorsCommand = de_DeleteBucketCorsCommand;
const de_DeleteBucketCorsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_DeleteBucketEncryptionCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteBucketEncryptionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteBucketEncryptionCommand = de_DeleteBucketEncryptionCommand;
const de_DeleteBucketEncryptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_DeleteBucketIntelligentTieringConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteBucketIntelligentTieringConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteBucketIntelligentTieringConfigurationCommand = de_DeleteBucketIntelligentTieringConfigurationCommand;
const de_DeleteBucketIntelligentTieringConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_DeleteBucketInventoryConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteBucketInventoryConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteBucketInventoryConfigurationCommand = de_DeleteBucketInventoryConfigurationCommand;
const de_DeleteBucketInventoryConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_DeleteBucketLifecycleCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteBucketLifecycleCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteBucketLifecycleCommand = de_DeleteBucketLifecycleCommand;
const de_DeleteBucketLifecycleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_DeleteBucketMetricsConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteBucketMetricsConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteBucketMetricsConfigurationCommand = de_DeleteBucketMetricsConfigurationCommand;
const de_DeleteBucketMetricsConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_DeleteBucketOwnershipControlsCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteBucketOwnershipControlsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteBucketOwnershipControlsCommand = de_DeleteBucketOwnershipControlsCommand;
const de_DeleteBucketOwnershipControlsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_DeleteBucketPolicyCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteBucketPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteBucketPolicyCommand = de_DeleteBucketPolicyCommand;
const de_DeleteBucketPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_DeleteBucketReplicationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteBucketReplicationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteBucketReplicationCommand = de_DeleteBucketReplicationCommand;
const de_DeleteBucketReplicationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_DeleteBucketTaggingCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteBucketTaggingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteBucketTaggingCommand = de_DeleteBucketTaggingCommand;
const de_DeleteBucketTaggingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_DeleteBucketWebsiteCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteBucketWebsiteCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteBucketWebsiteCommand = de_DeleteBucketWebsiteCommand;
const de_DeleteBucketWebsiteCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_DeleteObjectCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteObjectCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_DM]: [() => void 0 !== output.headers[_xadm], () => (0, smithy_client_1.parseBoolean)(output.headers[_xadm])],
        [_VI]: [, output.headers[_xavi]],
        [_RC]: [, output.headers[_xarc]],
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteObjectCommand = de_DeleteObjectCommand;
const de_DeleteObjectCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_DeleteObjectsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteObjectsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_RC]: [, output.headers[_xarc]],
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.Deleted === "") {
        contents[_De] = [];
    }
    else if (data[_De] != null) {
        contents[_De] = de_DeletedObjects((0, smithy_client_1.getArrayIfSingleItem)(data[_De]), context);
    }
    if (data.Error === "") {
        contents[_Err] = [];
    }
    else if (data[_Er] != null) {
        contents[_Err] = de_Errors((0, smithy_client_1.getArrayIfSingleItem)(data[_Er]), context);
    }
    return contents;
};
exports.de_DeleteObjectsCommand = de_DeleteObjectsCommand;
const de_DeleteObjectsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_DeleteObjectTaggingCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeleteObjectTaggingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_VI]: [, output.headers[_xavi]],
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteObjectTaggingCommand = de_DeleteObjectTaggingCommand;
const de_DeleteObjectTaggingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_DeletePublicAccessBlockCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_DeletePublicAccessBlockCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeletePublicAccessBlockCommand = de_DeletePublicAccessBlockCommand;
const de_DeletePublicAccessBlockCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketAccelerateConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketAccelerateConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_RC]: [, output.headers[_xarc]],
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_S] != null) {
        contents[_S] = (0, smithy_client_1.expectString)(data[_S]);
    }
    return contents;
};
exports.de_GetBucketAccelerateConfigurationCommand = de_GetBucketAccelerateConfigurationCommand;
const de_GetBucketAccelerateConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketAclCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketAclCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.AccessControlList === "") {
        contents[_Gr] = [];
    }
    else if (data[_ACLc] != null && data[_ACLc][_G] != null) {
        contents[_Gr] = de_Grants((0, smithy_client_1.getArrayIfSingleItem)(data[_ACLc][_G]), context);
    }
    if (data[_O] != null) {
        contents[_O] = de_Owner(data[_O], context);
    }
    return contents;
};
exports.de_GetBucketAclCommand = de_GetBucketAclCommand;
const de_GetBucketAclCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketAnalyticsConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketAnalyticsConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.AnalyticsConfiguration = de_AnalyticsConfiguration(data, context);
    return contents;
};
exports.de_GetBucketAnalyticsConfigurationCommand = de_GetBucketAnalyticsConfigurationCommand;
const de_GetBucketAnalyticsConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketCorsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketCorsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.CORSRule === "") {
        contents[_CORSRu] = [];
    }
    else if (data[_CORSR] != null) {
        contents[_CORSRu] = de_CORSRules((0, smithy_client_1.getArrayIfSingleItem)(data[_CORSR]), context);
    }
    return contents;
};
exports.de_GetBucketCorsCommand = de_GetBucketCorsCommand;
const de_GetBucketCorsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketEncryptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketEncryptionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ServerSideEncryptionConfiguration = de_ServerSideEncryptionConfiguration(data, context);
    return contents;
};
exports.de_GetBucketEncryptionCommand = de_GetBucketEncryptionCommand;
const de_GetBucketEncryptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketIntelligentTieringConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketIntelligentTieringConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.IntelligentTieringConfiguration = de_IntelligentTieringConfiguration(data, context);
    return contents;
};
exports.de_GetBucketIntelligentTieringConfigurationCommand = de_GetBucketIntelligentTieringConfigurationCommand;
const de_GetBucketIntelligentTieringConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketInventoryConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketInventoryConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.InventoryConfiguration = de_InventoryConfiguration(data, context);
    return contents;
};
exports.de_GetBucketInventoryConfigurationCommand = de_GetBucketInventoryConfigurationCommand;
const de_GetBucketInventoryConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketLifecycleConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketLifecycleConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.Rule === "") {
        contents[_Rul] = [];
    }
    else if (data[_Ru] != null) {
        contents[_Rul] = de_LifecycleRules((0, smithy_client_1.getArrayIfSingleItem)(data[_Ru]), context);
    }
    return contents;
};
exports.de_GetBucketLifecycleConfigurationCommand = de_GetBucketLifecycleConfigurationCommand;
const de_GetBucketLifecycleConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketLocationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketLocationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_LC] != null) {
        contents[_LC] = (0, smithy_client_1.expectString)(data[_LC]);
    }
    return contents;
};
exports.de_GetBucketLocationCommand = de_GetBucketLocationCommand;
const de_GetBucketLocationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketLoggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketLoggingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_LE] != null) {
        contents[_LE] = de_LoggingEnabled(data[_LE], context);
    }
    return contents;
};
exports.de_GetBucketLoggingCommand = de_GetBucketLoggingCommand;
const de_GetBucketLoggingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketMetricsConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketMetricsConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.MetricsConfiguration = de_MetricsConfiguration(data, context);
    return contents;
};
exports.de_GetBucketMetricsConfigurationCommand = de_GetBucketMetricsConfigurationCommand;
const de_GetBucketMetricsConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketNotificationConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketNotificationConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_EBC] != null) {
        contents[_EBC] = de_EventBridgeConfiguration(data[_EBC], context);
    }
    if (data.CloudFunctionConfiguration === "") {
        contents[_LFC] = [];
    }
    else if (data[_CFC] != null) {
        contents[_LFC] = de_LambdaFunctionConfigurationList((0, smithy_client_1.getArrayIfSingleItem)(data[_CFC]), context);
    }
    if (data.QueueConfiguration === "") {
        contents[_QCu] = [];
    }
    else if (data[_QC] != null) {
        contents[_QCu] = de_QueueConfigurationList((0, smithy_client_1.getArrayIfSingleItem)(data[_QC]), context);
    }
    if (data.TopicConfiguration === "") {
        contents[_TCop] = [];
    }
    else if (data[_TCo] != null) {
        contents[_TCop] = de_TopicConfigurationList((0, smithy_client_1.getArrayIfSingleItem)(data[_TCo]), context);
    }
    return contents;
};
exports.de_GetBucketNotificationConfigurationCommand = de_GetBucketNotificationConfigurationCommand;
const de_GetBucketNotificationConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketOwnershipControlsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketOwnershipControlsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.OwnershipControls = de_OwnershipControls(data, context);
    return contents;
};
exports.de_GetBucketOwnershipControlsCommand = de_GetBucketOwnershipControlsCommand;
const de_GetBucketOwnershipControlsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = await collectBodyString(output.body, context);
    contents.Policy = (0, smithy_client_1.expectString)(data);
    return contents;
};
exports.de_GetBucketPolicyCommand = de_GetBucketPolicyCommand;
const de_GetBucketPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketPolicyStatusCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketPolicyStatusCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.PolicyStatus = de_PolicyStatus(data, context);
    return contents;
};
exports.de_GetBucketPolicyStatusCommand = de_GetBucketPolicyStatusCommand;
const de_GetBucketPolicyStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketReplicationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketReplicationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ReplicationConfiguration = de_ReplicationConfiguration(data, context);
    return contents;
};
exports.de_GetBucketReplicationCommand = de_GetBucketReplicationCommand;
const de_GetBucketReplicationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketRequestPaymentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketRequestPaymentCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_Pa] != null) {
        contents[_Pa] = (0, smithy_client_1.expectString)(data[_Pa]);
    }
    return contents;
};
exports.de_GetBucketRequestPaymentCommand = de_GetBucketRequestPaymentCommand;
const de_GetBucketRequestPaymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketTaggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketTaggingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.TagSet === "") {
        contents[_TS] = [];
    }
    else if (data[_TS] != null && data[_TS][_Ta] != null) {
        contents[_TS] = de_TagSet((0, smithy_client_1.getArrayIfSingleItem)(data[_TS][_Ta]), context);
    }
    return contents;
};
exports.de_GetBucketTaggingCommand = de_GetBucketTaggingCommand;
const de_GetBucketTaggingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketVersioningCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketVersioningCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_MDf] != null) {
        contents[_MFAD] = (0, smithy_client_1.expectString)(data[_MDf]);
    }
    if (data[_S] != null) {
        contents[_S] = (0, smithy_client_1.expectString)(data[_S]);
    }
    return contents;
};
exports.de_GetBucketVersioningCommand = de_GetBucketVersioningCommand;
const de_GetBucketVersioningCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetBucketWebsiteCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketWebsiteCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_ED] != null) {
        contents[_ED] = de_ErrorDocument(data[_ED], context);
    }
    if (data[_ID] != null) {
        contents[_ID] = de_IndexDocument(data[_ID], context);
    }
    if (data[_RART] != null) {
        contents[_RART] = de_RedirectAllRequestsTo(data[_RART], context);
    }
    if (data.RoutingRules === "") {
        contents[_RRo] = [];
    }
    else if (data[_RRo] != null && data[_RRo][_RRou] != null) {
        contents[_RRo] = de_RoutingRules((0, smithy_client_1.getArrayIfSingleItem)(data[_RRo][_RRou]), context);
    }
    return contents;
};
exports.de_GetBucketWebsiteCommand = de_GetBucketWebsiteCommand;
const de_GetBucketWebsiteCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetObjectCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_DM]: [() => void 0 !== output.headers[_xadm], () => (0, smithy_client_1.parseBoolean)(output.headers[_xadm])],
        [_AR]: [, output.headers[_ar]],
        [_Exp]: [, output.headers[_xae]],
        [_Re]: [, output.headers[_xar]],
        [_LM]: [() => void 0 !== output.headers[_lm], () => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc7231DateTime)(output.headers[_lm]))],
        [_CLo]: [() => void 0 !== output.headers[_cl_], () => (0, smithy_client_1.strictParseLong)(output.headers[_cl_])],
        [_ETa]: [, output.headers[_eta]],
        [_CCRC]: [, output.headers[_xacc]],
        [_CCRCC]: [, output.headers[_xacc_]],
        [_CSHA]: [, output.headers[_xacs]],
        [_CSHAh]: [, output.headers[_xacs_]],
        [_MM]: [() => void 0 !== output.headers[_xamm], () => (0, smithy_client_1.strictParseInt32)(output.headers[_xamm])],
        [_VI]: [, output.headers[_xavi]],
        [_CC]: [, output.headers[_cc]],
        [_CD]: [, output.headers[_cd]],
        [_CE]: [, output.headers[_ce]],
        [_CL]: [, output.headers[_cl]],
        [_CR]: [, output.headers[_cr]],
        [_CT]: [, output.headers[_ct]],
        [_E]: [() => void 0 !== output.headers[_e], () => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc7231DateTime)(output.headers[_e]))],
        [_WRL]: [, output.headers[_xawrl]],
        [_SSE]: [, output.headers[_xasse]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => (0, smithy_client_1.parseBoolean)(output.headers[_xassebke])],
        [_SC]: [, output.headers[_xasc]],
        [_RC]: [, output.headers[_xarc]],
        [_RS]: [, output.headers[_xars]],
        [_PC]: [() => void 0 !== output.headers[_xampc], () => (0, smithy_client_1.strictParseInt32)(output.headers[_xampc])],
        [_TC]: [() => void 0 !== output.headers[_xatc], () => (0, smithy_client_1.strictParseInt32)(output.headers[_xatc])],
        [_OLM]: [, output.headers[_xaolm]],
        [_OLRUD]: [
            () => void 0 !== output.headers[_xaolrud],
            () => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output.headers[_xaolrud])),
        ],
        [_OLLHS]: [, output.headers[_xaollh]],
        Metadata: [
            ,
            Object.keys(output.headers)
                .filter((header) => header.startsWith("x-amz-meta-"))
                .reduce((acc, header) => {
                acc[header.substring(11)] = output.headers[header];
                return acc;
            }, {}),
        ],
    });
    const data = output.body;
    context.sdkStreamMixin(data);
    contents.Body = data;
    return contents;
};
exports.de_GetObjectCommand = de_GetObjectCommand;
const de_GetObjectCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidObjectState":
        case "com.amazonaws.s3#InvalidObjectState":
            throw await de_InvalidObjectStateRes(parsedOutput, context);
        case "NoSuchKey":
        case "com.amazonaws.s3#NoSuchKey":
            throw await de_NoSuchKeyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetObjectAclCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetObjectAclCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_RC]: [, output.headers[_xarc]],
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.AccessControlList === "") {
        contents[_Gr] = [];
    }
    else if (data[_ACLc] != null && data[_ACLc][_G] != null) {
        contents[_Gr] = de_Grants((0, smithy_client_1.getArrayIfSingleItem)(data[_ACLc][_G]), context);
    }
    if (data[_O] != null) {
        contents[_O] = de_Owner(data[_O], context);
    }
    return contents;
};
exports.de_GetObjectAclCommand = de_GetObjectAclCommand;
const de_GetObjectAclCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchKey":
        case "com.amazonaws.s3#NoSuchKey":
            throw await de_NoSuchKeyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetObjectAttributesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetObjectAttributesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_DM]: [() => void 0 !== output.headers[_xadm], () => (0, smithy_client_1.parseBoolean)(output.headers[_xadm])],
        [_LM]: [() => void 0 !== output.headers[_lm], () => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc7231DateTime)(output.headers[_lm]))],
        [_VI]: [, output.headers[_xavi]],
        [_RC]: [, output.headers[_xarc]],
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_Ch] != null) {
        contents[_Ch] = de_Checksum(data[_Ch], context);
    }
    if (data[_ETa] != null) {
        contents[_ETa] = (0, smithy_client_1.expectString)(data[_ETa]);
    }
    if (data[_OP] != null) {
        contents[_OP] = de_GetObjectAttributesParts(data[_OP], context);
    }
    if (data[_OSb] != null) {
        contents[_OSb] = (0, smithy_client_1.strictParseLong)(data[_OSb]);
    }
    if (data[_SC] != null) {
        contents[_SC] = (0, smithy_client_1.expectString)(data[_SC]);
    }
    return contents;
};
exports.de_GetObjectAttributesCommand = de_GetObjectAttributesCommand;
const de_GetObjectAttributesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchKey":
        case "com.amazonaws.s3#NoSuchKey":
            throw await de_NoSuchKeyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetObjectLegalHoldCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetObjectLegalHoldCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.LegalHold = de_ObjectLockLegalHold(data, context);
    return contents;
};
exports.de_GetObjectLegalHoldCommand = de_GetObjectLegalHoldCommand;
const de_GetObjectLegalHoldCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetObjectLockConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetObjectLockConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.ObjectLockConfiguration = de_ObjectLockConfiguration(data, context);
    return contents;
};
exports.de_GetObjectLockConfigurationCommand = de_GetObjectLockConfigurationCommand;
const de_GetObjectLockConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetObjectRetentionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetObjectRetentionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.Retention = de_ObjectLockRetention(data, context);
    return contents;
};
exports.de_GetObjectRetentionCommand = de_GetObjectRetentionCommand;
const de_GetObjectRetentionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetObjectTaggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetObjectTaggingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_VI]: [, output.headers[_xavi]],
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.TagSet === "") {
        contents[_TS] = [];
    }
    else if (data[_TS] != null && data[_TS][_Ta] != null) {
        contents[_TS] = de_TagSet((0, smithy_client_1.getArrayIfSingleItem)(data[_TS][_Ta]), context);
    }
    return contents;
};
exports.de_GetObjectTaggingCommand = de_GetObjectTaggingCommand;
const de_GetObjectTaggingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetObjectTorrentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetObjectTorrentCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_RC]: [, output.headers[_xarc]],
    });
    const data = output.body;
    context.sdkStreamMixin(data);
    contents.Body = data;
    return contents;
};
exports.de_GetObjectTorrentCommand = de_GetObjectTorrentCommand;
const de_GetObjectTorrentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_GetPublicAccessBlockCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetPublicAccessBlockCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.PublicAccessBlockConfiguration = de_PublicAccessBlockConfiguration(data, context);
    return contents;
};
exports.de_GetPublicAccessBlockCommand = de_GetPublicAccessBlockCommand;
const de_GetPublicAccessBlockCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_HeadBucketCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_HeadBucketCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_BLT]: [, output.headers[_xablt]],
        [_BLN]: [, output.headers[_xabln]],
        [_BR]: [, output.headers[_xabr]],
        [_APA]: [() => void 0 !== output.headers[_xaapa], () => (0, smithy_client_1.parseBoolean)(output.headers[_xaapa])],
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_HeadBucketCommand = de_HeadBucketCommand;
const de_HeadBucketCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFound":
        case "com.amazonaws.s3#NotFound":
            throw await de_NotFoundRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_HeadObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_HeadObjectCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_DM]: [() => void 0 !== output.headers[_xadm], () => (0, smithy_client_1.parseBoolean)(output.headers[_xadm])],
        [_AR]: [, output.headers[_ar]],
        [_Exp]: [, output.headers[_xae]],
        [_Re]: [, output.headers[_xar]],
        [_AS]: [, output.headers[_xaas]],
        [_LM]: [() => void 0 !== output.headers[_lm], () => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc7231DateTime)(output.headers[_lm]))],
        [_CLo]: [() => void 0 !== output.headers[_cl_], () => (0, smithy_client_1.strictParseLong)(output.headers[_cl_])],
        [_CCRC]: [, output.headers[_xacc]],
        [_CCRCC]: [, output.headers[_xacc_]],
        [_CSHA]: [, output.headers[_xacs]],
        [_CSHAh]: [, output.headers[_xacs_]],
        [_ETa]: [, output.headers[_eta]],
        [_MM]: [() => void 0 !== output.headers[_xamm], () => (0, smithy_client_1.strictParseInt32)(output.headers[_xamm])],
        [_VI]: [, output.headers[_xavi]],
        [_CC]: [, output.headers[_cc]],
        [_CD]: [, output.headers[_cd]],
        [_CE]: [, output.headers[_ce]],
        [_CL]: [, output.headers[_cl]],
        [_CT]: [, output.headers[_ct]],
        [_E]: [() => void 0 !== output.headers[_e], () => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc7231DateTime)(output.headers[_e]))],
        [_WRL]: [, output.headers[_xawrl]],
        [_SSE]: [, output.headers[_xasse]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => (0, smithy_client_1.parseBoolean)(output.headers[_xassebke])],
        [_SC]: [, output.headers[_xasc]],
        [_RC]: [, output.headers[_xarc]],
        [_RS]: [, output.headers[_xars]],
        [_PC]: [() => void 0 !== output.headers[_xampc], () => (0, smithy_client_1.strictParseInt32)(output.headers[_xampc])],
        [_OLM]: [, output.headers[_xaolm]],
        [_OLRUD]: [
            () => void 0 !== output.headers[_xaolrud],
            () => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output.headers[_xaolrud])),
        ],
        [_OLLHS]: [, output.headers[_xaollh]],
        Metadata: [
            ,
            Object.keys(output.headers)
                .filter((header) => header.startsWith("x-amz-meta-"))
                .reduce((acc, header) => {
                acc[header.substring(11)] = output.headers[header];
                return acc;
            }, {}),
        ],
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_HeadObjectCommand = de_HeadObjectCommand;
const de_HeadObjectCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NotFound":
        case "com.amazonaws.s3#NotFound":
            throw await de_NotFoundRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListBucketAnalyticsConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListBucketAnalyticsConfigurationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.AnalyticsConfiguration === "") {
        contents[_ACLn] = [];
    }
    else if (data[_AC] != null) {
        contents[_ACLn] = de_AnalyticsConfigurationList((0, smithy_client_1.getArrayIfSingleItem)(data[_AC]), context);
    }
    if (data[_CTo] != null) {
        contents[_CTo] = (0, smithy_client_1.expectString)(data[_CTo]);
    }
    if (data[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(data[_IT]);
    }
    if (data[_NCT] != null) {
        contents[_NCT] = (0, smithy_client_1.expectString)(data[_NCT]);
    }
    return contents;
};
exports.de_ListBucketAnalyticsConfigurationsCommand = de_ListBucketAnalyticsConfigurationsCommand;
const de_ListBucketAnalyticsConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_ListBucketIntelligentTieringConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListBucketIntelligentTieringConfigurationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_CTo] != null) {
        contents[_CTo] = (0, smithy_client_1.expectString)(data[_CTo]);
    }
    if (data.IntelligentTieringConfiguration === "") {
        contents[_ITCL] = [];
    }
    else if (data[_ITC] != null) {
        contents[_ITCL] = de_IntelligentTieringConfigurationList((0, smithy_client_1.getArrayIfSingleItem)(data[_ITC]), context);
    }
    if (data[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(data[_IT]);
    }
    if (data[_NCT] != null) {
        contents[_NCT] = (0, smithy_client_1.expectString)(data[_NCT]);
    }
    return contents;
};
exports.de_ListBucketIntelligentTieringConfigurationsCommand = de_ListBucketIntelligentTieringConfigurationsCommand;
const de_ListBucketIntelligentTieringConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_ListBucketInventoryConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListBucketInventoryConfigurationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_CTo] != null) {
        contents[_CTo] = (0, smithy_client_1.expectString)(data[_CTo]);
    }
    if (data.InventoryConfiguration === "") {
        contents[_ICL] = [];
    }
    else if (data[_IC] != null) {
        contents[_ICL] = de_InventoryConfigurationList((0, smithy_client_1.getArrayIfSingleItem)(data[_IC]), context);
    }
    if (data[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(data[_IT]);
    }
    if (data[_NCT] != null) {
        contents[_NCT] = (0, smithy_client_1.expectString)(data[_NCT]);
    }
    return contents;
};
exports.de_ListBucketInventoryConfigurationsCommand = de_ListBucketInventoryConfigurationsCommand;
const de_ListBucketInventoryConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_ListBucketMetricsConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListBucketMetricsConfigurationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_CTo] != null) {
        contents[_CTo] = (0, smithy_client_1.expectString)(data[_CTo]);
    }
    if (data[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(data[_IT]);
    }
    if (data.MetricsConfiguration === "") {
        contents[_MCL] = [];
    }
    else if (data[_MC] != null) {
        contents[_MCL] = de_MetricsConfigurationList((0, smithy_client_1.getArrayIfSingleItem)(data[_MC]), context);
    }
    if (data[_NCT] != null) {
        contents[_NCT] = (0, smithy_client_1.expectString)(data[_NCT]);
    }
    return contents;
};
exports.de_ListBucketMetricsConfigurationsCommand = de_ListBucketMetricsConfigurationsCommand;
const de_ListBucketMetricsConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_ListBucketsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListBucketsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.Buckets === "") {
        contents[_Bu] = [];
    }
    else if (data[_Bu] != null && data[_Bu][_B] != null) {
        contents[_Bu] = de_Buckets((0, smithy_client_1.getArrayIfSingleItem)(data[_Bu][_B]), context);
    }
    if (data[_O] != null) {
        contents[_O] = de_Owner(data[_O], context);
    }
    return contents;
};
exports.de_ListBucketsCommand = de_ListBucketsCommand;
const de_ListBucketsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_ListDirectoryBucketsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDirectoryBucketsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.Buckets === "") {
        contents[_Bu] = [];
    }
    else if (data[_Bu] != null && data[_Bu][_B] != null) {
        contents[_Bu] = de_Buckets((0, smithy_client_1.getArrayIfSingleItem)(data[_Bu][_B]), context);
    }
    if (data[_CTo] != null) {
        contents[_CTo] = (0, smithy_client_1.expectString)(data[_CTo]);
    }
    return contents;
};
exports.de_ListDirectoryBucketsCommand = de_ListDirectoryBucketsCommand;
const de_ListDirectoryBucketsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_ListMultipartUploadsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListMultipartUploadsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_RC]: [, output.headers[_xarc]],
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_B] != null) {
        contents[_B] = (0, smithy_client_1.expectString)(data[_B]);
    }
    if (data.CommonPrefixes === "") {
        contents[_CP] = [];
    }
    else if (data[_CP] != null) {
        contents[_CP] = de_CommonPrefixList((0, smithy_client_1.getArrayIfSingleItem)(data[_CP]), context);
    }
    if (data[_D] != null) {
        contents[_D] = (0, smithy_client_1.expectString)(data[_D]);
    }
    if (data[_ET] != null) {
        contents[_ET] = (0, smithy_client_1.expectString)(data[_ET]);
    }
    if (data[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(data[_IT]);
    }
    if (data[_KM] != null) {
        contents[_KM] = (0, smithy_client_1.expectString)(data[_KM]);
    }
    if (data[_MU] != null) {
        contents[_MU] = (0, smithy_client_1.strictParseInt32)(data[_MU]);
    }
    if (data[_NKM] != null) {
        contents[_NKM] = (0, smithy_client_1.expectString)(data[_NKM]);
    }
    if (data[_NUIM] != null) {
        contents[_NUIM] = (0, smithy_client_1.expectString)(data[_NUIM]);
    }
    if (data[_P] != null) {
        contents[_P] = (0, smithy_client_1.expectString)(data[_P]);
    }
    if (data[_UIM] != null) {
        contents[_UIM] = (0, smithy_client_1.expectString)(data[_UIM]);
    }
    if (data.Upload === "") {
        contents[_Up] = [];
    }
    else if (data[_U] != null) {
        contents[_Up] = de_MultipartUploadList((0, smithy_client_1.getArrayIfSingleItem)(data[_U]), context);
    }
    return contents;
};
exports.de_ListMultipartUploadsCommand = de_ListMultipartUploadsCommand;
const de_ListMultipartUploadsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_ListObjectsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListObjectsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_RC]: [, output.headers[_xarc]],
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.CommonPrefixes === "") {
        contents[_CP] = [];
    }
    else if (data[_CP] != null) {
        contents[_CP] = de_CommonPrefixList((0, smithy_client_1.getArrayIfSingleItem)(data[_CP]), context);
    }
    if (data.Contents === "") {
        contents[_Co] = [];
    }
    else if (data[_Co] != null) {
        contents[_Co] = de_ObjectList((0, smithy_client_1.getArrayIfSingleItem)(data[_Co]), context);
    }
    if (data[_D] != null) {
        contents[_D] = (0, smithy_client_1.expectString)(data[_D]);
    }
    if (data[_ET] != null) {
        contents[_ET] = (0, smithy_client_1.expectString)(data[_ET]);
    }
    if (data[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(data[_IT]);
    }
    if (data[_M] != null) {
        contents[_M] = (0, smithy_client_1.expectString)(data[_M]);
    }
    if (data[_MK] != null) {
        contents[_MK] = (0, smithy_client_1.strictParseInt32)(data[_MK]);
    }
    if (data[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(data[_N]);
    }
    if (data[_NM] != null) {
        contents[_NM] = (0, smithy_client_1.expectString)(data[_NM]);
    }
    if (data[_P] != null) {
        contents[_P] = (0, smithy_client_1.expectString)(data[_P]);
    }
    return contents;
};
exports.de_ListObjectsCommand = de_ListObjectsCommand;
const de_ListObjectsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchBucket":
        case "com.amazonaws.s3#NoSuchBucket":
            throw await de_NoSuchBucketRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListObjectsV2Command = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListObjectsV2CommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_RC]: [, output.headers[_xarc]],
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.CommonPrefixes === "") {
        contents[_CP] = [];
    }
    else if (data[_CP] != null) {
        contents[_CP] = de_CommonPrefixList((0, smithy_client_1.getArrayIfSingleItem)(data[_CP]), context);
    }
    if (data.Contents === "") {
        contents[_Co] = [];
    }
    else if (data[_Co] != null) {
        contents[_Co] = de_ObjectList((0, smithy_client_1.getArrayIfSingleItem)(data[_Co]), context);
    }
    if (data[_CTo] != null) {
        contents[_CTo] = (0, smithy_client_1.expectString)(data[_CTo]);
    }
    if (data[_D] != null) {
        contents[_D] = (0, smithy_client_1.expectString)(data[_D]);
    }
    if (data[_ET] != null) {
        contents[_ET] = (0, smithy_client_1.expectString)(data[_ET]);
    }
    if (data[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(data[_IT]);
    }
    if (data[_KC] != null) {
        contents[_KC] = (0, smithy_client_1.strictParseInt32)(data[_KC]);
    }
    if (data[_MK] != null) {
        contents[_MK] = (0, smithy_client_1.strictParseInt32)(data[_MK]);
    }
    if (data[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(data[_N]);
    }
    if (data[_NCT] != null) {
        contents[_NCT] = (0, smithy_client_1.expectString)(data[_NCT]);
    }
    if (data[_P] != null) {
        contents[_P] = (0, smithy_client_1.expectString)(data[_P]);
    }
    if (data[_SA] != null) {
        contents[_SA] = (0, smithy_client_1.expectString)(data[_SA]);
    }
    return contents;
};
exports.de_ListObjectsV2Command = de_ListObjectsV2Command;
const de_ListObjectsV2CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchBucket":
        case "com.amazonaws.s3#NoSuchBucket":
            throw await de_NoSuchBucketRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListObjectVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListObjectVersionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_RC]: [, output.headers[_xarc]],
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.CommonPrefixes === "") {
        contents[_CP] = [];
    }
    else if (data[_CP] != null) {
        contents[_CP] = de_CommonPrefixList((0, smithy_client_1.getArrayIfSingleItem)(data[_CP]), context);
    }
    if (data.DeleteMarker === "") {
        contents[_DMe] = [];
    }
    else if (data[_DM] != null) {
        contents[_DMe] = de_DeleteMarkers((0, smithy_client_1.getArrayIfSingleItem)(data[_DM]), context);
    }
    if (data[_D] != null) {
        contents[_D] = (0, smithy_client_1.expectString)(data[_D]);
    }
    if (data[_ET] != null) {
        contents[_ET] = (0, smithy_client_1.expectString)(data[_ET]);
    }
    if (data[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(data[_IT]);
    }
    if (data[_KM] != null) {
        contents[_KM] = (0, smithy_client_1.expectString)(data[_KM]);
    }
    if (data[_MK] != null) {
        contents[_MK] = (0, smithy_client_1.strictParseInt32)(data[_MK]);
    }
    if (data[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(data[_N]);
    }
    if (data[_NKM] != null) {
        contents[_NKM] = (0, smithy_client_1.expectString)(data[_NKM]);
    }
    if (data[_NVIM] != null) {
        contents[_NVIM] = (0, smithy_client_1.expectString)(data[_NVIM]);
    }
    if (data[_P] != null) {
        contents[_P] = (0, smithy_client_1.expectString)(data[_P]);
    }
    if (data[_VIM] != null) {
        contents[_VIM] = (0, smithy_client_1.expectString)(data[_VIM]);
    }
    if (data.Version === "") {
        contents[_Ve] = [];
    }
    else if (data[_V] != null) {
        contents[_Ve] = de_ObjectVersionList((0, smithy_client_1.getArrayIfSingleItem)(data[_V]), context);
    }
    return contents;
};
exports.de_ListObjectVersionsCommand = de_ListObjectVersionsCommand;
const de_ListObjectVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_ListPartsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListPartsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_AD]: [
            () => void 0 !== output.headers[_xaad],
            () => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc7231DateTime)(output.headers[_xaad])),
        ],
        [_ARI]: [, output.headers[_xaari]],
        [_RC]: [, output.headers[_xarc]],
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data[_B] != null) {
        contents[_B] = (0, smithy_client_1.expectString)(data[_B]);
    }
    if (data[_CA] != null) {
        contents[_CA] = (0, smithy_client_1.expectString)(data[_CA]);
    }
    if (data[_In] != null) {
        contents[_In] = de_Initiator(data[_In], context);
    }
    if (data[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(data[_IT]);
    }
    if (data[_K] != null) {
        contents[_K] = (0, smithy_client_1.expectString)(data[_K]);
    }
    if (data[_MP] != null) {
        contents[_MP] = (0, smithy_client_1.strictParseInt32)(data[_MP]);
    }
    if (data[_NPNM] != null) {
        contents[_NPNM] = (0, smithy_client_1.expectString)(data[_NPNM]);
    }
    if (data[_O] != null) {
        contents[_O] = de_Owner(data[_O], context);
    }
    if (data[_PNM] != null) {
        contents[_PNM] = (0, smithy_client_1.expectString)(data[_PNM]);
    }
    if (data.Part === "") {
        contents[_Part] = [];
    }
    else if (data[_Par] != null) {
        contents[_Part] = de_Parts((0, smithy_client_1.getArrayIfSingleItem)(data[_Par]), context);
    }
    if (data[_SC] != null) {
        contents[_SC] = (0, smithy_client_1.expectString)(data[_SC]);
    }
    if (data[_UI] != null) {
        contents[_UI] = (0, smithy_client_1.expectString)(data[_UI]);
    }
    return contents;
};
exports.de_ListPartsCommand = de_ListPartsCommand;
const de_ListPartsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutBucketAccelerateConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketAccelerateConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutBucketAccelerateConfigurationCommand = de_PutBucketAccelerateConfigurationCommand;
const de_PutBucketAccelerateConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutBucketAclCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketAclCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutBucketAclCommand = de_PutBucketAclCommand;
const de_PutBucketAclCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutBucketAnalyticsConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketAnalyticsConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutBucketAnalyticsConfigurationCommand = de_PutBucketAnalyticsConfigurationCommand;
const de_PutBucketAnalyticsConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutBucketCorsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketCorsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutBucketCorsCommand = de_PutBucketCorsCommand;
const de_PutBucketCorsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutBucketEncryptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketEncryptionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutBucketEncryptionCommand = de_PutBucketEncryptionCommand;
const de_PutBucketEncryptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutBucketIntelligentTieringConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketIntelligentTieringConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutBucketIntelligentTieringConfigurationCommand = de_PutBucketIntelligentTieringConfigurationCommand;
const de_PutBucketIntelligentTieringConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutBucketInventoryConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketInventoryConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutBucketInventoryConfigurationCommand = de_PutBucketInventoryConfigurationCommand;
const de_PutBucketInventoryConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutBucketLifecycleConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketLifecycleConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutBucketLifecycleConfigurationCommand = de_PutBucketLifecycleConfigurationCommand;
const de_PutBucketLifecycleConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutBucketLoggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketLoggingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutBucketLoggingCommand = de_PutBucketLoggingCommand;
const de_PutBucketLoggingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutBucketMetricsConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketMetricsConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutBucketMetricsConfigurationCommand = de_PutBucketMetricsConfigurationCommand;
const de_PutBucketMetricsConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutBucketNotificationConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketNotificationConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutBucketNotificationConfigurationCommand = de_PutBucketNotificationConfigurationCommand;
const de_PutBucketNotificationConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutBucketOwnershipControlsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketOwnershipControlsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutBucketOwnershipControlsCommand = de_PutBucketOwnershipControlsCommand;
const de_PutBucketOwnershipControlsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutBucketPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutBucketPolicyCommand = de_PutBucketPolicyCommand;
const de_PutBucketPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutBucketReplicationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketReplicationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutBucketReplicationCommand = de_PutBucketReplicationCommand;
const de_PutBucketReplicationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutBucketRequestPaymentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketRequestPaymentCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutBucketRequestPaymentCommand = de_PutBucketRequestPaymentCommand;
const de_PutBucketRequestPaymentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutBucketTaggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketTaggingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutBucketTaggingCommand = de_PutBucketTaggingCommand;
const de_PutBucketTaggingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutBucketVersioningCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketVersioningCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutBucketVersioningCommand = de_PutBucketVersioningCommand;
const de_PutBucketVersioningCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutBucketWebsiteCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutBucketWebsiteCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutBucketWebsiteCommand = de_PutBucketWebsiteCommand;
const de_PutBucketWebsiteCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutObjectCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_Exp]: [, output.headers[_xae]],
        [_ETa]: [, output.headers[_eta]],
        [_CCRC]: [, output.headers[_xacc]],
        [_CCRCC]: [, output.headers[_xacc_]],
        [_CSHA]: [, output.headers[_xacs]],
        [_CSHAh]: [, output.headers[_xacs_]],
        [_SSE]: [, output.headers[_xasse]],
        [_VI]: [, output.headers[_xavi]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_SSEKMSEC]: [, output.headers[_xassec]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => (0, smithy_client_1.parseBoolean)(output.headers[_xassebke])],
        [_RC]: [, output.headers[_xarc]],
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutObjectCommand = de_PutObjectCommand;
const de_PutObjectCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutObjectAclCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutObjectAclCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_RC]: [, output.headers[_xarc]],
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutObjectAclCommand = de_PutObjectAclCommand;
const de_PutObjectAclCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchKey":
        case "com.amazonaws.s3#NoSuchKey":
            throw await de_NoSuchKeyRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PutObjectLegalHoldCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutObjectLegalHoldCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_RC]: [, output.headers[_xarc]],
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutObjectLegalHoldCommand = de_PutObjectLegalHoldCommand;
const de_PutObjectLegalHoldCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutObjectLockConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutObjectLockConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_RC]: [, output.headers[_xarc]],
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutObjectLockConfigurationCommand = de_PutObjectLockConfigurationCommand;
const de_PutObjectLockConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutObjectRetentionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutObjectRetentionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_RC]: [, output.headers[_xarc]],
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutObjectRetentionCommand = de_PutObjectRetentionCommand;
const de_PutObjectRetentionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutObjectTaggingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutObjectTaggingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_VI]: [, output.headers[_xavi]],
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutObjectTaggingCommand = de_PutObjectTaggingCommand;
const de_PutObjectTaggingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_PutPublicAccessBlockCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutPublicAccessBlockCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutPublicAccessBlockCommand = de_PutPublicAccessBlockCommand;
const de_PutPublicAccessBlockCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_RestoreObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RestoreObjectCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_RC]: [, output.headers[_xarc]],
        [_ROP]: [, output.headers[_xarop]],
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_RestoreObjectCommand = de_RestoreObjectCommand;
const de_RestoreObjectCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ObjectAlreadyInActiveTierError":
        case "com.amazonaws.s3#ObjectAlreadyInActiveTierError":
            throw await de_ObjectAlreadyInActiveTierErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_SelectObjectContentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_SelectObjectContentCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = output.body;
    contents.Payload = de_SelectObjectContentEventStream(data, context);
    return contents;
};
exports.de_SelectObjectContentCommand = de_SelectObjectContentCommand;
const de_SelectObjectContentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_UploadPartCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UploadPartCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_SSE]: [, output.headers[_xasse]],
        [_ETa]: [, output.headers[_eta]],
        [_CCRC]: [, output.headers[_xacc]],
        [_CCRCC]: [, output.headers[_xacc_]],
        [_CSHA]: [, output.headers[_xacs]],
        [_CSHAh]: [, output.headers[_xacs_]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => (0, smithy_client_1.parseBoolean)(output.headers[_xassebke])],
        [_RC]: [, output.headers[_xarc]],
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UploadPartCommand = de_UploadPartCommand;
const de_UploadPartCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_UploadPartCopyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UploadPartCopyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        [_CSVI]: [, output.headers[_xacsvi]],
        [_SSE]: [, output.headers[_xasse]],
        [_SSECA]: [, output.headers[_xasseca]],
        [_SSECKMD]: [, output.headers[_xasseckm]],
        [_SSEKMSKI]: [, output.headers[_xasseakki]],
        [_BKE]: [() => void 0 !== output.headers[_xassebke], () => (0, smithy_client_1.parseBoolean)(output.headers[_xassebke])],
        [_RC]: [, output.headers[_xarc]],
    });
    const data = (0, smithy_client_1.expectObject)(await parseBody(output.body, context));
    contents.CopyPartResult = de_CopyPartResult(data, context);
    return contents;
};
exports.de_UploadPartCopyCommand = de_UploadPartCopyCommand;
const de_UploadPartCopyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const de_WriteGetObjectResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_WriteGetObjectResponseCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_WriteGetObjectResponseCommand = de_WriteGetObjectResponseCommand;
const de_WriteGetObjectResponseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody,
        errorCode,
    });
};
const throwDefaultError = (0, smithy_client_1.withBaseException)(S3ServiceException_1.S3ServiceException);
const de_BucketAlreadyExistsRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const exception = new models_0_1.BucketAlreadyExists({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_BucketAlreadyOwnedByYouRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const exception = new models_0_1.BucketAlreadyOwnedByYou({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidObjectStateRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    if (data[_AT] != null) {
        contents[_AT] = (0, smithy_client_1.expectString)(data[_AT]);
    }
    if (data[_SC] != null) {
        contents[_SC] = (0, smithy_client_1.expectString)(data[_SC]);
    }
    const exception = new models_0_1.InvalidObjectState({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_NoSuchBucketRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const exception = new models_0_1.NoSuchBucket({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_NoSuchKeyRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const exception = new models_0_1.NoSuchKey({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_NoSuchUploadRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const exception = new models_0_1.NoSuchUpload({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_NotFoundRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const exception = new models_0_1.NotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ObjectAlreadyInActiveTierErrorRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const exception = new models_1_1.ObjectAlreadyInActiveTierError({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ObjectNotInActiveTierErrorRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const exception = new models_0_1.ObjectNotInActiveTierError({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_SelectObjectContentEventStream = (output, context) => {
    return context.eventStreamMarshaller.deserialize(output, async (event) => {
        if (event["Records"] != null) {
            return {
                Records: await de_RecordsEvent_event(event["Records"], context),
            };
        }
        if (event["Stats"] != null) {
            return {
                Stats: await de_StatsEvent_event(event["Stats"], context),
            };
        }
        if (event["Progress"] != null) {
            return {
                Progress: await de_ProgressEvent_event(event["Progress"], context),
            };
        }
        if (event["Cont"] != null) {
            return {
                Cont: await de_ContinuationEvent_event(event["Cont"], context),
            };
        }
        if (event["End"] != null) {
            return {
                End: await de_EndEvent_event(event["End"], context),
            };
        }
        return { $unknown: output };
    });
};
const de_ContinuationEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, de_ContinuationEvent(data, context));
    return contents;
};
const de_EndEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, de_EndEvent(data, context));
    return contents;
};
const de_ProgressEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    contents.Details = de_Progress(data, context);
    return contents;
};
const de_RecordsEvent_event = async (output, context) => {
    const contents = {};
    contents.Payload = output.body;
    return contents;
};
const de_StatsEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    contents.Details = de_Stats(data, context);
    return contents;
};
const se_AbortIncompleteMultipartUpload = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_AIMU);
    if (input[_DAI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_DAI, String(input[_DAI])).n(_DAI));
    }
    return bn;
};
const se_AccelerateConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ACc);
    if (input[_S] != null) {
        bn.c(xml_builder_1.XmlNode.of(_BAS, input[_S]).n(_S));
    }
    return bn;
};
const se_AccessControlPolicy = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ACP);
    bn.lc(input, "Grants", "AccessControlList", () => se_Grants(input[_Gr], context));
    if (input[_O] != null) {
        bn.c(se_Owner(input[_O], context).n(_O));
    }
    return bn;
};
const se_AccessControlTranslation = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ACT);
    if (input[_O] != null) {
        bn.c(xml_builder_1.XmlNode.of(_OOw, input[_O]).n(_O));
    }
    return bn;
};
const se_AllowedHeaders = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_AH, entry);
        return n.n(_me);
    });
};
const se_AllowedMethods = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_AM, entry);
        return n.n(_me);
    });
};
const se_AllowedOrigins = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_AO, entry);
        return n.n(_me);
    });
};
const se_AnalyticsAndOperator = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_AAO);
    bn.cc(input, _P);
    bn.l(input, "Tags", "Tag", () => se_TagSet(input[_Tag], context));
    return bn;
};
const se_AnalyticsConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_AC);
    if (input[_I] != null) {
        bn.c(xml_builder_1.XmlNode.of(_AI, input[_I]).n(_I));
    }
    if (input[_F] != null) {
        bn.c(se_AnalyticsFilter(input[_F], context).n(_F));
    }
    if (input[_SCA] != null) {
        bn.c(se_StorageClassAnalysis(input[_SCA], context).n(_SCA));
    }
    return bn;
};
const se_AnalyticsExportDestination = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_AED);
    if (input[_SBD] != null) {
        bn.c(se_AnalyticsS3BucketDestination(input[_SBD], context).n(_SBD));
    }
    return bn;
};
const se_AnalyticsFilter = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_AF);
    models_0_1.AnalyticsFilter.visit(input, {
        Prefix: (value) => {
            if (input[_P] != null) {
                bn.c(xml_builder_1.XmlNode.of(_P, value).n(_P));
            }
        },
        Tag: (value) => {
            if (input[_Ta] != null) {
                bn.c(se_Tag(value, context).n(_Ta));
            }
        },
        And: (value) => {
            if (input[_A] != null) {
                bn.c(se_AnalyticsAndOperator(value, context).n(_A));
            }
        },
        _: (name, value) => {
            if (!(value instanceof xml_builder_1.XmlNode || value instanceof xml_builder_1.XmlText)) {
                throw new Error("Unable to serialize unknown union members in XML.");
            }
            bn.c(new xml_builder_1.XmlNode(name).c(value));
        },
    });
    return bn;
};
const se_AnalyticsS3BucketDestination = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ASBD);
    if (input[_Fo] != null) {
        bn.c(xml_builder_1.XmlNode.of(_ASEFF, input[_Fo]).n(_Fo));
    }
    if (input[_BAI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_AIc, input[_BAI]).n(_BAI));
    }
    if (input[_B] != null) {
        bn.c(xml_builder_1.XmlNode.of(_BN, input[_B]).n(_B));
    }
    bn.cc(input, _P);
    return bn;
};
const se_BucketInfo = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_BI);
    bn.cc(input, _DR);
    if (input[_Ty] != null) {
        bn.c(xml_builder_1.XmlNode.of(_BT, input[_Ty]).n(_Ty));
    }
    return bn;
};
const se_BucketLifecycleConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_BLC);
    bn.l(input, "Rules", "Rule", () => se_LifecycleRules(input[_Rul], context));
    return bn;
};
const se_BucketLoggingStatus = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_BLS);
    if (input[_LE] != null) {
        bn.c(se_LoggingEnabled(input[_LE], context).n(_LE));
    }
    return bn;
};
const se_CompletedMultipartUpload = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CMU);
    bn.l(input, "Parts", "Part", () => se_CompletedPartList(input[_Part], context));
    return bn;
};
const se_CompletedPart = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CPo);
    bn.cc(input, _ETa);
    bn.cc(input, _CCRC);
    bn.cc(input, _CCRCC);
    bn.cc(input, _CSHA);
    bn.cc(input, _CSHAh);
    if (input[_PN] != null) {
        bn.c(xml_builder_1.XmlNode.of(_PN, String(input[_PN])).n(_PN));
    }
    return bn;
};
const se_CompletedPartList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_CompletedPart(entry, context);
        return n.n(_me);
    });
};
const se_Condition = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Con);
    bn.cc(input, _HECRE);
    bn.cc(input, _KPE);
    return bn;
};
const se_CORSConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CORSC);
    bn.l(input, "CORSRules", "CORSRule", () => se_CORSRules(input[_CORSRu], context));
    return bn;
};
const se_CORSRule = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CORSR);
    bn.cc(input, _ID_);
    bn.l(input, "AllowedHeaders", "AllowedHeader", () => se_AllowedHeaders(input[_AHl], context));
    bn.l(input, "AllowedMethods", "AllowedMethod", () => se_AllowedMethods(input[_AMl], context));
    bn.l(input, "AllowedOrigins", "AllowedOrigin", () => se_AllowedOrigins(input[_AOl], context));
    bn.l(input, "ExposeHeaders", "ExposeHeader", () => se_ExposeHeaders(input[_EH], context));
    if (input[_MAS] != null) {
        bn.c(xml_builder_1.XmlNode.of(_MAS, String(input[_MAS])).n(_MAS));
    }
    return bn;
};
const se_CORSRules = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_CORSRule(entry, context);
        return n.n(_me);
    });
};
const se_CreateBucketConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CBC);
    if (input[_LC] != null) {
        bn.c(xml_builder_1.XmlNode.of(_BLCu, input[_LC]).n(_LC));
    }
    if (input[_L] != null) {
        bn.c(se_LocationInfo(input[_L], context).n(_L));
    }
    if (input[_B] != null) {
        bn.c(se_BucketInfo(input[_B], context).n(_B));
    }
    return bn;
};
const se_CSVInput = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CSVIn);
    bn.cc(input, _FHI);
    bn.cc(input, _Com);
    bn.cc(input, _QEC);
    bn.cc(input, _RD);
    bn.cc(input, _FD);
    bn.cc(input, _QCuo);
    if (input[_AQRD] != null) {
        bn.c(xml_builder_1.XmlNode.of(_AQRD, String(input[_AQRD])).n(_AQRD));
    }
    return bn;
};
const se_CSVOutput = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_CSVO);
    bn.cc(input, _QF);
    bn.cc(input, _QEC);
    bn.cc(input, _RD);
    bn.cc(input, _FD);
    bn.cc(input, _QCuo);
    return bn;
};
const se_DefaultRetention = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_DRe);
    if (input[_Mo] != null) {
        bn.c(xml_builder_1.XmlNode.of(_OLRM, input[_Mo]).n(_Mo));
    }
    if (input[_Da] != null) {
        bn.c(xml_builder_1.XmlNode.of(_Da, String(input[_Da])).n(_Da));
    }
    if (input[_Y] != null) {
        bn.c(xml_builder_1.XmlNode.of(_Y, String(input[_Y])).n(_Y));
    }
    return bn;
};
const se_Delete = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Del);
    bn.l(input, "Objects", "Object", () => se_ObjectIdentifierList(input[_Ob], context));
    if (input[_Q] != null) {
        bn.c(xml_builder_1.XmlNode.of(_Q, String(input[_Q])).n(_Q));
    }
    return bn;
};
const se_DeleteMarkerReplication = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_DMR);
    if (input[_S] != null) {
        bn.c(xml_builder_1.XmlNode.of(_DMRS, input[_S]).n(_S));
    }
    return bn;
};
const se_Destination = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Des);
    if (input[_B] != null) {
        bn.c(xml_builder_1.XmlNode.of(_BN, input[_B]).n(_B));
    }
    if (input[_Ac] != null) {
        bn.c(xml_builder_1.XmlNode.of(_AIc, input[_Ac]).n(_Ac));
    }
    bn.cc(input, _SC);
    if (input[_ACT] != null) {
        bn.c(se_AccessControlTranslation(input[_ACT], context).n(_ACT));
    }
    if (input[_ECn] != null) {
        bn.c(se_EncryptionConfiguration(input[_ECn], context).n(_ECn));
    }
    if (input[_RTe] != null) {
        bn.c(se_ReplicationTime(input[_RTe], context).n(_RTe));
    }
    if (input[_Me] != null) {
        bn.c(se_Metrics(input[_Me], context).n(_Me));
    }
    return bn;
};
const se_Encryption = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_En);
    if (input[_ETn] != null) {
        bn.c(xml_builder_1.XmlNode.of(_SSE, input[_ETn]).n(_ETn));
    }
    if (input[_KMSKI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_SSEKMSKI, input[_KMSKI]).n(_KMSKI));
    }
    bn.cc(input, _KMSC);
    return bn;
};
const se_EncryptionConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ECn);
    bn.cc(input, _RKKID);
    return bn;
};
const se_ErrorDocument = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ED);
    if (input[_K] != null) {
        bn.c(xml_builder_1.XmlNode.of(_OK, input[_K]).n(_K));
    }
    return bn;
};
const se_EventBridgeConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_EBC);
    return bn;
};
const se_EventList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_Ev, entry);
        return n.n(_me);
    });
};
const se_ExistingObjectReplication = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_EOR);
    if (input[_S] != null) {
        bn.c(xml_builder_1.XmlNode.of(_EORS, input[_S]).n(_S));
    }
    return bn;
};
const se_ExposeHeaders = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_EHx, entry);
        return n.n(_me);
    });
};
const se_FilterRule = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_FR);
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_FRN, input[_N]).n(_N));
    }
    if (input[_Va] != null) {
        bn.c(xml_builder_1.XmlNode.of(_FRV, input[_Va]).n(_Va));
    }
    return bn;
};
const se_FilterRuleList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_FilterRule(entry, context);
        return n.n(_me);
    });
};
const se_GlacierJobParameters = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_GJP);
    bn.cc(input, _Ti);
    return bn;
};
const se_Grant = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_G);
    if (input[_Gra] != null) {
        const n = se_Grantee(input[_Gra], context).n(_Gra);
        n.a("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
        bn.c(n);
    }
    bn.cc(input, _Pe);
    return bn;
};
const se_Grantee = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Gra);
    bn.cc(input, _DN);
    bn.cc(input, _EA);
    bn.cc(input, _ID_);
    bn.cc(input, _URI);
    bn.a("xsi:type", input[_Ty]);
    return bn;
};
const se_Grants = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_Grant(entry, context);
        return n.n(_G);
    });
};
const se_IndexDocument = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ID);
    bn.cc(input, _Su);
    return bn;
};
const se_InputSerialization = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_IS);
    if (input[_CSV] != null) {
        bn.c(se_CSVInput(input[_CSV], context).n(_CSV));
    }
    bn.cc(input, _CTom);
    if (input[_JSON] != null) {
        bn.c(se_JSONInput(input[_JSON], context).n(_JSON));
    }
    if (input[_Parq] != null) {
        bn.c(se_ParquetInput(input[_Parq], context).n(_Parq));
    }
    return bn;
};
const se_IntelligentTieringAndOperator = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ITAO);
    bn.cc(input, _P);
    bn.l(input, "Tags", "Tag", () => se_TagSet(input[_Tag], context));
    return bn;
};
const se_IntelligentTieringConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ITC);
    if (input[_I] != null) {
        bn.c(xml_builder_1.XmlNode.of(_ITI, input[_I]).n(_I));
    }
    if (input[_F] != null) {
        bn.c(se_IntelligentTieringFilter(input[_F], context).n(_F));
    }
    if (input[_S] != null) {
        bn.c(xml_builder_1.XmlNode.of(_ITS, input[_S]).n(_S));
    }
    bn.l(input, "Tierings", "Tiering", () => se_TieringList(input[_Tie], context));
    return bn;
};
const se_IntelligentTieringFilter = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ITF);
    bn.cc(input, _P);
    if (input[_Ta] != null) {
        bn.c(se_Tag(input[_Ta], context).n(_Ta));
    }
    if (input[_A] != null) {
        bn.c(se_IntelligentTieringAndOperator(input[_A], context).n(_A));
    }
    return bn;
};
const se_InventoryConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_IC);
    if (input[_Des] != null) {
        bn.c(se_InventoryDestination(input[_Des], context).n(_Des));
    }
    if (input[_IE] != null) {
        bn.c(xml_builder_1.XmlNode.of(_IE, String(input[_IE])).n(_IE));
    }
    if (input[_F] != null) {
        bn.c(se_InventoryFilter(input[_F], context).n(_F));
    }
    if (input[_I] != null) {
        bn.c(xml_builder_1.XmlNode.of(_II, input[_I]).n(_I));
    }
    if (input[_IOV] != null) {
        bn.c(xml_builder_1.XmlNode.of(_IIOV, input[_IOV]).n(_IOV));
    }
    bn.lc(input, "OptionalFields", "OptionalFields", () => se_InventoryOptionalFields(input[_OF], context));
    if (input[_Sc] != null) {
        bn.c(se_InventorySchedule(input[_Sc], context).n(_Sc));
    }
    return bn;
};
const se_InventoryDestination = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_IDn);
    if (input[_SBD] != null) {
        bn.c(se_InventoryS3BucketDestination(input[_SBD], context).n(_SBD));
    }
    return bn;
};
const se_InventoryEncryption = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_IEn);
    if (input[_SSES] != null) {
        bn.c(se_SSES3(input[_SSES], context).n(_SS));
    }
    if (input[_SSEKMS] != null) {
        bn.c(se_SSEKMS(input[_SSEKMS], context).n(_SK));
    }
    return bn;
};
const se_InventoryFilter = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_IF);
    bn.cc(input, _P);
    return bn;
};
const se_InventoryOptionalFields = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = xml_builder_1.XmlNode.of(_IOF, entry);
        return n.n(_Fi);
    });
};
const se_InventoryS3BucketDestination = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ISBD);
    bn.cc(input, _AIc);
    if (input[_B] != null) {
        bn.c(xml_builder_1.XmlNode.of(_BN, input[_B]).n(_B));
    }
    if (input[_Fo] != null) {
        bn.c(xml_builder_1.XmlNode.of(_IFn, input[_Fo]).n(_Fo));
    }
    bn.cc(input, _P);
    if (input[_En] != null) {
        bn.c(se_InventoryEncryption(input[_En], context).n(_En));
    }
    return bn;
};
const se_InventorySchedule = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ISn);
    if (input[_Fr] != null) {
        bn.c(xml_builder_1.XmlNode.of(_IFnv, input[_Fr]).n(_Fr));
    }
    return bn;
};
const se_JSONInput = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_JSONI);
    if (input[_Ty] != null) {
        bn.c(xml_builder_1.XmlNode.of(_JSONT, input[_Ty]).n(_Ty));
    }
    return bn;
};
const se_JSONOutput = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_JSONO);
    bn.cc(input, _RD);
    return bn;
};
const se_LambdaFunctionConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_LFCa);
    if (input[_I] != null) {
        bn.c(xml_builder_1.XmlNode.of(_NI, input[_I]).n(_I));
    }
    if (input[_LFA] != null) {
        bn.c(xml_builder_1.XmlNode.of(_LFA, input[_LFA]).n(_CF));
    }
    bn.l(input, "Events", "Event", () => se_EventList(input[_Eve], context));
    if (input[_F] != null) {
        bn.c(se_NotificationConfigurationFilter(input[_F], context).n(_F));
    }
    return bn;
};
const se_LambdaFunctionConfigurationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_LambdaFunctionConfiguration(entry, context);
        return n.n(_me);
    });
};
const se_LifecycleExpiration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_LEi);
    if (input[_Dat] != null) {
        bn.c(xml_builder_1.XmlNode.of(_Dat, (input[_Dat].toISOString().split(".")[0] + "Z").toString()).n(_Dat));
    }
    if (input[_Da] != null) {
        bn.c(xml_builder_1.XmlNode.of(_Da, String(input[_Da])).n(_Da));
    }
    if (input[_EODM] != null) {
        bn.c(xml_builder_1.XmlNode.of(_EODM, String(input[_EODM])).n(_EODM));
    }
    return bn;
};
const se_LifecycleRule = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_LR);
    if (input[_Exp] != null) {
        bn.c(se_LifecycleExpiration(input[_Exp], context).n(_Exp));
    }
    bn.cc(input, _ID_);
    bn.cc(input, _P);
    if (input[_F] != null) {
        bn.c(se_LifecycleRuleFilter(input[_F], context).n(_F));
    }
    if (input[_S] != null) {
        bn.c(xml_builder_1.XmlNode.of(_ES, input[_S]).n(_S));
    }
    bn.l(input, "Transitions", "Transition", () => se_TransitionList(input[_Tr], context));
    bn.l(input, "NoncurrentVersionTransitions", "NoncurrentVersionTransition", () => se_NoncurrentVersionTransitionList(input[_NVT], context));
    if (input[_NVE] != null) {
        bn.c(se_NoncurrentVersionExpiration(input[_NVE], context).n(_NVE));
    }
    if (input[_AIMU] != null) {
        bn.c(se_AbortIncompleteMultipartUpload(input[_AIMU], context).n(_AIMU));
    }
    return bn;
};
const se_LifecycleRuleAndOperator = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_LRAO);
    bn.cc(input, _P);
    bn.l(input, "Tags", "Tag", () => se_TagSet(input[_Tag], context));
    if (input[_OSGT] != null) {
        bn.c(xml_builder_1.XmlNode.of(_OSGTB, String(input[_OSGT])).n(_OSGT));
    }
    if (input[_OSLT] != null) {
        bn.c(xml_builder_1.XmlNode.of(_OSLTB, String(input[_OSLT])).n(_OSLT));
    }
    return bn;
};
const se_LifecycleRuleFilter = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_LRF);
    models_0_1.LifecycleRuleFilter.visit(input, {
        Prefix: (value) => {
            if (input[_P] != null) {
                bn.c(xml_builder_1.XmlNode.of(_P, value).n(_P));
            }
        },
        Tag: (value) => {
            if (input[_Ta] != null) {
                bn.c(se_Tag(value, context).n(_Ta));
            }
        },
        ObjectSizeGreaterThan: (value) => {
            if (input[_OSGT] != null) {
                bn.c(xml_builder_1.XmlNode.of(_OSGTB, String(value)).n(_OSGT));
            }
        },
        ObjectSizeLessThan: (value) => {
            if (input[_OSLT] != null) {
                bn.c(xml_builder_1.XmlNode.of(_OSLTB, String(value)).n(_OSLT));
            }
        },
        And: (value) => {
            if (input[_A] != null) {
                bn.c(se_LifecycleRuleAndOperator(value, context).n(_A));
            }
        },
        _: (name, value) => {
            if (!(value instanceof xml_builder_1.XmlNode || value instanceof xml_builder_1.XmlText)) {
                throw new Error("Unable to serialize unknown union members in XML.");
            }
            bn.c(new xml_builder_1.XmlNode(name).c(value));
        },
    });
    return bn;
};
const se_LifecycleRules = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_LifecycleRule(entry, context);
        return n.n(_me);
    });
};
const se_LocationInfo = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_LI);
    if (input[_Ty] != null) {
        bn.c(xml_builder_1.XmlNode.of(_LT, input[_Ty]).n(_Ty));
    }
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_LNAS, input[_N]).n(_N));
    }
    return bn;
};
const se_LoggingEnabled = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_LE);
    bn.cc(input, _TB);
    bn.lc(input, "TargetGrants", "TargetGrants", () => se_TargetGrants(input[_TG], context));
    bn.cc(input, _TP);
    if (input[_TOKF] != null) {
        bn.c(se_TargetObjectKeyFormat(input[_TOKF], context).n(_TOKF));
    }
    return bn;
};
const se_MetadataEntry = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_ME);
    if (input[_N] != null) {
        bn.c(xml_builder_1.XmlNode.of(_MKe, input[_N]).n(_N));
    }
    if (input[_Va] != null) {
        bn.c(xml_builder_1.XmlNode.of(_MV, input[_Va]).n(_Va));
    }
    return bn;
};
const se_Metrics = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Me);
    if (input[_S] != null) {
        bn.c(xml_builder_1.XmlNode.of(_MS, input[_S]).n(_S));
    }
    if (input[_ETv] != null) {
        bn.c(se_ReplicationTimeValue(input[_ETv], context).n(_ETv));
    }
    return bn;
};
const se_MetricsAndOperator = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_MAO);
    bn.cc(input, _P);
    bn.l(input, "Tags", "Tag", () => se_TagSet(input[_Tag], context));
    bn.cc(input, _APAc);
    return bn;
};
const se_MetricsConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_MC);
    if (input[_I] != null) {
        bn.c(xml_builder_1.XmlNode.of(_MI, input[_I]).n(_I));
    }
    if (input[_F] != null) {
        bn.c(se_MetricsFilter(input[_F], context).n(_F));
    }
    return bn;
};
const se_MetricsFilter = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_MF);
    models_0_1.MetricsFilter.visit(input, {
        Prefix: (value) => {
            if (input[_P] != null) {
                bn.c(xml_builder_1.XmlNode.of(_P, value).n(_P));
            }
        },
        Tag: (value) => {
            if (input[_Ta] != null) {
                bn.c(se_Tag(value, context).n(_Ta));
            }
        },
        AccessPointArn: (value) => {
            if (input[_APAc] != null) {
                bn.c(xml_builder_1.XmlNode.of(_APAc, value).n(_APAc));
            }
        },
        And: (value) => {
            if (input[_A] != null) {
                bn.c(se_MetricsAndOperator(value, context).n(_A));
            }
        },
        _: (name, value) => {
            if (!(value instanceof xml_builder_1.XmlNode || value instanceof xml_builder_1.XmlText)) {
                throw new Error("Unable to serialize unknown union members in XML.");
            }
            bn.c(new xml_builder_1.XmlNode(name).c(value));
        },
    });
    return bn;
};
const se_NoncurrentVersionExpiration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_NVE);
    if (input[_ND] != null) {
        bn.c(xml_builder_1.XmlNode.of(_Da, String(input[_ND])).n(_ND));
    }
    if (input[_NNV] != null) {
        bn.c(xml_builder_1.XmlNode.of(_VC, String(input[_NNV])).n(_NNV));
    }
    return bn;
};
const se_NoncurrentVersionTransition = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_NVTo);
    if (input[_ND] != null) {
        bn.c(xml_builder_1.XmlNode.of(_Da, String(input[_ND])).n(_ND));
    }
    if (input[_SC] != null) {
        bn.c(xml_builder_1.XmlNode.of(_TSC, input[_SC]).n(_SC));
    }
    if (input[_NNV] != null) {
        bn.c(xml_builder_1.XmlNode.of(_VC, String(input[_NNV])).n(_NNV));
    }
    return bn;
};
const se_NoncurrentVersionTransitionList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_NoncurrentVersionTransition(entry, context);
        return n.n(_me);
    });
};
const se_NotificationConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_NC);
    bn.l(input, "TopicConfigurations", "TopicConfiguration", () => se_TopicConfigurationList(input[_TCop], context));
    bn.l(input, "QueueConfigurations", "QueueConfiguration", () => se_QueueConfigurationList(input[_QCu], context));
    bn.l(input, "LambdaFunctionConfigurations", "CloudFunctionConfiguration", () => se_LambdaFunctionConfigurationList(input[_LFC], context));
    if (input[_EBC] != null) {
        bn.c(se_EventBridgeConfiguration(input[_EBC], context).n(_EBC));
    }
    return bn;
};
const se_NotificationConfigurationFilter = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_NCF);
    if (input[_K] != null) {
        bn.c(se_S3KeyFilter(input[_K], context).n(_SKe));
    }
    return bn;
};
const se_ObjectIdentifier = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OI);
    if (input[_K] != null) {
        bn.c(xml_builder_1.XmlNode.of(_OK, input[_K]).n(_K));
    }
    if (input[_VI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_OVI, input[_VI]).n(_VI));
    }
    return bn;
};
const se_ObjectIdentifierList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_ObjectIdentifier(entry, context);
        return n.n(_me);
    });
};
const se_ObjectLockConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OLC);
    bn.cc(input, _OLE);
    if (input[_Ru] != null) {
        bn.c(se_ObjectLockRule(input[_Ru], context).n(_Ru));
    }
    return bn;
};
const se_ObjectLockLegalHold = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OLLH);
    if (input[_S] != null) {
        bn.c(xml_builder_1.XmlNode.of(_OLLHS, input[_S]).n(_S));
    }
    return bn;
};
const se_ObjectLockRetention = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OLR);
    if (input[_Mo] != null) {
        bn.c(xml_builder_1.XmlNode.of(_OLRM, input[_Mo]).n(_Mo));
    }
    if (input[_RUD] != null) {
        bn.c(xml_builder_1.XmlNode.of(_Dat, (input[_RUD].toISOString().split(".")[0] + "Z").toString()).n(_RUD));
    }
    return bn;
};
const se_ObjectLockRule = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OLRb);
    if (input[_DRe] != null) {
        bn.c(se_DefaultRetention(input[_DRe], context).n(_DRe));
    }
    return bn;
};
const se_OutputLocation = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OL);
    if (input[_S_] != null) {
        bn.c(se_S3Location(input[_S_], context).n(_S_));
    }
    return bn;
};
const se_OutputSerialization = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OS);
    if (input[_CSV] != null) {
        bn.c(se_CSVOutput(input[_CSV], context).n(_CSV));
    }
    if (input[_JSON] != null) {
        bn.c(se_JSONOutput(input[_JSON], context).n(_JSON));
    }
    return bn;
};
const se_Owner = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_O);
    bn.cc(input, _DN);
    bn.cc(input, _ID_);
    return bn;
};
const se_OwnershipControls = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OC);
    bn.l(input, "Rules", "Rule", () => se_OwnershipControlsRules(input[_Rul], context));
    return bn;
};
const se_OwnershipControlsRule = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_OCR);
    bn.cc(input, _OO);
    return bn;
};
const se_OwnershipControlsRules = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_OwnershipControlsRule(entry, context);
        return n.n(_me);
    });
};
const se_ParquetInput = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_PI);
    return bn;
};
const se_PartitionedPrefix = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_PP);
    bn.cc(input, _PDS);
    return bn;
};
const se_PublicAccessBlockConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_PABC);
    if (input[_BPA] != null) {
        bn.c(xml_builder_1.XmlNode.of(_Se, String(input[_BPA])).n(_BPA));
    }
    if (input[_IPA] != null) {
        bn.c(xml_builder_1.XmlNode.of(_Se, String(input[_IPA])).n(_IPA));
    }
    if (input[_BPP] != null) {
        bn.c(xml_builder_1.XmlNode.of(_Se, String(input[_BPP])).n(_BPP));
    }
    if (input[_RPB] != null) {
        bn.c(xml_builder_1.XmlNode.of(_Se, String(input[_RPB])).n(_RPB));
    }
    return bn;
};
const se_QueueConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_QC);
    if (input[_I] != null) {
        bn.c(xml_builder_1.XmlNode.of(_NI, input[_I]).n(_I));
    }
    if (input[_QA] != null) {
        bn.c(xml_builder_1.XmlNode.of(_QA, input[_QA]).n(_Qu));
    }
    bn.l(input, "Events", "Event", () => se_EventList(input[_Eve], context));
    if (input[_F] != null) {
        bn.c(se_NotificationConfigurationFilter(input[_F], context).n(_F));
    }
    return bn;
};
const se_QueueConfigurationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_QueueConfiguration(entry, context);
        return n.n(_me);
    });
};
const se_Redirect = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Red);
    bn.cc(input, _HN);
    bn.cc(input, _HRC);
    bn.cc(input, _Pr);
    bn.cc(input, _RKPW);
    bn.cc(input, _RKW);
    return bn;
};
const se_RedirectAllRequestsTo = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RART);
    bn.cc(input, _HN);
    bn.cc(input, _Pr);
    return bn;
};
const se_ReplicaModifications = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RM);
    if (input[_S] != null) {
        bn.c(xml_builder_1.XmlNode.of(_RMS, input[_S]).n(_S));
    }
    return bn;
};
const se_ReplicationConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RCe);
    bn.cc(input, _Ro);
    bn.l(input, "Rules", "Rule", () => se_ReplicationRules(input[_Rul], context));
    return bn;
};
const se_ReplicationRule = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RRe);
    bn.cc(input, _ID_);
    if (input[_Pri] != null) {
        bn.c(xml_builder_1.XmlNode.of(_Pri, String(input[_Pri])).n(_Pri));
    }
    bn.cc(input, _P);
    if (input[_F] != null) {
        bn.c(se_ReplicationRuleFilter(input[_F], context).n(_F));
    }
    if (input[_S] != null) {
        bn.c(xml_builder_1.XmlNode.of(_RRS, input[_S]).n(_S));
    }
    if (input[_SSC] != null) {
        bn.c(se_SourceSelectionCriteria(input[_SSC], context).n(_SSC));
    }
    if (input[_EOR] != null) {
        bn.c(se_ExistingObjectReplication(input[_EOR], context).n(_EOR));
    }
    if (input[_Des] != null) {
        bn.c(se_Destination(input[_Des], context).n(_Des));
    }
    if (input[_DMR] != null) {
        bn.c(se_DeleteMarkerReplication(input[_DMR], context).n(_DMR));
    }
    return bn;
};
const se_ReplicationRuleAndOperator = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RRAO);
    bn.cc(input, _P);
    bn.l(input, "Tags", "Tag", () => se_TagSet(input[_Tag], context));
    return bn;
};
const se_ReplicationRuleFilter = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RRF);
    models_0_1.ReplicationRuleFilter.visit(input, {
        Prefix: (value) => {
            if (input[_P] != null) {
                bn.c(xml_builder_1.XmlNode.of(_P, value).n(_P));
            }
        },
        Tag: (value) => {
            if (input[_Ta] != null) {
                bn.c(se_Tag(value, context).n(_Ta));
            }
        },
        And: (value) => {
            if (input[_A] != null) {
                bn.c(se_ReplicationRuleAndOperator(value, context).n(_A));
            }
        },
        _: (name, value) => {
            if (!(value instanceof xml_builder_1.XmlNode || value instanceof xml_builder_1.XmlText)) {
                throw new Error("Unable to serialize unknown union members in XML.");
            }
            bn.c(new xml_builder_1.XmlNode(name).c(value));
        },
    });
    return bn;
};
const se_ReplicationRules = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_ReplicationRule(entry, context);
        return n.n(_me);
    });
};
const se_ReplicationTime = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RTe);
    if (input[_S] != null) {
        bn.c(xml_builder_1.XmlNode.of(_RTS, input[_S]).n(_S));
    }
    if (input[_Tim] != null) {
        bn.c(se_ReplicationTimeValue(input[_Tim], context).n(_Tim));
    }
    return bn;
};
const se_ReplicationTimeValue = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RTV);
    if (input[_Mi] != null) {
        bn.c(xml_builder_1.XmlNode.of(_Mi, String(input[_Mi])).n(_Mi));
    }
    return bn;
};
const se_RequestPaymentConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RPC);
    bn.cc(input, _Pa);
    return bn;
};
const se_RequestProgress = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RPe);
    if (input[_Ena] != null) {
        bn.c(xml_builder_1.XmlNode.of(_ERP, String(input[_Ena])).n(_Ena));
    }
    return bn;
};
const se_RestoreRequest = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RRes);
    if (input[_Da] != null) {
        bn.c(xml_builder_1.XmlNode.of(_Da, String(input[_Da])).n(_Da));
    }
    if (input[_GJP] != null) {
        bn.c(se_GlacierJobParameters(input[_GJP], context).n(_GJP));
    }
    if (input[_Ty] != null) {
        bn.c(xml_builder_1.XmlNode.of(_RRT, input[_Ty]).n(_Ty));
    }
    bn.cc(input, _Ti);
    bn.cc(input, _Desc);
    if (input[_SP] != null) {
        bn.c(se_SelectParameters(input[_SP], context).n(_SP));
    }
    if (input[_OL] != null) {
        bn.c(se_OutputLocation(input[_OL], context).n(_OL));
    }
    return bn;
};
const se_RoutingRule = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_RRou);
    if (input[_Con] != null) {
        bn.c(se_Condition(input[_Con], context).n(_Con));
    }
    if (input[_Red] != null) {
        bn.c(se_Redirect(input[_Red], context).n(_Red));
    }
    return bn;
};
const se_RoutingRules = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_RoutingRule(entry, context);
        return n.n(_RRou);
    });
};
const se_S3KeyFilter = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SKF);
    bn.l(input, "FilterRules", "FilterRule", () => se_FilterRuleList(input[_FRi], context));
    return bn;
};
const se_S3Location = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SL);
    bn.cc(input, _BN);
    if (input[_P] != null) {
        bn.c(xml_builder_1.XmlNode.of(_LP, input[_P]).n(_P));
    }
    if (input[_En] != null) {
        bn.c(se_Encryption(input[_En], context).n(_En));
    }
    if (input[_CACL] != null) {
        bn.c(xml_builder_1.XmlNode.of(_OCACL, input[_CACL]).n(_CACL));
    }
    bn.lc(input, "AccessControlList", "AccessControlList", () => se_Grants(input[_ACLc], context));
    if (input[_T] != null) {
        bn.c(se_Tagging(input[_T], context).n(_T));
    }
    bn.lc(input, "UserMetadata", "UserMetadata", () => se_UserMetadata(input[_UM], context));
    bn.cc(input, _SC);
    return bn;
};
const se_ScanRange = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SR);
    if (input[_St] != null) {
        bn.c(xml_builder_1.XmlNode.of(_St, String(input[_St])).n(_St));
    }
    if (input[_End] != null) {
        bn.c(xml_builder_1.XmlNode.of(_End, String(input[_End])).n(_End));
    }
    return bn;
};
const se_SelectParameters = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SP);
    if (input[_IS] != null) {
        bn.c(se_InputSerialization(input[_IS], context).n(_IS));
    }
    bn.cc(input, _ETx);
    bn.cc(input, _Ex);
    if (input[_OS] != null) {
        bn.c(se_OutputSerialization(input[_OS], context).n(_OS));
    }
    return bn;
};
const se_ServerSideEncryptionByDefault = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SSEBD);
    if (input[_SSEA] != null) {
        bn.c(xml_builder_1.XmlNode.of(_SSE, input[_SSEA]).n(_SSEA));
    }
    if (input[_KMSMKID] != null) {
        bn.c(xml_builder_1.XmlNode.of(_SSEKMSKI, input[_KMSMKID]).n(_KMSMKID));
    }
    return bn;
};
const se_ServerSideEncryptionConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SSEC);
    bn.l(input, "Rules", "Rule", () => se_ServerSideEncryptionRules(input[_Rul], context));
    return bn;
};
const se_ServerSideEncryptionRule = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SSER);
    if (input[_ASSEBD] != null) {
        bn.c(se_ServerSideEncryptionByDefault(input[_ASSEBD], context).n(_ASSEBD));
    }
    if (input[_BKE] != null) {
        bn.c(xml_builder_1.XmlNode.of(_BKE, String(input[_BKE])).n(_BKE));
    }
    return bn;
};
const se_ServerSideEncryptionRules = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_ServerSideEncryptionRule(entry, context);
        return n.n(_me);
    });
};
const se_SimplePrefix = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SPi);
    return bn;
};
const se_SourceSelectionCriteria = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SSC);
    if (input[_SKEO] != null) {
        bn.c(se_SseKmsEncryptedObjects(input[_SKEO], context).n(_SKEO));
    }
    if (input[_RM] != null) {
        bn.c(se_ReplicaModifications(input[_RM], context).n(_RM));
    }
    return bn;
};
const se_SSEKMS = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SK);
    if (input[_KI] != null) {
        bn.c(xml_builder_1.XmlNode.of(_SSEKMSKI, input[_KI]).n(_KI));
    }
    return bn;
};
const se_SseKmsEncryptedObjects = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SKEO);
    if (input[_S] != null) {
        bn.c(xml_builder_1.XmlNode.of(_SKEOS, input[_S]).n(_S));
    }
    return bn;
};
const se_SSES3 = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SS);
    return bn;
};
const se_StorageClassAnalysis = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SCA);
    if (input[_DE] != null) {
        bn.c(se_StorageClassAnalysisDataExport(input[_DE], context).n(_DE));
    }
    return bn;
};
const se_StorageClassAnalysisDataExport = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_SCADE);
    if (input[_OSV] != null) {
        bn.c(xml_builder_1.XmlNode.of(_SCASV, input[_OSV]).n(_OSV));
    }
    if (input[_Des] != null) {
        bn.c(se_AnalyticsExportDestination(input[_Des], context).n(_Des));
    }
    return bn;
};
const se_Tag = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Ta);
    if (input[_K] != null) {
        bn.c(xml_builder_1.XmlNode.of(_OK, input[_K]).n(_K));
    }
    bn.cc(input, _Va);
    return bn;
};
const se_Tagging = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_T);
    bn.lc(input, "TagSet", "TagSet", () => se_TagSet(input[_TS], context));
    return bn;
};
const se_TagSet = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_Tag(entry, context);
        return n.n(_Ta);
    });
};
const se_TargetGrant = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_TGa);
    if (input[_Gra] != null) {
        const n = se_Grantee(input[_Gra], context).n(_Gra);
        n.a("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
        bn.c(n);
    }
    if (input[_Pe] != null) {
        bn.c(xml_builder_1.XmlNode.of(_BLP, input[_Pe]).n(_Pe));
    }
    return bn;
};
const se_TargetGrants = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_TargetGrant(entry, context);
        return n.n(_G);
    });
};
const se_TargetObjectKeyFormat = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_TOKF);
    if (input[_SPi] != null) {
        bn.c(se_SimplePrefix(input[_SPi], context).n(_SPi));
    }
    if (input[_PP] != null) {
        bn.c(se_PartitionedPrefix(input[_PP], context).n(_PP));
    }
    return bn;
};
const se_Tiering = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Tier);
    if (input[_Da] != null) {
        bn.c(xml_builder_1.XmlNode.of(_ITD, String(input[_Da])).n(_Da));
    }
    if (input[_AT] != null) {
        bn.c(xml_builder_1.XmlNode.of(_ITAT, input[_AT]).n(_AT));
    }
    return bn;
};
const se_TieringList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_Tiering(entry, context);
        return n.n(_me);
    });
};
const se_TopicConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_TCo);
    if (input[_I] != null) {
        bn.c(xml_builder_1.XmlNode.of(_NI, input[_I]).n(_I));
    }
    if (input[_TA] != null) {
        bn.c(xml_builder_1.XmlNode.of(_TA, input[_TA]).n(_Top));
    }
    bn.l(input, "Events", "Event", () => se_EventList(input[_Eve], context));
    if (input[_F] != null) {
        bn.c(se_NotificationConfigurationFilter(input[_F], context).n(_F));
    }
    return bn;
};
const se_TopicConfigurationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_TopicConfiguration(entry, context);
        return n.n(_me);
    });
};
const se_Transition = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_Tra);
    if (input[_Dat] != null) {
        bn.c(xml_builder_1.XmlNode.of(_Dat, (input[_Dat].toISOString().split(".")[0] + "Z").toString()).n(_Dat));
    }
    if (input[_Da] != null) {
        bn.c(xml_builder_1.XmlNode.of(_Da, String(input[_Da])).n(_Da));
    }
    if (input[_SC] != null) {
        bn.c(xml_builder_1.XmlNode.of(_TSC, input[_SC]).n(_SC));
    }
    return bn;
};
const se_TransitionList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_Transition(entry, context);
        return n.n(_me);
    });
};
const se_UserMetadata = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        const n = se_MetadataEntry(entry, context);
        return n.n(_ME);
    });
};
const se_VersioningConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_VCe);
    if (input[_MFAD] != null) {
        bn.c(xml_builder_1.XmlNode.of(_MFAD, input[_MFAD]).n(_MDf));
    }
    if (input[_S] != null) {
        bn.c(xml_builder_1.XmlNode.of(_BVS, input[_S]).n(_S));
    }
    return bn;
};
const se_WebsiteConfiguration = (input, context) => {
    const bn = new xml_builder_1.XmlNode(_WC);
    if (input[_ED] != null) {
        bn.c(se_ErrorDocument(input[_ED], context).n(_ED));
    }
    if (input[_ID] != null) {
        bn.c(se_IndexDocument(input[_ID], context).n(_ID));
    }
    if (input[_RART] != null) {
        bn.c(se_RedirectAllRequestsTo(input[_RART], context).n(_RART));
    }
    bn.lc(input, "RoutingRules", "RoutingRules", () => se_RoutingRules(input[_RRo], context));
    return bn;
};
const de_AbortIncompleteMultipartUpload = (output, context) => {
    const contents = {};
    if (output[_DAI] != null) {
        contents[_DAI] = (0, smithy_client_1.strictParseInt32)(output[_DAI]);
    }
    return contents;
};
const de_AccessControlTranslation = (output, context) => {
    const contents = {};
    if (output[_O] != null) {
        contents[_O] = (0, smithy_client_1.expectString)(output[_O]);
    }
    return contents;
};
const de_AllowedHeaders = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_AllowedMethods = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_AllowedOrigins = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_AnalyticsAndOperator = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = (0, smithy_client_1.expectString)(output[_P]);
    }
    if (output.Tag === "") {
        contents[_Tag] = [];
    }
    else if (output[_Ta] != null) {
        contents[_Tag] = de_TagSet((0, smithy_client_1.getArrayIfSingleItem)(output[_Ta]), context);
    }
    return contents;
};
const de_AnalyticsConfiguration = (output, context) => {
    const contents = {};
    if (output[_I] != null) {
        contents[_I] = (0, smithy_client_1.expectString)(output[_I]);
    }
    if (output.Filter === "") {
    }
    else if (output[_F] != null) {
        contents[_F] = de_AnalyticsFilter((0, smithy_client_1.expectUnion)(output[_F]), context);
    }
    if (output[_SCA] != null) {
        contents[_SCA] = de_StorageClassAnalysis(output[_SCA], context);
    }
    return contents;
};
const de_AnalyticsConfigurationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AnalyticsConfiguration(entry, context);
    });
};
const de_AnalyticsExportDestination = (output, context) => {
    const contents = {};
    if (output[_SBD] != null) {
        contents[_SBD] = de_AnalyticsS3BucketDestination(output[_SBD], context);
    }
    return contents;
};
const de_AnalyticsFilter = (output, context) => {
    if (output[_P] != null) {
        return {
            Prefix: (0, smithy_client_1.expectString)(output[_P]),
        };
    }
    if (output[_Ta] != null) {
        return {
            Tag: de_Tag(output[_Ta], context),
        };
    }
    if (output[_A] != null) {
        return {
            And: de_AnalyticsAndOperator(output[_A], context),
        };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_AnalyticsS3BucketDestination = (output, context) => {
    const contents = {};
    if (output[_Fo] != null) {
        contents[_Fo] = (0, smithy_client_1.expectString)(output[_Fo]);
    }
    if (output[_BAI] != null) {
        contents[_BAI] = (0, smithy_client_1.expectString)(output[_BAI]);
    }
    if (output[_B] != null) {
        contents[_B] = (0, smithy_client_1.expectString)(output[_B]);
    }
    if (output[_P] != null) {
        contents[_P] = (0, smithy_client_1.expectString)(output[_P]);
    }
    return contents;
};
const de_Bucket = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_CDr] != null) {
        contents[_CDr] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_CDr]));
    }
    return contents;
};
const de_Buckets = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Bucket(entry, context);
    });
};
const de_Checksum = (output, context) => {
    const contents = {};
    if (output[_CCRC] != null) {
        contents[_CCRC] = (0, smithy_client_1.expectString)(output[_CCRC]);
    }
    if (output[_CCRCC] != null) {
        contents[_CCRCC] = (0, smithy_client_1.expectString)(output[_CCRCC]);
    }
    if (output[_CSHA] != null) {
        contents[_CSHA] = (0, smithy_client_1.expectString)(output[_CSHA]);
    }
    if (output[_CSHAh] != null) {
        contents[_CSHAh] = (0, smithy_client_1.expectString)(output[_CSHAh]);
    }
    return contents;
};
const de_ChecksumAlgorithmList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_CommonPrefix = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = (0, smithy_client_1.expectString)(output[_P]);
    }
    return contents;
};
const de_CommonPrefixList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CommonPrefix(entry, context);
    });
};
const de_Condition = (output, context) => {
    const contents = {};
    if (output[_HECRE] != null) {
        contents[_HECRE] = (0, smithy_client_1.expectString)(output[_HECRE]);
    }
    if (output[_KPE] != null) {
        contents[_KPE] = (0, smithy_client_1.expectString)(output[_KPE]);
    }
    return contents;
};
const de_ContinuationEvent = (output, context) => {
    const contents = {};
    return contents;
};
const de_CopyObjectResult = (output, context) => {
    const contents = {};
    if (output[_ETa] != null) {
        contents[_ETa] = (0, smithy_client_1.expectString)(output[_ETa]);
    }
    if (output[_LM] != null) {
        contents[_LM] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LM]));
    }
    if (output[_CCRC] != null) {
        contents[_CCRC] = (0, smithy_client_1.expectString)(output[_CCRC]);
    }
    if (output[_CCRCC] != null) {
        contents[_CCRCC] = (0, smithy_client_1.expectString)(output[_CCRCC]);
    }
    if (output[_CSHA] != null) {
        contents[_CSHA] = (0, smithy_client_1.expectString)(output[_CSHA]);
    }
    if (output[_CSHAh] != null) {
        contents[_CSHAh] = (0, smithy_client_1.expectString)(output[_CSHAh]);
    }
    return contents;
};
const de_CopyPartResult = (output, context) => {
    const contents = {};
    if (output[_ETa] != null) {
        contents[_ETa] = (0, smithy_client_1.expectString)(output[_ETa]);
    }
    if (output[_LM] != null) {
        contents[_LM] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LM]));
    }
    if (output[_CCRC] != null) {
        contents[_CCRC] = (0, smithy_client_1.expectString)(output[_CCRC]);
    }
    if (output[_CCRCC] != null) {
        contents[_CCRCC] = (0, smithy_client_1.expectString)(output[_CCRCC]);
    }
    if (output[_CSHA] != null) {
        contents[_CSHA] = (0, smithy_client_1.expectString)(output[_CSHA]);
    }
    if (output[_CSHAh] != null) {
        contents[_CSHAh] = (0, smithy_client_1.expectString)(output[_CSHAh]);
    }
    return contents;
};
const de_CORSRule = (output, context) => {
    const contents = {};
    if (output[_ID_] != null) {
        contents[_ID_] = (0, smithy_client_1.expectString)(output[_ID_]);
    }
    if (output.AllowedHeader === "") {
        contents[_AHl] = [];
    }
    else if (output[_AH] != null) {
        contents[_AHl] = de_AllowedHeaders((0, smithy_client_1.getArrayIfSingleItem)(output[_AH]), context);
    }
    if (output.AllowedMethod === "") {
        contents[_AMl] = [];
    }
    else if (output[_AM] != null) {
        contents[_AMl] = de_AllowedMethods((0, smithy_client_1.getArrayIfSingleItem)(output[_AM]), context);
    }
    if (output.AllowedOrigin === "") {
        contents[_AOl] = [];
    }
    else if (output[_AO] != null) {
        contents[_AOl] = de_AllowedOrigins((0, smithy_client_1.getArrayIfSingleItem)(output[_AO]), context);
    }
    if (output.ExposeHeader === "") {
        contents[_EH] = [];
    }
    else if (output[_EHx] != null) {
        contents[_EH] = de_ExposeHeaders((0, smithy_client_1.getArrayIfSingleItem)(output[_EHx]), context);
    }
    if (output[_MAS] != null) {
        contents[_MAS] = (0, smithy_client_1.strictParseInt32)(output[_MAS]);
    }
    return contents;
};
const de_CORSRules = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CORSRule(entry, context);
    });
};
const de_DefaultRetention = (output, context) => {
    const contents = {};
    if (output[_Mo] != null) {
        contents[_Mo] = (0, smithy_client_1.expectString)(output[_Mo]);
    }
    if (output[_Da] != null) {
        contents[_Da] = (0, smithy_client_1.strictParseInt32)(output[_Da]);
    }
    if (output[_Y] != null) {
        contents[_Y] = (0, smithy_client_1.strictParseInt32)(output[_Y]);
    }
    return contents;
};
const de_DeletedObject = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = (0, smithy_client_1.expectString)(output[_K]);
    }
    if (output[_VI] != null) {
        contents[_VI] = (0, smithy_client_1.expectString)(output[_VI]);
    }
    if (output[_DM] != null) {
        contents[_DM] = (0, smithy_client_1.parseBoolean)(output[_DM]);
    }
    if (output[_DMVI] != null) {
        contents[_DMVI] = (0, smithy_client_1.expectString)(output[_DMVI]);
    }
    return contents;
};
const de_DeletedObjects = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DeletedObject(entry, context);
    });
};
const de_DeleteMarkerEntry = (output, context) => {
    const contents = {};
    if (output[_O] != null) {
        contents[_O] = de_Owner(output[_O], context);
    }
    if (output[_K] != null) {
        contents[_K] = (0, smithy_client_1.expectString)(output[_K]);
    }
    if (output[_VI] != null) {
        contents[_VI] = (0, smithy_client_1.expectString)(output[_VI]);
    }
    if (output[_IL] != null) {
        contents[_IL] = (0, smithy_client_1.parseBoolean)(output[_IL]);
    }
    if (output[_LM] != null) {
        contents[_LM] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LM]));
    }
    return contents;
};
const de_DeleteMarkerReplication = (output, context) => {
    const contents = {};
    if (output[_S] != null) {
        contents[_S] = (0, smithy_client_1.expectString)(output[_S]);
    }
    return contents;
};
const de_DeleteMarkers = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DeleteMarkerEntry(entry, context);
    });
};
const de_Destination = (output, context) => {
    const contents = {};
    if (output[_B] != null) {
        contents[_B] = (0, smithy_client_1.expectString)(output[_B]);
    }
    if (output[_Ac] != null) {
        contents[_Ac] = (0, smithy_client_1.expectString)(output[_Ac]);
    }
    if (output[_SC] != null) {
        contents[_SC] = (0, smithy_client_1.expectString)(output[_SC]);
    }
    if (output[_ACT] != null) {
        contents[_ACT] = de_AccessControlTranslation(output[_ACT], context);
    }
    if (output[_ECn] != null) {
        contents[_ECn] = de_EncryptionConfiguration(output[_ECn], context);
    }
    if (output[_RTe] != null) {
        contents[_RTe] = de_ReplicationTime(output[_RTe], context);
    }
    if (output[_Me] != null) {
        contents[_Me] = de_Metrics(output[_Me], context);
    }
    return contents;
};
const de_EncryptionConfiguration = (output, context) => {
    const contents = {};
    if (output[_RKKID] != null) {
        contents[_RKKID] = (0, smithy_client_1.expectString)(output[_RKKID]);
    }
    return contents;
};
const de_EndEvent = (output, context) => {
    const contents = {};
    return contents;
};
const de__Error = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = (0, smithy_client_1.expectString)(output[_K]);
    }
    if (output[_VI] != null) {
        contents[_VI] = (0, smithy_client_1.expectString)(output[_VI]);
    }
    if (output[_Cod] != null) {
        contents[_Cod] = (0, smithy_client_1.expectString)(output[_Cod]);
    }
    if (output[_Mes] != null) {
        contents[_Mes] = (0, smithy_client_1.expectString)(output[_Mes]);
    }
    return contents;
};
const de_ErrorDocument = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = (0, smithy_client_1.expectString)(output[_K]);
    }
    return contents;
};
const de_Errors = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de__Error(entry, context);
    });
};
const de_EventBridgeConfiguration = (output, context) => {
    const contents = {};
    return contents;
};
const de_EventList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_ExistingObjectReplication = (output, context) => {
    const contents = {};
    if (output[_S] != null) {
        contents[_S] = (0, smithy_client_1.expectString)(output[_S]);
    }
    return contents;
};
const de_ExposeHeaders = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_FilterRule = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = (0, smithy_client_1.expectString)(output[_N]);
    }
    if (output[_Va] != null) {
        contents[_Va] = (0, smithy_client_1.expectString)(output[_Va]);
    }
    return contents;
};
const de_FilterRuleList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FilterRule(entry, context);
    });
};
const de_GetObjectAttributesParts = (output, context) => {
    const contents = {};
    if (output[_PC] != null) {
        contents[_TPC] = (0, smithy_client_1.strictParseInt32)(output[_PC]);
    }
    if (output[_PNM] != null) {
        contents[_PNM] = (0, smithy_client_1.expectString)(output[_PNM]);
    }
    if (output[_NPNM] != null) {
        contents[_NPNM] = (0, smithy_client_1.expectString)(output[_NPNM]);
    }
    if (output[_MP] != null) {
        contents[_MP] = (0, smithy_client_1.strictParseInt32)(output[_MP]);
    }
    if (output[_IT] != null) {
        contents[_IT] = (0, smithy_client_1.parseBoolean)(output[_IT]);
    }
    if (output.Part === "") {
        contents[_Part] = [];
    }
    else if (output[_Par] != null) {
        contents[_Part] = de_PartsList((0, smithy_client_1.getArrayIfSingleItem)(output[_Par]), context);
    }
    return contents;
};
const de_Grant = (output, context) => {
    const contents = {};
    if (output[_Gra] != null) {
        contents[_Gra] = de_Grantee(output[_Gra], context);
    }
    if (output[_Pe] != null) {
        contents[_Pe] = (0, smithy_client_1.expectString)(output[_Pe]);
    }
    return contents;
};
const de_Grantee = (output, context) => {
    const contents = {};
    if (output[_DN] != null) {
        contents[_DN] = (0, smithy_client_1.expectString)(output[_DN]);
    }
    if (output[_EA] != null) {
        contents[_EA] = (0, smithy_client_1.expectString)(output[_EA]);
    }
    if (output[_ID_] != null) {
        contents[_ID_] = (0, smithy_client_1.expectString)(output[_ID_]);
    }
    if (output[_URI] != null) {
        contents[_URI] = (0, smithy_client_1.expectString)(output[_URI]);
    }
    if (output[_x] != null) {
        contents[_Ty] = (0, smithy_client_1.expectString)(output[_x]);
    }
    return contents;
};
const de_Grants = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Grant(entry, context);
    });
};
const de_IndexDocument = (output, context) => {
    const contents = {};
    if (output[_Su] != null) {
        contents[_Su] = (0, smithy_client_1.expectString)(output[_Su]);
    }
    return contents;
};
const de_Initiator = (output, context) => {
    const contents = {};
    if (output[_ID_] != null) {
        contents[_ID_] = (0, smithy_client_1.expectString)(output[_ID_]);
    }
    if (output[_DN] != null) {
        contents[_DN] = (0, smithy_client_1.expectString)(output[_DN]);
    }
    return contents;
};
const de_IntelligentTieringAndOperator = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = (0, smithy_client_1.expectString)(output[_P]);
    }
    if (output.Tag === "") {
        contents[_Tag] = [];
    }
    else if (output[_Ta] != null) {
        contents[_Tag] = de_TagSet((0, smithy_client_1.getArrayIfSingleItem)(output[_Ta]), context);
    }
    return contents;
};
const de_IntelligentTieringConfiguration = (output, context) => {
    const contents = {};
    if (output[_I] != null) {
        contents[_I] = (0, smithy_client_1.expectString)(output[_I]);
    }
    if (output[_F] != null) {
        contents[_F] = de_IntelligentTieringFilter(output[_F], context);
    }
    if (output[_S] != null) {
        contents[_S] = (0, smithy_client_1.expectString)(output[_S]);
    }
    if (output.Tiering === "") {
        contents[_Tie] = [];
    }
    else if (output[_Tier] != null) {
        contents[_Tie] = de_TieringList((0, smithy_client_1.getArrayIfSingleItem)(output[_Tier]), context);
    }
    return contents;
};
const de_IntelligentTieringConfigurationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IntelligentTieringConfiguration(entry, context);
    });
};
const de_IntelligentTieringFilter = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = (0, smithy_client_1.expectString)(output[_P]);
    }
    if (output[_Ta] != null) {
        contents[_Ta] = de_Tag(output[_Ta], context);
    }
    if (output[_A] != null) {
        contents[_A] = de_IntelligentTieringAndOperator(output[_A], context);
    }
    return contents;
};
const de_InventoryConfiguration = (output, context) => {
    const contents = {};
    if (output[_Des] != null) {
        contents[_Des] = de_InventoryDestination(output[_Des], context);
    }
    if (output[_IE] != null) {
        contents[_IE] = (0, smithy_client_1.parseBoolean)(output[_IE]);
    }
    if (output[_F] != null) {
        contents[_F] = de_InventoryFilter(output[_F], context);
    }
    if (output[_I] != null) {
        contents[_I] = (0, smithy_client_1.expectString)(output[_I]);
    }
    if (output[_IOV] != null) {
        contents[_IOV] = (0, smithy_client_1.expectString)(output[_IOV]);
    }
    if (output.OptionalFields === "") {
        contents[_OF] = [];
    }
    else if (output[_OF] != null && output[_OF][_Fi] != null) {
        contents[_OF] = de_InventoryOptionalFields((0, smithy_client_1.getArrayIfSingleItem)(output[_OF][_Fi]), context);
    }
    if (output[_Sc] != null) {
        contents[_Sc] = de_InventorySchedule(output[_Sc], context);
    }
    return contents;
};
const de_InventoryConfigurationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InventoryConfiguration(entry, context);
    });
};
const de_InventoryDestination = (output, context) => {
    const contents = {};
    if (output[_SBD] != null) {
        contents[_SBD] = de_InventoryS3BucketDestination(output[_SBD], context);
    }
    return contents;
};
const de_InventoryEncryption = (output, context) => {
    const contents = {};
    if (output[_SS] != null) {
        contents[_SSES] = de_SSES3(output[_SS], context);
    }
    if (output[_SK] != null) {
        contents[_SSEKMS] = de_SSEKMS(output[_SK], context);
    }
    return contents;
};
const de_InventoryFilter = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = (0, smithy_client_1.expectString)(output[_P]);
    }
    return contents;
};
const de_InventoryOptionalFields = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_InventoryS3BucketDestination = (output, context) => {
    const contents = {};
    if (output[_AIc] != null) {
        contents[_AIc] = (0, smithy_client_1.expectString)(output[_AIc]);
    }
    if (output[_B] != null) {
        contents[_B] = (0, smithy_client_1.expectString)(output[_B]);
    }
    if (output[_Fo] != null) {
        contents[_Fo] = (0, smithy_client_1.expectString)(output[_Fo]);
    }
    if (output[_P] != null) {
        contents[_P] = (0, smithy_client_1.expectString)(output[_P]);
    }
    if (output[_En] != null) {
        contents[_En] = de_InventoryEncryption(output[_En], context);
    }
    return contents;
};
const de_InventorySchedule = (output, context) => {
    const contents = {};
    if (output[_Fr] != null) {
        contents[_Fr] = (0, smithy_client_1.expectString)(output[_Fr]);
    }
    return contents;
};
const de_LambdaFunctionConfiguration = (output, context) => {
    const contents = {};
    if (output[_I] != null) {
        contents[_I] = (0, smithy_client_1.expectString)(output[_I]);
    }
    if (output[_CF] != null) {
        contents[_LFA] = (0, smithy_client_1.expectString)(output[_CF]);
    }
    if (output.Event === "") {
        contents[_Eve] = [];
    }
    else if (output[_Ev] != null) {
        contents[_Eve] = de_EventList((0, smithy_client_1.getArrayIfSingleItem)(output[_Ev]), context);
    }
    if (output[_F] != null) {
        contents[_F] = de_NotificationConfigurationFilter(output[_F], context);
    }
    return contents;
};
const de_LambdaFunctionConfigurationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LambdaFunctionConfiguration(entry, context);
    });
};
const de_LifecycleExpiration = (output, context) => {
    const contents = {};
    if (output[_Dat] != null) {
        contents[_Dat] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_Dat]));
    }
    if (output[_Da] != null) {
        contents[_Da] = (0, smithy_client_1.strictParseInt32)(output[_Da]);
    }
    if (output[_EODM] != null) {
        contents[_EODM] = (0, smithy_client_1.parseBoolean)(output[_EODM]);
    }
    return contents;
};
const de_LifecycleRule = (output, context) => {
    const contents = {};
    if (output[_Exp] != null) {
        contents[_Exp] = de_LifecycleExpiration(output[_Exp], context);
    }
    if (output[_ID_] != null) {
        contents[_ID_] = (0, smithy_client_1.expectString)(output[_ID_]);
    }
    if (output[_P] != null) {
        contents[_P] = (0, smithy_client_1.expectString)(output[_P]);
    }
    if (output.Filter === "") {
    }
    else if (output[_F] != null) {
        contents[_F] = de_LifecycleRuleFilter((0, smithy_client_1.expectUnion)(output[_F]), context);
    }
    if (output[_S] != null) {
        contents[_S] = (0, smithy_client_1.expectString)(output[_S]);
    }
    if (output.Transition === "") {
        contents[_Tr] = [];
    }
    else if (output[_Tra] != null) {
        contents[_Tr] = de_TransitionList((0, smithy_client_1.getArrayIfSingleItem)(output[_Tra]), context);
    }
    if (output.NoncurrentVersionTransition === "") {
        contents[_NVT] = [];
    }
    else if (output[_NVTo] != null) {
        contents[_NVT] = de_NoncurrentVersionTransitionList((0, smithy_client_1.getArrayIfSingleItem)(output[_NVTo]), context);
    }
    if (output[_NVE] != null) {
        contents[_NVE] = de_NoncurrentVersionExpiration(output[_NVE], context);
    }
    if (output[_AIMU] != null) {
        contents[_AIMU] = de_AbortIncompleteMultipartUpload(output[_AIMU], context);
    }
    return contents;
};
const de_LifecycleRuleAndOperator = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = (0, smithy_client_1.expectString)(output[_P]);
    }
    if (output.Tag === "") {
        contents[_Tag] = [];
    }
    else if (output[_Ta] != null) {
        contents[_Tag] = de_TagSet((0, smithy_client_1.getArrayIfSingleItem)(output[_Ta]), context);
    }
    if (output[_OSGT] != null) {
        contents[_OSGT] = (0, smithy_client_1.strictParseLong)(output[_OSGT]);
    }
    if (output[_OSLT] != null) {
        contents[_OSLT] = (0, smithy_client_1.strictParseLong)(output[_OSLT]);
    }
    return contents;
};
const de_LifecycleRuleFilter = (output, context) => {
    if (output[_P] != null) {
        return {
            Prefix: (0, smithy_client_1.expectString)(output[_P]),
        };
    }
    if (output[_Ta] != null) {
        return {
            Tag: de_Tag(output[_Ta], context),
        };
    }
    if (output[_OSGT] != null) {
        return {
            ObjectSizeGreaterThan: (0, smithy_client_1.strictParseLong)(output[_OSGT]),
        };
    }
    if (output[_OSLT] != null) {
        return {
            ObjectSizeLessThan: (0, smithy_client_1.strictParseLong)(output[_OSLT]),
        };
    }
    if (output[_A] != null) {
        return {
            And: de_LifecycleRuleAndOperator(output[_A], context),
        };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_LifecycleRules = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LifecycleRule(entry, context);
    });
};
const de_LoggingEnabled = (output, context) => {
    const contents = {};
    if (output[_TB] != null) {
        contents[_TB] = (0, smithy_client_1.expectString)(output[_TB]);
    }
    if (output.TargetGrants === "") {
        contents[_TG] = [];
    }
    else if (output[_TG] != null && output[_TG][_G] != null) {
        contents[_TG] = de_TargetGrants((0, smithy_client_1.getArrayIfSingleItem)(output[_TG][_G]), context);
    }
    if (output[_TP] != null) {
        contents[_TP] = (0, smithy_client_1.expectString)(output[_TP]);
    }
    if (output[_TOKF] != null) {
        contents[_TOKF] = de_TargetObjectKeyFormat(output[_TOKF], context);
    }
    return contents;
};
const de_Metrics = (output, context) => {
    const contents = {};
    if (output[_S] != null) {
        contents[_S] = (0, smithy_client_1.expectString)(output[_S]);
    }
    if (output[_ETv] != null) {
        contents[_ETv] = de_ReplicationTimeValue(output[_ETv], context);
    }
    return contents;
};
const de_MetricsAndOperator = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = (0, smithy_client_1.expectString)(output[_P]);
    }
    if (output.Tag === "") {
        contents[_Tag] = [];
    }
    else if (output[_Ta] != null) {
        contents[_Tag] = de_TagSet((0, smithy_client_1.getArrayIfSingleItem)(output[_Ta]), context);
    }
    if (output[_APAc] != null) {
        contents[_APAc] = (0, smithy_client_1.expectString)(output[_APAc]);
    }
    return contents;
};
const de_MetricsConfiguration = (output, context) => {
    const contents = {};
    if (output[_I] != null) {
        contents[_I] = (0, smithy_client_1.expectString)(output[_I]);
    }
    if (output.Filter === "") {
    }
    else if (output[_F] != null) {
        contents[_F] = de_MetricsFilter((0, smithy_client_1.expectUnion)(output[_F]), context);
    }
    return contents;
};
const de_MetricsConfigurationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricsConfiguration(entry, context);
    });
};
const de_MetricsFilter = (output, context) => {
    if (output[_P] != null) {
        return {
            Prefix: (0, smithy_client_1.expectString)(output[_P]),
        };
    }
    if (output[_Ta] != null) {
        return {
            Tag: de_Tag(output[_Ta], context),
        };
    }
    if (output[_APAc] != null) {
        return {
            AccessPointArn: (0, smithy_client_1.expectString)(output[_APAc]),
        };
    }
    if (output[_A] != null) {
        return {
            And: de_MetricsAndOperator(output[_A], context),
        };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_MultipartUpload = (output, context) => {
    const contents = {};
    if (output[_UI] != null) {
        contents[_UI] = (0, smithy_client_1.expectString)(output[_UI]);
    }
    if (output[_K] != null) {
        contents[_K] = (0, smithy_client_1.expectString)(output[_K]);
    }
    if (output[_Ini] != null) {
        contents[_Ini] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_Ini]));
    }
    if (output[_SC] != null) {
        contents[_SC] = (0, smithy_client_1.expectString)(output[_SC]);
    }
    if (output[_O] != null) {
        contents[_O] = de_Owner(output[_O], context);
    }
    if (output[_In] != null) {
        contents[_In] = de_Initiator(output[_In], context);
    }
    if (output[_CA] != null) {
        contents[_CA] = (0, smithy_client_1.expectString)(output[_CA]);
    }
    return contents;
};
const de_MultipartUploadList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MultipartUpload(entry, context);
    });
};
const de_NoncurrentVersionExpiration = (output, context) => {
    const contents = {};
    if (output[_ND] != null) {
        contents[_ND] = (0, smithy_client_1.strictParseInt32)(output[_ND]);
    }
    if (output[_NNV] != null) {
        contents[_NNV] = (0, smithy_client_1.strictParseInt32)(output[_NNV]);
    }
    return contents;
};
const de_NoncurrentVersionTransition = (output, context) => {
    const contents = {};
    if (output[_ND] != null) {
        contents[_ND] = (0, smithy_client_1.strictParseInt32)(output[_ND]);
    }
    if (output[_SC] != null) {
        contents[_SC] = (0, smithy_client_1.expectString)(output[_SC]);
    }
    if (output[_NNV] != null) {
        contents[_NNV] = (0, smithy_client_1.strictParseInt32)(output[_NNV]);
    }
    return contents;
};
const de_NoncurrentVersionTransitionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_NoncurrentVersionTransition(entry, context);
    });
};
const de_NotificationConfigurationFilter = (output, context) => {
    const contents = {};
    if (output[_SKe] != null) {
        contents[_K] = de_S3KeyFilter(output[_SKe], context);
    }
    return contents;
};
const de__Object = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = (0, smithy_client_1.expectString)(output[_K]);
    }
    if (output[_LM] != null) {
        contents[_LM] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LM]));
    }
    if (output[_ETa] != null) {
        contents[_ETa] = (0, smithy_client_1.expectString)(output[_ETa]);
    }
    if (output.ChecksumAlgorithm === "") {
        contents[_CA] = [];
    }
    else if (output[_CA] != null) {
        contents[_CA] = de_ChecksumAlgorithmList((0, smithy_client_1.getArrayIfSingleItem)(output[_CA]), context);
    }
    if (output[_Si] != null) {
        contents[_Si] = (0, smithy_client_1.strictParseLong)(output[_Si]);
    }
    if (output[_SC] != null) {
        contents[_SC] = (0, smithy_client_1.expectString)(output[_SC]);
    }
    if (output[_O] != null) {
        contents[_O] = de_Owner(output[_O], context);
    }
    if (output[_RSe] != null) {
        contents[_RSe] = de_RestoreStatus(output[_RSe], context);
    }
    return contents;
};
const de_ObjectList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de__Object(entry, context);
    });
};
const de_ObjectLockConfiguration = (output, context) => {
    const contents = {};
    if (output[_OLE] != null) {
        contents[_OLE] = (0, smithy_client_1.expectString)(output[_OLE]);
    }
    if (output[_Ru] != null) {
        contents[_Ru] = de_ObjectLockRule(output[_Ru], context);
    }
    return contents;
};
const de_ObjectLockLegalHold = (output, context) => {
    const contents = {};
    if (output[_S] != null) {
        contents[_S] = (0, smithy_client_1.expectString)(output[_S]);
    }
    return contents;
};
const de_ObjectLockRetention = (output, context) => {
    const contents = {};
    if (output[_Mo] != null) {
        contents[_Mo] = (0, smithy_client_1.expectString)(output[_Mo]);
    }
    if (output[_RUD] != null) {
        contents[_RUD] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_RUD]));
    }
    return contents;
};
const de_ObjectLockRule = (output, context) => {
    const contents = {};
    if (output[_DRe] != null) {
        contents[_DRe] = de_DefaultRetention(output[_DRe], context);
    }
    return contents;
};
const de_ObjectPart = (output, context) => {
    const contents = {};
    if (output[_PN] != null) {
        contents[_PN] = (0, smithy_client_1.strictParseInt32)(output[_PN]);
    }
    if (output[_Si] != null) {
        contents[_Si] = (0, smithy_client_1.strictParseLong)(output[_Si]);
    }
    if (output[_CCRC] != null) {
        contents[_CCRC] = (0, smithy_client_1.expectString)(output[_CCRC]);
    }
    if (output[_CCRCC] != null) {
        contents[_CCRCC] = (0, smithy_client_1.expectString)(output[_CCRCC]);
    }
    if (output[_CSHA] != null) {
        contents[_CSHA] = (0, smithy_client_1.expectString)(output[_CSHA]);
    }
    if (output[_CSHAh] != null) {
        contents[_CSHAh] = (0, smithy_client_1.expectString)(output[_CSHAh]);
    }
    return contents;
};
const de_ObjectVersion = (output, context) => {
    const contents = {};
    if (output[_ETa] != null) {
        contents[_ETa] = (0, smithy_client_1.expectString)(output[_ETa]);
    }
    if (output.ChecksumAlgorithm === "") {
        contents[_CA] = [];
    }
    else if (output[_CA] != null) {
        contents[_CA] = de_ChecksumAlgorithmList((0, smithy_client_1.getArrayIfSingleItem)(output[_CA]), context);
    }
    if (output[_Si] != null) {
        contents[_Si] = (0, smithy_client_1.strictParseLong)(output[_Si]);
    }
    if (output[_SC] != null) {
        contents[_SC] = (0, smithy_client_1.expectString)(output[_SC]);
    }
    if (output[_K] != null) {
        contents[_K] = (0, smithy_client_1.expectString)(output[_K]);
    }
    if (output[_VI] != null) {
        contents[_VI] = (0, smithy_client_1.expectString)(output[_VI]);
    }
    if (output[_IL] != null) {
        contents[_IL] = (0, smithy_client_1.parseBoolean)(output[_IL]);
    }
    if (output[_LM] != null) {
        contents[_LM] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LM]));
    }
    if (output[_O] != null) {
        contents[_O] = de_Owner(output[_O], context);
    }
    if (output[_RSe] != null) {
        contents[_RSe] = de_RestoreStatus(output[_RSe], context);
    }
    return contents;
};
const de_ObjectVersionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ObjectVersion(entry, context);
    });
};
const de_Owner = (output, context) => {
    const contents = {};
    if (output[_DN] != null) {
        contents[_DN] = (0, smithy_client_1.expectString)(output[_DN]);
    }
    if (output[_ID_] != null) {
        contents[_ID_] = (0, smithy_client_1.expectString)(output[_ID_]);
    }
    return contents;
};
const de_OwnershipControls = (output, context) => {
    const contents = {};
    if (output.Rule === "") {
        contents[_Rul] = [];
    }
    else if (output[_Ru] != null) {
        contents[_Rul] = de_OwnershipControlsRules((0, smithy_client_1.getArrayIfSingleItem)(output[_Ru]), context);
    }
    return contents;
};
const de_OwnershipControlsRule = (output, context) => {
    const contents = {};
    if (output[_OO] != null) {
        contents[_OO] = (0, smithy_client_1.expectString)(output[_OO]);
    }
    return contents;
};
const de_OwnershipControlsRules = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OwnershipControlsRule(entry, context);
    });
};
const de_Part = (output, context) => {
    const contents = {};
    if (output[_PN] != null) {
        contents[_PN] = (0, smithy_client_1.strictParseInt32)(output[_PN]);
    }
    if (output[_LM] != null) {
        contents[_LM] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_LM]));
    }
    if (output[_ETa] != null) {
        contents[_ETa] = (0, smithy_client_1.expectString)(output[_ETa]);
    }
    if (output[_Si] != null) {
        contents[_Si] = (0, smithy_client_1.strictParseLong)(output[_Si]);
    }
    if (output[_CCRC] != null) {
        contents[_CCRC] = (0, smithy_client_1.expectString)(output[_CCRC]);
    }
    if (output[_CCRCC] != null) {
        contents[_CCRCC] = (0, smithy_client_1.expectString)(output[_CCRCC]);
    }
    if (output[_CSHA] != null) {
        contents[_CSHA] = (0, smithy_client_1.expectString)(output[_CSHA]);
    }
    if (output[_CSHAh] != null) {
        contents[_CSHAh] = (0, smithy_client_1.expectString)(output[_CSHAh]);
    }
    return contents;
};
const de_PartitionedPrefix = (output, context) => {
    const contents = {};
    if (output[_PDS] != null) {
        contents[_PDS] = (0, smithy_client_1.expectString)(output[_PDS]);
    }
    return contents;
};
const de_Parts = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Part(entry, context);
    });
};
const de_PartsList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ObjectPart(entry, context);
    });
};
const de_PolicyStatus = (output, context) => {
    const contents = {};
    if (output[_IP] != null) {
        contents[_IP] = (0, smithy_client_1.parseBoolean)(output[_IP]);
    }
    return contents;
};
const de_Progress = (output, context) => {
    const contents = {};
    if (output[_BS] != null) {
        contents[_BS] = (0, smithy_client_1.strictParseLong)(output[_BS]);
    }
    if (output[_BP] != null) {
        contents[_BP] = (0, smithy_client_1.strictParseLong)(output[_BP]);
    }
    if (output[_BRy] != null) {
        contents[_BRy] = (0, smithy_client_1.strictParseLong)(output[_BRy]);
    }
    return contents;
};
const de_PublicAccessBlockConfiguration = (output, context) => {
    const contents = {};
    if (output[_BPA] != null) {
        contents[_BPA] = (0, smithy_client_1.parseBoolean)(output[_BPA]);
    }
    if (output[_IPA] != null) {
        contents[_IPA] = (0, smithy_client_1.parseBoolean)(output[_IPA]);
    }
    if (output[_BPP] != null) {
        contents[_BPP] = (0, smithy_client_1.parseBoolean)(output[_BPP]);
    }
    if (output[_RPB] != null) {
        contents[_RPB] = (0, smithy_client_1.parseBoolean)(output[_RPB]);
    }
    return contents;
};
const de_QueueConfiguration = (output, context) => {
    const contents = {};
    if (output[_I] != null) {
        contents[_I] = (0, smithy_client_1.expectString)(output[_I]);
    }
    if (output[_Qu] != null) {
        contents[_QA] = (0, smithy_client_1.expectString)(output[_Qu]);
    }
    if (output.Event === "") {
        contents[_Eve] = [];
    }
    else if (output[_Ev] != null) {
        contents[_Eve] = de_EventList((0, smithy_client_1.getArrayIfSingleItem)(output[_Ev]), context);
    }
    if (output[_F] != null) {
        contents[_F] = de_NotificationConfigurationFilter(output[_F], context);
    }
    return contents;
};
const de_QueueConfigurationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_QueueConfiguration(entry, context);
    });
};
const de_Redirect = (output, context) => {
    const contents = {};
    if (output[_HN] != null) {
        contents[_HN] = (0, smithy_client_1.expectString)(output[_HN]);
    }
    if (output[_HRC] != null) {
        contents[_HRC] = (0, smithy_client_1.expectString)(output[_HRC]);
    }
    if (output[_Pr] != null) {
        contents[_Pr] = (0, smithy_client_1.expectString)(output[_Pr]);
    }
    if (output[_RKPW] != null) {
        contents[_RKPW] = (0, smithy_client_1.expectString)(output[_RKPW]);
    }
    if (output[_RKW] != null) {
        contents[_RKW] = (0, smithy_client_1.expectString)(output[_RKW]);
    }
    return contents;
};
const de_RedirectAllRequestsTo = (output, context) => {
    const contents = {};
    if (output[_HN] != null) {
        contents[_HN] = (0, smithy_client_1.expectString)(output[_HN]);
    }
    if (output[_Pr] != null) {
        contents[_Pr] = (0, smithy_client_1.expectString)(output[_Pr]);
    }
    return contents;
};
const de_ReplicaModifications = (output, context) => {
    const contents = {};
    if (output[_S] != null) {
        contents[_S] = (0, smithy_client_1.expectString)(output[_S]);
    }
    return contents;
};
const de_ReplicationConfiguration = (output, context) => {
    const contents = {};
    if (output[_Ro] != null) {
        contents[_Ro] = (0, smithy_client_1.expectString)(output[_Ro]);
    }
    if (output.Rule === "") {
        contents[_Rul] = [];
    }
    else if (output[_Ru] != null) {
        contents[_Rul] = de_ReplicationRules((0, smithy_client_1.getArrayIfSingleItem)(output[_Ru]), context);
    }
    return contents;
};
const de_ReplicationRule = (output, context) => {
    const contents = {};
    if (output[_ID_] != null) {
        contents[_ID_] = (0, smithy_client_1.expectString)(output[_ID_]);
    }
    if (output[_Pri] != null) {
        contents[_Pri] = (0, smithy_client_1.strictParseInt32)(output[_Pri]);
    }
    if (output[_P] != null) {
        contents[_P] = (0, smithy_client_1.expectString)(output[_P]);
    }
    if (output.Filter === "") {
    }
    else if (output[_F] != null) {
        contents[_F] = de_ReplicationRuleFilter((0, smithy_client_1.expectUnion)(output[_F]), context);
    }
    if (output[_S] != null) {
        contents[_S] = (0, smithy_client_1.expectString)(output[_S]);
    }
    if (output[_SSC] != null) {
        contents[_SSC] = de_SourceSelectionCriteria(output[_SSC], context);
    }
    if (output[_EOR] != null) {
        contents[_EOR] = de_ExistingObjectReplication(output[_EOR], context);
    }
    if (output[_Des] != null) {
        contents[_Des] = de_Destination(output[_Des], context);
    }
    if (output[_DMR] != null) {
        contents[_DMR] = de_DeleteMarkerReplication(output[_DMR], context);
    }
    return contents;
};
const de_ReplicationRuleAndOperator = (output, context) => {
    const contents = {};
    if (output[_P] != null) {
        contents[_P] = (0, smithy_client_1.expectString)(output[_P]);
    }
    if (output.Tag === "") {
        contents[_Tag] = [];
    }
    else if (output[_Ta] != null) {
        contents[_Tag] = de_TagSet((0, smithy_client_1.getArrayIfSingleItem)(output[_Ta]), context);
    }
    return contents;
};
const de_ReplicationRuleFilter = (output, context) => {
    if (output[_P] != null) {
        return {
            Prefix: (0, smithy_client_1.expectString)(output[_P]),
        };
    }
    if (output[_Ta] != null) {
        return {
            Tag: de_Tag(output[_Ta], context),
        };
    }
    if (output[_A] != null) {
        return {
            And: de_ReplicationRuleAndOperator(output[_A], context),
        };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_ReplicationRules = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReplicationRule(entry, context);
    });
};
const de_ReplicationTime = (output, context) => {
    const contents = {};
    if (output[_S] != null) {
        contents[_S] = (0, smithy_client_1.expectString)(output[_S]);
    }
    if (output[_Tim] != null) {
        contents[_Tim] = de_ReplicationTimeValue(output[_Tim], context);
    }
    return contents;
};
const de_ReplicationTimeValue = (output, context) => {
    const contents = {};
    if (output[_Mi] != null) {
        contents[_Mi] = (0, smithy_client_1.strictParseInt32)(output[_Mi]);
    }
    return contents;
};
const de_RestoreStatus = (output, context) => {
    const contents = {};
    if (output[_IRIP] != null) {
        contents[_IRIP] = (0, smithy_client_1.parseBoolean)(output[_IRIP]);
    }
    if (output[_RED] != null) {
        contents[_RED] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_RED]));
    }
    return contents;
};
const de_RoutingRule = (output, context) => {
    const contents = {};
    if (output[_Con] != null) {
        contents[_Con] = de_Condition(output[_Con], context);
    }
    if (output[_Red] != null) {
        contents[_Red] = de_Redirect(output[_Red], context);
    }
    return contents;
};
const de_RoutingRules = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RoutingRule(entry, context);
    });
};
const de_S3KeyFilter = (output, context) => {
    const contents = {};
    if (output.FilterRule === "") {
        contents[_FRi] = [];
    }
    else if (output[_FR] != null) {
        contents[_FRi] = de_FilterRuleList((0, smithy_client_1.getArrayIfSingleItem)(output[_FR]), context);
    }
    return contents;
};
const de_ServerSideEncryptionByDefault = (output, context) => {
    const contents = {};
    if (output[_SSEA] != null) {
        contents[_SSEA] = (0, smithy_client_1.expectString)(output[_SSEA]);
    }
    if (output[_KMSMKID] != null) {
        contents[_KMSMKID] = (0, smithy_client_1.expectString)(output[_KMSMKID]);
    }
    return contents;
};
const de_ServerSideEncryptionConfiguration = (output, context) => {
    const contents = {};
    if (output.Rule === "") {
        contents[_Rul] = [];
    }
    else if (output[_Ru] != null) {
        contents[_Rul] = de_ServerSideEncryptionRules((0, smithy_client_1.getArrayIfSingleItem)(output[_Ru]), context);
    }
    return contents;
};
const de_ServerSideEncryptionRule = (output, context) => {
    const contents = {};
    if (output[_ASSEBD] != null) {
        contents[_ASSEBD] = de_ServerSideEncryptionByDefault(output[_ASSEBD], context);
    }
    if (output[_BKE] != null) {
        contents[_BKE] = (0, smithy_client_1.parseBoolean)(output[_BKE]);
    }
    return contents;
};
const de_ServerSideEncryptionRules = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ServerSideEncryptionRule(entry, context);
    });
};
const de_SessionCredentials = (output, context) => {
    const contents = {};
    if (output[_AKI] != null) {
        contents[_AKI] = (0, smithy_client_1.expectString)(output[_AKI]);
    }
    if (output[_SAK] != null) {
        contents[_SAK] = (0, smithy_client_1.expectString)(output[_SAK]);
    }
    if (output[_ST] != null) {
        contents[_ST] = (0, smithy_client_1.expectString)(output[_ST]);
    }
    if (output[_Exp] != null) {
        contents[_Exp] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_Exp]));
    }
    return contents;
};
const de_SimplePrefix = (output, context) => {
    const contents = {};
    return contents;
};
const de_SourceSelectionCriteria = (output, context) => {
    const contents = {};
    if (output[_SKEO] != null) {
        contents[_SKEO] = de_SseKmsEncryptedObjects(output[_SKEO], context);
    }
    if (output[_RM] != null) {
        contents[_RM] = de_ReplicaModifications(output[_RM], context);
    }
    return contents;
};
const de_SSEKMS = (output, context) => {
    const contents = {};
    if (output[_KI] != null) {
        contents[_KI] = (0, smithy_client_1.expectString)(output[_KI]);
    }
    return contents;
};
const de_SseKmsEncryptedObjects = (output, context) => {
    const contents = {};
    if (output[_S] != null) {
        contents[_S] = (0, smithy_client_1.expectString)(output[_S]);
    }
    return contents;
};
const de_SSES3 = (output, context) => {
    const contents = {};
    return contents;
};
const de_Stats = (output, context) => {
    const contents = {};
    if (output[_BS] != null) {
        contents[_BS] = (0, smithy_client_1.strictParseLong)(output[_BS]);
    }
    if (output[_BP] != null) {
        contents[_BP] = (0, smithy_client_1.strictParseLong)(output[_BP]);
    }
    if (output[_BRy] != null) {
        contents[_BRy] = (0, smithy_client_1.strictParseLong)(output[_BRy]);
    }
    return contents;
};
const de_StorageClassAnalysis = (output, context) => {
    const contents = {};
    if (output[_DE] != null) {
        contents[_DE] = de_StorageClassAnalysisDataExport(output[_DE], context);
    }
    return contents;
};
const de_StorageClassAnalysisDataExport = (output, context) => {
    const contents = {};
    if (output[_OSV] != null) {
        contents[_OSV] = (0, smithy_client_1.expectString)(output[_OSV]);
    }
    if (output[_Des] != null) {
        contents[_Des] = de_AnalyticsExportDestination(output[_Des], context);
    }
    return contents;
};
const de_Tag = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = (0, smithy_client_1.expectString)(output[_K]);
    }
    if (output[_Va] != null) {
        contents[_Va] = (0, smithy_client_1.expectString)(output[_Va]);
    }
    return contents;
};
const de_TagSet = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Tag(entry, context);
    });
};
const de_TargetGrant = (output, context) => {
    const contents = {};
    if (output[_Gra] != null) {
        contents[_Gra] = de_Grantee(output[_Gra], context);
    }
    if (output[_Pe] != null) {
        contents[_Pe] = (0, smithy_client_1.expectString)(output[_Pe]);
    }
    return contents;
};
const de_TargetGrants = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TargetGrant(entry, context);
    });
};
const de_TargetObjectKeyFormat = (output, context) => {
    const contents = {};
    if (output[_SPi] != null) {
        contents[_SPi] = de_SimplePrefix(output[_SPi], context);
    }
    if (output[_PP] != null) {
        contents[_PP] = de_PartitionedPrefix(output[_PP], context);
    }
    return contents;
};
const de_Tiering = (output, context) => {
    const contents = {};
    if (output[_Da] != null) {
        contents[_Da] = (0, smithy_client_1.strictParseInt32)(output[_Da]);
    }
    if (output[_AT] != null) {
        contents[_AT] = (0, smithy_client_1.expectString)(output[_AT]);
    }
    return contents;
};
const de_TieringList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Tiering(entry, context);
    });
};
const de_TopicConfiguration = (output, context) => {
    const contents = {};
    if (output[_I] != null) {
        contents[_I] = (0, smithy_client_1.expectString)(output[_I]);
    }
    if (output[_Top] != null) {
        contents[_TA] = (0, smithy_client_1.expectString)(output[_Top]);
    }
    if (output.Event === "") {
        contents[_Eve] = [];
    }
    else if (output[_Ev] != null) {
        contents[_Eve] = de_EventList((0, smithy_client_1.getArrayIfSingleItem)(output[_Ev]), context);
    }
    if (output[_F] != null) {
        contents[_F] = de_NotificationConfigurationFilter(output[_F], context);
    }
    return contents;
};
const de_TopicConfigurationList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TopicConfiguration(entry, context);
    });
};
const de_Transition = (output, context) => {
    const contents = {};
    if (output[_Dat] != null) {
        contents[_Dat] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_Dat]));
    }
    if (output[_Da] != null) {
        contents[_Da] = (0, smithy_client_1.strictParseInt32)(output[_Da]);
    }
    if (output[_SC] != null) {
        contents[_SC] = (0, smithy_client_1.expectString)(output[_SC]);
    }
    return contents;
};
const de_TransitionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Transition(entry, context);
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _A = "And";
const _AAO = "AnalyticsAndOperator";
const _AC = "AnalyticsConfiguration";
const _ACL = "ACL";
const _ACLc = "AccessControlList";
const _ACLn = "AnalyticsConfigurationList";
const _ACP = "AccessControlPolicy";
const _ACT = "AccessControlTranslation";
const _ACc = "AccelerateConfiguration";
const _AD = "AbortDate";
const _AED = "AnalyticsExportDestination";
const _AF = "AnalyticsFilter";
const _AH = "AllowedHeader";
const _AHl = "AllowedHeaders";
const _AI = "AnalyticsId";
const _AIMU = "AbortIncompleteMultipartUpload";
const _AIc = "AccountId";
const _AKI = "AccessKeyId";
const _AM = "AllowedMethod";
const _AMl = "AllowedMethods";
const _AO = "AllowedOrigin";
const _AOl = "AllowedOrigins";
const _APA = "AccessPointAlias";
const _APAc = "AccessPointArn";
const _AQRD = "AllowQuotedRecordDelimiter";
const _AR = "AcceptRanges";
const _ARI = "AbortRuleId";
const _AS = "ArchiveStatus";
const _ASBD = "AnalyticsS3BucketDestination";
const _ASEFF = "AnalyticsS3ExportFileFormat";
const _ASSEBD = "ApplyServerSideEncryptionByDefault";
const _AT = "AccessTier";
const _Ac = "Account";
const _B = "Bucket";
const _BAI = "BucketAccountId";
const _BAS = "BucketAccelerateStatus";
const _BGR = "BypassGovernanceRetention";
const _BI = "BucketInfo";
const _BKE = "BucketKeyEnabled";
const _BLC = "BucketLifecycleConfiguration";
const _BLCu = "BucketLocationConstraint";
const _BLN = "BucketLocationName";
const _BLP = "BucketLogsPermission";
const _BLS = "BucketLoggingStatus";
const _BLT = "BucketLocationType";
const _BN = "BucketName";
const _BP = "BytesProcessed";
const _BPA = "BlockPublicAcls";
const _BPP = "BlockPublicPolicy";
const _BR = "BucketRegion";
const _BRy = "BytesReturned";
const _BS = "BytesScanned";
const _BT = "BucketType";
const _BVS = "BucketVersioningStatus";
const _Bu = "Buckets";
const _C = "Credentials";
const _CA = "ChecksumAlgorithm";
const _CACL = "CannedACL";
const _CBC = "CreateBucketConfiguration";
const _CC = "CacheControl";
const _CCRC = "ChecksumCRC32";
const _CCRCC = "ChecksumCRC32C";
const _CD = "ContentDisposition";
const _CDr = "CreationDate";
const _CE = "ContentEncoding";
const _CF = "CloudFunction";
const _CFC = "CloudFunctionConfiguration";
const _CL = "ContentLanguage";
const _CLo = "ContentLength";
const _CM = "ChecksumMode";
const _CMD = "ContentMD5";
const _CMU = "CompletedMultipartUpload";
const _CORSC = "CORSConfiguration";
const _CORSR = "CORSRule";
const _CORSRu = "CORSRules";
const _CP = "CommonPrefixes";
const _CPo = "CompletedPart";
const _CR = "ContentRange";
const _CRSBA = "ConfirmRemoveSelfBucketAccess";
const _CS = "CopySource";
const _CSHA = "ChecksumSHA1";
const _CSHAh = "ChecksumSHA256";
const _CSIM = "CopySourceIfMatch";
const _CSIMS = "CopySourceIfModifiedSince";
const _CSINM = "CopySourceIfNoneMatch";
const _CSIUS = "CopySourceIfUnmodifiedSince";
const _CSR = "CopySourceRange";
const _CSSSECA = "CopySourceSSECustomerAlgorithm";
const _CSSSECK = "CopySourceSSECustomerKey";
const _CSSSECKMD = "CopySourceSSECustomerKeyMD5";
const _CSV = "CSV";
const _CSVI = "CopySourceVersionId";
const _CSVIn = "CSVInput";
const _CSVO = "CSVOutput";
const _CT = "ContentType";
const _CTo = "ContinuationToken";
const _CTom = "CompressionType";
const _Ch = "Checksum";
const _Co = "Contents";
const _Cod = "Code";
const _Com = "Comments";
const _Con = "Condition";
const _D = "Delimiter";
const _DAI = "DaysAfterInitiation";
const _DE = "DataExport";
const _DM = "DeleteMarker";
const _DMR = "DeleteMarkerReplication";
const _DMRS = "DeleteMarkerReplicationStatus";
const _DMVI = "DeleteMarkerVersionId";
const _DMe = "DeleteMarkers";
const _DN = "DisplayName";
const _DR = "DataRedundancy";
const _DRe = "DefaultRetention";
const _Da = "Days";
const _Dat = "Date";
const _De = "Deleted";
const _Del = "Delete";
const _Des = "Destination";
const _Desc = "Description";
const _E = "Expires";
const _EA = "EmailAddress";
const _EBC = "EventBridgeConfiguration";
const _EBO = "ExpectedBucketOwner";
const _EC = "ErrorCode";
const _ECn = "EncryptionConfiguration";
const _ED = "ErrorDocument";
const _EH = "ExposeHeaders";
const _EHx = "ExposeHeader";
const _EM = "ErrorMessage";
const _EODM = "ExpiredObjectDeleteMarker";
const _EOR = "ExistingObjectReplication";
const _EORS = "ExistingObjectReplicationStatus";
const _ERP = "EnableRequestProgress";
const _ES = "ExpirationStatus";
const _ESBO = "ExpectedSourceBucketOwner";
const _ET = "EncodingType";
const _ETa = "ETag";
const _ETn = "EncryptionType";
const _ETv = "EventThreshold";
const _ETx = "ExpressionType";
const _En = "Encryption";
const _Ena = "Enabled";
const _End = "End";
const _Er = "Error";
const _Err = "Errors";
const _Ev = "Event";
const _Eve = "Events";
const _Ex = "Expression";
const _Exp = "Expiration";
const _F = "Filter";
const _FD = "FieldDelimiter";
const _FHI = "FileHeaderInfo";
const _FO = "FetchOwner";
const _FR = "FilterRule";
const _FRN = "FilterRuleName";
const _FRV = "FilterRuleValue";
const _FRi = "FilterRules";
const _Fi = "Field";
const _Fo = "Format";
const _Fr = "Frequency";
const _G = "Grant";
const _GFC = "GrantFullControl";
const _GJP = "GlacierJobParameters";
const _GR = "GrantRead";
const _GRACP = "GrantReadACP";
const _GW = "GrantWrite";
const _GWACP = "GrantWriteACP";
const _Gr = "Grants";
const _Gra = "Grantee";
const _HECRE = "HttpErrorCodeReturnedEquals";
const _HN = "HostName";
const _HRC = "HttpRedirectCode";
const _I = "Id";
const _IC = "InventoryConfiguration";
const _ICL = "InventoryConfigurationList";
const _ID = "IndexDocument";
const _ID_ = "ID";
const _IDn = "InventoryDestination";
const _IE = "IsEnabled";
const _IEn = "InventoryEncryption";
const _IF = "InventoryFilter";
const _IFn = "InventoryFormat";
const _IFnv = "InventoryFrequency";
const _II = "InventoryId";
const _IIOV = "InventoryIncludedObjectVersions";
const _IL = "IsLatest";
const _IM = "IfMatch";
const _IMS = "IfModifiedSince";
const _INM = "IfNoneMatch";
const _IOF = "InventoryOptionalField";
const _IOV = "IncludedObjectVersions";
const _IP = "IsPublic";
const _IPA = "IgnorePublicAcls";
const _IRIP = "IsRestoreInProgress";
const _IS = "InputSerialization";
const _ISBD = "InventoryS3BucketDestination";
const _ISn = "InventorySchedule";
const _IT = "IsTruncated";
const _ITAO = "IntelligentTieringAndOperator";
const _ITAT = "IntelligentTieringAccessTier";
const _ITC = "IntelligentTieringConfiguration";
const _ITCL = "IntelligentTieringConfigurationList";
const _ITD = "IntelligentTieringDays";
const _ITF = "IntelligentTieringFilter";
const _ITI = "IntelligentTieringId";
const _ITS = "IntelligentTieringStatus";
const _IUS = "IfUnmodifiedSince";
const _In = "Initiator";
const _Ini = "Initiated";
const _JSON = "JSON";
const _JSONI = "JSONInput";
const _JSONO = "JSONOutput";
const _JSONT = "JSONType";
const _K = "Key";
const _KC = "KeyCount";
const _KI = "KeyId";
const _KM = "KeyMarker";
const _KMSC = "KMSContext";
const _KMSKI = "KMSKeyId";
const _KMSMKID = "KMSMasterKeyID";
const _KPE = "KeyPrefixEquals";
const _L = "Location";
const _LC = "LocationConstraint";
const _LE = "LoggingEnabled";
const _LEi = "LifecycleExpiration";
const _LFA = "LambdaFunctionArn";
const _LFC = "LambdaFunctionConfigurations";
const _LFCa = "LambdaFunctionConfiguration";
const _LI = "LocationInfo";
const _LM = "LastModified";
const _LNAS = "LocationNameAsString";
const _LP = "LocationPrefix";
const _LR = "LifecycleRule";
const _LRAO = "LifecycleRuleAndOperator";
const _LRF = "LifecycleRuleFilter";
const _LT = "LocationType";
const _M = "Marker";
const _MAO = "MetricsAndOperator";
const _MAS = "MaxAgeSeconds";
const _MC = "MetricsConfiguration";
const _MCL = "MetricsConfigurationList";
const _MD = "MetadataDirective";
const _MDB = "MaxDirectoryBuckets";
const _MDf = "MfaDelete";
const _ME = "MetadataEntry";
const _MF = "MetricsFilter";
const _MFA = "MFA";
const _MFAD = "MFADelete";
const _MI = "MetricsId";
const _MK = "MaxKeys";
const _MKe = "MetadataKey";
const _MM = "MissingMeta";
const _MP = "MaxParts";
const _MS = "MetricsStatus";
const _MU = "MaxUploads";
const _MV = "MetadataValue";
const _Me = "Metrics";
const _Mes = "Message";
const _Mi = "Minutes";
const _Mo = "Mode";
const _N = "Name";
const _NC = "NotificationConfiguration";
const _NCF = "NotificationConfigurationFilter";
const _NCT = "NextContinuationToken";
const _ND = "NoncurrentDays";
const _NI = "NotificationId";
const _NKM = "NextKeyMarker";
const _NM = "NextMarker";
const _NNV = "NewerNoncurrentVersions";
const _NPNM = "NextPartNumberMarker";
const _NUIM = "NextUploadIdMarker";
const _NVE = "NoncurrentVersionExpiration";
const _NVIM = "NextVersionIdMarker";
const _NVT = "NoncurrentVersionTransitions";
const _NVTo = "NoncurrentVersionTransition";
const _O = "Owner";
const _OA = "ObjectAttributes";
const _OC = "OwnershipControls";
const _OCACL = "ObjectCannedACL";
const _OCR = "OwnershipControlsRule";
const _OF = "OptionalFields";
const _OI = "ObjectIdentifier";
const _OK = "ObjectKey";
const _OL = "OutputLocation";
const _OLC = "ObjectLockConfiguration";
const _OLE = "ObjectLockEnabled";
const _OLEFB = "ObjectLockEnabledForBucket";
const _OLLH = "ObjectLockLegalHold";
const _OLLHS = "ObjectLockLegalHoldStatus";
const _OLM = "ObjectLockMode";
const _OLR = "ObjectLockRetention";
const _OLRM = "ObjectLockRetentionMode";
const _OLRUD = "ObjectLockRetainUntilDate";
const _OLRb = "ObjectLockRule";
const _OO = "ObjectOwnership";
const _OOA = "OptionalObjectAttributes";
const _OOw = "OwnerOverride";
const _OP = "ObjectParts";
const _OS = "OutputSerialization";
const _OSGT = "ObjectSizeGreaterThan";
const _OSGTB = "ObjectSizeGreaterThanBytes";
const _OSLT = "ObjectSizeLessThan";
const _OSLTB = "ObjectSizeLessThanBytes";
const _OSV = "OutputSchemaVersion";
const _OSb = "ObjectSize";
const _OVI = "ObjectVersionId";
const _Ob = "Objects";
const _P = "Prefix";
const _PABC = "PublicAccessBlockConfiguration";
const _PC = "PartsCount";
const _PDS = "PartitionDateSource";
const _PI = "ParquetInput";
const _PN = "PartNumber";
const _PNM = "PartNumberMarker";
const _PP = "PartitionedPrefix";
const _Pa = "Payer";
const _Par = "Part";
const _Parq = "Parquet";
const _Part = "Parts";
const _Pe = "Permission";
const _Pr = "Protocol";
const _Pri = "Priority";
const _Q = "Quiet";
const _QA = "QueueArn";
const _QC = "QueueConfiguration";
const _QCu = "QueueConfigurations";
const _QCuo = "QuoteCharacter";
const _QEC = "QuoteEscapeCharacter";
const _QF = "QuoteFields";
const _Qu = "Queue";
const _R = "Range";
const _RART = "RedirectAllRequestsTo";
const _RC = "RequestCharged";
const _RCC = "ResponseCacheControl";
const _RCD = "ResponseContentDisposition";
const _RCE = "ResponseContentEncoding";
const _RCL = "ResponseContentLanguage";
const _RCT = "ResponseContentType";
const _RCe = "ReplicationConfiguration";
const _RD = "RecordDelimiter";
const _RE = "ResponseExpires";
const _RED = "RestoreExpiryDate";
const _RKKID = "ReplicaKmsKeyID";
const _RKPW = "ReplaceKeyPrefixWith";
const _RKW = "ReplaceKeyWith";
const _RM = "ReplicaModifications";
const _RMS = "ReplicaModificationsStatus";
const _ROP = "RestoreOutputPath";
const _RP = "RequestPayer";
const _RPB = "RestrictPublicBuckets";
const _RPC = "RequestPaymentConfiguration";
const _RPe = "RequestProgress";
const _RR = "RequestRoute";
const _RRAO = "ReplicationRuleAndOperator";
const _RRF = "ReplicationRuleFilter";
const _RRS = "ReplicationRuleStatus";
const _RRT = "RestoreRequestType";
const _RRe = "ReplicationRule";
const _RRes = "RestoreRequest";
const _RRo = "RoutingRules";
const _RRou = "RoutingRule";
const _RS = "ReplicationStatus";
const _RSe = "RestoreStatus";
const _RT = "RequestToken";
const _RTS = "ReplicationTimeStatus";
const _RTV = "ReplicationTimeValue";
const _RTe = "ReplicationTime";
const _RUD = "RetainUntilDate";
const _Re = "Restore";
const _Red = "Redirect";
const _Ro = "Role";
const _Ru = "Rule";
const _Rul = "Rules";
const _S = "Status";
const _SA = "StartAfter";
const _SAK = "SecretAccessKey";
const _SBD = "S3BucketDestination";
const _SC = "StorageClass";
const _SCA = "StorageClassAnalysis";
const _SCADE = "StorageClassAnalysisDataExport";
const _SCASV = "StorageClassAnalysisSchemaVersion";
const _SCt = "StatusCode";
const _SDV = "SkipDestinationValidation";
const _SK = "SSE-KMS";
const _SKEO = "SseKmsEncryptedObjects";
const _SKEOS = "SseKmsEncryptedObjectsStatus";
const _SKF = "S3KeyFilter";
const _SKe = "S3Key";
const _SL = "S3Location";
const _SM = "SessionMode";
const _SOCR = "SelectObjectContentRequest";
const _SP = "SelectParameters";
const _SPi = "SimplePrefix";
const _SR = "ScanRange";
const _SS = "SSE-S3";
const _SSC = "SourceSelectionCriteria";
const _SSE = "ServerSideEncryption";
const _SSEA = "SSEAlgorithm";
const _SSEBD = "ServerSideEncryptionByDefault";
const _SSEC = "ServerSideEncryptionConfiguration";
const _SSECA = "SSECustomerAlgorithm";
const _SSECK = "SSECustomerKey";
const _SSECKMD = "SSECustomerKeyMD5";
const _SSEKMS = "SSEKMS";
const _SSEKMSEC = "SSEKMSEncryptionContext";
const _SSEKMSKI = "SSEKMSKeyId";
const _SSER = "ServerSideEncryptionRule";
const _SSES = "SSES3";
const _ST = "SessionToken";
const _S_ = "S3";
const _Sc = "Schedule";
const _Se = "Setting";
const _Si = "Size";
const _St = "Start";
const _Su = "Suffix";
const _T = "Tagging";
const _TA = "TopicArn";
const _TB = "TargetBucket";
const _TC = "TagCount";
const _TCo = "TopicConfiguration";
const _TCop = "TopicConfigurations";
const _TD = "TaggingDirective";
const _TG = "TargetGrants";
const _TGa = "TargetGrant";
const _TOKF = "TargetObjectKeyFormat";
const _TP = "TargetPrefix";
const _TPC = "TotalPartsCount";
const _TS = "TagSet";
const _TSC = "TransitionStorageClass";
const _Ta = "Tag";
const _Tag = "Tags";
const _Ti = "Tier";
const _Tie = "Tierings";
const _Tier = "Tiering";
const _Tim = "Time";
const _To = "Token";
const _Top = "Topic";
const _Tr = "Transitions";
const _Tra = "Transition";
const _Ty = "Type";
const _U = "Upload";
const _UI = "UploadId";
const _UIM = "UploadIdMarker";
const _UM = "UserMetadata";
const _URI = "URI";
const _Up = "Uploads";
const _V = "Version";
const _VC = "VersionCount";
const _VCe = "VersioningConfiguration";
const _VI = "VersionId";
const _VIM = "VersionIdMarker";
const _Va = "Value";
const _Ve = "Versions";
const _WC = "WebsiteConfiguration";
const _WRL = "WebsiteRedirectLocation";
const _Y = "Years";
const _a = "analytics";
const _ac = "accelerate";
const _acl = "acl";
const _ar = "accept-ranges";
const _at = "attributes";
const _c = "cors";
const _cc = "cache-control";
const _cd = "content-disposition";
const _ce = "content-encoding";
const _cl = "content-language";
const _cl_ = "content-length";
const _cm = "content-md5";
const _cr = "content-range";
const _ct = "content-type";
const _ct_ = "continuation-token";
const _d = "delete";
const _de = "delimiter";
const _e = "expires";
const _en = "encryption";
const _et = "encoding-type";
const _eta = "etag";
const _fo = "fetch-owner";
const _i = "id";
const _im = "if-match";
const _ims = "if-modified-since";
const _in = "inventory";
const _inm = "if-none-match";
const _it = "intelligent-tiering";
const _ius = "if-unmodified-since";
const _km = "key-marker";
const _l = "lifecycle";
const _lh = "legal-hold";
const _lm = "last-modified";
const _lo = "location";
const _log = "logging";
const _lt = "list-type";
const _m = "metrics";
const _ma = "marker";
const _mdb = "max-directory-buckets";
const _me = "member";
const _mk = "max-keys";
const _mp = "max-parts";
const _mu = "max-uploads";
const _n = "notification";
const _oC = "ownershipControls";
const _ol = "object-lock";
const _p = "policy";
const _pAB = "publicAccessBlock";
const _pN = "partNumber";
const _pS = "policyStatus";
const _pnm = "part-number-marker";
const _pr = "prefix";
const _r = "replication";
const _rP = "requestPayment";
const _ra = "range";
const _rcc = "response-cache-control";
const _rcd = "response-content-disposition";
const _rce = "response-content-encoding";
const _rcl = "response-content-language";
const _rct = "response-content-type";
const _re = "response-expires";
const _res = "restore";
const _ret = "retention";
const _s = "session";
const _sa = "start-after";
const _se = "select";
const _st = "select-type";
const _t = "tagging";
const _to = "torrent";
const _u = "uploads";
const _uI = "uploadId";
const _uim = "upload-id-marker";
const _v = "versioning";
const _vI = "versionId";
const _ve = '<?xml version="1.0" encoding="UTF-8"?>';
const _ver = "versions";
const _vim = "version-id-marker";
const _w = "website";
const _x = "xsi:type";
const _xaa = "x-amz-acl";
const _xaad = "x-amz-abort-date";
const _xaapa = "x-amz-access-point-alias";
const _xaari = "x-amz-abort-rule-id";
const _xaas = "x-amz-archive-status";
const _xabgr = "x-amz-bypass-governance-retention";
const _xabln = "x-amz-bucket-location-name";
const _xablt = "x-amz-bucket-location-type";
const _xabole = "x-amz-bucket-object-lock-enabled";
const _xabolt = "x-amz-bucket-object-lock-token";
const _xabr = "x-amz-bucket-region";
const _xaca = "x-amz-checksum-algorithm";
const _xacc = "x-amz-checksum-crc32";
const _xacc_ = "x-amz-checksum-crc32c";
const _xacm = "x-amz-checksum-mode";
const _xacrsba = "x-amz-confirm-remove-self-bucket-access";
const _xacs = "x-amz-checksum-sha1";
const _xacs_ = "x-amz-checksum-sha256";
const _xacs__ = "x-amz-copy-source";
const _xacsim = "x-amz-copy-source-if-match";
const _xacsims = "x-amz-copy-source-if-modified-since";
const _xacsinm = "x-amz-copy-source-if-none-match";
const _xacsius = "x-amz-copy-source-if-unmodified-since";
const _xacsm = "x-amz-create-session-mode";
const _xacsr = "x-amz-copy-source-range";
const _xacssseca = "x-amz-copy-source-server-side-encryption-customer-algorithm";
const _xacssseck = "x-amz-copy-source-server-side-encryption-customer-key";
const _xacssseckm = "x-amz-copy-source-server-side-encryption-customer-key-md5";
const _xacsvi = "x-amz-copy-source-version-id";
const _xadm = "x-amz-delete-marker";
const _xae = "x-amz-expiration";
const _xaebo = "x-amz-expected-bucket-owner";
const _xafec = "x-amz-fwd-error-code";
const _xafem = "x-amz-fwd-error-message";
const _xafhar = "x-amz-fwd-header-accept-ranges";
const _xafhcc = "x-amz-fwd-header-cache-control";
const _xafhcd = "x-amz-fwd-header-content-disposition";
const _xafhce = "x-amz-fwd-header-content-encoding";
const _xafhcl = "x-amz-fwd-header-content-language";
const _xafhcr = "x-amz-fwd-header-content-range";
const _xafhct = "x-amz-fwd-header-content-type";
const _xafhe = "x-amz-fwd-header-etag";
const _xafhe_ = "x-amz-fwd-header-expires";
const _xafhlm = "x-amz-fwd-header-last-modified";
const _xafhxacc = "x-amz-fwd-header-x-amz-checksum-crc32";
const _xafhxacc_ = "x-amz-fwd-header-x-amz-checksum-crc32c";
const _xafhxacs = "x-amz-fwd-header-x-amz-checksum-sha1";
const _xafhxacs_ = "x-amz-fwd-header-x-amz-checksum-sha256";
const _xafhxadm = "x-amz-fwd-header-x-amz-delete-marker";
const _xafhxae = "x-amz-fwd-header-x-amz-expiration";
const _xafhxamm = "x-amz-fwd-header-x-amz-missing-meta";
const _xafhxampc = "x-amz-fwd-header-x-amz-mp-parts-count";
const _xafhxaollh = "x-amz-fwd-header-x-amz-object-lock-legal-hold";
const _xafhxaolm = "x-amz-fwd-header-x-amz-object-lock-mode";
const _xafhxaolrud = "x-amz-fwd-header-x-amz-object-lock-retain-until-date";
const _xafhxar = "x-amz-fwd-header-x-amz-restore";
const _xafhxarc = "x-amz-fwd-header-x-amz-request-charged";
const _xafhxars = "x-amz-fwd-header-x-amz-replication-status";
const _xafhxasc = "x-amz-fwd-header-x-amz-storage-class";
const _xafhxasse = "x-amz-fwd-header-x-amz-server-side-encryption";
const _xafhxasseakki = "x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id";
const _xafhxassebke = "x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled";
const _xafhxasseca = "x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm";
const _xafhxasseckm = "x-amz-fwd-header-x-amz-server-side-encryption-customer-key-md5";
const _xafhxatc = "x-amz-fwd-header-x-amz-tagging-count";
const _xafhxavi = "x-amz-fwd-header-x-amz-version-id";
const _xafs = "x-amz-fwd-status";
const _xagfc = "x-amz-grant-full-control";
const _xagr = "x-amz-grant-read";
const _xagra = "x-amz-grant-read-acp";
const _xagw = "x-amz-grant-write";
const _xagwa = "x-amz-grant-write-acp";
const _xam = "x-amz-mfa";
const _xamd = "x-amz-metadata-directive";
const _xamm = "x-amz-missing-meta";
const _xamp = "x-amz-max-parts";
const _xampc = "x-amz-mp-parts-count";
const _xaoa = "x-amz-object-attributes";
const _xaollh = "x-amz-object-lock-legal-hold";
const _xaolm = "x-amz-object-lock-mode";
const _xaolrud = "x-amz-object-lock-retain-until-date";
const _xaoo = "x-amz-object-ownership";
const _xaooa = "x-amz-optional-object-attributes";
const _xapnm = "x-amz-part-number-marker";
const _xar = "x-amz-restore";
const _xarc = "x-amz-request-charged";
const _xarop = "x-amz-restore-output-path";
const _xarp = "x-amz-request-payer";
const _xarr = "x-amz-request-route";
const _xars = "x-amz-replication-status";
const _xart = "x-amz-request-token";
const _xasc = "x-amz-storage-class";
const _xasca = "x-amz-sdk-checksum-algorithm";
const _xasdv = "x-amz-skip-destination-validation";
const _xasebo = "x-amz-source-expected-bucket-owner";
const _xasse = "x-amz-server-side-encryption";
const _xasseakki = "x-amz-server-side-encryption-aws-kms-key-id";
const _xassebke = "x-amz-server-side-encryption-bucket-key-enabled";
const _xassec = "x-amz-server-side-encryption-context";
const _xasseca = "x-amz-server-side-encryption-customer-algorithm";
const _xasseck = "x-amz-server-side-encryption-customer-key";
const _xasseckm = "x-amz-server-side-encryption-customer-key-md5";
const _xat = "x-amz-tagging";
const _xatc = "x-amz-tagging-count";
const _xatd = "x-amz-tagging-directive";
const _xavi = "x-amz-version-id";
const _xawrl = "x-amz-website-redirect-location";
const _xi = "x-id";
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new fast_xml_parser_1.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        const parsedObj = parser.parse(encoded);
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return (0, smithy_client_1.getValueFromTextNode)(parsedObjToReturn);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const loadRestXmlErrorCode = (output, data) => {
    if (data?.Code !== undefined) {
        return data.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};


/***/ }),

/***/ 12714:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const tslib_1 = __nccwpck_require__(4351);
const package_json_1 = tslib_1.__importDefault(__nccwpck_require__(50677));
const client_sts_1 = __nccwpck_require__(52209);
const core_1 = __nccwpck_require__(59963);
const credential_provider_node_1 = __nccwpck_require__(75531);
const middleware_bucket_endpoint_1 = __nccwpck_require__(96689);
const middleware_sdk_s3_1 = __nccwpck_require__(81139);
const util_user_agent_node_1 = __nccwpck_require__(98095);
const config_resolver_1 = __nccwpck_require__(53098);
const eventstream_serde_node_1 = __nccwpck_require__(77682);
const hash_node_1 = __nccwpck_require__(3081);
const hash_stream_node_1 = __nccwpck_require__(48866);
const middleware_retry_1 = __nccwpck_require__(96039);
const node_config_provider_1 = __nccwpck_require__(33461);
const node_http_handler_1 = __nccwpck_require__(20258);
const util_body_length_node_1 = __nccwpck_require__(68075);
const util_retry_1 = __nccwpck_require__(84902);
const runtimeConfig_shared_1 = __nccwpck_require__(5239);
const smithy_client_1 = __nccwpck_require__(63570);
const util_defaults_mode_node_1 = __nccwpck_require__(72429);
const smithy_client_2 = __nccwpck_require__(63570);
const getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? (0, client_sts_1.decorateDefaultCredentialProvider)(credential_provider_node_1.defaultProvider),
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        disableS3ExpressSessionAuth: config?.disableS3ExpressSessionAuth ?? (0, node_config_provider_1.loadConfig)(middleware_sdk_s3_1.NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS),
        eventStreamSerdeProvider: config?.eventStreamSerdeProvider ?? eventstream_serde_node_1.eventStreamSerdeProvider,
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        md5: config?.md5 ?? hash_node_1.Hash.bind(null, "md5"),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0, node_config_provider_1.loadConfig)({
                ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE,
            }),
        sha1: config?.sha1 ?? hash_node_1.Hash.bind(null, "sha1"),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        streamHasher: config?.streamHasher ?? hash_stream_node_1.readableStreamHasher,
        useArnRegion: config?.useArnRegion ?? (0, node_config_provider_1.loadConfig)(middleware_bucket_endpoint_1.NODE_USE_ARN_REGION_CONFIG_OPTIONS),
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 5239:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const signature_v4_multi_region_1 = __nccwpck_require__(51856);
const smithy_client_1 = __nccwpck_require__(63570);
const url_parser_1 = __nccwpck_require__(14681);
const util_base64_1 = __nccwpck_require__(75600);
const util_stream_1 = __nccwpck_require__(96607);
const util_utf8_1 = __nccwpck_require__(41895);
const endpointResolver_1 = __nccwpck_require__(3722);
const getRuntimeConfig = (config) => {
    return {
        apiVersion: "2006-03-01",
        base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
        base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        getAwsChunkedEncodingStream: config?.getAwsChunkedEncodingStream ?? util_stream_1.getAwsChunkedEncodingStream,
        logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
        sdkStreamMixin: config?.sdkStreamMixin ?? util_stream_1.sdkStreamMixin,
        serviceId: config?.serviceId ?? "S3",
        signerConstructor: config?.signerConstructor ?? signature_v4_multi_region_1.SignatureV4MultiRegion,
        signingEscapePath: config?.signingEscapePath ?? false,
        urlParser: config?.urlParser ?? url_parser_1.parseUrl,
        useArnRegion: config?.useArnRegion ?? false,
        utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8,
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 44875:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveRuntimeExtensions = void 0;
const region_config_resolver_1 = __nccwpck_require__(18156);
const protocol_http_1 = __nccwpck_require__(64418);
const smithy_client_1 = __nccwpck_require__(63570);
const asPartial = (t) => t;
const resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
        ...asPartial((0, region_config_resolver_1.getAwsRegionExtensionConfiguration)(runtimeConfig)),
        ...asPartial((0, smithy_client_1.getDefaultExtensionConfiguration)(runtimeConfig)),
        ...asPartial((0, protocol_http_1.getHttpHandlerExtensionConfiguration)(runtimeConfig)),
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...(0, region_config_resolver_1.resolveAwsRegionExtensionConfiguration)(extensionConfiguration),
        ...(0, smithy_client_1.resolveDefaultRuntimeConfig)(extensionConfiguration),
        ...(0, protocol_http_1.resolveHttpHandlerRuntimeConfig)(extensionConfiguration),
    };
};
exports.resolveRuntimeExtensions = resolveRuntimeExtensions;


/***/ }),

/***/ 6908:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(51334), exports);
tslib_1.__exportStar(__nccwpck_require__(42715), exports);
tslib_1.__exportStar(__nccwpck_require__(8303), exports);
tslib_1.__exportStar(__nccwpck_require__(40216), exports);


/***/ }),

/***/ 51334:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitUntilBucketExists = exports.waitForBucketExists = void 0;
const util_waiter_1 = __nccwpck_require__(78011);
const HeadBucketCommand_1 = __nccwpck_require__(62121);
const checkState = async (client, input) => {
    let reason;
    try {
        const result = await client.send(new HeadBucketCommand_1.HeadBucketCommand(input));
        reason = result;
        return { state: util_waiter_1.WaiterState.SUCCESS, reason };
    }
    catch (exception) {
        reason = exception;
        if (exception.name && exception.name == "NotFound") {
            return { state: util_waiter_1.WaiterState.RETRY, reason };
        }
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
};
const waitForBucketExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
};
exports.waitForBucketExists = waitForBucketExists;
const waitUntilBucketExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
};
exports.waitUntilBucketExists = waitUntilBucketExists;


/***/ }),

/***/ 42715:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitUntilBucketNotExists = exports.waitForBucketNotExists = void 0;
const util_waiter_1 = __nccwpck_require__(78011);
const HeadBucketCommand_1 = __nccwpck_require__(62121);
const checkState = async (client, input) => {
    let reason;
    try {
        const result = await client.send(new HeadBucketCommand_1.HeadBucketCommand(input));
        reason = result;
    }
    catch (exception) {
        reason = exception;
        if (exception.name && exception.name == "NotFound") {
            return { state: util_waiter_1.WaiterState.SUCCESS, reason };
        }
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
};
const waitForBucketNotExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
};
exports.waitForBucketNotExists = waitForBucketNotExists;
const waitUntilBucketNotExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
};
exports.waitUntilBucketNotExists = waitUntilBucketNotExists;


/***/ }),

/***/ 8303:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitUntilObjectExists = exports.waitForObjectExists = void 0;
const util_waiter_1 = __nccwpck_require__(78011);
const HeadObjectCommand_1 = __nccwpck_require__(82375);
const checkState = async (client, input) => {
    let reason;
    try {
        const result = await client.send(new HeadObjectCommand_1.HeadObjectCommand(input));
        reason = result;
        return { state: util_waiter_1.WaiterState.SUCCESS, reason };
    }
    catch (exception) {
        reason = exception;
        if (exception.name && exception.name == "NotFound") {
            return { state: util_waiter_1.WaiterState.RETRY, reason };
        }
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
};
const waitForObjectExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
};
exports.waitForObjectExists = waitForObjectExists;
const waitUntilObjectExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
};
exports.waitUntilObjectExists = waitUntilObjectExists;


/***/ }),

/***/ 40216:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitUntilObjectNotExists = exports.waitForObjectNotExists = void 0;
const util_waiter_1 = __nccwpck_require__(78011);
const HeadObjectCommand_1 = __nccwpck_require__(82375);
const checkState = async (client, input) => {
    let reason;
    try {
        const result = await client.send(new HeadObjectCommand_1.HeadObjectCommand(input));
        reason = result;
    }
    catch (exception) {
        reason = exception;
        if (exception.name && exception.name == "NotFound") {
            return { state: util_waiter_1.WaiterState.SUCCESS, reason };
        }
    }
    return { state: util_waiter_1.WaiterState.RETRY, reason };
};
const waitForObjectNotExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    return (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
};
exports.waitForObjectNotExists = waitForObjectNotExists;
const waitUntilObjectNotExists = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    const result = await (0, util_waiter_1.createWaiter)({ ...serviceDefaults, ...params }, input, checkState);
    return (0, util_waiter_1.checkExceptions)(result);
};
exports.waitUntilObjectNotExists = waitUntilObjectNotExists;


/***/ }),

/***/ 69838:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSO = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const GetRoleCredentialsCommand_1 = __nccwpck_require__(18972);
const ListAccountRolesCommand_1 = __nccwpck_require__(1513);
const ListAccountsCommand_1 = __nccwpck_require__(64296);
const LogoutCommand_1 = __nccwpck_require__(12586);
const SSOClient_1 = __nccwpck_require__(71057);
const commands = {
    GetRoleCredentialsCommand: GetRoleCredentialsCommand_1.GetRoleCredentialsCommand,
    ListAccountRolesCommand: ListAccountRolesCommand_1.ListAccountRolesCommand,
    ListAccountsCommand: ListAccountsCommand_1.ListAccountsCommand,
    LogoutCommand: LogoutCommand_1.LogoutCommand,
};
class SSO extends SSOClient_1.SSOClient {
}
exports.SSO = SSO;
(0, smithy_client_1.createAggregatedClient)(commands, SSO);


/***/ }),

/***/ 71057:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSOClient = exports.__Client = void 0;
const middleware_host_header_1 = __nccwpck_require__(22545);
const middleware_logger_1 = __nccwpck_require__(20014);
const middleware_recursion_detection_1 = __nccwpck_require__(85525);
const middleware_user_agent_1 = __nccwpck_require__(64688);
const config_resolver_1 = __nccwpck_require__(53098);
const middleware_content_length_1 = __nccwpck_require__(82800);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_retry_1 = __nccwpck_require__(96039);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "__Client", ({ enumerable: true, get: function () { return smithy_client_1.Client; } }));
const EndpointParameters_1 = __nccwpck_require__(34214);
const runtimeConfig_1 = __nccwpck_require__(19756);
const runtimeExtensions_1 = __nccwpck_require__(63398);
class SSOClient extends smithy_client_1.Client {
    constructor(...[configuration]) {
        const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration || {});
        const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_5);
        const _config_7 = (0, runtimeExtensions_1.resolveRuntimeExtensions)(_config_6, configuration?.extensions || []);
        super(_config_7);
        this.config = _config_7;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}
exports.SSOClient = SSOClient;


/***/ }),

/***/ 18972:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetRoleCredentialsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(34214);
const models_0_1 = __nccwpck_require__(66390);
const Aws_restJson1_1 = __nccwpck_require__(98507);
class GetRoleCredentialsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("SWBPortalService", "GetRoleCredentials", {})
    .n("SSOClient", "GetRoleCredentialsCommand")
    .f(models_0_1.GetRoleCredentialsRequestFilterSensitiveLog, models_0_1.GetRoleCredentialsResponseFilterSensitiveLog)
    .ser(Aws_restJson1_1.se_GetRoleCredentialsCommand)
    .de(Aws_restJson1_1.de_GetRoleCredentialsCommand)
    .build() {
}
exports.GetRoleCredentialsCommand = GetRoleCredentialsCommand;


/***/ }),

/***/ 1513:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListAccountRolesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(34214);
const models_0_1 = __nccwpck_require__(66390);
const Aws_restJson1_1 = __nccwpck_require__(98507);
class ListAccountRolesCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("SWBPortalService", "ListAccountRoles", {})
    .n("SSOClient", "ListAccountRolesCommand")
    .f(models_0_1.ListAccountRolesRequestFilterSensitiveLog, void 0)
    .ser(Aws_restJson1_1.se_ListAccountRolesCommand)
    .de(Aws_restJson1_1.de_ListAccountRolesCommand)
    .build() {
}
exports.ListAccountRolesCommand = ListAccountRolesCommand;


/***/ }),

/***/ 64296:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListAccountsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(34214);
const models_0_1 = __nccwpck_require__(66390);
const Aws_restJson1_1 = __nccwpck_require__(98507);
class ListAccountsCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("SWBPortalService", "ListAccounts", {})
    .n("SSOClient", "ListAccountsCommand")
    .f(models_0_1.ListAccountsRequestFilterSensitiveLog, void 0)
    .ser(Aws_restJson1_1.se_ListAccountsCommand)
    .de(Aws_restJson1_1.de_ListAccountsCommand)
    .build() {
}
exports.ListAccountsCommand = ListAccountsCommand;


/***/ }),

/***/ 12586:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogoutCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(34214);
const models_0_1 = __nccwpck_require__(66390);
const Aws_restJson1_1 = __nccwpck_require__(98507);
class LogoutCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("SWBPortalService", "Logout", {})
    .n("SSOClient", "LogoutCommand")
    .f(models_0_1.LogoutRequestFilterSensitiveLog, void 0)
    .ser(Aws_restJson1_1.se_LogoutCommand)
    .de(Aws_restJson1_1.de_LogoutCommand)
    .build() {
}
exports.LogoutCommand = LogoutCommand;


/***/ }),

/***/ 65706:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(18972), exports);
tslib_1.__exportStar(__nccwpck_require__(1513), exports);
tslib_1.__exportStar(__nccwpck_require__(64296), exports);
tslib_1.__exportStar(__nccwpck_require__(12586), exports);


/***/ }),

/***/ 34214:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.commonParams = exports.resolveClientEndpointParameters = void 0;
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "awsssoportal",
    };
};
exports.resolveClientEndpointParameters = resolveClientEndpointParameters;
exports.commonParams = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
};


/***/ }),

/***/ 30898:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __nccwpck_require__(45473);
const ruleset_1 = __nccwpck_require__(13341);
const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
exports.defaultEndpointResolver = defaultEndpointResolver;


/***/ }),

/***/ 13341:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ruleSet = void 0;
const u = "required", v = "fn", w = "argv", x = "ref";
const a = true, b = "isSet", c = "booleanEquals", d = "error", e = "endpoint", f = "tree", g = "PartitionResult", h = "getAttr", i = { [u]: false, "type": "String" }, j = { [u]: true, "default": false, "type": "Boolean" }, k = { [x]: "Endpoint" }, l = { [v]: c, [w]: [{ [x]: "UseFIPS" }, true] }, m = { [v]: c, [w]: [{ [x]: "UseDualStack" }, true] }, n = {}, o = { [v]: h, [w]: [{ [x]: g }, "supportsFIPS"] }, p = { [x]: g }, q = { [v]: c, [w]: [true, { [v]: h, [w]: [p, "supportsDualStack"] }] }, r = [l], s = [m], t = [{ [x]: "Region" }];
const _data = { version: "1.0", parameters: { Region: i, UseDualStack: j, UseFIPS: j, Endpoint: i }, rules: [{ conditions: [{ [v]: b, [w]: [k] }], rules: [{ conditions: r, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: s, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: k, properties: n, headers: n }, type: e }], type: f }, { conditions: [{ [v]: b, [w]: t }], rules: [{ conditions: [{ [v]: "aws.partition", [w]: t, assign: g }], rules: [{ conditions: [l, m], rules: [{ conditions: [{ [v]: c, [w]: [a, o] }, q], rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: r, rules: [{ conditions: [{ [v]: c, [w]: [o, a] }], rules: [{ conditions: [{ [v]: "stringEquals", [w]: [{ [v]: h, [w]: [p, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://portal.sso.{Region}.amazonaws.com", properties: n, headers: n }, type: e }, { endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: s, rules: [{ conditions: [q], rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
exports.ruleSet = _data;


/***/ }),

/***/ 82666:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSOServiceException = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(71057), exports);
tslib_1.__exportStar(__nccwpck_require__(69838), exports);
tslib_1.__exportStar(__nccwpck_require__(65706), exports);
tslib_1.__exportStar(__nccwpck_require__(36773), exports);
tslib_1.__exportStar(__nccwpck_require__(14952), exports);
__nccwpck_require__(13350);
var SSOServiceException_1 = __nccwpck_require__(81517);
Object.defineProperty(exports, "SSOServiceException", ({ enumerable: true, get: function () { return SSOServiceException_1.SSOServiceException; } }));


/***/ }),

/***/ 81517:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SSOServiceException = exports.__ServiceException = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "__ServiceException", ({ enumerable: true, get: function () { return smithy_client_1.ServiceException; } }));
class SSOServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, SSOServiceException.prototype);
    }
}
exports.SSOServiceException = SSOServiceException;


/***/ }),

/***/ 14952:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(66390), exports);


/***/ }),

/***/ 66390:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogoutRequestFilterSensitiveLog = exports.ListAccountsRequestFilterSensitiveLog = exports.ListAccountRolesRequestFilterSensitiveLog = exports.GetRoleCredentialsResponseFilterSensitiveLog = exports.RoleCredentialsFilterSensitiveLog = exports.GetRoleCredentialsRequestFilterSensitiveLog = exports.UnauthorizedException = exports.TooManyRequestsException = exports.ResourceNotFoundException = exports.InvalidRequestException = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const SSOServiceException_1 = __nccwpck_require__(81517);
class InvalidRequestException extends SSOServiceException_1.SSOServiceException {
    constructor(opts) {
        super({
            name: "InvalidRequestException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRequestException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRequestException.prototype);
    }
}
exports.InvalidRequestException = InvalidRequestException;
class ResourceNotFoundException extends SSOServiceException_1.SSOServiceException {
    constructor(opts) {
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    }
}
exports.ResourceNotFoundException = ResourceNotFoundException;
class TooManyRequestsException extends SSOServiceException_1.SSOServiceException {
    constructor(opts) {
        super({
            name: "TooManyRequestsException",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyRequestsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyRequestsException.prototype);
    }
}
exports.TooManyRequestsException = TooManyRequestsException;
class UnauthorizedException extends SSOServiceException_1.SSOServiceException {
    constructor(opts) {
        super({
            name: "UnauthorizedException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnauthorizedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnauthorizedException.prototype);
    }
}
exports.UnauthorizedException = UnauthorizedException;
const GetRoleCredentialsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: smithy_client_1.SENSITIVE_STRING }),
});
exports.GetRoleCredentialsRequestFilterSensitiveLog = GetRoleCredentialsRequestFilterSensitiveLog;
const RoleCredentialsFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.secretAccessKey && { secretAccessKey: smithy_client_1.SENSITIVE_STRING }),
    ...(obj.sessionToken && { sessionToken: smithy_client_1.SENSITIVE_STRING }),
});
exports.RoleCredentialsFilterSensitiveLog = RoleCredentialsFilterSensitiveLog;
const GetRoleCredentialsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.roleCredentials && { roleCredentials: (0, exports.RoleCredentialsFilterSensitiveLog)(obj.roleCredentials) }),
});
exports.GetRoleCredentialsResponseFilterSensitiveLog = GetRoleCredentialsResponseFilterSensitiveLog;
const ListAccountRolesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: smithy_client_1.SENSITIVE_STRING }),
});
exports.ListAccountRolesRequestFilterSensitiveLog = ListAccountRolesRequestFilterSensitiveLog;
const ListAccountsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: smithy_client_1.SENSITIVE_STRING }),
});
exports.ListAccountsRequestFilterSensitiveLog = ListAccountsRequestFilterSensitiveLog;
const LogoutRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: smithy_client_1.SENSITIVE_STRING }),
});
exports.LogoutRequestFilterSensitiveLog = LogoutRequestFilterSensitiveLog;


/***/ }),

/***/ 80849:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 88460:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListAccountRoles = void 0;
const core_1 = __nccwpck_require__(55829);
const ListAccountRolesCommand_1 = __nccwpck_require__(1513);
const SSOClient_1 = __nccwpck_require__(71057);
exports.paginateListAccountRoles = (0, core_1.createPaginator)(SSOClient_1.SSOClient, ListAccountRolesCommand_1.ListAccountRolesCommand, "nextToken", "nextToken", "maxResults");


/***/ }),

/***/ 50938:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paginateListAccounts = void 0;
const core_1 = __nccwpck_require__(55829);
const ListAccountsCommand_1 = __nccwpck_require__(64296);
const SSOClient_1 = __nccwpck_require__(71057);
exports.paginateListAccounts = (0, core_1.createPaginator)(SSOClient_1.SSOClient, ListAccountsCommand_1.ListAccountsCommand, "nextToken", "nextToken", "maxResults");


/***/ }),

/***/ 36773:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(80849), exports);
tslib_1.__exportStar(__nccwpck_require__(88460), exports);
tslib_1.__exportStar(__nccwpck_require__(50938), exports);


/***/ }),

/***/ 98507:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.de_LogoutCommand = exports.de_ListAccountsCommand = exports.de_ListAccountRolesCommand = exports.de_GetRoleCredentialsCommand = exports.se_LogoutCommand = exports.se_ListAccountsCommand = exports.se_ListAccountRolesCommand = exports.se_GetRoleCredentialsCommand = void 0;
const core_1 = __nccwpck_require__(55829);
const smithy_client_1 = __nccwpck_require__(63570);
const models_0_1 = __nccwpck_require__(66390);
const SSOServiceException_1 = __nccwpck_require__(81517);
const se_GetRoleCredentialsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xasbt]: input[_aT],
    });
    b.bp("/federation/credentials");
    const query = (0, smithy_client_1.map)({
        [_rn]: [, (0, smithy_client_1.expectNonNull)(input[_rN], `roleName`)],
        [_ai]: [, (0, smithy_client_1.expectNonNull)(input[_aI], `accountId`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_GetRoleCredentialsCommand = se_GetRoleCredentialsCommand;
const se_ListAccountRolesCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xasbt]: input[_aT],
    });
    b.bp("/assignment/roles");
    const query = (0, smithy_client_1.map)({
        [_nt]: [, input[_nT]],
        [_mr]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_ai]: [, (0, smithy_client_1.expectNonNull)(input[_aI], `accountId`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListAccountRolesCommand = se_ListAccountRolesCommand;
const se_ListAccountsCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xasbt]: input[_aT],
    });
    b.bp("/assignment/accounts");
    const query = (0, smithy_client_1.map)({
        [_nt]: [, input[_nT]],
        [_mr]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
exports.se_ListAccountsCommand = se_ListAccountsCommand;
const se_LogoutCommand = async (input, context) => {
    const b = (0, core_1.requestBuilder)(input, context);
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        [_xasbt]: input[_aT],
    });
    b.bp("/logout");
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
exports.se_LogoutCommand = se_LogoutCommand;
const de_GetRoleCredentialsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRoleCredentialsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        roleCredentials: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetRoleCredentialsCommand = de_GetRoleCredentialsCommand;
const de_GetRoleCredentialsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListAccountRolesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAccountRolesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        roleList: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListAccountRolesCommand = de_ListAccountRolesCommand;
const de_ListAccountRolesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListAccountsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAccountsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        accountList: smithy_client_1._json,
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListAccountsCommand = de_ListAccountsCommand;
const de_ListAccountsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_LogoutCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_LogoutCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_LogoutCommand = de_LogoutCommand;
const de_LogoutCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = (0, smithy_client_1.withBaseException)(SSOServiceException_1.SSOServiceException);
const de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.TooManyRequestsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_UnauthorizedExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.UnauthorizedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _aI = "accountId";
const _aT = "accessToken";
const _ai = "account_id";
const _mR = "maxResults";
const _mr = "max_result";
const _nT = "nextToken";
const _nt = "next_token";
const _rN = "roleName";
const _rn = "role_name";
const _xasbt = "x-amz-sso_bearer_token";
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};


/***/ }),

/***/ 19756:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const tslib_1 = __nccwpck_require__(4351);
const package_json_1 = tslib_1.__importDefault(__nccwpck_require__(91092));
const core_1 = __nccwpck_require__(59963);
const util_user_agent_node_1 = __nccwpck_require__(98095);
const config_resolver_1 = __nccwpck_require__(53098);
const hash_node_1 = __nccwpck_require__(3081);
const middleware_retry_1 = __nccwpck_require__(96039);
const node_config_provider_1 = __nccwpck_require__(33461);
const node_http_handler_1 = __nccwpck_require__(20258);
const util_body_length_node_1 = __nccwpck_require__(68075);
const util_retry_1 = __nccwpck_require__(84902);
const runtimeConfig_shared_1 = __nccwpck_require__(44809);
const smithy_client_1 = __nccwpck_require__(63570);
const util_defaults_mode_node_1 = __nccwpck_require__(72429);
const smithy_client_2 = __nccwpck_require__(63570);
const getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0, node_config_provider_1.loadConfig)({
                ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 44809:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const url_parser_1 = __nccwpck_require__(14681);
const util_base64_1 = __nccwpck_require__(75600);
const util_utf8_1 = __nccwpck_require__(41895);
const endpointResolver_1 = __nccwpck_require__(30898);
const getRuntimeConfig = (config) => {
    return {
        apiVersion: "2019-06-10",
        base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
        base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
        serviceId: config?.serviceId ?? "SSO",
        urlParser: config?.urlParser ?? url_parser_1.parseUrl,
        utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8,
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 63398:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveRuntimeExtensions = void 0;
const region_config_resolver_1 = __nccwpck_require__(18156);
const protocol_http_1 = __nccwpck_require__(64418);
const smithy_client_1 = __nccwpck_require__(63570);
const asPartial = (t) => t;
const resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
        ...asPartial((0, region_config_resolver_1.getAwsRegionExtensionConfiguration)(runtimeConfig)),
        ...asPartial((0, smithy_client_1.getDefaultExtensionConfiguration)(runtimeConfig)),
        ...asPartial((0, protocol_http_1.getHttpHandlerExtensionConfiguration)(runtimeConfig)),
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...(0, region_config_resolver_1.resolveAwsRegionExtensionConfiguration)(extensionConfiguration),
        ...(0, smithy_client_1.resolveDefaultRuntimeConfig)(extensionConfiguration),
        ...(0, protocol_http_1.resolveHttpHandlerRuntimeConfig)(extensionConfiguration),
    };
};
exports.resolveRuntimeExtensions = resolveRuntimeExtensions;


/***/ }),

/***/ 32605:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STS = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const AssumeRoleCommand_1 = __nccwpck_require__(59802);
const AssumeRoleWithSAMLCommand_1 = __nccwpck_require__(72865);
const AssumeRoleWithWebIdentityCommand_1 = __nccwpck_require__(37451);
const DecodeAuthorizationMessageCommand_1 = __nccwpck_require__(74150);
const GetAccessKeyInfoCommand_1 = __nccwpck_require__(49804);
const GetCallerIdentityCommand_1 = __nccwpck_require__(24278);
const GetFederationTokenCommand_1 = __nccwpck_require__(57552);
const GetSessionTokenCommand_1 = __nccwpck_require__(43285);
const STSClient_1 = __nccwpck_require__(64195);
const commands = {
    AssumeRoleCommand: AssumeRoleCommand_1.AssumeRoleCommand,
    AssumeRoleWithSAMLCommand: AssumeRoleWithSAMLCommand_1.AssumeRoleWithSAMLCommand,
    AssumeRoleWithWebIdentityCommand: AssumeRoleWithWebIdentityCommand_1.AssumeRoleWithWebIdentityCommand,
    DecodeAuthorizationMessageCommand: DecodeAuthorizationMessageCommand_1.DecodeAuthorizationMessageCommand,
    GetAccessKeyInfoCommand: GetAccessKeyInfoCommand_1.GetAccessKeyInfoCommand,
    GetCallerIdentityCommand: GetCallerIdentityCommand_1.GetCallerIdentityCommand,
    GetFederationTokenCommand: GetFederationTokenCommand_1.GetFederationTokenCommand,
    GetSessionTokenCommand: GetSessionTokenCommand_1.GetSessionTokenCommand,
};
class STS extends STSClient_1.STSClient {
}
exports.STS = STS;
(0, smithy_client_1.createAggregatedClient)(commands, STS);


/***/ }),

/***/ 64195:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STSClient = exports.__Client = void 0;
const middleware_host_header_1 = __nccwpck_require__(22545);
const middleware_logger_1 = __nccwpck_require__(20014);
const middleware_recursion_detection_1 = __nccwpck_require__(85525);
const middleware_user_agent_1 = __nccwpck_require__(64688);
const config_resolver_1 = __nccwpck_require__(53098);
const core_1 = __nccwpck_require__(55829);
const middleware_content_length_1 = __nccwpck_require__(82800);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_retry_1 = __nccwpck_require__(96039);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "__Client", ({ enumerable: true, get: function () { return smithy_client_1.Client; } }));
const httpAuthSchemeProvider_1 = __nccwpck_require__(17145);
const EndpointParameters_1 = __nccwpck_require__(20510);
const runtimeConfig_1 = __nccwpck_require__(83405);
const runtimeExtensions_1 = __nccwpck_require__(32053);
class STSClient extends smithy_client_1.Client {
    getDefaultHttpAuthSchemeParametersProvider() {
        return httpAuthSchemeProvider_1.defaultSTSHttpAuthSchemeParametersProvider;
    }
    getIdentityProviderConfigProvider() {
        return async (config) => new core_1.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": config.credentials,
        });
    }
    constructor(...[configuration]) {
        const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration || {});
        const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_5);
        const _config_7 = (0, httpAuthSchemeProvider_1.resolveHttpAuthSchemeConfig)(_config_6);
        const _config_8 = (0, runtimeExtensions_1.resolveRuntimeExtensions)(_config_7, configuration?.extensions || []);
        super(_config_8);
        this.config = _config_8;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
        this.middlewareStack.use((0, core_1.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
            httpAuthSchemeParametersProvider: this.getDefaultHttpAuthSchemeParametersProvider(),
            identityProviderConfigProvider: this.getIdentityProviderConfigProvider(),
        }));
        this.middlewareStack.use((0, core_1.getHttpSigningPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}
exports.STSClient = STSClient;


/***/ }),

/***/ 28527:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveHttpAuthRuntimeConfig = exports.getHttpAuthExtensionConfiguration = void 0;
const getHttpAuthExtensionConfiguration = (runtimeConfig) => {
    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
    let _credentials = runtimeConfig.credentials;
    return {
        setHttpAuthScheme(httpAuthScheme) {
            const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
            if (index === -1) {
                _httpAuthSchemes.push(httpAuthScheme);
            }
            else {
                _httpAuthSchemes.splice(index, 1, httpAuthScheme);
            }
        },
        httpAuthSchemes() {
            return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
            _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
            return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
            _credentials = credentials;
        },
        credentials() {
            return _credentials;
        },
    };
};
exports.getHttpAuthExtensionConfiguration = getHttpAuthExtensionConfiguration;
const resolveHttpAuthRuntimeConfig = (config) => {
    return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials(),
    };
};
exports.resolveHttpAuthRuntimeConfig = resolveHttpAuthRuntimeConfig;


/***/ }),

/***/ 17145:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveHttpAuthSchemeConfig = exports.resolveStsAuthConfig = exports.defaultSTSHttpAuthSchemeProvider = exports.defaultSTSHttpAuthSchemeParametersProvider = void 0;
const core_1 = __nccwpck_require__(59963);
const util_middleware_1 = __nccwpck_require__(2390);
const STSClient_1 = __nccwpck_require__(64195);
const defaultSTSHttpAuthSchemeParametersProvider = async (config, context, input) => {
    return {
        operation: (0, util_middleware_1.getSmithyContext)(context).operation,
        region: (await (0, util_middleware_1.normalizeProvider)(config.region)()) ||
            (() => {
                throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
            })(),
    };
};
exports.defaultSTSHttpAuthSchemeParametersProvider = defaultSTSHttpAuthSchemeParametersProvider;
function createAwsAuthSigv4HttpAuthOption(authParameters) {
    return {
        schemeId: "aws.auth#sigv4",
        signingProperties: {
            name: "sts",
            region: authParameters.region,
        },
        propertiesExtractor: (config, context) => ({
            signingProperties: {
                config,
                context,
            },
        }),
    };
}
function createSmithyApiNoAuthHttpAuthOption(authParameters) {
    return {
        schemeId: "smithy.api#noAuth",
    };
}
const defaultSTSHttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
        case "AssumeRoleWithSAML": {
            options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
            break;
        }
        case "AssumeRoleWithWebIdentity": {
            options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
            break;
        }
        default: {
            options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
        }
    }
    return options;
};
exports.defaultSTSHttpAuthSchemeProvider = defaultSTSHttpAuthSchemeProvider;
const resolveStsAuthConfig = (input) => ({
    ...input,
    stsClientCtor: STSClient_1.STSClient,
});
exports.resolveStsAuthConfig = resolveStsAuthConfig;
const resolveHttpAuthSchemeConfig = (config) => {
    const config_0 = (0, exports.resolveStsAuthConfig)(config);
    const config_1 = (0, core_1.resolveAWSSDKSigV4Config)(config_0);
    return {
        ...config_1,
    };
};
exports.resolveHttpAuthSchemeConfig = resolveHttpAuthSchemeConfig;


/***/ }),

/***/ 59802:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssumeRoleCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(20510);
const models_0_1 = __nccwpck_require__(21780);
const Aws_query_1 = __nccwpck_require__(10740);
class AssumeRoleCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AWSSecurityTokenServiceV20110615", "AssumeRole", {})
    .n("STSClient", "AssumeRoleCommand")
    .f(void 0, models_0_1.AssumeRoleResponseFilterSensitiveLog)
    .ser(Aws_query_1.se_AssumeRoleCommand)
    .de(Aws_query_1.de_AssumeRoleCommand)
    .build() {
}
exports.AssumeRoleCommand = AssumeRoleCommand;


/***/ }),

/***/ 72865:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssumeRoleWithSAMLCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(20510);
const models_0_1 = __nccwpck_require__(21780);
const Aws_query_1 = __nccwpck_require__(10740);
class AssumeRoleWithSAMLCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithSAML", {})
    .n("STSClient", "AssumeRoleWithSAMLCommand")
    .f(models_0_1.AssumeRoleWithSAMLRequestFilterSensitiveLog, models_0_1.AssumeRoleWithSAMLResponseFilterSensitiveLog)
    .ser(Aws_query_1.se_AssumeRoleWithSAMLCommand)
    .de(Aws_query_1.de_AssumeRoleWithSAMLCommand)
    .build() {
}
exports.AssumeRoleWithSAMLCommand = AssumeRoleWithSAMLCommand;


/***/ }),

/***/ 37451:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssumeRoleWithWebIdentityCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(20510);
const models_0_1 = __nccwpck_require__(21780);
const Aws_query_1 = __nccwpck_require__(10740);
class AssumeRoleWithWebIdentityCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {})
    .n("STSClient", "AssumeRoleWithWebIdentityCommand")
    .f(models_0_1.AssumeRoleWithWebIdentityRequestFilterSensitiveLog, models_0_1.AssumeRoleWithWebIdentityResponseFilterSensitiveLog)
    .ser(Aws_query_1.se_AssumeRoleWithWebIdentityCommand)
    .de(Aws_query_1.de_AssumeRoleWithWebIdentityCommand)
    .build() {
}
exports.AssumeRoleWithWebIdentityCommand = AssumeRoleWithWebIdentityCommand;


/***/ }),

/***/ 74150:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DecodeAuthorizationMessageCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(20510);
const Aws_query_1 = __nccwpck_require__(10740);
class DecodeAuthorizationMessageCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AWSSecurityTokenServiceV20110615", "DecodeAuthorizationMessage", {})
    .n("STSClient", "DecodeAuthorizationMessageCommand")
    .f(void 0, void 0)
    .ser(Aws_query_1.se_DecodeAuthorizationMessageCommand)
    .de(Aws_query_1.de_DecodeAuthorizationMessageCommand)
    .build() {
}
exports.DecodeAuthorizationMessageCommand = DecodeAuthorizationMessageCommand;


/***/ }),

/***/ 49804:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetAccessKeyInfoCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(20510);
const Aws_query_1 = __nccwpck_require__(10740);
class GetAccessKeyInfoCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AWSSecurityTokenServiceV20110615", "GetAccessKeyInfo", {})
    .n("STSClient", "GetAccessKeyInfoCommand")
    .f(void 0, void 0)
    .ser(Aws_query_1.se_GetAccessKeyInfoCommand)
    .de(Aws_query_1.de_GetAccessKeyInfoCommand)
    .build() {
}
exports.GetAccessKeyInfoCommand = GetAccessKeyInfoCommand;


/***/ }),

/***/ 24278:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetCallerIdentityCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(20510);
const Aws_query_1 = __nccwpck_require__(10740);
class GetCallerIdentityCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AWSSecurityTokenServiceV20110615", "GetCallerIdentity", {})
    .n("STSClient", "GetCallerIdentityCommand")
    .f(void 0, void 0)
    .ser(Aws_query_1.se_GetCallerIdentityCommand)
    .de(Aws_query_1.de_GetCallerIdentityCommand)
    .build() {
}
exports.GetCallerIdentityCommand = GetCallerIdentityCommand;


/***/ }),

/***/ 57552:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetFederationTokenCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(20510);
const models_0_1 = __nccwpck_require__(21780);
const Aws_query_1 = __nccwpck_require__(10740);
class GetFederationTokenCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AWSSecurityTokenServiceV20110615", "GetFederationToken", {})
    .n("STSClient", "GetFederationTokenCommand")
    .f(void 0, models_0_1.GetFederationTokenResponseFilterSensitiveLog)
    .ser(Aws_query_1.se_GetFederationTokenCommand)
    .de(Aws_query_1.de_GetFederationTokenCommand)
    .build() {
}
exports.GetFederationTokenCommand = GetFederationTokenCommand;


/***/ }),

/***/ 43285:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetSessionTokenCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "$Command", ({ enumerable: true, get: function () { return smithy_client_1.Command; } }));
const EndpointParameters_1 = __nccwpck_require__(20510);
const models_0_1 = __nccwpck_require__(21780);
const Aws_query_1 = __nccwpck_require__(10740);
class GetSessionTokenCommand extends smithy_client_1.Command
    .classBuilder()
    .ep({
    ...EndpointParameters_1.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0, middleware_serde_1.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0, middleware_endpoint_1.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("AWSSecurityTokenServiceV20110615", "GetSessionToken", {})
    .n("STSClient", "GetSessionTokenCommand")
    .f(void 0, models_0_1.GetSessionTokenResponseFilterSensitiveLog)
    .ser(Aws_query_1.se_GetSessionTokenCommand)
    .de(Aws_query_1.de_GetSessionTokenCommand)
    .build() {
}
exports.GetSessionTokenCommand = GetSessionTokenCommand;


/***/ }),

/***/ 55716:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(59802), exports);
tslib_1.__exportStar(__nccwpck_require__(72865), exports);
tslib_1.__exportStar(__nccwpck_require__(37451), exports);
tslib_1.__exportStar(__nccwpck_require__(74150), exports);
tslib_1.__exportStar(__nccwpck_require__(49804), exports);
tslib_1.__exportStar(__nccwpck_require__(24278), exports);
tslib_1.__exportStar(__nccwpck_require__(57552), exports);
tslib_1.__exportStar(__nccwpck_require__(43285), exports);


/***/ }),

/***/ 88028:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decorateDefaultCredentialProvider = exports.getDefaultRoleAssumerWithWebIdentity = exports.getDefaultRoleAssumer = void 0;
const defaultStsRoleAssumers_1 = __nccwpck_require__(90048);
const STSClient_1 = __nccwpck_require__(64195);
const getCustomizableStsClientCtor = (baseCtor, customizations) => {
    if (!customizations)
        return baseCtor;
    else
        return class CustomizableSTSClient extends baseCtor {
            constructor(config) {
                super(config);
                for (const customization of customizations) {
                    this.middlewareStack.use(customization);
                }
            }
        };
};
const getDefaultRoleAssumer = (stsOptions = {}, stsPlugins) => (0, defaultStsRoleAssumers_1.getDefaultRoleAssumer)(stsOptions, getCustomizableStsClientCtor(STSClient_1.STSClient, stsPlugins));
exports.getDefaultRoleAssumer = getDefaultRoleAssumer;
const getDefaultRoleAssumerWithWebIdentity = (stsOptions = {}, stsPlugins) => (0, defaultStsRoleAssumers_1.getDefaultRoleAssumerWithWebIdentity)(stsOptions, getCustomizableStsClientCtor(STSClient_1.STSClient, stsPlugins));
exports.getDefaultRoleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity;
const decorateDefaultCredentialProvider = (provider) => (input) => provider({
    roleAssumer: (0, exports.getDefaultRoleAssumer)(input),
    roleAssumerWithWebIdentity: (0, exports.getDefaultRoleAssumerWithWebIdentity)(input),
    ...input,
});
exports.decorateDefaultCredentialProvider = decorateDefaultCredentialProvider;


/***/ }),

/***/ 90048:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decorateDefaultCredentialProvider = exports.getDefaultRoleAssumerWithWebIdentity = exports.getDefaultRoleAssumer = void 0;
const AssumeRoleCommand_1 = __nccwpck_require__(59802);
const AssumeRoleWithWebIdentityCommand_1 = __nccwpck_require__(37451);
const ASSUME_ROLE_DEFAULT_REGION = "us-east-1";
const decorateDefaultRegion = (region) => {
    if (typeof region !== "function") {
        return region === undefined ? ASSUME_ROLE_DEFAULT_REGION : region;
    }
    return async () => {
        try {
            return await region();
        }
        catch (e) {
            return ASSUME_ROLE_DEFAULT_REGION;
        }
    };
};
const getDefaultRoleAssumer = (stsOptions, stsClientCtor) => {
    let stsClient;
    let closureSourceCreds;
    return async (sourceCreds, params) => {
        closureSourceCreds = sourceCreds;
        if (!stsClient) {
            const { logger, region, requestHandler } = stsOptions;
            stsClient = new stsClientCtor({
                logger,
                credentialDefaultProvider: () => async () => closureSourceCreds,
                region: decorateDefaultRegion(region || stsOptions.region),
                ...(requestHandler ? { requestHandler } : {}),
            });
        }
        const { Credentials } = await stsClient.send(new AssumeRoleCommand_1.AssumeRoleCommand(params));
        if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
            throw new Error(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
        }
        return {
            accessKeyId: Credentials.AccessKeyId,
            secretAccessKey: Credentials.SecretAccessKey,
            sessionToken: Credentials.SessionToken,
            expiration: Credentials.Expiration,
            credentialScope: Credentials.CredentialScope,
        };
    };
};
exports.getDefaultRoleAssumer = getDefaultRoleAssumer;
const getDefaultRoleAssumerWithWebIdentity = (stsOptions, stsClientCtor) => {
    let stsClient;
    return async (params) => {
        if (!stsClient) {
            const { logger, region, requestHandler } = stsOptions;
            stsClient = new stsClientCtor({
                logger,
                region: decorateDefaultRegion(region || stsOptions.region),
                ...(requestHandler ? { requestHandler } : {}),
            });
        }
        const { Credentials } = await stsClient.send(new AssumeRoleWithWebIdentityCommand_1.AssumeRoleWithWebIdentityCommand(params));
        if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
            throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
        }
        return {
            accessKeyId: Credentials.AccessKeyId,
            secretAccessKey: Credentials.SecretAccessKey,
            sessionToken: Credentials.SessionToken,
            expiration: Credentials.Expiration,
            credentialScope: Credentials.CredentialScope,
        };
    };
};
exports.getDefaultRoleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity;
const decorateDefaultCredentialProvider = (provider) => (input) => provider({
    roleAssumer: (0, exports.getDefaultRoleAssumer)(input, input.stsClientCtor),
    roleAssumerWithWebIdentity: (0, exports.getDefaultRoleAssumerWithWebIdentity)(input, input.stsClientCtor),
    ...input,
});
exports.decorateDefaultCredentialProvider = decorateDefaultCredentialProvider;


/***/ }),

/***/ 20510:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.commonParams = exports.resolveClientEndpointParameters = void 0;
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        useGlobalEndpoint: options.useGlobalEndpoint ?? false,
        defaultSigningName: "sts",
    };
};
exports.resolveClientEndpointParameters = resolveClientEndpointParameters;
exports.commonParams = {
    UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
};


/***/ }),

/***/ 41203:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __nccwpck_require__(45473);
const ruleset_1 = __nccwpck_require__(86882);
const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};
exports.defaultEndpointResolver = defaultEndpointResolver;


/***/ }),

/***/ 86882:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ruleSet = void 0;
const F = "required", G = "type", H = "fn", I = "argv", J = "ref";
const a = false, b = true, c = "booleanEquals", d = "stringEquals", e = "sigv4", f = "sts", g = "us-east-1", h = "endpoint", i = "https://sts.{Region}.{PartitionResult#dnsSuffix}", j = "tree", k = "error", l = "getAttr", m = { [F]: false, [G]: "String" }, n = { [F]: true, "default": false, [G]: "Boolean" }, o = { [J]: "Endpoint" }, p = { [H]: "isSet", [I]: [{ [J]: "Region" }] }, q = { [J]: "Region" }, r = { [H]: "aws.partition", [I]: [q], "assign": "PartitionResult" }, s = { [J]: "UseFIPS" }, t = { [J]: "UseDualStack" }, u = { "url": "https://sts.amazonaws.com", "properties": { "authSchemes": [{ "name": e, "signingName": f, "signingRegion": g }] }, "headers": {} }, v = {}, w = { "conditions": [{ [H]: d, [I]: [q, "aws-global"] }], [h]: u, [G]: h }, x = { [H]: c, [I]: [s, true] }, y = { [H]: c, [I]: [t, true] }, z = { [H]: l, [I]: [{ [J]: "PartitionResult" }, "supportsFIPS"] }, A = { [J]: "PartitionResult" }, B = { [H]: c, [I]: [true, { [H]: l, [I]: [A, "supportsDualStack"] }] }, C = [{ [H]: "isSet", [I]: [o] }], D = [x], E = [y];
const _data = { version: "1.0", parameters: { Region: m, UseDualStack: n, UseFIPS: n, Endpoint: m, UseGlobalEndpoint: n }, rules: [{ conditions: [{ [H]: c, [I]: [{ [J]: "UseGlobalEndpoint" }, b] }, { [H]: "not", [I]: C }, p, r, { [H]: c, [I]: [s, a] }, { [H]: c, [I]: [t, a] }], rules: [{ conditions: [{ [H]: d, [I]: [q, "ap-northeast-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "ap-south-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "ap-southeast-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "ap-southeast-2"] }], endpoint: u, [G]: h }, w, { conditions: [{ [H]: d, [I]: [q, "ca-central-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-central-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-north-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-west-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-west-2"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "eu-west-3"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "sa-east-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, g] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "us-east-2"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "us-west-1"] }], endpoint: u, [G]: h }, { conditions: [{ [H]: d, [I]: [q, "us-west-2"] }], endpoint: u, [G]: h }, { endpoint: { url: i, properties: { authSchemes: [{ name: e, signingName: f, signingRegion: "{Region}" }] }, headers: v }, [G]: h }], [G]: j }, { conditions: C, rules: [{ conditions: D, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [G]: k }, { conditions: E, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [G]: k }, { endpoint: { url: o, properties: v, headers: v }, [G]: h }], [G]: j }, { conditions: [p], rules: [{ conditions: [r], rules: [{ conditions: [x, y], rules: [{ conditions: [{ [H]: c, [I]: [b, z] }, B], rules: [{ endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v, headers: v }, [G]: h }], [G]: j }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [G]: k }], [G]: j }, { conditions: D, rules: [{ conditions: [{ [H]: c, [I]: [z, b] }], rules: [{ conditions: [{ [H]: d, [I]: [{ [H]: l, [I]: [A, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://sts.{Region}.amazonaws.com", properties: v, headers: v }, [G]: h }, { endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}", properties: v, headers: v }, [G]: h }], [G]: j }, { error: "FIPS is enabled but this partition does not support FIPS", [G]: k }], [G]: j }, { conditions: E, rules: [{ conditions: [B], rules: [{ endpoint: { url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v, headers: v }, [G]: h }], [G]: j }, { error: "DualStack is enabled but this partition does not support DualStack", [G]: k }], [G]: j }, w, { endpoint: { url: i, properties: v, headers: v }, [G]: h }], [G]: j }], [G]: j }, { error: "Invalid Configuration: Missing Region", [G]: k }] };
exports.ruleSet = _data;


/***/ }),

/***/ 52209:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STSServiceException = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(64195), exports);
tslib_1.__exportStar(__nccwpck_require__(32605), exports);
tslib_1.__exportStar(__nccwpck_require__(55716), exports);
tslib_1.__exportStar(__nccwpck_require__(20106), exports);
__nccwpck_require__(13350);
tslib_1.__exportStar(__nccwpck_require__(88028), exports);
var STSServiceException_1 = __nccwpck_require__(26450);
Object.defineProperty(exports, "STSServiceException", ({ enumerable: true, get: function () { return STSServiceException_1.STSServiceException; } }));


/***/ }),

/***/ 26450:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STSServiceException = exports.__ServiceException = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
Object.defineProperty(exports, "__ServiceException", ({ enumerable: true, get: function () { return smithy_client_1.ServiceException; } }));
class STSServiceException extends smithy_client_1.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, STSServiceException.prototype);
    }
}
exports.STSServiceException = STSServiceException;


/***/ }),

/***/ 20106:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(21780), exports);


/***/ }),

/***/ 21780:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetSessionTokenResponseFilterSensitiveLog = exports.GetFederationTokenResponseFilterSensitiveLog = exports.AssumeRoleWithWebIdentityResponseFilterSensitiveLog = exports.AssumeRoleWithWebIdentityRequestFilterSensitiveLog = exports.AssumeRoleWithSAMLResponseFilterSensitiveLog = exports.AssumeRoleWithSAMLRequestFilterSensitiveLog = exports.AssumeRoleResponseFilterSensitiveLog = exports.CredentialsFilterSensitiveLog = exports.InvalidAuthorizationMessageException = exports.IDPCommunicationErrorException = exports.InvalidIdentityTokenException = exports.IDPRejectedClaimException = exports.RegionDisabledException = exports.PackedPolicyTooLargeException = exports.MalformedPolicyDocumentException = exports.ExpiredTokenException = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const STSServiceException_1 = __nccwpck_require__(26450);
class ExpiredTokenException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "ExpiredTokenException",
            $fault: "client",
            ...opts,
        });
        this.name = "ExpiredTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ExpiredTokenException.prototype);
    }
}
exports.ExpiredTokenException = ExpiredTokenException;
class MalformedPolicyDocumentException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "MalformedPolicyDocumentException",
            $fault: "client",
            ...opts,
        });
        this.name = "MalformedPolicyDocumentException";
        this.$fault = "client";
        Object.setPrototypeOf(this, MalformedPolicyDocumentException.prototype);
    }
}
exports.MalformedPolicyDocumentException = MalformedPolicyDocumentException;
class PackedPolicyTooLargeException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "PackedPolicyTooLargeException",
            $fault: "client",
            ...opts,
        });
        this.name = "PackedPolicyTooLargeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, PackedPolicyTooLargeException.prototype);
    }
}
exports.PackedPolicyTooLargeException = PackedPolicyTooLargeException;
class RegionDisabledException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "RegionDisabledException",
            $fault: "client",
            ...opts,
        });
        this.name = "RegionDisabledException";
        this.$fault = "client";
        Object.setPrototypeOf(this, RegionDisabledException.prototype);
    }
}
exports.RegionDisabledException = RegionDisabledException;
class IDPRejectedClaimException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "IDPRejectedClaimException",
            $fault: "client",
            ...opts,
        });
        this.name = "IDPRejectedClaimException";
        this.$fault = "client";
        Object.setPrototypeOf(this, IDPRejectedClaimException.prototype);
    }
}
exports.IDPRejectedClaimException = IDPRejectedClaimException;
class InvalidIdentityTokenException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "InvalidIdentityTokenException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidIdentityTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidIdentityTokenException.prototype);
    }
}
exports.InvalidIdentityTokenException = InvalidIdentityTokenException;
class IDPCommunicationErrorException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "IDPCommunicationErrorException",
            $fault: "client",
            ...opts,
        });
        this.name = "IDPCommunicationErrorException";
        this.$fault = "client";
        Object.setPrototypeOf(this, IDPCommunicationErrorException.prototype);
    }
}
exports.IDPCommunicationErrorException = IDPCommunicationErrorException;
class InvalidAuthorizationMessageException extends STSServiceException_1.STSServiceException {
    constructor(opts) {
        super({
            name: "InvalidAuthorizationMessageException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidAuthorizationMessageException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidAuthorizationMessageException.prototype);
    }
}
exports.InvalidAuthorizationMessageException = InvalidAuthorizationMessageException;
const CredentialsFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SecretAccessKey && { SecretAccessKey: smithy_client_1.SENSITIVE_STRING }),
});
exports.CredentialsFilterSensitiveLog = CredentialsFilterSensitiveLog;
const AssumeRoleResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Credentials && { Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials) }),
});
exports.AssumeRoleResponseFilterSensitiveLog = AssumeRoleResponseFilterSensitiveLog;
const AssumeRoleWithSAMLRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.SAMLAssertion && { SAMLAssertion: smithy_client_1.SENSITIVE_STRING }),
});
exports.AssumeRoleWithSAMLRequestFilterSensitiveLog = AssumeRoleWithSAMLRequestFilterSensitiveLog;
const AssumeRoleWithSAMLResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Credentials && { Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials) }),
});
exports.AssumeRoleWithSAMLResponseFilterSensitiveLog = AssumeRoleWithSAMLResponseFilterSensitiveLog;
const AssumeRoleWithWebIdentityRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.WebIdentityToken && { WebIdentityToken: smithy_client_1.SENSITIVE_STRING }),
});
exports.AssumeRoleWithWebIdentityRequestFilterSensitiveLog = AssumeRoleWithWebIdentityRequestFilterSensitiveLog;
const AssumeRoleWithWebIdentityResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Credentials && { Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials) }),
});
exports.AssumeRoleWithWebIdentityResponseFilterSensitiveLog = AssumeRoleWithWebIdentityResponseFilterSensitiveLog;
const GetFederationTokenResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Credentials && { Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials) }),
});
exports.GetFederationTokenResponseFilterSensitiveLog = GetFederationTokenResponseFilterSensitiveLog;
const GetSessionTokenResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Credentials && { Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials) }),
});
exports.GetSessionTokenResponseFilterSensitiveLog = GetSessionTokenResponseFilterSensitiveLog;


/***/ }),

/***/ 10740:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.de_GetSessionTokenCommand = exports.de_GetFederationTokenCommand = exports.de_GetCallerIdentityCommand = exports.de_GetAccessKeyInfoCommand = exports.de_DecodeAuthorizationMessageCommand = exports.de_AssumeRoleWithWebIdentityCommand = exports.de_AssumeRoleWithSAMLCommand = exports.de_AssumeRoleCommand = exports.se_GetSessionTokenCommand = exports.se_GetFederationTokenCommand = exports.se_GetCallerIdentityCommand = exports.se_GetAccessKeyInfoCommand = exports.se_DecodeAuthorizationMessageCommand = exports.se_AssumeRoleWithWebIdentityCommand = exports.se_AssumeRoleWithSAMLCommand = exports.se_AssumeRoleCommand = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const smithy_client_1 = __nccwpck_require__(63570);
const fast_xml_parser_1 = __nccwpck_require__(12603);
const models_0_1 = __nccwpck_require__(21780);
const STSServiceException_1 = __nccwpck_require__(26450);
const se_AssumeRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssumeRoleRequest(input, context),
        [_A]: _AR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AssumeRoleCommand = se_AssumeRoleCommand;
const se_AssumeRoleWithSAMLCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssumeRoleWithSAMLRequest(input, context),
        [_A]: _ARWSAML,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AssumeRoleWithSAMLCommand = se_AssumeRoleWithSAMLCommand;
const se_AssumeRoleWithWebIdentityCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssumeRoleWithWebIdentityRequest(input, context),
        [_A]: _ARWWI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AssumeRoleWithWebIdentityCommand = se_AssumeRoleWithWebIdentityCommand;
const se_DecodeAuthorizationMessageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DecodeAuthorizationMessageRequest(input, context),
        [_A]: _DAM,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DecodeAuthorizationMessageCommand = se_DecodeAuthorizationMessageCommand;
const se_GetAccessKeyInfoCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetAccessKeyInfoRequest(input, context),
        [_A]: _GAKI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetAccessKeyInfoCommand = se_GetAccessKeyInfoCommand;
const se_GetCallerIdentityCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetCallerIdentityRequest(input, context),
        [_A]: _GCI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetCallerIdentityCommand = se_GetCallerIdentityCommand;
const se_GetFederationTokenCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetFederationTokenRequest(input, context),
        [_A]: _GFT,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetFederationTokenCommand = se_GetFederationTokenCommand;
const se_GetSessionTokenCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetSessionTokenRequest(input, context),
        [_A]: _GST,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetSessionTokenCommand = se_GetSessionTokenCommand;
const de_AssumeRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AssumeRoleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssumeRoleResponse(data.AssumeRoleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_AssumeRoleCommand = de_AssumeRoleCommand;
const de_AssumeRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
            throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await de_RegionDisabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_AssumeRoleWithSAMLCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AssumeRoleWithSAMLCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssumeRoleWithSAMLResponse(data.AssumeRoleWithSAMLResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_AssumeRoleWithSAMLCommand = de_AssumeRoleWithSAMLCommand;
const de_AssumeRoleWithSAMLCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
            throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
        case "IDPRejectedClaim":
        case "com.amazonaws.sts#IDPRejectedClaimException":
            throw await de_IDPRejectedClaimExceptionRes(parsedOutput, context);
        case "InvalidIdentityToken":
        case "com.amazonaws.sts#InvalidIdentityTokenException":
            throw await de_InvalidIdentityTokenExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await de_RegionDisabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_AssumeRoleWithWebIdentityCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AssumeRoleWithWebIdentityCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssumeRoleWithWebIdentityResponse(data.AssumeRoleWithWebIdentityResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_AssumeRoleWithWebIdentityCommand = de_AssumeRoleWithWebIdentityCommand;
const de_AssumeRoleWithWebIdentityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
            throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
        case "IDPCommunicationError":
        case "com.amazonaws.sts#IDPCommunicationErrorException":
            throw await de_IDPCommunicationErrorExceptionRes(parsedOutput, context);
        case "IDPRejectedClaim":
        case "com.amazonaws.sts#IDPRejectedClaimException":
            throw await de_IDPRejectedClaimExceptionRes(parsedOutput, context);
        case "InvalidIdentityToken":
        case "com.amazonaws.sts#InvalidIdentityTokenException":
            throw await de_InvalidIdentityTokenExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await de_RegionDisabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DecodeAuthorizationMessageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DecodeAuthorizationMessageCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DecodeAuthorizationMessageResponse(data.DecodeAuthorizationMessageResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DecodeAuthorizationMessageCommand = de_DecodeAuthorizationMessageCommand;
const de_DecodeAuthorizationMessageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidAuthorizationMessageException":
        case "com.amazonaws.sts#InvalidAuthorizationMessageException":
            throw await de_InvalidAuthorizationMessageExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetAccessKeyInfoCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetAccessKeyInfoCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAccessKeyInfoResponse(data.GetAccessKeyInfoResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetAccessKeyInfoCommand = de_GetAccessKeyInfoCommand;
const de_GetAccessKeyInfoCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
const de_GetCallerIdentityCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetCallerIdentityCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetCallerIdentityResponse(data.GetCallerIdentityResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetCallerIdentityCommand = de_GetCallerIdentityCommand;
const de_GetCallerIdentityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
const de_GetFederationTokenCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetFederationTokenCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetFederationTokenResponse(data.GetFederationTokenResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetFederationTokenCommand = de_GetFederationTokenCommand;
const de_GetFederationTokenCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await de_RegionDisabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetSessionTokenCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetSessionTokenCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetSessionTokenResponse(data.GetSessionTokenResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_GetSessionTokenCommand = de_GetSessionTokenCommand;
const de_GetSessionTokenCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await de_RegionDisabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ExpiredTokenExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ExpiredTokenException(body.Error, context);
    const exception = new models_0_1.ExpiredTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_IDPCommunicationErrorExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IDPCommunicationErrorException(body.Error, context);
    const exception = new models_0_1.IDPCommunicationErrorException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_IDPRejectedClaimExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IDPRejectedClaimException(body.Error, context);
    const exception = new models_0_1.IDPRejectedClaimException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidAuthorizationMessageExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidAuthorizationMessageException(body.Error, context);
    const exception = new models_0_1.InvalidAuthorizationMessageException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidIdentityTokenExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidIdentityTokenException(body.Error, context);
    const exception = new models_0_1.InvalidIdentityTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MalformedPolicyDocumentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_MalformedPolicyDocumentException(body.Error, context);
    const exception = new models_0_1.MalformedPolicyDocumentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PackedPolicyTooLargeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PackedPolicyTooLargeException(body.Error, context);
    const exception = new models_0_1.PackedPolicyTooLargeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RegionDisabledExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_RegionDisabledException(body.Error, context);
    const exception = new models_0_1.RegionDisabledException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const se_AssumeRoleRequest = (input, context) => {
    const entries = {};
    if (input[_RA] != null) {
        entries[_RA] = input[_RA];
    }
    if (input[_RSN] != null) {
        entries[_RSN] = input[_RSN];
    }
    if (input[_PA] != null) {
        const memberEntries = se_policyDescriptorListType(input[_PA], context);
        if (input[_PA]?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_DS] != null) {
        entries[_DS] = input[_DS];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TTK] != null) {
        const memberEntries = se_tagKeyListType(input[_TTK], context);
        if (input[_TTK]?.length === 0) {
            entries.TransitiveTagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TransitiveTagKeys.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_EI] != null) {
        entries[_EI] = input[_EI];
    }
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_TC] != null) {
        entries[_TC] = input[_TC];
    }
    if (input[_SI] != null) {
        entries[_SI] = input[_SI];
    }
    if (input[_PC] != null) {
        const memberEntries = se_ProvidedContextsListType(input[_PC], context);
        if (input[_PC]?.length === 0) {
            entries.ProvidedContexts = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ProvidedContexts.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AssumeRoleWithSAMLRequest = (input, context) => {
    const entries = {};
    if (input[_RA] != null) {
        entries[_RA] = input[_RA];
    }
    if (input[_PAr] != null) {
        entries[_PAr] = input[_PAr];
    }
    if (input[_SAMLA] != null) {
        entries[_SAMLA] = input[_SAMLA];
    }
    if (input[_PA] != null) {
        const memberEntries = se_policyDescriptorListType(input[_PA], context);
        if (input[_PA]?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_DS] != null) {
        entries[_DS] = input[_DS];
    }
    return entries;
};
const se_AssumeRoleWithWebIdentityRequest = (input, context) => {
    const entries = {};
    if (input[_RA] != null) {
        entries[_RA] = input[_RA];
    }
    if (input[_RSN] != null) {
        entries[_RSN] = input[_RSN];
    }
    if (input[_WIT] != null) {
        entries[_WIT] = input[_WIT];
    }
    if (input[_PI] != null) {
        entries[_PI] = input[_PI];
    }
    if (input[_PA] != null) {
        const memberEntries = se_policyDescriptorListType(input[_PA], context);
        if (input[_PA]?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_DS] != null) {
        entries[_DS] = input[_DS];
    }
    return entries;
};
const se_DecodeAuthorizationMessageRequest = (input, context) => {
    const entries = {};
    if (input[_EM] != null) {
        entries[_EM] = input[_EM];
    }
    return entries;
};
const se_GetAccessKeyInfoRequest = (input, context) => {
    const entries = {};
    if (input[_AKI] != null) {
        entries[_AKI] = input[_AKI];
    }
    return entries;
};
const se_GetCallerIdentityRequest = (input, context) => {
    const entries = {};
    return entries;
};
const se_GetFederationTokenRequest = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_PA] != null) {
        const memberEntries = se_policyDescriptorListType(input[_PA], context);
        if (input[_PA]?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DS] != null) {
        entries[_DS] = input[_DS];
    }
    if (input[_T] != null) {
        const memberEntries = se_tagListType(input[_T], context);
        if (input[_T]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_GetSessionTokenRequest = (input, context) => {
    const entries = {};
    if (input[_DS] != null) {
        entries[_DS] = input[_DS];
    }
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_TC] != null) {
        entries[_TC] = input[_TC];
    }
    return entries;
};
const se_policyDescriptorListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_PolicyDescriptorType(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_PolicyDescriptorType = (input, context) => {
    const entries = {};
    if (input[_a] != null) {
        entries[_a] = input[_a];
    }
    return entries;
};
const se_ProvidedContext = (input, context) => {
    const entries = {};
    if (input[_PAro] != null) {
        entries[_PAro] = input[_PAro];
    }
    if (input[_CA] != null) {
        entries[_CA] = input[_CA];
    }
    return entries;
};
const se_ProvidedContextsListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ProvidedContext(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Tag = (input, context) => {
    const entries = {};
    if (input[_K] != null) {
        entries[_K] = input[_K];
    }
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_tagKeyListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_tagListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const de_AssumedRoleUser = (output, context) => {
    const contents = {};
    if (output[_ARI] != null) {
        contents[_ARI] = (0, smithy_client_1.expectString)(output[_ARI]);
    }
    if (output[_Ar] != null) {
        contents[_Ar] = (0, smithy_client_1.expectString)(output[_Ar]);
    }
    return contents;
};
const de_AssumeRoleResponse = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = de_Credentials(output[_C], context);
    }
    if (output[_ARU] != null) {
        contents[_ARU] = de_AssumedRoleUser(output[_ARU], context);
    }
    if (output[_PPS] != null) {
        contents[_PPS] = (0, smithy_client_1.strictParseInt32)(output[_PPS]);
    }
    if (output[_SI] != null) {
        contents[_SI] = (0, smithy_client_1.expectString)(output[_SI]);
    }
    return contents;
};
const de_AssumeRoleWithSAMLResponse = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = de_Credentials(output[_C], context);
    }
    if (output[_ARU] != null) {
        contents[_ARU] = de_AssumedRoleUser(output[_ARU], context);
    }
    if (output[_PPS] != null) {
        contents[_PPS] = (0, smithy_client_1.strictParseInt32)(output[_PPS]);
    }
    if (output[_S] != null) {
        contents[_S] = (0, smithy_client_1.expectString)(output[_S]);
    }
    if (output[_ST] != null) {
        contents[_ST] = (0, smithy_client_1.expectString)(output[_ST]);
    }
    if (output[_I] != null) {
        contents[_I] = (0, smithy_client_1.expectString)(output[_I]);
    }
    if (output[_Au] != null) {
        contents[_Au] = (0, smithy_client_1.expectString)(output[_Au]);
    }
    if (output[_NQ] != null) {
        contents[_NQ] = (0, smithy_client_1.expectString)(output[_NQ]);
    }
    if (output[_SI] != null) {
        contents[_SI] = (0, smithy_client_1.expectString)(output[_SI]);
    }
    return contents;
};
const de_AssumeRoleWithWebIdentityResponse = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = de_Credentials(output[_C], context);
    }
    if (output[_SFWIT] != null) {
        contents[_SFWIT] = (0, smithy_client_1.expectString)(output[_SFWIT]);
    }
    if (output[_ARU] != null) {
        contents[_ARU] = de_AssumedRoleUser(output[_ARU], context);
    }
    if (output[_PPS] != null) {
        contents[_PPS] = (0, smithy_client_1.strictParseInt32)(output[_PPS]);
    }
    if (output[_Pr] != null) {
        contents[_Pr] = (0, smithy_client_1.expectString)(output[_Pr]);
    }
    if (output[_Au] != null) {
        contents[_Au] = (0, smithy_client_1.expectString)(output[_Au]);
    }
    if (output[_SI] != null) {
        contents[_SI] = (0, smithy_client_1.expectString)(output[_SI]);
    }
    return contents;
};
const de_Credentials = (output, context) => {
    const contents = {};
    if (output[_AKI] != null) {
        contents[_AKI] = (0, smithy_client_1.expectString)(output[_AKI]);
    }
    if (output[_SAK] != null) {
        contents[_SAK] = (0, smithy_client_1.expectString)(output[_SAK]);
    }
    if (output[_STe] != null) {
        contents[_STe] = (0, smithy_client_1.expectString)(output[_STe]);
    }
    if (output[_E] != null) {
        contents[_E] = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output[_E]));
    }
    return contents;
};
const de_DecodeAuthorizationMessageResponse = (output, context) => {
    const contents = {};
    if (output[_DM] != null) {
        contents[_DM] = (0, smithy_client_1.expectString)(output[_DM]);
    }
    return contents;
};
const de_ExpiredTokenException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = (0, smithy_client_1.expectString)(output[_m]);
    }
    return contents;
};
const de_FederatedUser = (output, context) => {
    const contents = {};
    if (output[_FUI] != null) {
        contents[_FUI] = (0, smithy_client_1.expectString)(output[_FUI]);
    }
    if (output[_Ar] != null) {
        contents[_Ar] = (0, smithy_client_1.expectString)(output[_Ar]);
    }
    return contents;
};
const de_GetAccessKeyInfoResponse = (output, context) => {
    const contents = {};
    if (output[_Ac] != null) {
        contents[_Ac] = (0, smithy_client_1.expectString)(output[_Ac]);
    }
    return contents;
};
const de_GetCallerIdentityResponse = (output, context) => {
    const contents = {};
    if (output[_UI] != null) {
        contents[_UI] = (0, smithy_client_1.expectString)(output[_UI]);
    }
    if (output[_Ac] != null) {
        contents[_Ac] = (0, smithy_client_1.expectString)(output[_Ac]);
    }
    if (output[_Ar] != null) {
        contents[_Ar] = (0, smithy_client_1.expectString)(output[_Ar]);
    }
    return contents;
};
const de_GetFederationTokenResponse = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = de_Credentials(output[_C], context);
    }
    if (output[_FU] != null) {
        contents[_FU] = de_FederatedUser(output[_FU], context);
    }
    if (output[_PPS] != null) {
        contents[_PPS] = (0, smithy_client_1.strictParseInt32)(output[_PPS]);
    }
    return contents;
};
const de_GetSessionTokenResponse = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = de_Credentials(output[_C], context);
    }
    return contents;
};
const de_IDPCommunicationErrorException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = (0, smithy_client_1.expectString)(output[_m]);
    }
    return contents;
};
const de_IDPRejectedClaimException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = (0, smithy_client_1.expectString)(output[_m]);
    }
    return contents;
};
const de_InvalidAuthorizationMessageException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = (0, smithy_client_1.expectString)(output[_m]);
    }
    return contents;
};
const de_InvalidIdentityTokenException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = (0, smithy_client_1.expectString)(output[_m]);
    }
    return contents;
};
const de_MalformedPolicyDocumentException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = (0, smithy_client_1.expectString)(output[_m]);
    }
    return contents;
};
const de_PackedPolicyTooLargeException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = (0, smithy_client_1.expectString)(output[_m]);
    }
    return contents;
};
const de_RegionDisabledException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
        contents[_m] = (0, smithy_client_1.expectString)(output[_m]);
    }
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = (0, smithy_client_1.withBaseException)(STSServiceException_1.STSServiceException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded",
};
const _ = "2011-06-15";
const _A = "Action";
const _AKI = "AccessKeyId";
const _AR = "AssumeRole";
const _ARI = "AssumedRoleId";
const _ARU = "AssumedRoleUser";
const _ARWSAML = "AssumeRoleWithSAML";
const _ARWWI = "AssumeRoleWithWebIdentity";
const _Ac = "Account";
const _Ar = "Arn";
const _Au = "Audience";
const _C = "Credentials";
const _CA = "ContextAssertion";
const _DAM = "DecodeAuthorizationMessage";
const _DM = "DecodedMessage";
const _DS = "DurationSeconds";
const _E = "Expiration";
const _EI = "ExternalId";
const _EM = "EncodedMessage";
const _FU = "FederatedUser";
const _FUI = "FederatedUserId";
const _GAKI = "GetAccessKeyInfo";
const _GCI = "GetCallerIdentity";
const _GFT = "GetFederationToken";
const _GST = "GetSessionToken";
const _I = "Issuer";
const _K = "Key";
const _N = "Name";
const _NQ = "NameQualifier";
const _P = "Policy";
const _PA = "PolicyArns";
const _PAr = "PrincipalArn";
const _PAro = "ProviderArn";
const _PC = "ProvidedContexts";
const _PI = "ProviderId";
const _PPS = "PackedPolicySize";
const _Pr = "Provider";
const _RA = "RoleArn";
const _RSN = "RoleSessionName";
const _S = "Subject";
const _SAK = "SecretAccessKey";
const _SAMLA = "SAMLAssertion";
const _SFWIT = "SubjectFromWebIdentityToken";
const _SI = "SourceIdentity";
const _SN = "SerialNumber";
const _ST = "SubjectType";
const _STe = "SessionToken";
const _T = "Tags";
const _TC = "TokenCode";
const _TTK = "TransitiveTagKeys";
const _UI = "UserId";
const _V = "Version";
const _Va = "Value";
const _WIT = "WebIdentityToken";
const _a = "arn";
const _m = "message";
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new fast_xml_parser_1.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        const parsedObj = parser.parse(encoded);
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return (0, smithy_client_1.getValueFromTextNode)(parsedObjToReturn);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => (0, smithy_client_1.extendedEncodeURIComponent)(key) + "=" + (0, smithy_client_1.extendedEncodeURIComponent)(value))
    .join("&");
const loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};


/***/ }),

/***/ 83405:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const tslib_1 = __nccwpck_require__(4351);
const package_json_1 = tslib_1.__importDefault(__nccwpck_require__(7947));
const defaultStsRoleAssumers_1 = __nccwpck_require__(90048);
const core_1 = __nccwpck_require__(59963);
const credential_provider_node_1 = __nccwpck_require__(75531);
const util_user_agent_node_1 = __nccwpck_require__(98095);
const config_resolver_1 = __nccwpck_require__(53098);
const core_2 = __nccwpck_require__(55829);
const hash_node_1 = __nccwpck_require__(3081);
const middleware_retry_1 = __nccwpck_require__(96039);
const node_config_provider_1 = __nccwpck_require__(33461);
const node_http_handler_1 = __nccwpck_require__(20258);
const util_body_length_node_1 = __nccwpck_require__(68075);
const util_retry_1 = __nccwpck_require__(84902);
const runtimeConfig_shared_1 = __nccwpck_require__(52642);
const smithy_client_1 = __nccwpck_require__(63570);
const util_defaults_mode_node_1 = __nccwpck_require__(72429);
const smithy_client_2 = __nccwpck_require__(63570);
const getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? (0, defaultStsRoleAssumers_1.decorateDefaultCredentialProvider)(credential_provider_node_1.defaultProvider),
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        httpAuthSchemes: config?.httpAuthSchemes ?? [
            {
                schemeId: "aws.auth#sigv4",
                identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4") ||
                    (async (idProps) => await (0, defaultStsRoleAssumers_1.decorateDefaultCredentialProvider)(credential_provider_node_1.defaultProvider)(idProps?.__config || {})()),
                signer: new core_1.AWSSDKSigV4Signer(),
            },
            {
                schemeId: "smithy.api#noAuth",
                identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
                signer: new core_2.NoAuthSigner(),
            },
        ],
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0, node_config_provider_1.loadConfig)({
                ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 52642:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const core_1 = __nccwpck_require__(59963);
const core_2 = __nccwpck_require__(55829);
const smithy_client_1 = __nccwpck_require__(63570);
const url_parser_1 = __nccwpck_require__(14681);
const util_base64_1 = __nccwpck_require__(75600);
const util_utf8_1 = __nccwpck_require__(41895);
const httpAuthSchemeProvider_1 = __nccwpck_require__(17145);
const endpointResolver_1 = __nccwpck_require__(41203);
const getRuntimeConfig = (config) => {
    return {
        apiVersion: "2011-06-15",
        base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
        base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? httpAuthSchemeProvider_1.defaultSTSHttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
            {
                schemeId: "aws.auth#sigv4",
                identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
                signer: new core_1.AWSSDKSigV4Signer(),
            },
            {
                schemeId: "smithy.api#noAuth",
                identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
                signer: new core_2.NoAuthSigner(),
            },
        ],
        logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
        serviceId: config?.serviceId ?? "STS",
        urlParser: config?.urlParser ?? url_parser_1.parseUrl,
        utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8,
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 32053:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveRuntimeExtensions = void 0;
const region_config_resolver_1 = __nccwpck_require__(18156);
const protocol_http_1 = __nccwpck_require__(64418);
const smithy_client_1 = __nccwpck_require__(63570);
const httpAuthExtensionConfiguration_1 = __nccwpck_require__(28527);
const asPartial = (t) => t;
const resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
        ...asPartial((0, region_config_resolver_1.getAwsRegionExtensionConfiguration)(runtimeConfig)),
        ...asPartial((0, smithy_client_1.getDefaultExtensionConfiguration)(runtimeConfig)),
        ...asPartial((0, protocol_http_1.getHttpHandlerExtensionConfiguration)(runtimeConfig)),
        ...asPartial((0, httpAuthExtensionConfiguration_1.getHttpAuthExtensionConfiguration)(runtimeConfig)),
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...(0, region_config_resolver_1.resolveAwsRegionExtensionConfiguration)(extensionConfiguration),
        ...(0, smithy_client_1.resolveDefaultRuntimeConfig)(extensionConfiguration),
        ...(0, protocol_http_1.resolveHttpHandlerRuntimeConfig)(extensionConfiguration),
        ...(0, httpAuthExtensionConfiguration_1.resolveHttpAuthRuntimeConfig)(extensionConfiguration),
    };
};
exports.resolveRuntimeExtensions = resolveRuntimeExtensions;


/***/ }),

/***/ 14154:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.emitWarningIfUnsupportedVersion = void 0;
let warningEmitted = false;
const emitWarningIfUnsupportedVersion = (version) => {
    if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 16) {
        warningEmitted = true;
        process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 14.x on May 1, 2024.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to an active Node.js LTS version.

More information can be found at: https://a.co/dzr2AJd`);
    }
};
exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion;


/***/ }),

/***/ 7249:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(14154), exports);


/***/ }),

/***/ 47584:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AWSSDKSigV4Signer = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const utils_1 = __nccwpck_require__(76026);
const throwAWSSDKSigningPropertyError_1 = __nccwpck_require__(29809);
const validateSigningProperties = async (signingProperties) => {
    var _a, _b, _c;
    const context = (0, throwAWSSDKSigningPropertyError_1.throwAWSSDKSigningPropertyError)("context", signingProperties.context);
    const config = (0, throwAWSSDKSigningPropertyError_1.throwAWSSDKSigningPropertyError)("config", signingProperties.config);
    const authScheme = (_c = (_b = (_a = context.endpointV2) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.authSchemes) === null || _c === void 0 ? void 0 : _c[0];
    const signerFunction = (0, throwAWSSDKSigningPropertyError_1.throwAWSSDKSigningPropertyError)("signer", config.signer);
    const signer = await signerFunction(authScheme);
    const signingRegion = signingProperties === null || signingProperties === void 0 ? void 0 : signingProperties.signingRegion;
    const signingName = signingProperties === null || signingProperties === void 0 ? void 0 : signingProperties.signingName;
    return {
        config,
        signer,
        signingRegion,
        signingName,
    };
};
class AWSSDKSigV4Signer {
    async sign(httpRequest, identity, signingProperties) {
        if (!protocol_http_1.HttpRequest.isInstance(httpRequest)) {
            throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
        }
        const { config, signer, signingRegion, signingName } = await validateSigningProperties(signingProperties);
        const signedRequest = await signer.sign(httpRequest, {
            signingDate: (0, utils_1.getSkewCorrectedDate)(config.systemClockOffset),
            signingRegion: signingRegion,
            signingService: signingName,
        });
        return signedRequest;
    }
    errorHandler(signingProperties) {
        return (error) => {
            var _a;
            const serverTime = (_a = error.ServerTime) !== null && _a !== void 0 ? _a : (0, utils_1.getDateHeader)(error.$response);
            if (serverTime) {
                const config = (0, throwAWSSDKSigningPropertyError_1.throwAWSSDKSigningPropertyError)("config", signingProperties.config);
                config.systemClockOffset = (0, utils_1.getUpdatedSystemClockOffset)(serverTime, config.systemClockOffset);
            }
            throw error;
        };
    }
    successHandler(httpResponse, signingProperties) {
        const dateHeader = (0, utils_1.getDateHeader)(httpResponse);
        if (dateHeader) {
            const config = (0, throwAWSSDKSigningPropertyError_1.throwAWSSDKSigningPropertyError)("config", signingProperties.config);
            config.systemClockOffset = (0, utils_1.getUpdatedSystemClockOffset)(dateHeader, config.systemClockOffset);
        }
    }
}
exports.AWSSDKSigV4Signer = AWSSDKSigV4Signer;


/***/ }),

/***/ 86710:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(47584), exports);
tslib_1.__exportStar(__nccwpck_require__(17668), exports);


/***/ }),

/***/ 17668:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveAWSSDKSigV4Config = void 0;
const core_1 = __nccwpck_require__(55829);
const signature_v4_1 = __nccwpck_require__(11528);
const resolveAWSSDKSigV4Config = (config) => {
    let normalizedCreds;
    if (config.credentials) {
        normalizedCreds = (0, core_1.memoizeIdentityProvider)(config.credentials, core_1.isIdentityExpired, core_1.doesIdentityRequireRefresh);
    }
    if (!normalizedCreds) {
        if (config.credentialDefaultProvider) {
            normalizedCreds = (0, core_1.normalizeProvider)(config.credentialDefaultProvider(config));
        }
        else {
            normalizedCreds = async () => { throw new Error("`credentials` is missing"); };
        }
    }
    const { signingEscapePath = true, systemClockOffset = config.systemClockOffset || 0, sha256, } = config;
    let signer;
    if (config.signer) {
        signer = (0, core_1.normalizeProvider)(config.signer);
    }
    else if (config.regionInfoProvider) {
        signer = () => (0, core_1.normalizeProvider)(config.region)()
            .then(async (region) => [
            (await config.regionInfoProvider(region, {
                useFipsEndpoint: await config.useFipsEndpoint(),
                useDualstackEndpoint: await config.useDualstackEndpoint(),
            })) || {},
            region,
        ])
            .then(([regionInfo, region]) => {
            const { signingRegion, signingService } = regionInfo;
            config.signingRegion = config.signingRegion || signingRegion || region;
            config.signingName = config.signingName || signingService || config.serviceId;
            const params = {
                ...config,
                credentials: normalizedCreds,
                region: config.signingRegion,
                service: config.signingName,
                sha256,
                uriEscapePath: signingEscapePath,
            };
            const SignerCtor = config.signerConstructor || signature_v4_1.SignatureV4;
            return new SignerCtor(params);
        });
    }
    else {
        signer = async (authScheme) => {
            authScheme = Object.assign({}, {
                name: "sigv4",
                signingName: config.signingName || config.defaultSigningName,
                signingRegion: await (0, core_1.normalizeProvider)(config.region)(),
                properties: {},
            }, authScheme);
            const signingRegion = authScheme.signingRegion;
            const signingService = authScheme.signingName;
            config.signingRegion = config.signingRegion || signingRegion;
            config.signingName = config.signingName || signingService || config.serviceId;
            const params = {
                ...config,
                credentials: normalizedCreds,
                region: config.signingRegion,
                service: config.signingName,
                sha256,
                uriEscapePath: signingEscapePath,
            };
            const SignerCtor = config.signerConstructor || signature_v4_1.SignatureV4;
            return new SignerCtor(params);
        };
    }
    return {
        ...config,
        systemClockOffset,
        signingEscapePath,
        credentials: normalizedCreds,
        signer,
    };
};
exports.resolveAWSSDKSigV4Config = resolveAWSSDKSigV4Config;


/***/ }),

/***/ 29809:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.throwAWSSDKSigningPropertyError = void 0;
const throwAWSSDKSigningPropertyError = (name, property) => {
    if (!property) {
        throw new Error(`Property \`${name}\` is not resolved for AWS SDK SigV4Auth`);
    }
    return property;
};
exports.throwAWSSDKSigningPropertyError = throwAWSSDKSigningPropertyError;


/***/ }),

/***/ 64353:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(86710), exports);


/***/ }),

/***/ 75193:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDateHeader = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const getDateHeader = (response) => { var _a, _b, _c; return protocol_http_1.HttpResponse.isInstance(response) ? (_b = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.date) !== null && _b !== void 0 ? _b : (_c = response.headers) === null || _c === void 0 ? void 0 : _c.Date : undefined; };
exports.getDateHeader = getDateHeader;


/***/ }),

/***/ 66649:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSkewCorrectedDate = void 0;
const getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);
exports.getSkewCorrectedDate = getSkewCorrectedDate;


/***/ }),

/***/ 66374:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUpdatedSystemClockOffset = void 0;
const isClockSkewed_1 = __nccwpck_require__(35033);
const getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
    const clockTimeInMs = Date.parse(clockTime);
    if ((0, isClockSkewed_1.isClockSkewed)(clockTimeInMs, currentSystemClockOffset)) {
        return clockTimeInMs - Date.now();
    }
    return currentSystemClockOffset;
};
exports.getUpdatedSystemClockOffset = getUpdatedSystemClockOffset;


/***/ }),

/***/ 76026:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(75193), exports);
tslib_1.__exportStar(__nccwpck_require__(66649), exports);
tslib_1.__exportStar(__nccwpck_require__(66374), exports);


/***/ }),

/***/ 35033:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isClockSkewed = void 0;
const getSkewCorrectedDate_1 = __nccwpck_require__(66649);
const isClockSkewed = (clockTime, systemClockOffset) => Math.abs((0, getSkewCorrectedDate_1.getSkewCorrectedDate)(systemClockOffset).getTime() - clockTime) >= 300000;
exports.isClockSkewed = isClockSkewed;


/***/ }),

/***/ 59963:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(7249), exports);
tslib_1.__exportStar(__nccwpck_require__(64353), exports);
tslib_1.__exportStar(__nccwpck_require__(53069), exports);


/***/ }),

/***/ 26133:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._toNum = exports._toBool = exports._toStr = void 0;
const _toStr = (val) => {
    if (val == null) {
        return val;
    }
    if (typeof val === "number" || typeof val === "bigint") {
        const warning = new Error(`Received number ${val} where a string was expected.`);
        warning.name = "Warning";
        console.warn(warning);
        return String(val);
    }
    if (typeof val === "boolean") {
        const warning = new Error(`Received boolean ${val} where a string was expected.`);
        warning.name = "Warning";
        console.warn(warning);
        return String(val);
    }
    return val;
};
exports._toStr = _toStr;
const _toBool = (val) => {
    if (val == null) {
        return val;
    }
    if (typeof val === "number") {
    }
    if (typeof val === "string") {
        const lowercase = val.toLowerCase();
        if (val !== "" && lowercase !== "false" && lowercase !== "true") {
            const warning = new Error(`Received string "${val}" where a boolean was expected.`);
            warning.name = "Warning";
            console.warn(warning);
        }
        return val !== "" && lowercase !== "false";
    }
    return val;
};
exports._toBool = _toBool;
const _toNum = (val) => {
    if (val == null) {
        return val;
    }
    if (typeof val === "boolean") {
    }
    if (typeof val === "string") {
        const num = Number(val);
        if (num.toString() !== val) {
            const warning = new Error(`Received string "${val}" where a number was expected.`);
            warning.name = "Warning";
            console.warn(warning);
            return val;
        }
        return num;
    }
    return val;
};
exports._toNum = _toNum;


/***/ }),

/***/ 53069:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(26133), exports);
tslib_1.__exportStar(__nccwpck_require__(11823), exports);


/***/ }),

/***/ 11823:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.awsExpectUnion = void 0;
const smithy_client_1 = __nccwpck_require__(63570);
const awsExpectUnion = (value) => {
    if (value == null) {
        return undefined;
    }
    if (typeof value === "object" && "__type" in value) {
        delete value.__type;
    }
    return (0, smithy_client_1.expectUnion)(value);
};
exports.awsExpectUnion = awsExpectUnion;


/***/ }),

/***/ 80255:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromEnv = exports.ENV_CREDENTIAL_SCOPE = exports.ENV_EXPIRATION = exports.ENV_SESSION = exports.ENV_SECRET = exports.ENV_KEY = void 0;
const property_provider_1 = __nccwpck_require__(79721);
exports.ENV_KEY = "AWS_ACCESS_KEY_ID";
exports.ENV_SECRET = "AWS_SECRET_ACCESS_KEY";
exports.ENV_SESSION = "AWS_SESSION_TOKEN";
exports.ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION";
exports.ENV_CREDENTIAL_SCOPE = "AWS_CREDENTIAL_SCOPE";
const fromEnv = () => async () => {
    const accessKeyId = process.env[exports.ENV_KEY];
    const secretAccessKey = process.env[exports.ENV_SECRET];
    const sessionToken = process.env[exports.ENV_SESSION];
    const expiry = process.env[exports.ENV_EXPIRATION];
    const credentialScope = process.env[exports.ENV_CREDENTIAL_SCOPE];
    if (accessKeyId && secretAccessKey) {
        return {
            accessKeyId,
            secretAccessKey,
            ...(sessionToken && { sessionToken }),
            ...(expiry && { expiration: new Date(expiry) }),
            ...(credentialScope && { credentialScope }),
        };
    }
    throw new property_provider_1.CredentialsProviderError("Unable to find environment variable credentials.");
};
exports.fromEnv = fromEnv;


/***/ }),

/***/ 15972:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(80255), exports);


/***/ }),

/***/ 55442:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromIni = void 0;
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const resolveProfileData_1 = __nccwpck_require__(95653);
const fromIni = (init = {}) => async () => {
    const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
    return (0, resolveProfileData_1.resolveProfileData)((0, shared_ini_file_loader_1.getProfileName)(init), profiles, init);
};
exports.fromIni = fromIni;


/***/ }),

/***/ 74203:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(55442), exports);


/***/ }),

/***/ 60853:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveAssumeRoleCredentials = exports.isAssumeRoleProfile = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const resolveCredentialSource_1 = __nccwpck_require__(82458);
const resolveProfileData_1 = __nccwpck_require__(95653);
const isAssumeRoleProfile = (arg) => Boolean(arg) &&
    typeof arg === "object" &&
    typeof arg.role_arn === "string" &&
    ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 &&
    ["undefined", "string"].indexOf(typeof arg.external_id) > -1 &&
    ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 &&
    (isAssumeRoleWithSourceProfile(arg) || isAssumeRoleWithProviderProfile(arg));
exports.isAssumeRoleProfile = isAssumeRoleProfile;
const isAssumeRoleWithSourceProfile = (arg) => typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined";
const isAssumeRoleWithProviderProfile = (arg) => typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined";
const resolveAssumeRoleCredentials = async (profileName, profiles, options, visitedProfiles = {}) => {
    const data = profiles[profileName];
    if (!options.roleAssumer) {
        throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} requires a role to be assumed, but no role assumption callback was provided.`, false);
    }
    const { source_profile } = data;
    if (source_profile && source_profile in visitedProfiles) {
        throw new property_provider_1.CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile` +
            ` ${(0, shared_ini_file_loader_1.getProfileName)(options)}. Profiles visited: ` +
            Object.keys(visitedProfiles).join(", "), false);
    }
    const sourceCredsProvider = source_profile
        ? (0, resolveProfileData_1.resolveProfileData)(source_profile, profiles, options, {
            ...visitedProfiles,
            [source_profile]: true,
        })
        : (0, resolveCredentialSource_1.resolveCredentialSource)(data.credential_source, profileName)();
    const params = {
        RoleArn: data.role_arn,
        RoleSessionName: data.role_session_name || `aws-sdk-js-${Date.now()}`,
        ExternalId: data.external_id,
        DurationSeconds: parseInt(data.duration_seconds || "3600", 10),
    };
    const { mfa_serial } = data;
    if (mfa_serial) {
        if (!options.mfaCodeProvider) {
            throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, false);
        }
        params.SerialNumber = mfa_serial;
        params.TokenCode = await options.mfaCodeProvider(mfa_serial);
    }
    const sourceCreds = await sourceCredsProvider;
    return options.roleAssumer(sourceCreds, params);
};
exports.resolveAssumeRoleCredentials = resolveAssumeRoleCredentials;


/***/ }),

/***/ 82458:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveCredentialSource = void 0;
const credential_provider_env_1 = __nccwpck_require__(15972);
const credential_provider_imds_1 = __nccwpck_require__(7477);
const property_provider_1 = __nccwpck_require__(79721);
const resolveCredentialSource = (credentialSource, profileName) => {
    const sourceProvidersMap = {
        EcsContainer: credential_provider_imds_1.fromContainerMetadata,
        Ec2InstanceMetadata: credential_provider_imds_1.fromInstanceMetadata,
        Environment: credential_provider_env_1.fromEnv,
    };
    if (credentialSource in sourceProvidersMap) {
        return sourceProvidersMap[credentialSource]();
    }
    else {
        throw new property_provider_1.CredentialsProviderError(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, ` +
            `expected EcsContainer or Ec2InstanceMetadata or Environment.`);
    }
};
exports.resolveCredentialSource = resolveCredentialSource;


/***/ }),

/***/ 69993:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveProcessCredentials = exports.isProcessProfile = void 0;
const credential_provider_process_1 = __nccwpck_require__(89969);
const isProcessProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.credential_process === "string";
exports.isProcessProfile = isProcessProfile;
const resolveProcessCredentials = async (options, profile) => (0, credential_provider_process_1.fromProcess)({
    ...options,
    profile,
})();
exports.resolveProcessCredentials = resolveProcessCredentials;


/***/ }),

/***/ 95653:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveProfileData = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const resolveAssumeRoleCredentials_1 = __nccwpck_require__(60853);
const resolveProcessCredentials_1 = __nccwpck_require__(69993);
const resolveSsoCredentials_1 = __nccwpck_require__(59867);
const resolveStaticCredentials_1 = __nccwpck_require__(33071);
const resolveWebIdentityCredentials_1 = __nccwpck_require__(58342);
const resolveProfileData = async (profileName, profiles, options, visitedProfiles = {}) => {
    const data = profiles[profileName];
    if (Object.keys(visitedProfiles).length > 0 && (0, resolveStaticCredentials_1.isStaticCredsProfile)(data)) {
        return (0, resolveStaticCredentials_1.resolveStaticCredentials)(data);
    }
    if ((0, resolveAssumeRoleCredentials_1.isAssumeRoleProfile)(data)) {
        return (0, resolveAssumeRoleCredentials_1.resolveAssumeRoleCredentials)(profileName, profiles, options, visitedProfiles);
    }
    if ((0, resolveStaticCredentials_1.isStaticCredsProfile)(data)) {
        return (0, resolveStaticCredentials_1.resolveStaticCredentials)(data);
    }
    if ((0, resolveWebIdentityCredentials_1.isWebIdentityProfile)(data)) {
        return (0, resolveWebIdentityCredentials_1.resolveWebIdentityCredentials)(data, options);
    }
    if ((0, resolveProcessCredentials_1.isProcessProfile)(data)) {
        return (0, resolveProcessCredentials_1.resolveProcessCredentials)(options, profileName);
    }
    if ((0, resolveSsoCredentials_1.isSsoProfile)(data)) {
        return (0, resolveSsoCredentials_1.resolveSsoCredentials)(data);
    }
    throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} could not be found or parsed in shared credentials file.`);
};
exports.resolveProfileData = resolveProfileData;


/***/ }),

/***/ 59867:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveSsoCredentials = exports.isSsoProfile = void 0;
const credential_provider_sso_1 = __nccwpck_require__(26414);
var credential_provider_sso_2 = __nccwpck_require__(26414);
Object.defineProperty(exports, "isSsoProfile", ({ enumerable: true, get: function () { return credential_provider_sso_2.isSsoProfile; } }));
const resolveSsoCredentials = (data) => {
    const { sso_start_url, sso_account_id, sso_session, sso_region, sso_role_name } = (0, credential_provider_sso_1.validateSsoProfile)(data);
    return (0, credential_provider_sso_1.fromSSO)({
        ssoStartUrl: sso_start_url,
        ssoAccountId: sso_account_id,
        ssoSession: sso_session,
        ssoRegion: sso_region,
        ssoRoleName: sso_role_name,
    })();
};
exports.resolveSsoCredentials = resolveSsoCredentials;


/***/ }),

/***/ 33071:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveStaticCredentials = exports.isStaticCredsProfile = void 0;
const isStaticCredsProfile = (arg) => Boolean(arg) &&
    typeof arg === "object" &&
    typeof arg.aws_access_key_id === "string" &&
    typeof arg.aws_secret_access_key === "string" &&
    ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1;
exports.isStaticCredsProfile = isStaticCredsProfile;
const resolveStaticCredentials = (profile) => Promise.resolve({
    accessKeyId: profile.aws_access_key_id,
    secretAccessKey: profile.aws_secret_access_key,
    sessionToken: profile.aws_session_token,
    credentialScope: profile.aws_credential_scope,
});
exports.resolveStaticCredentials = resolveStaticCredentials;


/***/ }),

/***/ 58342:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveWebIdentityCredentials = exports.isWebIdentityProfile = void 0;
const credential_provider_web_identity_1 = __nccwpck_require__(15646);
const isWebIdentityProfile = (arg) => Boolean(arg) &&
    typeof arg === "object" &&
    typeof arg.web_identity_token_file === "string" &&
    typeof arg.role_arn === "string" &&
    ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1;
exports.isWebIdentityProfile = isWebIdentityProfile;
const resolveWebIdentityCredentials = async (profile, options) => (0, credential_provider_web_identity_1.fromTokenFile)({
    webIdentityTokenFile: profile.web_identity_token_file,
    roleArn: profile.role_arn,
    roleSessionName: profile.role_session_name,
    roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity,
})();
exports.resolveWebIdentityCredentials = resolveWebIdentityCredentials;


/***/ }),

/***/ 15560:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultProvider = void 0;
const credential_provider_env_1 = __nccwpck_require__(15972);
const credential_provider_ini_1 = __nccwpck_require__(74203);
const credential_provider_process_1 = __nccwpck_require__(89969);
const credential_provider_sso_1 = __nccwpck_require__(26414);
const credential_provider_web_identity_1 = __nccwpck_require__(15646);
const property_provider_1 = __nccwpck_require__(79721);
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const remoteProvider_1 = __nccwpck_require__(50626);
const defaultProvider = (init = {}) => (0, property_provider_1.memoize)((0, property_provider_1.chain)(...(init.profile || process.env[shared_ini_file_loader_1.ENV_PROFILE] ? [] : [(0, credential_provider_env_1.fromEnv)()]), (0, credential_provider_sso_1.fromSSO)(init), (0, credential_provider_ini_1.fromIni)(init), (0, credential_provider_process_1.fromProcess)(init), (0, credential_provider_web_identity_1.fromTokenFile)(init), (0, remoteProvider_1.remoteProvider)(init), async () => {
    throw new property_provider_1.CredentialsProviderError("Could not load credentials from any providers", false);
}), (credentials) => credentials.expiration !== undefined && credentials.expiration.getTime() - Date.now() < 300000, (credentials) => credentials.expiration !== undefined);
exports.defaultProvider = defaultProvider;


/***/ }),

/***/ 75531:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(15560), exports);


/***/ }),

/***/ 50626:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.remoteProvider = exports.ENV_IMDS_DISABLED = void 0;
const credential_provider_imds_1 = __nccwpck_require__(7477);
const property_provider_1 = __nccwpck_require__(79721);
exports.ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
const remoteProvider = (init) => {
    if (process.env[credential_provider_imds_1.ENV_CMDS_RELATIVE_URI] || process.env[credential_provider_imds_1.ENV_CMDS_FULL_URI]) {
        return (0, credential_provider_imds_1.fromContainerMetadata)(init);
    }
    if (process.env[exports.ENV_IMDS_DISABLED]) {
        return async () => {
            throw new property_provider_1.CredentialsProviderError("EC2 Instance Metadata Service access disabled");
        };
    }
    return (0, credential_provider_imds_1.fromInstanceMetadata)(init);
};
exports.remoteProvider = remoteProvider;


/***/ }),

/***/ 72650:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromProcess = void 0;
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const resolveProcessCredentials_1 = __nccwpck_require__(74926);
const fromProcess = (init = {}) => async () => {
    const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
    return (0, resolveProcessCredentials_1.resolveProcessCredentials)((0, shared_ini_file_loader_1.getProfileName)(init), profiles);
};
exports.fromProcess = fromProcess;


/***/ }),

/***/ 41104:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getValidatedProcessCredentials = void 0;
const getValidatedProcessCredentials = (profileName, data) => {
    if (data.Version !== 1) {
        throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
    }
    if (data.AccessKeyId === undefined || data.SecretAccessKey === undefined) {
        throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
    }
    if (data.Expiration) {
        const currentTime = new Date();
        const expireTime = new Date(data.Expiration);
        if (expireTime < currentTime) {
            throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
        }
    }
    return {
        accessKeyId: data.AccessKeyId,
        secretAccessKey: data.SecretAccessKey,
        ...(data.SessionToken && { sessionToken: data.SessionToken }),
        ...(data.Expiration && { expiration: new Date(data.Expiration) }),
        ...(data.CredentialScope && { credentialScope: data.CredentialScope }),
    };
};
exports.getValidatedProcessCredentials = getValidatedProcessCredentials;


/***/ }),

/***/ 89969:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(72650), exports);


/***/ }),

/***/ 74926:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveProcessCredentials = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const child_process_1 = __nccwpck_require__(32081);
const util_1 = __nccwpck_require__(73837);
const getValidatedProcessCredentials_1 = __nccwpck_require__(41104);
const resolveProcessCredentials = async (profileName, profiles) => {
    const profile = profiles[profileName];
    if (profiles[profileName]) {
        const credentialProcess = profile["credential_process"];
        if (credentialProcess !== undefined) {
            const execPromise = (0, util_1.promisify)(child_process_1.exec);
            try {
                const { stdout } = await execPromise(credentialProcess);
                let data;
                try {
                    data = JSON.parse(stdout.trim());
                }
                catch (_a) {
                    throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
                }
                return (0, getValidatedProcessCredentials_1.getValidatedProcessCredentials)(profileName, data);
            }
            catch (error) {
                throw new property_provider_1.CredentialsProviderError(error.message);
            }
        }
        else {
            throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} did not contain credential_process.`);
        }
    }
    else {
        throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} could not be found in shared credentials file.`);
    }
};
exports.resolveProcessCredentials = resolveProcessCredentials;


/***/ }),

/***/ 35959:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromSSO = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const isSsoProfile_1 = __nccwpck_require__(32572);
const resolveSSOCredentials_1 = __nccwpck_require__(94729);
const validateSsoProfile_1 = __nccwpck_require__(48098);
const fromSSO = (init = {}) => async () => {
    const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, ssoSession } = init;
    const profileName = (0, shared_ini_file_loader_1.getProfileName)(init);
    if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
        const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
        const profile = profiles[profileName];
        if (!profile) {
            throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} was not found.`);
        }
        if (!(0, isSsoProfile_1.isSsoProfile)(profile)) {
            throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`);
        }
        if (profile === null || profile === void 0 ? void 0 : profile.sso_session) {
            const ssoSessions = await (0, shared_ini_file_loader_1.loadSsoSessionData)(init);
            const session = ssoSessions[profile.sso_session];
            const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;
            if (ssoRegion && ssoRegion !== session.sso_region) {
                throw new property_provider_1.CredentialsProviderError(`Conflicting SSO region` + conflictMsg, false);
            }
            if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) {
                throw new property_provider_1.CredentialsProviderError(`Conflicting SSO start_url` + conflictMsg, false);
            }
            profile.sso_region = session.sso_region;
            profile.sso_start_url = session.sso_start_url;
        }
        const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = (0, validateSsoProfile_1.validateSsoProfile)(profile);
        return (0, resolveSSOCredentials_1.resolveSSOCredentials)({
            ssoStartUrl: sso_start_url,
            ssoSession: sso_session,
            ssoAccountId: sso_account_id,
            ssoRegion: sso_region,
            ssoRoleName: sso_role_name,
            ssoClient: ssoClient,
            profile: profileName,
        });
    }
    else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
        throw new property_provider_1.CredentialsProviderError("Incomplete configuration. The fromSSO() argument hash must include " +
            '"ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"');
    }
    else {
        return (0, resolveSSOCredentials_1.resolveSSOCredentials)({
            ssoStartUrl,
            ssoSession,
            ssoAccountId,
            ssoRegion,
            ssoRoleName,
            ssoClient,
            profile: profileName,
        });
    }
};
exports.fromSSO = fromSSO;


/***/ }),

/***/ 26414:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(35959), exports);
tslib_1.__exportStar(__nccwpck_require__(32572), exports);
tslib_1.__exportStar(__nccwpck_require__(86623), exports);
tslib_1.__exportStar(__nccwpck_require__(48098), exports);


/***/ }),

/***/ 32572:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSsoProfile = void 0;
const isSsoProfile = (arg) => arg &&
    (typeof arg.sso_start_url === "string" ||
        typeof arg.sso_account_id === "string" ||
        typeof arg.sso_session === "string" ||
        typeof arg.sso_region === "string" ||
        typeof arg.sso_role_name === "string");
exports.isSsoProfile = isSsoProfile;


/***/ }),

/***/ 94729:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveSSOCredentials = void 0;
const client_sso_1 = __nccwpck_require__(82666);
const token_providers_1 = __nccwpck_require__(52843);
const property_provider_1 = __nccwpck_require__(79721);
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const SHOULD_FAIL_CREDENTIAL_CHAIN = false;
const resolveSSOCredentials = async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, profile, }) => {
    var _a;
    let token;
    const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
    if (ssoSession) {
        try {
            const _token = await (0, token_providers_1.fromSso)({ profile })();
            token = {
                accessToken: _token.token,
                expiresAt: new Date(_token.expiration).toISOString(),
            };
        }
        catch (e) {
            throw new property_provider_1.CredentialsProviderError(e.message, SHOULD_FAIL_CREDENTIAL_CHAIN);
        }
    }
    else {
        try {
            token = await (0, shared_ini_file_loader_1.getSSOTokenFromFile)(ssoStartUrl);
        }
        catch (e) {
            throw new property_provider_1.CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
        }
    }
    if (new Date(token.expiresAt).getTime() - Date.now() <= 0) {
        throw new property_provider_1.CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
    const { accessToken } = token;
    const sso = ssoClient || new client_sso_1.SSOClient({ region: ssoRegion });
    let ssoResp;
    try {
        ssoResp = await sso.send(new client_sso_1.GetRoleCredentialsCommand({
            accountId: ssoAccountId,
            roleName: ssoRoleName,
            accessToken,
        }));
    }
    catch (e) {
        throw property_provider_1.CredentialsProviderError.from(e, SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
    const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration } = {} } = ssoResp;
    const credentialScope = (_a = ssoResp === null || ssoResp === void 0 ? void 0 : ssoResp.roleCredentials) === null || _a === void 0 ? void 0 : _a.credentialScope;
    if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
        throw new property_provider_1.CredentialsProviderError("SSO returns an invalid temporary credential.", SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
    return { accessKeyId, secretAccessKey, sessionToken, expiration: new Date(expiration), credentialScope };
};
exports.resolveSSOCredentials = resolveSSOCredentials;


/***/ }),

/***/ 86623:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 48098:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateSsoProfile = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const validateSsoProfile = (profile) => {
    const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;
    if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
        throw new property_provider_1.CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", ` +
            `"sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}\nReference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, false);
    }
    return profile;
};
exports.validateSsoProfile = validateSsoProfile;


/***/ }),

/***/ 35614:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromTokenFile = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const fs_1 = __nccwpck_require__(57147);
const fromWebToken_1 = __nccwpck_require__(47905);
const ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE";
const ENV_ROLE_ARN = "AWS_ROLE_ARN";
const ENV_ROLE_SESSION_NAME = "AWS_ROLE_SESSION_NAME";
const fromTokenFile = (init = {}) => async () => {
    var _a, _b, _c;
    const webIdentityTokenFile = (_a = init === null || init === void 0 ? void 0 : init.webIdentityTokenFile) !== null && _a !== void 0 ? _a : process.env[ENV_TOKEN_FILE];
    const roleArn = (_b = init === null || init === void 0 ? void 0 : init.roleArn) !== null && _b !== void 0 ? _b : process.env[ENV_ROLE_ARN];
    const roleSessionName = (_c = init === null || init === void 0 ? void 0 : init.roleSessionName) !== null && _c !== void 0 ? _c : process.env[ENV_ROLE_SESSION_NAME];
    if (!webIdentityTokenFile || !roleArn) {
        throw new property_provider_1.CredentialsProviderError("Web identity configuration not specified");
    }
    return (0, fromWebToken_1.fromWebToken)({
        ...init,
        webIdentityToken: (0, fs_1.readFileSync)(webIdentityTokenFile, { encoding: "ascii" }),
        roleArn,
        roleSessionName,
    })();
};
exports.fromTokenFile = fromTokenFile;


/***/ }),

/***/ 47905:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromWebToken = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const fromWebToken = (init) => () => {
    const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds, roleAssumerWithWebIdentity, } = init;
    if (!roleAssumerWithWebIdentity) {
        throw new property_provider_1.CredentialsProviderError(`Role Arn '${roleArn}' needs to be assumed with web identity,` +
            ` but no role assumption callback was provided.`, false);
    }
    return roleAssumerWithWebIdentity({
        RoleArn: roleArn,
        RoleSessionName: roleSessionName !== null && roleSessionName !== void 0 ? roleSessionName : `aws-sdk-js-session-${Date.now()}`,
        WebIdentityToken: webIdentityToken,
        ProviderId: providerId,
        PolicyArns: policyArns,
        Policy: policy,
        DurationSeconds: durationSeconds,
    });
};
exports.fromWebToken = fromWebToken;


/***/ }),

/***/ 15646:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(35614), exports);
tslib_1.__exportStar(__nccwpck_require__(47905), exports);


/***/ }),

/***/ 83939:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_CONFIG_OPTIONS = exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME = exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME = void 0;
const util_config_provider_1 = __nccwpck_require__(83375);
exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME = "AWS_S3_DISABLE_MULTIREGION_ACCESS_POINTS";
exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME = "s3_disable_multiregion_access_points";
exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => (0, util_config_provider_1.booleanSelector)(env, exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME, util_config_provider_1.SelectorType.ENV),
    configFileSelector: (profile) => (0, util_config_provider_1.booleanSelector)(profile, exports.NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME, util_config_provider_1.SelectorType.CONFIG),
    default: false,
};


/***/ }),

/***/ 98580:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_USE_ARN_REGION_CONFIG_OPTIONS = exports.NODE_USE_ARN_REGION_INI_NAME = exports.NODE_USE_ARN_REGION_ENV_NAME = void 0;
const util_config_provider_1 = __nccwpck_require__(83375);
exports.NODE_USE_ARN_REGION_ENV_NAME = "AWS_S3_USE_ARN_REGION";
exports.NODE_USE_ARN_REGION_INI_NAME = "s3_use_arn_region";
exports.NODE_USE_ARN_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => (0, util_config_provider_1.booleanSelector)(env, exports.NODE_USE_ARN_REGION_ENV_NAME, util_config_provider_1.SelectorType.ENV),
    configFileSelector: (profile) => (0, util_config_provider_1.booleanSelector)(profile, exports.NODE_USE_ARN_REGION_INI_NAME, util_config_provider_1.SelectorType.CONFIG),
    default: false,
};


/***/ }),

/***/ 60504:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBucketEndpointPlugin = exports.bucketEndpointMiddlewareOptions = exports.bucketEndpointMiddleware = void 0;
const util_arn_parser_1 = __nccwpck_require__(85487);
const protocol_http_1 = __nccwpck_require__(64418);
const bucketHostname_1 = __nccwpck_require__(9388);
const bucketEndpointMiddleware = (options) => (next, context) => async (args) => {
    const { Bucket: bucketName } = args.input;
    let replaceBucketInPath = options.bucketEndpoint;
    const request = args.request;
    if (protocol_http_1.HttpRequest.isInstance(request)) {
        if (options.bucketEndpoint) {
            request.hostname = bucketName;
        }
        else if ((0, util_arn_parser_1.validate)(bucketName)) {
            const bucketArn = (0, util_arn_parser_1.parse)(bucketName);
            const clientRegion = await options.region();
            const useDualstackEndpoint = await options.useDualstackEndpoint();
            const useFipsEndpoint = await options.useFipsEndpoint();
            const { partition, signingRegion = clientRegion } = (await options.regionInfoProvider(clientRegion, { useDualstackEndpoint, useFipsEndpoint })) || {};
            const useArnRegion = await options.useArnRegion();
            const { hostname, bucketEndpoint, signingRegion: modifiedSigningRegion, signingService, } = (0, bucketHostname_1.bucketHostname)({
                bucketName: bucketArn,
                baseHostname: request.hostname,
                accelerateEndpoint: options.useAccelerateEndpoint,
                dualstackEndpoint: useDualstackEndpoint,
                fipsEndpoint: useFipsEndpoint,
                pathStyleEndpoint: options.forcePathStyle,
                tlsCompatible: request.protocol === "https:",
                useArnRegion,
                clientPartition: partition,
                clientSigningRegion: signingRegion,
                clientRegion: clientRegion,
                isCustomEndpoint: options.isCustomEndpoint,
                disableMultiregionAccessPoints: await options.disableMultiregionAccessPoints(),
            });
            if (modifiedSigningRegion && modifiedSigningRegion !== signingRegion) {
                context["signing_region"] = modifiedSigningRegion;
            }
            if (signingService && signingService !== "s3") {
                context["signing_service"] = signingService;
            }
            request.hostname = hostname;
            replaceBucketInPath = bucketEndpoint;
        }
        else {
            const clientRegion = await options.region();
            const dualstackEndpoint = await options.useDualstackEndpoint();
            const fipsEndpoint = await options.useFipsEndpoint();
            const { hostname, bucketEndpoint } = (0, bucketHostname_1.bucketHostname)({
                bucketName,
                clientRegion,
                baseHostname: request.hostname,
                accelerateEndpoint: options.useAccelerateEndpoint,
                dualstackEndpoint,
                fipsEndpoint,
                pathStyleEndpoint: options.forcePathStyle,
                tlsCompatible: request.protocol === "https:",
                isCustomEndpoint: options.isCustomEndpoint,
            });
            request.hostname = hostname;
            replaceBucketInPath = bucketEndpoint;
        }
        if (replaceBucketInPath) {
            request.path = request.path.replace(/^(\/)?[^\/]+/, "");
            if (request.path === "") {
                request.path = "/";
            }
        }
    }
    return next({ ...args, request });
};
exports.bucketEndpointMiddleware = bucketEndpointMiddleware;
exports.bucketEndpointMiddlewareOptions = {
    tags: ["BUCKET_ENDPOINT"],
    name: "bucketEndpointMiddleware",
    relation: "before",
    toMiddleware: "hostHeaderMiddleware",
    override: true,
};
const getBucketEndpointPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo((0, exports.bucketEndpointMiddleware)(options), exports.bucketEndpointMiddlewareOptions);
    },
});
exports.getBucketEndpointPlugin = getBucketEndpointPlugin;


/***/ }),

/***/ 9388:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bucketHostname = void 0;
const bucketHostnameUtils_1 = __nccwpck_require__(80848);
const bucketHostname = (options) => {
    (0, bucketHostnameUtils_1.validateCustomEndpoint)(options);
    return (0, bucketHostnameUtils_1.isBucketNameOptions)(options)
        ?
            getEndpointFromBucketName(options)
        :
            getEndpointFromArn(options);
};
exports.bucketHostname = bucketHostname;
const getEndpointFromBucketName = ({ accelerateEndpoint = false, clientRegion: region, baseHostname, bucketName, dualstackEndpoint = false, fipsEndpoint = false, pathStyleEndpoint = false, tlsCompatible = true, isCustomEndpoint = false, }) => {
    const [clientRegion, hostnameSuffix] = isCustomEndpoint ? [region, baseHostname] : (0, bucketHostnameUtils_1.getSuffix)(baseHostname);
    if (pathStyleEndpoint || !(0, bucketHostnameUtils_1.isDnsCompatibleBucketName)(bucketName) || (tlsCompatible && bucketHostnameUtils_1.DOT_PATTERN.test(bucketName))) {
        return {
            bucketEndpoint: false,
            hostname: dualstackEndpoint ? `s3.dualstack.${clientRegion}.${hostnameSuffix}` : baseHostname,
        };
    }
    if (accelerateEndpoint) {
        baseHostname = `s3-accelerate${dualstackEndpoint ? ".dualstack" : ""}.${hostnameSuffix}`;
    }
    else if (dualstackEndpoint) {
        baseHostname = `s3.dualstack.${clientRegion}.${hostnameSuffix}`;
    }
    return {
        bucketEndpoint: true,
        hostname: `${bucketName}.${baseHostname}`,
    };
};
const getEndpointFromArn = (options) => {
    const { isCustomEndpoint, baseHostname, clientRegion } = options;
    const hostnameSuffix = isCustomEndpoint ? baseHostname : (0, bucketHostnameUtils_1.getSuffixForArnEndpoint)(baseHostname)[1];
    const { pathStyleEndpoint, accelerateEndpoint = false, fipsEndpoint = false, tlsCompatible = true, bucketName, clientPartition = "aws", } = options;
    (0, bucketHostnameUtils_1.validateArnEndpointOptions)({ pathStyleEndpoint, accelerateEndpoint, tlsCompatible });
    const { service, partition, accountId, region, resource } = bucketName;
    (0, bucketHostnameUtils_1.validateService)(service);
    (0, bucketHostnameUtils_1.validatePartition)(partition, { clientPartition });
    (0, bucketHostnameUtils_1.validateAccountId)(accountId);
    const { accesspointName, outpostId } = (0, bucketHostnameUtils_1.getArnResources)(resource);
    if (service === "s3-object-lambda") {
        return getEndpointFromObjectLambdaArn({ ...options, tlsCompatible, bucketName, accesspointName, hostnameSuffix });
    }
    if (region === "") {
        return getEndpointFromMRAPArn({ ...options, clientRegion, mrapAlias: accesspointName, hostnameSuffix });
    }
    if (outpostId) {
        return getEndpointFromOutpostArn({ ...options, clientRegion, outpostId, accesspointName, hostnameSuffix });
    }
    return getEndpointFromAccessPointArn({ ...options, clientRegion, accesspointName, hostnameSuffix });
};
const getEndpointFromObjectLambdaArn = ({ dualstackEndpoint = false, fipsEndpoint = false, tlsCompatible = true, useArnRegion, clientRegion, clientSigningRegion = clientRegion, accesspointName, bucketName, hostnameSuffix, }) => {
    const { accountId, region, service } = bucketName;
    (0, bucketHostnameUtils_1.validateRegionalClient)(clientRegion);
    (0, bucketHostnameUtils_1.validateRegion)(region, {
        useArnRegion,
        clientRegion,
        clientSigningRegion,
        allowFipsRegion: true,
        useFipsEndpoint: fipsEndpoint,
    });
    (0, bucketHostnameUtils_1.validateNoDualstack)(dualstackEndpoint);
    const DNSHostLabel = `${accesspointName}-${accountId}`;
    (0, bucketHostnameUtils_1.validateDNSHostLabel)(DNSHostLabel, { tlsCompatible });
    const endpointRegion = useArnRegion ? region : clientRegion;
    const signingRegion = useArnRegion ? region : clientSigningRegion;
    return {
        bucketEndpoint: true,
        hostname: `${DNSHostLabel}.${service}${fipsEndpoint ? "-fips" : ""}.${endpointRegion}.${hostnameSuffix}`,
        signingRegion,
        signingService: service,
    };
};
const getEndpointFromMRAPArn = ({ disableMultiregionAccessPoints, dualstackEndpoint = false, isCustomEndpoint, mrapAlias, hostnameSuffix, }) => {
    if (disableMultiregionAccessPoints === true) {
        throw new Error("SDK is attempting to use a MRAP ARN. Please enable to feature.");
    }
    (0, bucketHostnameUtils_1.validateMrapAlias)(mrapAlias);
    (0, bucketHostnameUtils_1.validateNoDualstack)(dualstackEndpoint);
    return {
        bucketEndpoint: true,
        hostname: `${mrapAlias}${isCustomEndpoint ? "" : `.accesspoint.s3-global`}.${hostnameSuffix}`,
        signingRegion: "*",
    };
};
const getEndpointFromOutpostArn = ({ useArnRegion, clientRegion, clientSigningRegion = clientRegion, bucketName, outpostId, dualstackEndpoint = false, fipsEndpoint = false, tlsCompatible = true, accesspointName, isCustomEndpoint, hostnameSuffix, }) => {
    (0, bucketHostnameUtils_1.validateRegionalClient)(clientRegion);
    (0, bucketHostnameUtils_1.validateRegion)(bucketName.region, { useArnRegion, clientRegion, clientSigningRegion, useFipsEndpoint: fipsEndpoint });
    const DNSHostLabel = `${accesspointName}-${bucketName.accountId}`;
    (0, bucketHostnameUtils_1.validateDNSHostLabel)(DNSHostLabel, { tlsCompatible });
    const endpointRegion = useArnRegion ? bucketName.region : clientRegion;
    const signingRegion = useArnRegion ? bucketName.region : clientSigningRegion;
    (0, bucketHostnameUtils_1.validateOutpostService)(bucketName.service);
    (0, bucketHostnameUtils_1.validateDNSHostLabel)(outpostId, { tlsCompatible });
    (0, bucketHostnameUtils_1.validateNoDualstack)(dualstackEndpoint);
    (0, bucketHostnameUtils_1.validateNoFIPS)(fipsEndpoint);
    const hostnamePrefix = `${DNSHostLabel}.${outpostId}`;
    return {
        bucketEndpoint: true,
        hostname: `${hostnamePrefix}${isCustomEndpoint ? "" : `.s3-outposts.${endpointRegion}`}.${hostnameSuffix}`,
        signingRegion,
        signingService: "s3-outposts",
    };
};
const getEndpointFromAccessPointArn = ({ useArnRegion, clientRegion, clientSigningRegion = clientRegion, bucketName, dualstackEndpoint = false, fipsEndpoint = false, tlsCompatible = true, accesspointName, isCustomEndpoint, hostnameSuffix, }) => {
    (0, bucketHostnameUtils_1.validateRegionalClient)(clientRegion);
    (0, bucketHostnameUtils_1.validateRegion)(bucketName.region, {
        useArnRegion,
        clientRegion,
        clientSigningRegion,
        allowFipsRegion: true,
        useFipsEndpoint: fipsEndpoint,
    });
    const hostnamePrefix = `${accesspointName}-${bucketName.accountId}`;
    (0, bucketHostnameUtils_1.validateDNSHostLabel)(hostnamePrefix, { tlsCompatible });
    const endpointRegion = useArnRegion ? bucketName.region : clientRegion;
    const signingRegion = useArnRegion ? bucketName.region : clientSigningRegion;
    (0, bucketHostnameUtils_1.validateS3Service)(bucketName.service);
    return {
        bucketEndpoint: true,
        hostname: `${hostnamePrefix}${isCustomEndpoint
            ? ""
            : `.s3-accesspoint${fipsEndpoint ? "-fips" : ""}${dualstackEndpoint ? ".dualstack" : ""}.${endpointRegion}`}.${hostnameSuffix}`,
        signingRegion,
    };
};


/***/ }),

/***/ 80848:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateMrapAlias = exports.validateNoFIPS = exports.validateNoDualstack = exports.getArnResources = exports.validateCustomEndpoint = exports.validateDNSHostLabel = exports.validateAccountId = exports.validateRegionalClient = exports.validateRegion = exports.validatePartition = exports.validateOutpostService = exports.validateS3Service = exports.validateService = exports.validateArnEndpointOptions = exports.getSuffixForArnEndpoint = exports.getSuffix = exports.isDnsCompatibleBucketName = exports.isBucketNameOptions = exports.S3_HOSTNAME_PATTERN = exports.DOT_PATTERN = void 0;
const DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
const IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
const DOTS_PATTERN = /\.\./;
exports.DOT_PATTERN = /\./;
exports.S3_HOSTNAME_PATTERN = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./;
const S3_US_EAST_1_ALTNAME_PATTERN = /^s3(-external-1)?\.amazonaws\.com$/;
const AWS_PARTITION_SUFFIX = "amazonaws.com";
const isBucketNameOptions = (options) => typeof options.bucketName === "string";
exports.isBucketNameOptions = isBucketNameOptions;
const isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
exports.isDnsCompatibleBucketName = isDnsCompatibleBucketName;
const getRegionalSuffix = (hostname) => {
    const parts = hostname.match(exports.S3_HOSTNAME_PATTERN);
    return [parts[4], hostname.replace(new RegExp(`^${parts[0]}`), "")];
};
const getSuffix = (hostname) => S3_US_EAST_1_ALTNAME_PATTERN.test(hostname) ? ["us-east-1", AWS_PARTITION_SUFFIX] : getRegionalSuffix(hostname);
exports.getSuffix = getSuffix;
const getSuffixForArnEndpoint = (hostname) => S3_US_EAST_1_ALTNAME_PATTERN.test(hostname)
    ? [hostname.replace(`.${AWS_PARTITION_SUFFIX}`, ""), AWS_PARTITION_SUFFIX]
    : getRegionalSuffix(hostname);
exports.getSuffixForArnEndpoint = getSuffixForArnEndpoint;
const validateArnEndpointOptions = (options) => {
    if (options.pathStyleEndpoint) {
        throw new Error("Path-style S3 endpoint is not supported when bucket is an ARN");
    }
    if (options.accelerateEndpoint) {
        throw new Error("Accelerate endpoint is not supported when bucket is an ARN");
    }
    if (!options.tlsCompatible) {
        throw new Error("HTTPS is required when bucket is an ARN");
    }
};
exports.validateArnEndpointOptions = validateArnEndpointOptions;
const validateService = (service) => {
    if (service !== "s3" && service !== "s3-outposts" && service !== "s3-object-lambda") {
        throw new Error("Expect 's3' or 's3-outposts' or 's3-object-lambda' in ARN service component");
    }
};
exports.validateService = validateService;
const validateS3Service = (service) => {
    if (service !== "s3") {
        throw new Error("Expect 's3' in Accesspoint ARN service component");
    }
};
exports.validateS3Service = validateS3Service;
const validateOutpostService = (service) => {
    if (service !== "s3-outposts") {
        throw new Error("Expect 's3-posts' in Outpost ARN service component");
    }
};
exports.validateOutpostService = validateOutpostService;
const validatePartition = (partition, options) => {
    if (partition !== options.clientPartition) {
        throw new Error(`Partition in ARN is incompatible, got "${partition}" but expected "${options.clientPartition}"`);
    }
};
exports.validatePartition = validatePartition;
const validateRegion = (region, options) => {
    if (region === "") {
        throw new Error("ARN region is empty");
    }
    if (options.useFipsEndpoint) {
        if (!options.allowFipsRegion) {
            throw new Error("FIPS region is not supported");
        }
        else if (!isEqualRegions(region, options.clientRegion)) {
            throw new Error(`Client FIPS region ${options.clientRegion} doesn't match region ${region} in ARN`);
        }
    }
    if (!options.useArnRegion &&
        !isEqualRegions(region, options.clientRegion || "") &&
        !isEqualRegions(region, options.clientSigningRegion || "")) {
        throw new Error(`Region in ARN is incompatible, got ${region} but expected ${options.clientRegion}`);
    }
};
exports.validateRegion = validateRegion;
const validateRegionalClient = (region) => {
    if (["s3-external-1", "aws-global"].includes(region)) {
        throw new Error(`Client region ${region} is not regional`);
    }
};
exports.validateRegionalClient = validateRegionalClient;
const isEqualRegions = (regionA, regionB) => regionA === regionB;
const validateAccountId = (accountId) => {
    if (!/[0-9]{12}/.exec(accountId)) {
        throw new Error("Access point ARN accountID does not match regex '[0-9]{12}'");
    }
};
exports.validateAccountId = validateAccountId;
const validateDNSHostLabel = (label, options = { tlsCompatible: true }) => {
    if (label.length >= 64 ||
        !/^[a-z0-9][a-z0-9.-]*[a-z0-9]$/.test(label) ||
        /(\d+\.){3}\d+/.test(label) ||
        /[.-]{2}/.test(label) ||
        ((options === null || options === void 0 ? void 0 : options.tlsCompatible) && exports.DOT_PATTERN.test(label))) {
        throw new Error(`Invalid DNS label ${label}`);
    }
};
exports.validateDNSHostLabel = validateDNSHostLabel;
const validateCustomEndpoint = (options) => {
    if (options.isCustomEndpoint) {
        if (options.dualstackEndpoint)
            throw new Error("Dualstack endpoint is not supported with custom endpoint");
        if (options.accelerateEndpoint)
            throw new Error("Accelerate endpoint is not supported with custom endpoint");
    }
};
exports.validateCustomEndpoint = validateCustomEndpoint;
const getArnResources = (resource) => {
    const delimiter = resource.includes(":") ? ":" : "/";
    const [resourceType, ...rest] = resource.split(delimiter);
    if (resourceType === "accesspoint") {
        if (rest.length !== 1 || rest[0] === "") {
            throw new Error(`Access Point ARN should have one resource accesspoint${delimiter}{accesspointname}`);
        }
        return { accesspointName: rest[0] };
    }
    else if (resourceType === "outpost") {
        if (!rest[0] || rest[1] !== "accesspoint" || !rest[2] || rest.length !== 3) {
            throw new Error(`Outpost ARN should have resource outpost${delimiter}{outpostId}${delimiter}accesspoint${delimiter}{accesspointName}`);
        }
        const [outpostId, _, accesspointName] = rest;
        return { outpostId, accesspointName };
    }
    else {
        throw new Error(`ARN resource should begin with 'accesspoint${delimiter}' or 'outpost${delimiter}'`);
    }
};
exports.getArnResources = getArnResources;
const validateNoDualstack = (dualstackEndpoint) => {
    if (dualstackEndpoint)
        throw new Error("Dualstack endpoint is not supported with Outpost or Multi-region Access Point ARN.");
};
exports.validateNoDualstack = validateNoDualstack;
const validateNoFIPS = (useFipsEndpoint) => {
    if (useFipsEndpoint)
        throw new Error(`FIPS region is not supported with Outpost.`);
};
exports.validateNoFIPS = validateNoFIPS;
const validateMrapAlias = (name) => {
    try {
        name.split(".").forEach((label) => {
            (0, exports.validateDNSHostLabel)(label);
        });
    }
    catch (e) {
        throw new Error(`"${name}" is not a DNS compatible name.`);
    }
};
exports.validateMrapAlias = validateMrapAlias;


/***/ }),

/***/ 7946:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveBucketEndpointConfig = void 0;
function resolveBucketEndpointConfig(input) {
    const { bucketEndpoint = false, forcePathStyle = false, useAccelerateEndpoint = false, useArnRegion = false, disableMultiregionAccessPoints = false, } = input;
    return {
        ...input,
        bucketEndpoint,
        forcePathStyle,
        useAccelerateEndpoint,
        useArnRegion: typeof useArnRegion === "function" ? useArnRegion : () => Promise.resolve(useArnRegion),
        disableMultiregionAccessPoints: typeof disableMultiregionAccessPoints === "function"
            ? disableMultiregionAccessPoints
            : () => Promise.resolve(disableMultiregionAccessPoints),
    };
}
exports.resolveBucketEndpointConfig = resolveBucketEndpointConfig;


/***/ }),

/***/ 96689:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateNoFIPS = exports.validateNoDualstack = exports.validateDNSHostLabel = exports.validateRegion = exports.validateAccountId = exports.validatePartition = exports.validateOutpostService = exports.getSuffixForArnEndpoint = exports.getArnResources = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(83939), exports);
tslib_1.__exportStar(__nccwpck_require__(98580), exports);
tslib_1.__exportStar(__nccwpck_require__(60504), exports);
tslib_1.__exportStar(__nccwpck_require__(9388), exports);
tslib_1.__exportStar(__nccwpck_require__(7946), exports);
var bucketHostnameUtils_1 = __nccwpck_require__(80848);
Object.defineProperty(exports, "getArnResources", ({ enumerable: true, get: function () { return bucketHostnameUtils_1.getArnResources; } }));
Object.defineProperty(exports, "getSuffixForArnEndpoint", ({ enumerable: true, get: function () { return bucketHostnameUtils_1.getSuffixForArnEndpoint; } }));
Object.defineProperty(exports, "validateOutpostService", ({ enumerable: true, get: function () { return bucketHostnameUtils_1.validateOutpostService; } }));
Object.defineProperty(exports, "validatePartition", ({ enumerable: true, get: function () { return bucketHostnameUtils_1.validatePartition; } }));
Object.defineProperty(exports, "validateAccountId", ({ enumerable: true, get: function () { return bucketHostnameUtils_1.validateAccountId; } }));
Object.defineProperty(exports, "validateRegion", ({ enumerable: true, get: function () { return bucketHostnameUtils_1.validateRegion; } }));
Object.defineProperty(exports, "validateDNSHostLabel", ({ enumerable: true, get: function () { return bucketHostnameUtils_1.validateDNSHostLabel; } }));
Object.defineProperty(exports, "validateNoDualstack", ({ enumerable: true, get: function () { return bucketHostnameUtils_1.validateNoDualstack; } }));
Object.defineProperty(exports, "validateNoFIPS", ({ enumerable: true, get: function () { return bucketHostnameUtils_1.validateNoFIPS; } }));


/***/ }),

/***/ 81990:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAddExpectContinuePlugin = exports.addExpectContinueMiddlewareOptions = exports.addExpectContinueMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
function addExpectContinueMiddleware(options) {
    return (next) => async (args) => {
        const { request } = args;
        if (protocol_http_1.HttpRequest.isInstance(request) && request.body && options.runtime === "node") {
            request.headers = {
                ...request.headers,
                Expect: "100-continue",
            };
        }
        return next({
            ...args,
            request,
        });
    };
}
exports.addExpectContinueMiddleware = addExpectContinueMiddleware;
exports.addExpectContinueMiddlewareOptions = {
    step: "build",
    tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
    name: "addExpectContinueMiddleware",
    override: true,
};
const getAddExpectContinuePlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(addExpectContinueMiddleware(options), exports.addExpectContinueMiddlewareOptions);
    },
});
exports.getAddExpectContinuePlugin = getAddExpectContinuePlugin;


/***/ }),

/***/ 5972:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.S3_EXPRESS_DEFAULT_CHECKSUM_ALGORITHM = exports.DEFAULT_CHECKSUM_ALGORITHM = exports.ChecksumLocation = exports.ChecksumAlgorithm = void 0;
var ChecksumAlgorithm;
(function (ChecksumAlgorithm) {
    ChecksumAlgorithm["MD5"] = "MD5";
    ChecksumAlgorithm["CRC32"] = "CRC32";
    ChecksumAlgorithm["CRC32C"] = "CRC32C";
    ChecksumAlgorithm["SHA1"] = "SHA1";
    ChecksumAlgorithm["SHA256"] = "SHA256";
})(ChecksumAlgorithm = exports.ChecksumAlgorithm || (exports.ChecksumAlgorithm = {}));
var ChecksumLocation;
(function (ChecksumLocation) {
    ChecksumLocation["HEADER"] = "header";
    ChecksumLocation["TRAILER"] = "trailer";
})(ChecksumLocation = exports.ChecksumLocation || (exports.ChecksumLocation = {}));
exports.DEFAULT_CHECKSUM_ALGORITHM = ChecksumAlgorithm.MD5;
exports.S3_EXPRESS_DEFAULT_CHECKSUM_ALGORITHM = ChecksumAlgorithm.CRC32;


/***/ }),

/***/ 20825:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.flexibleChecksumsMiddleware = exports.flexibleChecksumsMiddlewareOptions = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const getChecksumAlgorithmForRequest_1 = __nccwpck_require__(13218);
const getChecksumLocationName_1 = __nccwpck_require__(95633);
const hasHeader_1 = __nccwpck_require__(37878);
const isStreaming_1 = __nccwpck_require__(94786);
const selectChecksumAlgorithmFunction_1 = __nccwpck_require__(30513);
const stringHasher_1 = __nccwpck_require__(73044);
exports.flexibleChecksumsMiddlewareOptions = {
    name: "flexibleChecksumsMiddleware",
    step: "build",
    tags: ["BODY_CHECKSUM"],
    override: true,
};
const flexibleChecksumsMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
    if (!protocol_http_1.HttpRequest.isInstance(args.request)) {
        return next(args);
    }
    const { request } = args;
    const { body: requestBody, headers } = request;
    const { base64Encoder, streamHasher } = config;
    const { input, requestChecksumRequired, requestAlgorithmMember } = middlewareConfig;
    const checksumAlgorithm = (0, getChecksumAlgorithmForRequest_1.getChecksumAlgorithmForRequest)(input, {
        requestChecksumRequired,
        requestAlgorithmMember,
    }, !!context.isS3ExpressBucket);
    let updatedBody = requestBody;
    let updatedHeaders = headers;
    if (checksumAlgorithm) {
        const checksumLocationName = (0, getChecksumLocationName_1.getChecksumLocationName)(checksumAlgorithm);
        const checksumAlgorithmFn = (0, selectChecksumAlgorithmFunction_1.selectChecksumAlgorithmFunction)(checksumAlgorithm, config);
        if ((0, isStreaming_1.isStreaming)(requestBody)) {
            const { getAwsChunkedEncodingStream, bodyLengthChecker } = config;
            updatedBody = getAwsChunkedEncodingStream(requestBody, {
                base64Encoder,
                bodyLengthChecker,
                checksumLocationName,
                checksumAlgorithmFn,
                streamHasher,
            });
            updatedHeaders = {
                ...headers,
                "content-encoding": headers["content-encoding"]
                    ? `${headers["content-encoding"]},aws-chunked`
                    : "aws-chunked",
                "transfer-encoding": "chunked",
                "x-amz-decoded-content-length": headers["content-length"],
                "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
                "x-amz-trailer": checksumLocationName,
            };
            delete updatedHeaders["content-length"];
        }
        else if (!(0, hasHeader_1.hasHeader)(checksumLocationName, headers)) {
            const rawChecksum = await (0, stringHasher_1.stringHasher)(checksumAlgorithmFn, requestBody);
            updatedHeaders = {
                ...headers,
                [checksumLocationName]: base64Encoder(rawChecksum),
            };
        }
    }
    const result = await next({
        ...args,
        request: {
            ...request,
            headers: updatedHeaders,
            body: updatedBody,
        },
    });
    return result;
};
exports.flexibleChecksumsMiddleware = flexibleChecksumsMiddleware;


/***/ }),

/***/ 57525:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.flexibleChecksumsResponseMiddleware = exports.flexibleChecksumsResponseMiddlewareOptions = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const getChecksumAlgorithmListForResponse_1 = __nccwpck_require__(29245);
const getChecksumLocationName_1 = __nccwpck_require__(95633);
const isChecksumWithPartNumber_1 = __nccwpck_require__(26439);
const isStreaming_1 = __nccwpck_require__(94786);
const create_read_stream_on_buffer_1 = __nccwpck_require__(93920);
const validateChecksumFromResponse_1 = __nccwpck_require__(91773);
exports.flexibleChecksumsResponseMiddlewareOptions = {
    name: "flexibleChecksumsResponseMiddleware",
    toMiddleware: "deserializerMiddleware",
    relation: "after",
    tags: ["BODY_CHECKSUM"],
    override: true,
};
const flexibleChecksumsResponseMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
    if (!protocol_http_1.HttpRequest.isInstance(args.request)) {
        return next(args);
    }
    const input = args.input;
    const result = await next(args);
    const response = result.response;
    let collectedStream = undefined;
    const { requestValidationModeMember, responseAlgorithms } = middlewareConfig;
    if (requestValidationModeMember && input[requestValidationModeMember] === "ENABLED") {
        const { clientName, commandName } = context;
        const isS3WholeObjectMultipartGetResponseChecksum = clientName === "S3Client" &&
            commandName === "GetObjectCommand" &&
            (0, getChecksumAlgorithmListForResponse_1.getChecksumAlgorithmListForResponse)(responseAlgorithms).every((algorithm) => {
                const responseHeader = (0, getChecksumLocationName_1.getChecksumLocationName)(algorithm);
                const checksumFromResponse = response.headers[responseHeader];
                return !checksumFromResponse || (0, isChecksumWithPartNumber_1.isChecksumWithPartNumber)(checksumFromResponse);
            });
        if (isS3WholeObjectMultipartGetResponseChecksum) {
            return result;
        }
        const isStreamingBody = (0, isStreaming_1.isStreaming)(response.body);
        if (isStreamingBody) {
            collectedStream = await config.streamCollector(response.body);
            response.body = (0, create_read_stream_on_buffer_1.createReadStreamOnBuffer)(collectedStream);
        }
        await (0, validateChecksumFromResponse_1.validateChecksumFromResponse)(result.response, {
            config,
            responseAlgorithms,
        });
        if (isStreamingBody && collectedStream) {
            response.body = (0, create_read_stream_on_buffer_1.createReadStreamOnBuffer)(collectedStream);
        }
    }
    return result;
};
exports.flexibleChecksumsResponseMiddleware = flexibleChecksumsResponseMiddleware;


/***/ }),

/***/ 23568:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getChecksum = void 0;
const isStreaming_1 = __nccwpck_require__(94786);
const stringHasher_1 = __nccwpck_require__(73044);
const getChecksum = async (body, { streamHasher, checksumAlgorithmFn, base64Encoder }) => {
    const digest = (0, isStreaming_1.isStreaming)(body) ? streamHasher(checksumAlgorithmFn, body) : (0, stringHasher_1.stringHasher)(checksumAlgorithmFn, body);
    return base64Encoder(await digest);
};
exports.getChecksum = getChecksum;


/***/ }),

/***/ 13218:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getChecksumAlgorithmForRequest = void 0;
const constants_1 = __nccwpck_require__(5972);
const types_1 = __nccwpck_require__(70724);
const getChecksumAlgorithmForRequest = (input, { requestChecksumRequired, requestAlgorithmMember }, isS3Express) => {
    const defaultAlgorithm = isS3Express ? constants_1.S3_EXPRESS_DEFAULT_CHECKSUM_ALGORITHM : constants_1.DEFAULT_CHECKSUM_ALGORITHM;
    if (!requestAlgorithmMember || !input[requestAlgorithmMember]) {
        return requestChecksumRequired ? defaultAlgorithm : undefined;
    }
    const checksumAlgorithm = input[requestAlgorithmMember];
    if (!types_1.CLIENT_SUPPORTED_ALGORITHMS.includes(checksumAlgorithm)) {
        throw new Error(`The checksum algorithm "${checksumAlgorithm}" is not supported by the client.` +
            ` Select one of ${types_1.CLIENT_SUPPORTED_ALGORITHMS}.`);
    }
    return checksumAlgorithm;
};
exports.getChecksumAlgorithmForRequest = getChecksumAlgorithmForRequest;


/***/ }),

/***/ 29245:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getChecksumAlgorithmListForResponse = void 0;
const types_1 = __nccwpck_require__(70724);
const getChecksumAlgorithmListForResponse = (responseAlgorithms = []) => {
    const validChecksumAlgorithms = [];
    for (const algorithm of types_1.PRIORITY_ORDER_ALGORITHMS) {
        if (!responseAlgorithms.includes(algorithm) || !types_1.CLIENT_SUPPORTED_ALGORITHMS.includes(algorithm)) {
            continue;
        }
        validChecksumAlgorithms.push(algorithm);
    }
    return validChecksumAlgorithms;
};
exports.getChecksumAlgorithmListForResponse = getChecksumAlgorithmListForResponse;


/***/ }),

/***/ 95633:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getChecksumLocationName = void 0;
const constants_1 = __nccwpck_require__(5972);
const getChecksumLocationName = (algorithm) => algorithm === constants_1.ChecksumAlgorithm.MD5 ? "content-md5" : `x-amz-checksum-${algorithm.toLowerCase()}`;
exports.getChecksumLocationName = getChecksumLocationName;


/***/ }),

/***/ 75028:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFlexibleChecksumsPlugin = void 0;
const flexibleChecksumsMiddleware_1 = __nccwpck_require__(20825);
const flexibleChecksumsResponseMiddleware_1 = __nccwpck_require__(57525);
const getFlexibleChecksumsPlugin = (config, middlewareConfig) => ({
    applyToStack: (clientStack) => {
        clientStack.add((0, flexibleChecksumsMiddleware_1.flexibleChecksumsMiddleware)(config, middlewareConfig), flexibleChecksumsMiddleware_1.flexibleChecksumsMiddlewareOptions);
        clientStack.addRelativeTo((0, flexibleChecksumsResponseMiddleware_1.flexibleChecksumsResponseMiddleware)(config, middlewareConfig), flexibleChecksumsResponseMiddleware_1.flexibleChecksumsResponseMiddlewareOptions);
    },
});
exports.getFlexibleChecksumsPlugin = getFlexibleChecksumsPlugin;


/***/ }),

/***/ 37878:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasHeader = void 0;
const hasHeader = (header, headers) => {
    const soughtHeader = header.toLowerCase();
    for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
            return true;
        }
    }
    return false;
};
exports.hasHeader = hasHeader;


/***/ }),

/***/ 13799:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(5972), exports);
tslib_1.__exportStar(__nccwpck_require__(20825), exports);
tslib_1.__exportStar(__nccwpck_require__(75028), exports);


/***/ }),

/***/ 26439:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isChecksumWithPartNumber = void 0;
const isChecksumWithPartNumber = (checksum) => {
    const lastHyphenIndex = checksum.lastIndexOf("-");
    if (lastHyphenIndex !== -1) {
        const numberPart = checksum.slice(lastHyphenIndex + 1);
        if (!numberPart.startsWith("0")) {
            const number = parseInt(numberPart, 10);
            if (!isNaN(number) && number >= 1 && number <= 10000) {
                return true;
            }
        }
    }
    return false;
};
exports.isChecksumWithPartNumber = isChecksumWithPartNumber;


/***/ }),

/***/ 94786:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isStreaming = void 0;
const is_array_buffer_1 = __nccwpck_require__(10780);
const isStreaming = (body) => body !== undefined && typeof body !== "string" && !ArrayBuffer.isView(body) && !(0, is_array_buffer_1.isArrayBuffer)(body);
exports.isStreaming = isStreaming;


/***/ }),

/***/ 30513:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.selectChecksumAlgorithmFunction = void 0;
const crc32_1 = __nccwpck_require__(47327);
const crc32c_1 = __nccwpck_require__(27507);
const constants_1 = __nccwpck_require__(5972);
const selectChecksumAlgorithmFunction = (checksumAlgorithm, config) => ({
    [constants_1.ChecksumAlgorithm.MD5]: config.md5,
    [constants_1.ChecksumAlgorithm.CRC32]: crc32_1.AwsCrc32,
    [constants_1.ChecksumAlgorithm.CRC32C]: crc32c_1.AwsCrc32c,
    [constants_1.ChecksumAlgorithm.SHA1]: config.sha1,
    [constants_1.ChecksumAlgorithm.SHA256]: config.sha256,
}[checksumAlgorithm]);
exports.selectChecksumAlgorithmFunction = selectChecksumAlgorithmFunction;


/***/ }),

/***/ 93920:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createReadStreamOnBuffer = void 0;
const stream_1 = __nccwpck_require__(12781);
function createReadStreamOnBuffer(buffer) {
    const stream = new stream_1.Transform();
    stream.push(buffer);
    stream.push(null);
    return stream;
}
exports.createReadStreamOnBuffer = createReadStreamOnBuffer;


/***/ }),

/***/ 73044:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringHasher = void 0;
const util_utf8_1 = __nccwpck_require__(41895);
const stringHasher = (checksumAlgorithmFn, body) => {
    const hash = new checksumAlgorithmFn();
    hash.update((0, util_utf8_1.toUint8Array)(body || ""));
    return hash.digest();
};
exports.stringHasher = stringHasher;


/***/ }),

/***/ 70724:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PRIORITY_ORDER_ALGORITHMS = exports.CLIENT_SUPPORTED_ALGORITHMS = void 0;
const constants_1 = __nccwpck_require__(5972);
exports.CLIENT_SUPPORTED_ALGORITHMS = [
    constants_1.ChecksumAlgorithm.CRC32,
    constants_1.ChecksumAlgorithm.CRC32C,
    constants_1.ChecksumAlgorithm.SHA1,
    constants_1.ChecksumAlgorithm.SHA256,
];
exports.PRIORITY_ORDER_ALGORITHMS = [
    constants_1.ChecksumAlgorithm.CRC32,
    constants_1.ChecksumAlgorithm.CRC32C,
    constants_1.ChecksumAlgorithm.SHA1,
    constants_1.ChecksumAlgorithm.SHA256,
];


/***/ }),

/***/ 91773:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateChecksumFromResponse = void 0;
const getChecksum_1 = __nccwpck_require__(23568);
const getChecksumAlgorithmListForResponse_1 = __nccwpck_require__(29245);
const getChecksumLocationName_1 = __nccwpck_require__(95633);
const selectChecksumAlgorithmFunction_1 = __nccwpck_require__(30513);
const validateChecksumFromResponse = async (response, { config, responseAlgorithms }) => {
    const checksumAlgorithms = (0, getChecksumAlgorithmListForResponse_1.getChecksumAlgorithmListForResponse)(responseAlgorithms);
    const { body: responseBody, headers: responseHeaders } = response;
    for (const algorithm of checksumAlgorithms) {
        const responseHeader = (0, getChecksumLocationName_1.getChecksumLocationName)(algorithm);
        const checksumFromResponse = responseHeaders[responseHeader];
        if (checksumFromResponse) {
            const checksumAlgorithmFn = (0, selectChecksumAlgorithmFunction_1.selectChecksumAlgorithmFunction)(algorithm, config);
            const { streamHasher, base64Encoder } = config;
            const checksum = await (0, getChecksum_1.getChecksum)(responseBody, { streamHasher, checksumAlgorithmFn, base64Encoder });
            if (checksum === checksumFromResponse) {
                break;
            }
            throw new Error(`Checksum mismatch: expected "${checksum}" but received "${checksumFromResponse}"` +
                ` in response header "${responseHeader}".`);
        }
    }
};
exports.validateChecksumFromResponse = validateChecksumFromResponse;


/***/ }),

/***/ 22545:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHostHeaderPlugin = exports.hostHeaderMiddlewareOptions = exports.hostHeaderMiddleware = exports.resolveHostHeaderConfig = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
function resolveHostHeaderConfig(input) {
    return input;
}
exports.resolveHostHeaderConfig = resolveHostHeaderConfig;
const hostHeaderMiddleware = (options) => (next) => async (args) => {
    if (!protocol_http_1.HttpRequest.isInstance(args.request))
        return next(args);
    const { request } = args;
    const { handlerProtocol = "" } = options.requestHandler.metadata || {};
    if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
        delete request.headers["host"];
        request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
    }
    else if (!request.headers["host"]) {
        let host = request.hostname;
        if (request.port != null)
            host += `:${request.port}`;
        request.headers["host"] = host;
    }
    return next(args);
};
exports.hostHeaderMiddleware = hostHeaderMiddleware;
exports.hostHeaderMiddlewareOptions = {
    name: "hostHeaderMiddleware",
    step: "build",
    priority: "low",
    tags: ["HOST"],
    override: true,
};
const getHostHeaderPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add((0, exports.hostHeaderMiddleware)(options), exports.hostHeaderMiddlewareOptions);
    },
});
exports.getHostHeaderPlugin = getHostHeaderPlugin;


/***/ }),

/***/ 42098:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLocationConstraintPlugin = exports.locationConstraintMiddlewareOptions = exports.locationConstraintMiddleware = void 0;
function locationConstraintMiddleware(options) {
    return (next) => async (args) => {
        const { CreateBucketConfiguration } = args.input;
        const region = await options.region();
        if (!(CreateBucketConfiguration === null || CreateBucketConfiguration === void 0 ? void 0 : CreateBucketConfiguration.LocationConstraint) && !(CreateBucketConfiguration === null || CreateBucketConfiguration === void 0 ? void 0 : CreateBucketConfiguration.Location)) {
            args = {
                ...args,
                input: {
                    ...args.input,
                    CreateBucketConfiguration: region === "us-east-1" ? undefined : { LocationConstraint: region },
                },
            };
        }
        return next(args);
    };
}
exports.locationConstraintMiddleware = locationConstraintMiddleware;
exports.locationConstraintMiddlewareOptions = {
    step: "initialize",
    tags: ["LOCATION_CONSTRAINT", "CREATE_BUCKET_CONFIGURATION"],
    name: "locationConstraintMiddleware",
    override: true,
};
const getLocationConstraintPlugin = (config) => ({
    applyToStack: (clientStack) => {
        clientStack.add(locationConstraintMiddleware(config), exports.locationConstraintMiddlewareOptions);
    },
});
exports.getLocationConstraintPlugin = getLocationConstraintPlugin;


/***/ }),

/***/ 20014:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(9754), exports);


/***/ }),

/***/ 9754:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLoggerPlugin = exports.loggerMiddlewareOptions = exports.loggerMiddleware = void 0;
const loggerMiddleware = () => (next, context) => async (args) => {
    var _a, _b;
    try {
        const response = await next(args);
        const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
        const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog !== null && overrideInputFilterSensitiveLog !== void 0 ? overrideInputFilterSensitiveLog : context.inputFilterSensitiveLog;
        const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog !== null && overrideOutputFilterSensitiveLog !== void 0 ? overrideOutputFilterSensitiveLog : context.outputFilterSensitiveLog;
        const { $metadata, ...outputWithoutMetadata } = response.output;
        (_a = logger === null || logger === void 0 ? void 0 : logger.info) === null || _a === void 0 ? void 0 : _a.call(logger, {
            clientName,
            commandName,
            input: inputFilterSensitiveLog(args.input),
            output: outputFilterSensitiveLog(outputWithoutMetadata),
            metadata: $metadata,
        });
        return response;
    }
    catch (error) {
        const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
        const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog !== null && overrideInputFilterSensitiveLog !== void 0 ? overrideInputFilterSensitiveLog : context.inputFilterSensitiveLog;
        (_b = logger === null || logger === void 0 ? void 0 : logger.error) === null || _b === void 0 ? void 0 : _b.call(logger, {
            clientName,
            commandName,
            input: inputFilterSensitiveLog(args.input),
            error,
            metadata: error.$metadata,
        });
        throw error;
    }
};
exports.loggerMiddleware = loggerMiddleware;
exports.loggerMiddlewareOptions = {
    name: "loggerMiddleware",
    tags: ["LOGGER"],
    step: "initialize",
    override: true,
};
const getLoggerPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add((0, exports.loggerMiddleware)(), exports.loggerMiddlewareOptions);
    },
});
exports.getLoggerPlugin = getLoggerPlugin;


/***/ }),

/***/ 85525:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRecursionDetectionPlugin = exports.addRecursionDetectionMiddlewareOptions = exports.recursionDetectionMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
const ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
const ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
const recursionDetectionMiddleware = (options) => (next) => async (args) => {
    const { request } = args;
    if (!protocol_http_1.HttpRequest.isInstance(request) ||
        options.runtime !== "node" ||
        request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
        return next(args);
    }
    const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
    const traceId = process.env[ENV_TRACE_ID];
    const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
    if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
        request.headers[TRACE_ID_HEADER_NAME] = traceId;
    }
    return next({
        ...args,
        request,
    });
};
exports.recursionDetectionMiddleware = recursionDetectionMiddleware;
exports.addRecursionDetectionMiddlewareOptions = {
    step: "build",
    tags: ["RECURSION_DETECTION"],
    name: "recursionDetectionMiddleware",
    override: true,
    priority: "low",
};
const getRecursionDetectionPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add((0, exports.recursionDetectionMiddleware)(options), exports.addRecursionDetectionMiddlewareOptions);
    },
});
exports.getRecursionDetectionPlugin = getRecursionDetectionPlugin;


/***/ }),

/***/ 51671:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCheckContentLengthHeaderPlugin = exports.checkContentLengthHeaderMiddlewareOptions = exports.checkContentLengthHeader = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const smithy_client_1 = __nccwpck_require__(63570);
const CONTENT_LENGTH_HEADER = "content-length";
function checkContentLengthHeader() {
    return (next, context) => async (args) => {
        var _a;
        const { request } = args;
        if (protocol_http_1.HttpRequest.isInstance(request)) {
            if (!request.headers[CONTENT_LENGTH_HEADER]) {
                const message = `Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage.`;
                if (typeof ((_a = context === null || context === void 0 ? void 0 : context.logger) === null || _a === void 0 ? void 0 : _a.warn) === "function" && !(context.logger instanceof smithy_client_1.NoOpLogger)) {
                    context.logger.warn(message);
                }
                else {
                    console.warn(message);
                }
            }
        }
        return next({ ...args });
    };
}
exports.checkContentLengthHeader = checkContentLengthHeader;
exports.checkContentLengthHeaderMiddlewareOptions = {
    step: "finalizeRequest",
    tags: ["CHECK_CONTENT_LENGTH_HEADER"],
    name: "getCheckContentLengthHeaderPlugin",
    override: true,
};
const getCheckContentLengthHeaderPlugin = (unused) => ({
    applyToStack: (clientStack) => {
        clientStack.add(checkContentLengthHeader(), exports.checkContentLengthHeaderMiddlewareOptions);
    },
});
exports.getCheckContentLengthHeaderPlugin = getCheckContentLengthHeaderPlugin;


/***/ }),

/***/ 81139:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(51671), exports);
tslib_1.__exportStar(__nccwpck_require__(34332), exports);
tslib_1.__exportStar(__nccwpck_require__(7552), exports);
tslib_1.__exportStar(__nccwpck_require__(84253), exports);
tslib_1.__exportStar(__nccwpck_require__(15537), exports);
tslib_1.__exportStar(__nccwpck_require__(10404), exports);
tslib_1.__exportStar(__nccwpck_require__(56777), exports);


/***/ }),

/***/ 34332:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.regionRedirectEndpointMiddlewareOptions = exports.regionRedirectEndpointMiddleware = void 0;
const regionRedirectEndpointMiddleware = (config) => {
    return (next, context) => async (args) => {
        const originalRegion = await config.region();
        const regionProviderRef = config.region;
        if (context.__s3RegionRedirect) {
            config.region = async () => {
                config.region = regionProviderRef;
                return context.__s3RegionRedirect;
            };
        }
        const result = await next(args);
        if (context.__s3RegionRedirect) {
            const region = await config.region();
            if (originalRegion !== region) {
                throw new Error("Region was not restored following S3 region redirect.");
            }
        }
        return result;
    };
};
exports.regionRedirectEndpointMiddleware = regionRedirectEndpointMiddleware;
exports.regionRedirectEndpointMiddlewareOptions = {
    tags: ["REGION_REDIRECT", "S3"],
    name: "regionRedirectEndpointMiddleware",
    override: true,
    relation: "before",
    toMiddleware: "endpointV2Middleware",
};


/***/ }),

/***/ 7552:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRegionRedirectMiddlewarePlugin = exports.regionRedirectMiddlewareOptions = exports.regionRedirectMiddleware = void 0;
const region_redirect_endpoint_middleware_1 = __nccwpck_require__(34332);
function regionRedirectMiddleware(clientConfig) {
    return (next, context) => async (args) => {
        var _a, _b;
        try {
            return await next(args);
        }
        catch (err) {
            if (clientConfig.followRegionRedirects &&
                ((_a = err === null || err === void 0 ? void 0 : err.$metadata) === null || _a === void 0 ? void 0 : _a.httpStatusCode) === 301) {
                try {
                    const actualRegion = err.$response.headers["x-amz-bucket-region"];
                    (_b = context.logger) === null || _b === void 0 ? void 0 : _b.debug(`Redirecting from ${await clientConfig.region()} to ${actualRegion}`);
                    context.__s3RegionRedirect = actualRegion;
                }
                catch (e) {
                    throw new Error("Region redirect failed: " + e);
                }
                return next(args);
            }
            else {
                throw err;
            }
        }
    };
}
exports.regionRedirectMiddleware = regionRedirectMiddleware;
exports.regionRedirectMiddlewareOptions = {
    step: "initialize",
    tags: ["REGION_REDIRECT", "S3"],
    name: "regionRedirectMiddleware",
    override: true,
};
const getRegionRedirectMiddlewarePlugin = (clientConfig) => ({
    applyToStack: (clientStack) => {
        clientStack.add(regionRedirectMiddleware(clientConfig), exports.regionRedirectMiddlewareOptions);
        clientStack.addRelativeTo((0, region_redirect_endpoint_middleware_1.regionRedirectEndpointMiddleware)(clientConfig), region_redirect_endpoint_middleware_1.regionRedirectEndpointMiddlewareOptions);
    },
});
exports.getRegionRedirectMiddlewarePlugin = getRegionRedirectMiddlewarePlugin;


/***/ }),

/***/ 86434:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.S3ExpressIdentityCache = void 0;
class S3ExpressIdentityCache {
    constructor(data = {}) {
        this.data = data;
        this.lastPurgeTime = Date.now();
    }
    get(key) {
        const entry = this.data[key];
        if (!entry) {
            return;
        }
        return entry;
    }
    set(key, entry) {
        this.data[key] = entry;
        return entry;
    }
    delete(key) {
        delete this.data[key];
    }
    async purgeExpired() {
        const now = Date.now();
        if (this.lastPurgeTime + S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > now) {
            return;
        }
        for (const key in this.data) {
            const entry = this.data[key];
            if (!entry.isRefreshing) {
                const credential = await entry.identity;
                if (credential.expiration) {
                    if (credential.expiration.getTime() < now) {
                        delete this.data[key];
                    }
                }
            }
        }
    }
}
exports.S3ExpressIdentityCache = S3ExpressIdentityCache;
S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 30000;


/***/ }),

/***/ 16667:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.S3ExpressIdentityCacheEntry = void 0;
class S3ExpressIdentityCacheEntry {
    constructor(_identity, isRefreshing = false, accessed = Date.now()) {
        this._identity = _identity;
        this.isRefreshing = isRefreshing;
        this.accessed = accessed;
    }
    get identity() {
        this.accessed = Date.now();
        return this._identity;
    }
}
exports.S3ExpressIdentityCacheEntry = S3ExpressIdentityCacheEntry;


/***/ }),

/***/ 2895:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.S3ExpressIdentityProviderImpl = void 0;
const S3ExpressIdentityCache_1 = __nccwpck_require__(86434);
const S3ExpressIdentityCacheEntry_1 = __nccwpck_require__(16667);
class S3ExpressIdentityProviderImpl {
    constructor(createSessionFn, cache = new S3ExpressIdentityCache_1.S3ExpressIdentityCache()) {
        this.createSessionFn = createSessionFn;
        this.cache = cache;
    }
    async getS3ExpressIdentity(awsIdentity, identityProperties) {
        const key = identityProperties.Bucket;
        const { cache } = this;
        const entry = cache.get(key);
        if (entry) {
            return entry.identity.then((identity) => {
                var _a, _b, _c, _d;
                const isExpired = ((_b = (_a = identity.expiration) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) < Date.now();
                if (isExpired) {
                    return cache.set(key, new S3ExpressIdentityCacheEntry_1.S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
                }
                const isExpiringSoon = ((_d = (_c = identity.expiration) === null || _c === void 0 ? void 0 : _c.getTime()) !== null && _d !== void 0 ? _d : 0) < Date.now() + S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS;
                if (isExpiringSoon && !entry.isRefreshing) {
                    entry.isRefreshing = true;
                    this.getIdentity(key).then((id) => {
                        cache.set(key, new S3ExpressIdentityCacheEntry_1.S3ExpressIdentityCacheEntry(Promise.resolve(id)));
                    });
                }
                return identity;
            });
        }
        return cache.set(key, new S3ExpressIdentityCacheEntry_1.S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
    }
    async getIdentity(key) {
        var _a, _b;
        await this.cache.purgeExpired().catch((error) => {
            console.warn("Error while clearing expired entries in S3ExpressIdentityCache: \n" + error);
        });
        const session = await this.createSessionFn(key);
        if (!((_a = session.Credentials) === null || _a === void 0 ? void 0 : _a.AccessKeyId) || !((_b = session.Credentials) === null || _b === void 0 ? void 0 : _b.SecretAccessKey)) {
            throw new Error("s3#createSession response credential missing AccessKeyId or SecretAccessKey.");
        }
        const identity = {
            accessKeyId: session.Credentials.AccessKeyId,
            secretAccessKey: session.Credentials.SecretAccessKey,
            sessionToken: session.Credentials.SessionToken,
            expiration: session.Credentials.Expiration ? new Date(session.Credentials.Expiration) : undefined,
        };
        return identity;
    }
}
exports.S3ExpressIdentityProviderImpl = S3ExpressIdentityProviderImpl;
S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS = 60000;


/***/ }),

/***/ 93574:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignatureV4S3Express = void 0;
const signature_v4_1 = __nccwpck_require__(11528);
const constants_1 = __nccwpck_require__(96905);
class SignatureV4S3Express extends signature_v4_1.SignatureV4 {
    async signWithCredentials(requestToSign, credentials, options) {
        const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
        requestToSign.headers[constants_1.SESSION_TOKEN_HEADER] = credentials.sessionToken;
        const privateAccess = this;
        setSingleOverride(privateAccess, credentialsWithoutSessionToken);
        return privateAccess.signRequest(requestToSign, options !== null && options !== void 0 ? options : {});
    }
    async presignWithCredentials(requestToSign, credentials, options) {
        var _a;
        const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
        delete requestToSign.headers[constants_1.SESSION_TOKEN_HEADER];
        requestToSign.headers[constants_1.SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
        requestToSign.query = (_a = requestToSign.query) !== null && _a !== void 0 ? _a : {};
        requestToSign.query[constants_1.SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
        const privateAccess = this;
        setSingleOverride(privateAccess, credentialsWithoutSessionToken);
        return this.presign(requestToSign, options);
    }
}
exports.SignatureV4S3Express = SignatureV4S3Express;
function getCredentialsWithoutSessionToken(credentials) {
    const credentialsWithoutSessionToken = {
        accessKeyId: credentials.accessKeyId,
        secretAccessKey: credentials.secretAccessKey,
        expiration: credentials.expiration,
    };
    return credentialsWithoutSessionToken;
}
function setSingleOverride(privateAccess, credentialsWithoutSessionToken) {
    const id = setTimeout(() => {
        throw new Error("SignatureV4S3Express credential override was created but not called.");
    }, 10);
    const currentCredentialProvider = privateAccess.credentialProvider;
    const overrideCredentialsProviderOnce = () => {
        clearTimeout(id);
        privateAccess.credentialProvider = currentCredentialProvider;
        return Promise.resolve(credentialsWithoutSessionToken);
    };
    privateAccess.credentialProvider = overrideCredentialsProviderOnce;
}


/***/ }),

/***/ 96905:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS = exports.NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_INI_NAME = exports.NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_ENV_NAME = exports.SESSION_TOKEN_HEADER = exports.SESSION_TOKEN_QUERY_PARAM = exports.S3_EXPRESS_AUTH_SCHEME = exports.S3_EXPRESS_BACKEND = exports.S3_EXPRESS_BUCKET_TYPE = void 0;
const util_config_provider_1 = __nccwpck_require__(83375);
exports.S3_EXPRESS_BUCKET_TYPE = "Directory";
exports.S3_EXPRESS_BACKEND = "S3Express";
exports.S3_EXPRESS_AUTH_SCHEME = "sigv4-s3express";
exports.SESSION_TOKEN_QUERY_PARAM = "X-Amz-S3session-Token";
exports.SESSION_TOKEN_HEADER = exports.SESSION_TOKEN_QUERY_PARAM.toLowerCase();
exports.NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_ENV_NAME = "AWS_S3_DISABLE_EXPRESS_SESSION_AUTH";
exports.NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_INI_NAME = "s3_disable_express_session_auth";
exports.NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS = {
    environmentVariableSelector: (env) => (0, util_config_provider_1.booleanSelector)(env, exports.NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_ENV_NAME, util_config_provider_1.SelectorType.ENV),
    configFileSelector: (profile) => (0, util_config_provider_1.booleanSelector)(profile, exports.NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_INI_NAME, util_config_provider_1.SelectorType.CONFIG),
    default: false,
};


/***/ }),

/***/ 28693:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getS3ExpressPlugin = exports.s3ExpressMiddlewareOptions = exports.s3ExpressMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const constants_1 = __nccwpck_require__(96905);
const s3ExpressMiddleware = (options) => {
    return (next, context) => async (args) => {
        var _a, _b, _c, _d, _e;
        if (context.endpointV2) {
            const endpoint = context.endpointV2;
            const isS3ExpressAuth = ((_c = (_b = (_a = endpoint.properties) === null || _a === void 0 ? void 0 : _a.authSchemes) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.name) === constants_1.S3_EXPRESS_AUTH_SCHEME;
            const isS3ExpressBucket = ((_d = endpoint.properties) === null || _d === void 0 ? void 0 : _d.backend) === constants_1.S3_EXPRESS_BACKEND ||
                ((_e = endpoint.properties) === null || _e === void 0 ? void 0 : _e.bucketType) === constants_1.S3_EXPRESS_BUCKET_TYPE;
            if (isS3ExpressBucket) {
                context.isS3ExpressBucket = true;
            }
            if (isS3ExpressAuth) {
                const requestBucket = args.input.Bucket;
                if (requestBucket) {
                    const s3ExpressIdentity = await options.s3ExpressIdentityProvider.getS3ExpressIdentity(await options.credentials(), {
                        Bucket: requestBucket,
                    });
                    context.s3ExpressIdentity = s3ExpressIdentity;
                    if (protocol_http_1.HttpRequest.isInstance(args.request) && s3ExpressIdentity.sessionToken) {
                        args.request.headers[constants_1.SESSION_TOKEN_HEADER] = s3ExpressIdentity.sessionToken;
                    }
                }
            }
        }
        return next(args);
    };
};
exports.s3ExpressMiddleware = s3ExpressMiddleware;
exports.s3ExpressMiddlewareOptions = {
    name: "s3ExpressMiddleware",
    step: "build",
    tags: ["S3", "S3_EXPRESS"],
    override: true,
};
const getS3ExpressPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add((0, exports.s3ExpressMiddleware)(options), exports.s3ExpressMiddlewareOptions);
    },
});
exports.getS3ExpressPlugin = getS3ExpressPlugin;


/***/ }),

/***/ 84253:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.s3ExpressMiddlewareOptions = exports.s3ExpressMiddleware = exports.getS3ExpressPlugin = exports.NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS = exports.SignatureV4S3Express = exports.S3ExpressIdentityProviderImpl = exports.S3ExpressIdentityCacheEntry = exports.S3ExpressIdentityCache = void 0;
var S3ExpressIdentityCache_1 = __nccwpck_require__(86434);
Object.defineProperty(exports, "S3ExpressIdentityCache", ({ enumerable: true, get: function () { return S3ExpressIdentityCache_1.S3ExpressIdentityCache; } }));
var S3ExpressIdentityCacheEntry_1 = __nccwpck_require__(16667);
Object.defineProperty(exports, "S3ExpressIdentityCacheEntry", ({ enumerable: true, get: function () { return S3ExpressIdentityCacheEntry_1.S3ExpressIdentityCacheEntry; } }));
var S3ExpressIdentityProviderImpl_1 = __nccwpck_require__(2895);
Object.defineProperty(exports, "S3ExpressIdentityProviderImpl", ({ enumerable: true, get: function () { return S3ExpressIdentityProviderImpl_1.S3ExpressIdentityProviderImpl; } }));
var SignatureV4S3Express_1 = __nccwpck_require__(93574);
Object.defineProperty(exports, "SignatureV4S3Express", ({ enumerable: true, get: function () { return SignatureV4S3Express_1.SignatureV4S3Express; } }));
var constants_1 = __nccwpck_require__(96905);
Object.defineProperty(exports, "NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS", ({ enumerable: true, get: function () { return constants_1.NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS; } }));
var s3ExpressMiddleware_1 = __nccwpck_require__(28693);
Object.defineProperty(exports, "getS3ExpressPlugin", ({ enumerable: true, get: function () { return s3ExpressMiddleware_1.getS3ExpressPlugin; } }));
Object.defineProperty(exports, "s3ExpressMiddleware", ({ enumerable: true, get: function () { return s3ExpressMiddleware_1.s3ExpressMiddleware; } }));
Object.defineProperty(exports, "s3ExpressMiddlewareOptions", ({ enumerable: true, get: function () { return s3ExpressMiddleware_1.s3ExpressMiddlewareOptions; } }));


/***/ }),

/***/ 15537:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveS3Config = void 0;
const s3_express_1 = __nccwpck_require__(84253);
const resolveS3Config = (input, { session, }) => {
    var _a, _b, _c, _d, _e;
    const [s3ClientProvider, CreateSessionCommandCtor] = session;
    return {
        ...input,
        forcePathStyle: (_a = input.forcePathStyle) !== null && _a !== void 0 ? _a : false,
        useAccelerateEndpoint: (_b = input.useAccelerateEndpoint) !== null && _b !== void 0 ? _b : false,
        disableMultiregionAccessPoints: (_c = input.disableMultiregionAccessPoints) !== null && _c !== void 0 ? _c : false,
        followRegionRedirects: (_d = input.followRegionRedirects) !== null && _d !== void 0 ? _d : false,
        s3ExpressIdentityProvider: (_e = input.s3ExpressIdentityProvider) !== null && _e !== void 0 ? _e : new s3_express_1.S3ExpressIdentityProviderImpl(async (key) => s3ClientProvider().send(new CreateSessionCommandCtor({
            Bucket: key,
            SessionMode: "ReadWrite",
        }))),
    };
};
exports.resolveS3Config = resolveS3Config;


/***/ }),

/***/ 10404:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getThrow200ExceptionsPlugin = exports.throw200ExceptionsMiddlewareOptions = exports.throw200ExceptionsMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const throw200ExceptionsMiddleware = (config) => (next) => async (args) => {
    const result = await next(args);
    const { response } = result;
    if (!protocol_http_1.HttpResponse.isInstance(response))
        return result;
    const { statusCode, body } = response;
    if (statusCode < 200 || statusCode >= 300)
        return result;
    const bodyBytes = await collectBody(body, config);
    const bodyString = await collectBodyString(bodyBytes, config);
    if (bodyBytes.length === 0) {
        const err = new Error("S3 aborted request");
        err.name = "InternalError";
        throw err;
    }
    if (bodyString && bodyString.match("<Error>")) {
        response.statusCode = 400;
    }
    response.body = bodyBytes;
    return result;
};
exports.throw200ExceptionsMiddleware = throw200ExceptionsMiddleware;
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
exports.throw200ExceptionsMiddlewareOptions = {
    relation: "after",
    toMiddleware: "deserializerMiddleware",
    tags: ["THROW_200_EXCEPTIONS", "S3"],
    name: "throw200ExceptionsMiddleware",
    override: true,
};
const getThrow200ExceptionsPlugin = (config) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo((0, exports.throw200ExceptionsMiddleware)(config), exports.throw200ExceptionsMiddlewareOptions);
    },
});
exports.getThrow200ExceptionsPlugin = getThrow200ExceptionsPlugin;


/***/ }),

/***/ 56777:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getValidateBucketNamePlugin = exports.validateBucketNameMiddlewareOptions = exports.validateBucketNameMiddleware = void 0;
const util_arn_parser_1 = __nccwpck_require__(85487);
function validateBucketNameMiddleware() {
    return (next) => async (args) => {
        const { input: { Bucket }, } = args;
        if (typeof Bucket === "string" && !(0, util_arn_parser_1.validate)(Bucket) && Bucket.indexOf("/") >= 0) {
            const err = new Error(`Bucket name shouldn't contain '/', received '${Bucket}'`);
            err.name = "InvalidBucketName";
            throw err;
        }
        return next({ ...args });
    };
}
exports.validateBucketNameMiddleware = validateBucketNameMiddleware;
exports.validateBucketNameMiddlewareOptions = {
    step: "initialize",
    tags: ["VALIDATE_BUCKET_NAME"],
    name: "validateBucketNameMiddleware",
    override: true,
};
const getValidateBucketNamePlugin = (unused) => ({
    applyToStack: (clientStack) => {
        clientStack.add(validateBucketNameMiddleware(), exports.validateBucketNameMiddlewareOptions);
    },
});
exports.getValidateBucketNamePlugin = getValidateBucketNamePlugin;


/***/ }),

/***/ 84193:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveSigV4AuthConfig = exports.resolveAwsAuthConfig = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const signature_v4_1 = __nccwpck_require__(11528);
const util_middleware_1 = __nccwpck_require__(2390);
const CREDENTIAL_EXPIRE_WINDOW = 300000;
const resolveAwsAuthConfig = (input) => {
    const normalizedCreds = input.credentials
        ? normalizeCredentialProvider(input.credentials)
        : input.credentialDefaultProvider(input);
    const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
    let signer;
    if (input.signer) {
        signer = (0, util_middleware_1.normalizeProvider)(input.signer);
    }
    else if (input.regionInfoProvider) {
        signer = () => (0, util_middleware_1.normalizeProvider)(input.region)()
            .then(async (region) => [
            (await input.regionInfoProvider(region, {
                useFipsEndpoint: await input.useFipsEndpoint(),
                useDualstackEndpoint: await input.useDualstackEndpoint(),
            })) || {},
            region,
        ])
            .then(([regionInfo, region]) => {
            const { signingRegion, signingService } = regionInfo;
            input.signingRegion = input.signingRegion || signingRegion || region;
            input.signingName = input.signingName || signingService || input.serviceId;
            const params = {
                ...input,
                credentials: normalizedCreds,
                region: input.signingRegion,
                service: input.signingName,
                sha256,
                uriEscapePath: signingEscapePath,
            };
            const SignerCtor = input.signerConstructor || signature_v4_1.SignatureV4;
            return new SignerCtor(params);
        });
    }
    else {
        signer = async (authScheme) => {
            authScheme = Object.assign({}, {
                name: "sigv4",
                signingName: input.signingName || input.defaultSigningName,
                signingRegion: await (0, util_middleware_1.normalizeProvider)(input.region)(),
                properties: {},
            }, authScheme);
            const signingRegion = authScheme.signingRegion;
            const signingService = authScheme.signingName;
            input.signingRegion = input.signingRegion || signingRegion;
            input.signingName = input.signingName || signingService || input.serviceId;
            const params = {
                ...input,
                credentials: normalizedCreds,
                region: input.signingRegion,
                service: input.signingName,
                sha256,
                uriEscapePath: signingEscapePath,
            };
            const SignerCtor = input.signerConstructor || signature_v4_1.SignatureV4;
            return new SignerCtor(params);
        };
    }
    return {
        ...input,
        systemClockOffset,
        signingEscapePath,
        credentials: normalizedCreds,
        signer,
    };
};
exports.resolveAwsAuthConfig = resolveAwsAuthConfig;
const resolveSigV4AuthConfig = (input) => {
    const normalizedCreds = input.credentials
        ? normalizeCredentialProvider(input.credentials)
        : input.credentialDefaultProvider(input);
    const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
    let signer;
    if (input.signer) {
        signer = (0, util_middleware_1.normalizeProvider)(input.signer);
    }
    else {
        signer = (0, util_middleware_1.normalizeProvider)(new signature_v4_1.SignatureV4({
            credentials: normalizedCreds,
            region: input.region,
            service: input.signingName,
            sha256,
            uriEscapePath: signingEscapePath,
        }));
    }
    return {
        ...input,
        systemClockOffset,
        signingEscapePath,
        credentials: normalizedCreds,
        signer,
    };
};
exports.resolveSigV4AuthConfig = resolveSigV4AuthConfig;
const normalizeCredentialProvider = (credentials) => {
    if (typeof credentials === "function") {
        return (0, property_provider_1.memoize)(credentials, (credentials) => credentials.expiration !== undefined &&
            credentials.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW, (credentials) => credentials.expiration !== undefined);
    }
    return (0, util_middleware_1.normalizeProvider)(credentials);
};


/***/ }),

/***/ 88053:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSigV4AuthPlugin = exports.getAwsAuthPlugin = exports.awsAuthMiddlewareOptions = exports.awsAuthMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const getSkewCorrectedDate_1 = __nccwpck_require__(68253);
const getUpdatedSystemClockOffset_1 = __nccwpck_require__(35863);
const awsAuthMiddleware = (options) => (next, context) => async function (args) {
    var _a, _b, _c, _d;
    if (!protocol_http_1.HttpRequest.isInstance(args.request))
        return next(args);
    const authScheme = (_c = (_b = (_a = context.endpointV2) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.authSchemes) === null || _c === void 0 ? void 0 : _c[0];
    const multiRegionOverride = (authScheme === null || authScheme === void 0 ? void 0 : authScheme.name) === "sigv4a" ? (_d = authScheme === null || authScheme === void 0 ? void 0 : authScheme.signingRegionSet) === null || _d === void 0 ? void 0 : _d.join(",") : undefined;
    const signer = await options.signer(authScheme);
    let signedRequest;
    const signingOptions = {
        signingDate: (0, getSkewCorrectedDate_1.getSkewCorrectedDate)(options.systemClockOffset),
        signingRegion: multiRegionOverride || context["signing_region"],
        signingService: context["signing_service"],
    };
    if (context.s3ExpressIdentity) {
        const sigV4MultiRegion = signer;
        signedRequest = await sigV4MultiRegion.signWithCredentials(args.request, context.s3ExpressIdentity, signingOptions);
        if (signedRequest.headers["X-Amz-Security-Token"] || signedRequest.headers["x-amz-security-token"]) {
            throw new Error("X-Amz-Security-Token must not be set for s3-express requests.");
        }
    }
    else {
        signedRequest = await signer.sign(args.request, signingOptions);
    }
    const output = await next({
        ...args,
        request: signedRequest,
    }).catch((error) => {
        var _a;
        const serverTime = (_a = error.ServerTime) !== null && _a !== void 0 ? _a : getDateHeader(error.$response);
        if (serverTime) {
            options.systemClockOffset = (0, getUpdatedSystemClockOffset_1.getUpdatedSystemClockOffset)(serverTime, options.systemClockOffset);
        }
        throw error;
    });
    const dateHeader = getDateHeader(output.response);
    if (dateHeader) {
        options.systemClockOffset = (0, getUpdatedSystemClockOffset_1.getUpdatedSystemClockOffset)(dateHeader, options.systemClockOffset);
    }
    return output;
};
exports.awsAuthMiddleware = awsAuthMiddleware;
const getDateHeader = (response) => { var _a, _b, _c; return protocol_http_1.HttpResponse.isInstance(response) ? (_b = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.date) !== null && _b !== void 0 ? _b : (_c = response.headers) === null || _c === void 0 ? void 0 : _c.Date : undefined; };
exports.awsAuthMiddlewareOptions = {
    name: "awsAuthMiddleware",
    tags: ["SIGNATURE", "AWSAUTH"],
    relation: "after",
    toMiddleware: "retryMiddleware",
    override: true,
};
const getAwsAuthPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo((0, exports.awsAuthMiddleware)(options), exports.awsAuthMiddlewareOptions);
    },
});
exports.getAwsAuthPlugin = getAwsAuthPlugin;
exports.getSigV4AuthPlugin = exports.getAwsAuthPlugin;


/***/ }),

/***/ 14935:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(84193), exports);
tslib_1.__exportStar(__nccwpck_require__(88053), exports);


/***/ }),

/***/ 68253:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSkewCorrectedDate = void 0;
const getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);
exports.getSkewCorrectedDate = getSkewCorrectedDate;


/***/ }),

/***/ 35863:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUpdatedSystemClockOffset = void 0;
const isClockSkewed_1 = __nccwpck_require__(85301);
const getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
    const clockTimeInMs = Date.parse(clockTime);
    if ((0, isClockSkewed_1.isClockSkewed)(clockTimeInMs, currentSystemClockOffset)) {
        return clockTimeInMs - Date.now();
    }
    return currentSystemClockOffset;
};
exports.getUpdatedSystemClockOffset = getUpdatedSystemClockOffset;


/***/ }),

/***/ 85301:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isClockSkewed = void 0;
const getSkewCorrectedDate_1 = __nccwpck_require__(68253);
const isClockSkewed = (clockTime, systemClockOffset) => Math.abs((0, getSkewCorrectedDate_1.getSkewCorrectedDate)(systemClockOffset).getTime() - clockTime) >= 300000;
exports.isClockSkewed = isClockSkewed;


/***/ }),

/***/ 49718:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSsecPlugin = exports.ssecMiddlewareOptions = exports.ssecMiddleware = void 0;
function ssecMiddleware(options) {
    return (next) => async (args) => {
        let input = { ...args.input };
        const properties = [
            {
                target: "SSECustomerKey",
                hash: "SSECustomerKeyMD5",
            },
            {
                target: "CopySourceSSECustomerKey",
                hash: "CopySourceSSECustomerKeyMD5",
            },
        ];
        for (const prop of properties) {
            const value = input[prop.target];
            if (value) {
                const valueView = ArrayBuffer.isView(value)
                    ? new Uint8Array(value.buffer, value.byteOffset, value.byteLength)
                    : typeof value === "string"
                        ? options.utf8Decoder(value)
                        : new Uint8Array(value);
                const encoded = options.base64Encoder(valueView);
                const hash = new options.md5();
                hash.update(valueView);
                input = {
                    ...input,
                    [prop.target]: encoded,
                    [prop.hash]: options.base64Encoder(await hash.digest()),
                };
            }
        }
        return next({
            ...args,
            input,
        });
    };
}
exports.ssecMiddleware = ssecMiddleware;
exports.ssecMiddlewareOptions = {
    name: "ssecMiddleware",
    step: "initialize",
    tags: ["SSE"],
    override: true,
};
const getSsecPlugin = (config) => ({
    applyToStack: (clientStack) => {
        clientStack.add(ssecMiddleware(config), exports.ssecMiddlewareOptions);
    },
});
exports.getSsecPlugin = getSsecPlugin;


/***/ }),

/***/ 36546:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveUserAgentConfig = void 0;
function resolveUserAgentConfig(input) {
    return {
        ...input,
        customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent,
    };
}
exports.resolveUserAgentConfig = resolveUserAgentConfig;


/***/ }),

/***/ 28025:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UA_ESCAPE_CHAR = exports.UA_VALUE_ESCAPE_REGEX = exports.UA_NAME_ESCAPE_REGEX = exports.UA_NAME_SEPARATOR = exports.SPACE = exports.X_AMZ_USER_AGENT = exports.USER_AGENT = void 0;
exports.USER_AGENT = "user-agent";
exports.X_AMZ_USER_AGENT = "x-amz-user-agent";
exports.SPACE = " ";
exports.UA_NAME_SEPARATOR = "/";
exports.UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
exports.UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
exports.UA_ESCAPE_CHAR = "-";


/***/ }),

/***/ 64688:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(36546), exports);
tslib_1.__exportStar(__nccwpck_require__(76236), exports);


/***/ }),

/***/ 76236:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUserAgentPlugin = exports.getUserAgentMiddlewareOptions = exports.userAgentMiddleware = void 0;
const util_endpoints_1 = __nccwpck_require__(13350);
const protocol_http_1 = __nccwpck_require__(64418);
const constants_1 = __nccwpck_require__(28025);
const userAgentMiddleware = (options) => (next, context) => async (args) => {
    var _a, _b;
    const { request } = args;
    if (!protocol_http_1.HttpRequest.isInstance(request))
        return next(args);
    const { headers } = request;
    const userAgent = ((_a = context === null || context === void 0 ? void 0 : context.userAgent) === null || _a === void 0 ? void 0 : _a.map(escapeUserAgent)) || [];
    const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
    const customUserAgent = ((_b = options === null || options === void 0 ? void 0 : options.customUserAgent) === null || _b === void 0 ? void 0 : _b.map(escapeUserAgent)) || [];
    const prefix = (0, util_endpoints_1.getUserAgentPrefix)();
    const sdkUserAgentValue = (prefix ? [prefix] : [])
        .concat([...defaultUserAgent, ...userAgent, ...customUserAgent])
        .join(constants_1.SPACE);
    const normalUAValue = [
        ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
        ...customUserAgent,
    ].join(constants_1.SPACE);
    if (options.runtime !== "browser") {
        if (normalUAValue) {
            headers[constants_1.X_AMZ_USER_AGENT] = headers[constants_1.X_AMZ_USER_AGENT]
                ? `${headers[constants_1.USER_AGENT]} ${normalUAValue}`
                : normalUAValue;
        }
        headers[constants_1.USER_AGENT] = sdkUserAgentValue;
    }
    else {
        headers[constants_1.X_AMZ_USER_AGENT] = sdkUserAgentValue;
    }
    return next({
        ...args,
        request,
    });
};
exports.userAgentMiddleware = userAgentMiddleware;
const escapeUserAgent = (userAgentPair) => {
    var _a;
    const name = userAgentPair[0]
        .split(constants_1.UA_NAME_SEPARATOR)
        .map((part) => part.replace(constants_1.UA_NAME_ESCAPE_REGEX, constants_1.UA_ESCAPE_CHAR))
        .join(constants_1.UA_NAME_SEPARATOR);
    const version = (_a = userAgentPair[1]) === null || _a === void 0 ? void 0 : _a.replace(constants_1.UA_VALUE_ESCAPE_REGEX, constants_1.UA_ESCAPE_CHAR);
    const prefixSeparatorIndex = name.indexOf(constants_1.UA_NAME_SEPARATOR);
    const prefix = name.substring(0, prefixSeparatorIndex);
    let uaName = name.substring(prefixSeparatorIndex + 1);
    if (prefix === "api") {
        uaName = uaName.toLowerCase();
    }
    return [prefix, uaName, version]
        .filter((item) => item && item.length > 0)
        .reduce((acc, item, index) => {
        switch (index) {
            case 0:
                return item;
            case 1:
                return `${acc}/${item}`;
            default:
                return `${acc}#${item}`;
        }
    }, "");
};
exports.getUserAgentMiddlewareOptions = {
    name: "getUserAgentMiddleware",
    step: "build",
    priority: "low",
    tags: ["SET_USER_AGENT", "USER_AGENT"],
    override: true,
};
const getUserAgentPlugin = (config) => ({
    applyToStack: (clientStack) => {
        clientStack.add((0, exports.userAgentMiddleware)(config), exports.getUserAgentMiddlewareOptions);
    },
});
exports.getUserAgentPlugin = getUserAgentPlugin;


/***/ }),

/***/ 60079:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveAwsRegionExtensionConfiguration = exports.getAwsRegionExtensionConfiguration = void 0;
const getAwsRegionExtensionConfiguration = (runtimeConfig) => {
    let runtimeConfigRegion = async () => {
        if (runtimeConfig.region === undefined) {
            throw new Error("Region is missing from runtimeConfig");
        }
        const region = runtimeConfig.region;
        if (typeof region === "string") {
            return region;
        }
        return region();
    };
    return {
        setRegion(region) {
            runtimeConfigRegion = region;
        },
        region() {
            return runtimeConfigRegion;
        },
    };
};
exports.getAwsRegionExtensionConfiguration = getAwsRegionExtensionConfiguration;
const resolveAwsRegionExtensionConfiguration = (awsRegionExtensionConfiguration) => {
    return {
        region: awsRegionExtensionConfiguration.region(),
    };
};
exports.resolveAwsRegionExtensionConfiguration = resolveAwsRegionExtensionConfiguration;


/***/ }),

/***/ 18156:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(60079), exports);
tslib_1.__exportStar(__nccwpck_require__(17177), exports);


/***/ }),

/***/ 60123:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_REGION_CONFIG_FILE_OPTIONS = exports.NODE_REGION_CONFIG_OPTIONS = exports.REGION_INI_NAME = exports.REGION_ENV_NAME = void 0;
exports.REGION_ENV_NAME = "AWS_REGION";
exports.REGION_INI_NAME = "region";
exports.NODE_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[exports.REGION_ENV_NAME],
    configFileSelector: (profile) => profile[exports.REGION_INI_NAME],
    default: () => {
        throw new Error("Region is missing");
    },
};
exports.NODE_REGION_CONFIG_FILE_OPTIONS = {
    preferredFile: "credentials",
};


/***/ }),

/***/ 30048:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRealRegion = void 0;
const isFipsRegion_1 = __nccwpck_require__(37257);
const getRealRegion = (region) => (0, isFipsRegion_1.isFipsRegion)(region)
    ? ["fips-aws-global", "aws-fips"].includes(region)
        ? "us-east-1"
        : region.replace(/fips-(dkr-|prod-)?|-fips/, "")
    : region;
exports.getRealRegion = getRealRegion;


/***/ }),

/***/ 17177:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(60123), exports);
tslib_1.__exportStar(__nccwpck_require__(46187), exports);


/***/ }),

/***/ 37257:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isFipsRegion = void 0;
const isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
exports.isFipsRegion = isFipsRegion;


/***/ }),

/***/ 46187:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveRegionConfig = void 0;
const getRealRegion_1 = __nccwpck_require__(30048);
const isFipsRegion_1 = __nccwpck_require__(37257);
const resolveRegionConfig = (input) => {
    const { region, useFipsEndpoint } = input;
    if (!region) {
        throw new Error("Region is missing");
    }
    return {
        ...input,
        region: async () => {
            if (typeof region === "string") {
                return (0, getRealRegion_1.getRealRegion)(region);
            }
            const providedRegion = await region();
            return (0, getRealRegion_1.getRealRegion)(providedRegion);
        },
        useFipsEndpoint: async () => {
            const providedRegion = typeof region === "string" ? region : await region();
            if ((0, isFipsRegion_1.isFipsRegion)(providedRegion)) {
                return true;
            }
            return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
        },
    };
};
exports.resolveRegionConfig = resolveRegionConfig;


/***/ }),

/***/ 24885:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignatureV4MultiRegion = void 0;
const middleware_sdk_s3_1 = __nccwpck_require__(81139);
const signature_v4_crt_container_1 = __nccwpck_require__(72286);
class SignatureV4MultiRegion {
    constructor(options) {
        this.sigv4Signer = new middleware_sdk_s3_1.SignatureV4S3Express(options);
        this.signerOptions = options;
    }
    async sign(requestToSign, options = {}) {
        if (options.signingRegion === "*") {
            if (this.signerOptions.runtime !== "node")
                throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
            return this.getSigv4aSigner().sign(requestToSign, options);
        }
        return this.sigv4Signer.sign(requestToSign, options);
    }
    async signWithCredentials(requestToSign, credentials, options = {}) {
        if (options.signingRegion === "*") {
            if (this.signerOptions.runtime !== "node")
                throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
            return this.getSigv4aSigner().signWithCredentials(requestToSign, credentials, options);
        }
        return this.sigv4Signer.signWithCredentials(requestToSign, credentials, options);
    }
    async presign(originalRequest, options = {}) {
        if (options.signingRegion === "*") {
            if (this.signerOptions.runtime !== "node")
                throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
            return this.getSigv4aSigner().presign(originalRequest, options);
        }
        return this.sigv4Signer.presign(originalRequest, options);
    }
    async presignWithCredentials(originalRequest, credentials, options = {}) {
        if (options.signingRegion === "*") {
            throw new Error("Method presignWithCredentials is not supported for [signingRegion=*].");
        }
        return this.sigv4Signer.presignWithCredentials(originalRequest, credentials, options);
    }
    getSigv4aSigner() {
        if (!this.sigv4aSigner) {
            let CrtSignerV4 = null;
            try {
                CrtSignerV4 = signature_v4_crt_container_1.signatureV4CrtContainer.CrtSignerV4;
                if (typeof CrtSignerV4 !== "function")
                    throw new Error();
            }
            catch (e) {
                e.message =
                    `${e.message}\n` +
                        `Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. \n` +
                        `You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] ` +
                        `or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. \n` +
                        "For more information please go to " +
                        "https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt";
                throw e;
            }
            this.sigv4aSigner = new CrtSignerV4({
                ...this.signerOptions,
                signingAlgorithm: 1,
            });
        }
        return this.sigv4aSigner;
    }
}
exports.SignatureV4MultiRegion = SignatureV4MultiRegion;


/***/ }),

/***/ 51856:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(24885), exports);
tslib_1.__exportStar(__nccwpck_require__(72286), exports);


/***/ }),

/***/ 72286:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signatureV4CrtContainer = void 0;
exports.signatureV4CrtContainer = {
    CrtSignerV4: null,
};


/***/ }),

/***/ 52664:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnsupportedGrantTypeException = exports.UnauthorizedClientException = exports.SlowDownException = exports.SSOOIDCClient = exports.InvalidScopeException = exports.InvalidRequestException = exports.InvalidClientException = exports.InternalServerException = exports.ExpiredTokenException = exports.CreateTokenCommand = exports.AuthorizationPendingException = exports.AccessDeniedException = void 0;
const middleware_host_header_1 = __nccwpck_require__(22545);
const middleware_logger_1 = __nccwpck_require__(20014);
const middleware_recursion_detection_1 = __nccwpck_require__(85525);
const middleware_user_agent_1 = __nccwpck_require__(64688);
const config_resolver_1 = __nccwpck_require__(53098);
const middleware_content_length_1 = __nccwpck_require__(82800);
const middleware_endpoint_1 = __nccwpck_require__(82918);
const middleware_retry_1 = __nccwpck_require__(96039);
const smithy_client_1 = __nccwpck_require__(63570);
var resolveClientEndpointParameters = (options) => {
    var _a, _b;
    return {
        ...options,
        useDualstackEndpoint: (_a = options.useDualstackEndpoint) !== null && _a !== void 0 ? _a : false,
        useFipsEndpoint: (_b = options.useFipsEndpoint) !== null && _b !== void 0 ? _b : false,
        defaultSigningName: "awsssooidc",
    };
};
var package_default = { version: "3.429.0" };
const util_user_agent_node_1 = __nccwpck_require__(98095);
const config_resolver_2 = __nccwpck_require__(53098);
const hash_node_1 = __nccwpck_require__(3081);
const middleware_retry_2 = __nccwpck_require__(96039);
const node_config_provider_1 = __nccwpck_require__(33461);
const node_http_handler_1 = __nccwpck_require__(20258);
const util_body_length_node_1 = __nccwpck_require__(68075);
const util_retry_1 = __nccwpck_require__(84902);
const smithy_client_2 = __nccwpck_require__(63570);
const url_parser_1 = __nccwpck_require__(14681);
const util_base64_1 = __nccwpck_require__(75600);
const util_utf8_1 = __nccwpck_require__(41895);
const util_endpoints_1 = __nccwpck_require__(45473);
var s = "required";
var t = "fn";
var u = "argv";
var v = "ref";
var a = "isSet";
var b = "tree";
var c = "error";
var d = "endpoint";
var e = "PartitionResult";
var f = "getAttr";
var g = { [s]: false, type: "String" };
var h = { [s]: true, default: false, type: "Boolean" };
var i = { [v]: "Endpoint" };
var j = { [t]: "booleanEquals", [u]: [{ [v]: "UseFIPS" }, true] };
var k = { [t]: "booleanEquals", [u]: [{ [v]: "UseDualStack" }, true] };
var l = {};
var m = { [t]: "booleanEquals", [u]: [true, { [t]: f, [u]: [{ [v]: e }, "supportsFIPS"] }] };
var n = { [v]: e };
var o = { [t]: "booleanEquals", [u]: [true, { [t]: f, [u]: [n, "supportsDualStack"] }] };
var p = [j];
var q = [k];
var r = [{ [v]: "Region" }];
var _data = {
    version: "1.0",
    parameters: { Region: g, UseDualStack: h, UseFIPS: h, Endpoint: g },
    rules: [
        {
            conditions: [{ [t]: a, [u]: [i] }],
            type: b,
            rules: [
                { conditions: p, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: c },
                { conditions: q, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: c },
                { endpoint: { url: i, properties: l, headers: l }, type: d },
            ],
        },
        {
            conditions: [{ [t]: a, [u]: r }],
            type: b,
            rules: [
                {
                    conditions: [{ [t]: "aws.partition", [u]: r, assign: e }],
                    type: b,
                    rules: [
                        {
                            conditions: [j, k],
                            type: b,
                            rules: [
                                {
                                    conditions: [m, o],
                                    type: b,
                                    rules: [
                                        {
                                            endpoint: {
                                                url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                                                properties: l,
                                                headers: l,
                                            },
                                            type: d,
                                        },
                                    ],
                                },
                                { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: c },
                            ],
                        },
                        {
                            conditions: p,
                            type: b,
                            rules: [
                                {
                                    conditions: [m],
                                    type: b,
                                    rules: [
                                        {
                                            conditions: [{ [t]: "stringEquals", [u]: ["aws-us-gov", { [t]: f, [u]: [n, "name"] }] }],
                                            endpoint: { url: "https://oidc.{Region}.amazonaws.com", properties: l, headers: l },
                                            type: d,
                                        },
                                        {
                                            endpoint: {
                                                url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}",
                                                properties: l,
                                                headers: l,
                                            },
                                            type: d,
                                        },
                                    ],
                                },
                                { error: "FIPS is enabled but this partition does not support FIPS", type: c },
                            ],
                        },
                        {
                            conditions: q,
                            type: b,
                            rules: [
                                {
                                    conditions: [o],
                                    type: b,
                                    rules: [
                                        {
                                            endpoint: {
                                                url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}",
                                                properties: l,
                                                headers: l,
                                            },
                                            type: d,
                                        },
                                    ],
                                },
                                { error: "DualStack is enabled but this partition does not support DualStack", type: c },
                            ],
                        },
                        {
                            endpoint: { url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}", properties: l, headers: l },
                            type: d,
                        },
                    ],
                },
            ],
        },
        { error: "Invalid Configuration: Missing Region", type: c },
    ],
};
var ruleSet = _data;
var defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0, util_endpoints_1.resolveEndpoint)(ruleSet, {
        endpointParams,
        logger: context.logger,
    });
};
var getRuntimeConfig = (config) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    return ({
        apiVersion: "2019-06-10",
        base64Decoder: (_a = config === null || config === void 0 ? void 0 : config.base64Decoder) !== null && _a !== void 0 ? _a : util_base64_1.fromBase64,
        base64Encoder: (_b = config === null || config === void 0 ? void 0 : config.base64Encoder) !== null && _b !== void 0 ? _b : util_base64_1.toBase64,
        disableHostPrefix: (_c = config === null || config === void 0 ? void 0 : config.disableHostPrefix) !== null && _c !== void 0 ? _c : false,
        endpointProvider: (_d = config === null || config === void 0 ? void 0 : config.endpointProvider) !== null && _d !== void 0 ? _d : defaultEndpointResolver,
        extensions: (_e = config === null || config === void 0 ? void 0 : config.extensions) !== null && _e !== void 0 ? _e : [],
        logger: (_f = config === null || config === void 0 ? void 0 : config.logger) !== null && _f !== void 0 ? _f : new smithy_client_2.NoOpLogger(),
        serviceId: (_g = config === null || config === void 0 ? void 0 : config.serviceId) !== null && _g !== void 0 ? _g : "SSO OIDC",
        urlParser: (_h = config === null || config === void 0 ? void 0 : config.urlParser) !== null && _h !== void 0 ? _h : url_parser_1.parseUrl,
        utf8Decoder: (_j = config === null || config === void 0 ? void 0 : config.utf8Decoder) !== null && _j !== void 0 ? _j : util_utf8_1.fromUtf8,
        utf8Encoder: (_k = config === null || config === void 0 ? void 0 : config.utf8Encoder) !== null && _k !== void 0 ? _k : util_utf8_1.toUtf8,
    });
};
const smithy_client_3 = __nccwpck_require__(63570);
const util_defaults_mode_node_1 = __nccwpck_require__(72429);
const smithy_client_4 = __nccwpck_require__(63570);
var getRuntimeConfig2 = (config) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    (0, smithy_client_4.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_3.loadConfigsForDefaultMode);
    const clientSharedValues = getRuntimeConfig(config);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: (_a = config === null || config === void 0 ? void 0 : config.bodyLengthChecker) !== null && _a !== void 0 ? _a : util_body_length_node_1.calculateBodyLength,
        defaultUserAgentProvider: (_b = config === null || config === void 0 ? void 0 : config.defaultUserAgentProvider) !== null && _b !== void 0 ? _b : (0, util_user_agent_node_1.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
        maxAttempts: (_c = config === null || config === void 0 ? void 0 : config.maxAttempts) !== null && _c !== void 0 ? _c : (0, node_config_provider_1.loadConfig)(middleware_retry_2.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: (_d = config === null || config === void 0 ? void 0 : config.region) !== null && _d !== void 0 ? _d : (0, node_config_provider_1.loadConfig)(config_resolver_2.NODE_REGION_CONFIG_OPTIONS, config_resolver_2.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: (_e = config === null || config === void 0 ? void 0 : config.requestHandler) !== null && _e !== void 0 ? _e : new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: (_f = config === null || config === void 0 ? void 0 : config.retryMode) !== null && _f !== void 0 ? _f : (0, node_config_provider_1.loadConfig)({
            ...middleware_retry_2.NODE_RETRY_MODE_CONFIG_OPTIONS,
            default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE,
        }),
        sha256: (_g = config === null || config === void 0 ? void 0 : config.sha256) !== null && _g !== void 0 ? _g : hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: (_h = config === null || config === void 0 ? void 0 : config.streamCollector) !== null && _h !== void 0 ? _h : node_http_handler_1.streamCollector,
        useDualstackEndpoint: (_j = config === null || config === void 0 ? void 0 : config.useDualstackEndpoint) !== null && _j !== void 0 ? _j : (0, node_config_provider_1.loadConfig)(config_resolver_2.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: (_k = config === null || config === void 0 ? void 0 : config.useFipsEndpoint) !== null && _k !== void 0 ? _k : (0, node_config_provider_1.loadConfig)(config_resolver_2.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
    };
};
const region_config_resolver_1 = __nccwpck_require__(18156);
const protocol_http_1 = __nccwpck_require__(64418);
const smithy_client_5 = __nccwpck_require__(63570);
var asPartial = (t2) => t2;
var resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
        ...asPartial((0, region_config_resolver_1.getAwsRegionExtensionConfiguration)(runtimeConfig)),
        ...asPartial((0, smithy_client_5.getDefaultExtensionConfiguration)(runtimeConfig)),
        ...asPartial((0, protocol_http_1.getHttpHandlerExtensionConfiguration)(runtimeConfig)),
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...(0, region_config_resolver_1.resolveAwsRegionExtensionConfiguration)(extensionConfiguration),
        ...(0, smithy_client_5.resolveDefaultRuntimeConfig)(extensionConfiguration),
        ...(0, protocol_http_1.resolveHttpHandlerRuntimeConfig)(extensionConfiguration),
    };
};
var SSOOIDCClient = class extends smithy_client_1.Client {
    constructor(...[configuration]) {
        const _config_0 = getRuntimeConfig2(configuration || {});
        const _config_1 = resolveClientEndpointParameters(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_5);
        const _config_7 = resolveRuntimeExtensions(_config_6, (configuration === null || configuration === void 0 ? void 0 : configuration.extensions) || []);
        super(_config_7);
        this.config = _config_7;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
};
exports.SSOOIDCClient = SSOOIDCClient;
const smithy_client_6 = __nccwpck_require__(63570);
const middleware_endpoint_2 = __nccwpck_require__(82918);
const middleware_serde_1 = __nccwpck_require__(81238);
const smithy_client_7 = __nccwpck_require__(63570);
const types_1 = __nccwpck_require__(55756);
const protocol_http_2 = __nccwpck_require__(64418);
const smithy_client_8 = __nccwpck_require__(63570);
const smithy_client_9 = __nccwpck_require__(63570);
var SSOOIDCServiceException = class _SSOOIDCServiceException extends smithy_client_9.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, _SSOOIDCServiceException.prototype);
    }
};
var AccessDeniedException = class _AccessDeniedException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "AccessDeniedException",
            $fault: "client",
            ...opts,
        });
        this.name = "AccessDeniedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _AccessDeniedException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.AccessDeniedException = AccessDeniedException;
var AuthorizationPendingException = class _AuthorizationPendingException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "AuthorizationPendingException",
            $fault: "client",
            ...opts,
        });
        this.name = "AuthorizationPendingException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _AuthorizationPendingException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.AuthorizationPendingException = AuthorizationPendingException;
var ExpiredTokenException = class _ExpiredTokenException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "ExpiredTokenException",
            $fault: "client",
            ...opts,
        });
        this.name = "ExpiredTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _ExpiredTokenException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.ExpiredTokenException = ExpiredTokenException;
var InternalServerException = class _InternalServerException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InternalServerException",
            $fault: "server",
            ...opts,
        });
        this.name = "InternalServerException";
        this.$fault = "server";
        Object.setPrototypeOf(this, _InternalServerException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.InternalServerException = InternalServerException;
var InvalidClientException = class _InvalidClientException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidClientException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidClientException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _InvalidClientException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.InvalidClientException = InvalidClientException;
var InvalidGrantException = class _InvalidGrantException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidGrantException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidGrantException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _InvalidGrantException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
var InvalidRequestException = class _InvalidRequestException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidRequestException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRequestException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _InvalidRequestException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.InvalidRequestException = InvalidRequestException;
var InvalidScopeException = class _InvalidScopeException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidScopeException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidScopeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _InvalidScopeException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.InvalidScopeException = InvalidScopeException;
var SlowDownException = class _SlowDownException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "SlowDownException",
            $fault: "client",
            ...opts,
        });
        this.name = "SlowDownException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _SlowDownException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.SlowDownException = SlowDownException;
var UnauthorizedClientException = class _UnauthorizedClientException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "UnauthorizedClientException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnauthorizedClientException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _UnauthorizedClientException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.UnauthorizedClientException = UnauthorizedClientException;
var UnsupportedGrantTypeException = class _UnsupportedGrantTypeException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "UnsupportedGrantTypeException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnsupportedGrantTypeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _UnsupportedGrantTypeException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.UnsupportedGrantTypeException = UnsupportedGrantTypeException;
var InvalidClientMetadataException = class _InvalidClientMetadataException extends SSOOIDCServiceException {
    constructor(opts) {
        super({
            name: "InvalidClientMetadataException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidClientMetadataException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _InvalidClientMetadataException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
var se_CreateTokenCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}/token`;
    let body;
    body = JSON.stringify((0, smithy_client_8.take)(input, {
        clientId: [],
        clientSecret: [],
        code: [],
        deviceCode: [],
        grantType: [],
        redirectUri: [],
        refreshToken: [],
        scope: (_) => (0, smithy_client_8._json)(_),
    }));
    return new protocol_http_2.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
var se_RegisterClientCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}/client/register`;
    let body;
    body = JSON.stringify((0, smithy_client_8.take)(input, {
        clientName: [],
        clientType: [],
        scopes: (_) => (0, smithy_client_8._json)(_),
    }));
    return new protocol_http_2.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
var se_StartDeviceAuthorizationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}/device_authorization`;
    let body;
    body = JSON.stringify((0, smithy_client_8.take)(input, {
        clientId: [],
        clientSecret: [],
        startUrl: [],
    }));
    return new protocol_http_2.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
var de_CreateTokenCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateTokenCommandError(output, context);
    }
    const contents = (0, smithy_client_8.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_8.expectNonNull)((0, smithy_client_8.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_8.take)(data, {
        accessToken: smithy_client_8.expectString,
        expiresIn: smithy_client_8.expectInt32,
        idToken: smithy_client_8.expectString,
        refreshToken: smithy_client_8.expectString,
        tokenType: smithy_client_8.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
var de_CreateTokenCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.ssooidc#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "AuthorizationPendingException":
        case "com.amazonaws.ssooidc#AuthorizationPendingException":
            throw await de_AuthorizationPendingExceptionRes(parsedOutput, context);
        case "ExpiredTokenException":
        case "com.amazonaws.ssooidc#ExpiredTokenException":
            throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "InvalidClientException":
        case "com.amazonaws.ssooidc#InvalidClientException":
            throw await de_InvalidClientExceptionRes(parsedOutput, context);
        case "InvalidGrantException":
        case "com.amazonaws.ssooidc#InvalidGrantException":
            throw await de_InvalidGrantExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "InvalidScopeException":
        case "com.amazonaws.ssooidc#InvalidScopeException":
            throw await de_InvalidScopeExceptionRes(parsedOutput, context);
        case "SlowDownException":
        case "com.amazonaws.ssooidc#SlowDownException":
            throw await de_SlowDownExceptionRes(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.ssooidc#UnauthorizedClientException":
            throw await de_UnauthorizedClientExceptionRes(parsedOutput, context);
        case "UnsupportedGrantTypeException":
        case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
            throw await de_UnsupportedGrantTypeExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
var de_RegisterClientCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RegisterClientCommandError(output, context);
    }
    const contents = (0, smithy_client_8.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_8.expectNonNull)((0, smithy_client_8.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_8.take)(data, {
        authorizationEndpoint: smithy_client_8.expectString,
        clientId: smithy_client_8.expectString,
        clientIdIssuedAt: smithy_client_8.expectLong,
        clientSecret: smithy_client_8.expectString,
        clientSecretExpiresAt: smithy_client_8.expectLong,
        tokenEndpoint: smithy_client_8.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
var de_RegisterClientCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "InvalidClientMetadataException":
        case "com.amazonaws.ssooidc#InvalidClientMetadataException":
            throw await de_InvalidClientMetadataExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "InvalidScopeException":
        case "com.amazonaws.ssooidc#InvalidScopeException":
            throw await de_InvalidScopeExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
var de_StartDeviceAuthorizationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StartDeviceAuthorizationCommandError(output, context);
    }
    const contents = (0, smithy_client_8.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_8.expectNonNull)((0, smithy_client_8.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_8.take)(data, {
        deviceCode: smithy_client_8.expectString,
        expiresIn: smithy_client_8.expectInt32,
        interval: smithy_client_8.expectInt32,
        userCode: smithy_client_8.expectString,
        verificationUri: smithy_client_8.expectString,
        verificationUriComplete: smithy_client_8.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
var de_StartDeviceAuthorizationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "InvalidClientException":
        case "com.amazonaws.ssooidc#InvalidClientException":
            throw await de_InvalidClientExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "SlowDownException":
        case "com.amazonaws.ssooidc#SlowDownException":
            throw await de_SlowDownExceptionRes(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.ssooidc#UnauthorizedClientException":
            throw await de_UnauthorizedClientExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
var throwDefaultError = (0, smithy_client_8.withBaseException)(SSOOIDCServiceException);
var de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
        error: smithy_client_8.expectString,
        error_description: smithy_client_8.expectString,
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
};
var de_AuthorizationPendingExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
        error: smithy_client_8.expectString,
        error_description: smithy_client_8.expectString,
    });
    Object.assign(contents, doc);
    const exception = new AuthorizationPendingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
};
var de_ExpiredTokenExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
        error: smithy_client_8.expectString,
        error_description: smithy_client_8.expectString,
    });
    Object.assign(contents, doc);
    const exception = new ExpiredTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
};
var de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
        error: smithy_client_8.expectString,
        error_description: smithy_client_8.expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
};
var de_InvalidClientExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
        error: smithy_client_8.expectString,
        error_description: smithy_client_8.expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidClientException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
};
var de_InvalidClientMetadataExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
        error: smithy_client_8.expectString,
        error_description: smithy_client_8.expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidClientMetadataException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
};
var de_InvalidGrantExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
        error: smithy_client_8.expectString,
        error_description: smithy_client_8.expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidGrantException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
};
var de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
        error: smithy_client_8.expectString,
        error_description: smithy_client_8.expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
};
var de_InvalidScopeExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
        error: smithy_client_8.expectString,
        error_description: smithy_client_8.expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidScopeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
};
var de_SlowDownExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
        error: smithy_client_8.expectString,
        error_description: smithy_client_8.expectString,
    });
    Object.assign(contents, doc);
    const exception = new SlowDownException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
};
var de_UnauthorizedClientExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
        error: smithy_client_8.expectString,
        error_description: smithy_client_8.expectString,
    });
    Object.assign(contents, doc);
    const exception = new UnauthorizedClientException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
};
var de_UnsupportedGrantTypeExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_8.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_8.take)(data, {
        error: smithy_client_8.expectString,
        error_description: smithy_client_8.expectString,
    });
    Object.assign(contents, doc);
    const exception = new UnsupportedGrantTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_8.decorateServiceException)(exception, parsedOutput.body);
};
var deserializeMetadata = (output) => {
    var _a, _b;
    return ({
        httpStatusCode: output.statusCode,
        requestId: (_b = (_a = output.headers["x-amzn-requestid"]) !== null && _a !== void 0 ? _a : output.headers["x-amzn-request-id"]) !== null && _b !== void 0 ? _b : output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"],
    });
};
var collectBodyString = (streamBody, context) => (0, smithy_client_8.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
var parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
var parseErrorBody = async (errorBody, context) => {
    var _a;
    const value = await parseBody(errorBody, context);
    value.message = (_a = value.message) !== null && _a !== void 0 ? _a : value.Message;
    return value;
};
var loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k2) => k2.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== void 0) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== void 0) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== void 0) {
        return sanitizeErrorCode(data["__type"]);
    }
};
class CreateTokenCommand extends smithy_client_7.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_2.getEndpointPlugin)(configuration, _CreateTokenCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOOIDCClient";
        const commandName = "CreateTokenCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
            [types_1.SMITHY_CONTEXT_KEY]: {
                service: "AWSSSOOIDCService",
                operation: "CreateToken",
            },
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return se_CreateTokenCommand(input, context);
    }
    deserialize(output, context) {
        return de_CreateTokenCommand(output, context);
    }
}
exports.CreateTokenCommand = CreateTokenCommand;
const middleware_endpoint_3 = __nccwpck_require__(82918);
const middleware_serde_2 = __nccwpck_require__(81238);
const smithy_client_10 = __nccwpck_require__(63570);
const types_2 = __nccwpck_require__(55756);
class RegisterClientCommand extends smithy_client_10.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_2.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_3.getEndpointPlugin)(configuration, _RegisterClientCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOOIDCClient";
        const commandName = "RegisterClientCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
            [types_2.SMITHY_CONTEXT_KEY]: {
                service: "AWSSSOOIDCService",
                operation: "RegisterClient",
            },
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return se_RegisterClientCommand(input, context);
    }
    deserialize(output, context) {
        return de_RegisterClientCommand(output, context);
    }
}
const middleware_endpoint_4 = __nccwpck_require__(82918);
const middleware_serde_3 = __nccwpck_require__(81238);
const smithy_client_11 = __nccwpck_require__(63570);
const types_3 = __nccwpck_require__(55756);
class StartDeviceAuthorizationCommand extends smithy_client_11.Command {
    constructor(input) {
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
            Endpoint: { type: "builtInParams", name: "endpoint" },
            Region: { type: "builtInParams", name: "region" },
            UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_3.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_4.getEndpointPlugin)(configuration, _StartDeviceAuthorizationCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOOIDCClient";
        const commandName = "StartDeviceAuthorizationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_) => _,
            outputFilterSensitiveLog: (_) => _,
            [types_3.SMITHY_CONTEXT_KEY]: {
                service: "AWSSSOOIDCService",
                operation: "StartDeviceAuthorization",
            },
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return se_StartDeviceAuthorizationCommand(input, context);
    }
    deserialize(output, context) {
        return de_StartDeviceAuthorizationCommand(output, context);
    }
}
var commands = {
    CreateTokenCommand,
    RegisterClientCommand,
    StartDeviceAuthorizationCommand,
};
var SSOOIDC = class extends SSOOIDCClient {
};
(0, smithy_client_6.createAggregatedClient)(commands, SSOOIDC);


/***/ }),

/***/ 92242:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.REFRESH_MESSAGE = exports.EXPIRE_WINDOW_MS = void 0;
exports.EXPIRE_WINDOW_MS = 5 * 60 * 1000;
exports.REFRESH_MESSAGE = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;


/***/ }),

/***/ 85125:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromSso = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const constants_1 = __nccwpck_require__(92242);
const getNewSsoOidcToken_1 = __nccwpck_require__(93601);
const validateTokenExpiry_1 = __nccwpck_require__(28418);
const validateTokenKey_1 = __nccwpck_require__(2488);
const writeSSOTokenToFile_1 = __nccwpck_require__(48552);
const lastRefreshAttemptTime = new Date(0);
const fromSso = (init = {}) => async () => {
    const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
    const profileName = (0, shared_ini_file_loader_1.getProfileName)(init);
    const profile = profiles[profileName];
    if (!profile) {
        throw new property_provider_1.TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
    }
    else if (!profile["sso_session"]) {
        throw new property_provider_1.TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
    }
    const ssoSessionName = profile["sso_session"];
    const ssoSessions = await (0, shared_ini_file_loader_1.loadSsoSessionData)(init);
    const ssoSession = ssoSessions[ssoSessionName];
    if (!ssoSession) {
        throw new property_provider_1.TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
    }
    for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {
        if (!ssoSession[ssoSessionRequiredKey]) {
            throw new property_provider_1.TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
        }
    }
    const ssoStartUrl = ssoSession["sso_start_url"];
    const ssoRegion = ssoSession["sso_region"];
    let ssoToken;
    try {
        ssoToken = await (0, shared_ini_file_loader_1.getSSOTokenFromFile)(ssoSessionName);
    }
    catch (e) {
        throw new property_provider_1.TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${constants_1.REFRESH_MESSAGE}`, false);
    }
    (0, validateTokenKey_1.validateTokenKey)("accessToken", ssoToken.accessToken);
    (0, validateTokenKey_1.validateTokenKey)("expiresAt", ssoToken.expiresAt);
    const { accessToken, expiresAt } = ssoToken;
    const existingToken = { token: accessToken, expiration: new Date(expiresAt) };
    if (existingToken.expiration.getTime() - Date.now() > constants_1.EXPIRE_WINDOW_MS) {
        return existingToken;
    }
    if (Date.now() - lastRefreshAttemptTime.getTime() < 30 * 1000) {
        (0, validateTokenExpiry_1.validateTokenExpiry)(existingToken);
        return existingToken;
    }
    (0, validateTokenKey_1.validateTokenKey)("clientId", ssoToken.clientId, true);
    (0, validateTokenKey_1.validateTokenKey)("clientSecret", ssoToken.clientSecret, true);
    (0, validateTokenKey_1.validateTokenKey)("refreshToken", ssoToken.refreshToken, true);
    try {
        lastRefreshAttemptTime.setTime(Date.now());
        const newSsoOidcToken = await (0, getNewSsoOidcToken_1.getNewSsoOidcToken)(ssoToken, ssoRegion);
        (0, validateTokenKey_1.validateTokenKey)("accessToken", newSsoOidcToken.accessToken);
        (0, validateTokenKey_1.validateTokenKey)("expiresIn", newSsoOidcToken.expiresIn);
        const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1000);
        try {
            await (0, writeSSOTokenToFile_1.writeSSOTokenToFile)(ssoSessionName, {
                ...ssoToken,
                accessToken: newSsoOidcToken.accessToken,
                expiresAt: newTokenExpiration.toISOString(),
                refreshToken: newSsoOidcToken.refreshToken,
            });
        }
        catch (error) {
        }
        return {
            token: newSsoOidcToken.accessToken,
            expiration: newTokenExpiration,
        };
    }
    catch (error) {
        (0, validateTokenExpiry_1.validateTokenExpiry)(existingToken);
        return existingToken;
    }
};
exports.fromSso = fromSso;


/***/ }),

/***/ 63258:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromStatic = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const fromStatic = ({ token }) => async () => {
    if (!token || !token.token) {
        throw new property_provider_1.TokenProviderError(`Please pass a valid token to fromStatic`, false);
    }
    return token;
};
exports.fromStatic = fromStatic;


/***/ }),

/***/ 93601:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getNewSsoOidcToken = void 0;
const client_sso_oidc_node_1 = __nccwpck_require__(52664);
const getSsoOidcClient_1 = __nccwpck_require__(99775);
const getNewSsoOidcToken = (ssoToken, ssoRegion) => {
    const ssoOidcClient = (0, getSsoOidcClient_1.getSsoOidcClient)(ssoRegion);
    return ssoOidcClient.send(new client_sso_oidc_node_1.CreateTokenCommand({
        clientId: ssoToken.clientId,
        clientSecret: ssoToken.clientSecret,
        refreshToken: ssoToken.refreshToken,
        grantType: "refresh_token",
    }));
};
exports.getNewSsoOidcToken = getNewSsoOidcToken;


/***/ }),

/***/ 99775:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSsoOidcClient = void 0;
const client_sso_oidc_node_1 = __nccwpck_require__(52664);
const ssoOidcClientsHash = {};
const getSsoOidcClient = (ssoRegion) => {
    if (ssoOidcClientsHash[ssoRegion]) {
        return ssoOidcClientsHash[ssoRegion];
    }
    const ssoOidcClient = new client_sso_oidc_node_1.SSOOIDCClient({ region: ssoRegion });
    ssoOidcClientsHash[ssoRegion] = ssoOidcClient;
    return ssoOidcClient;
};
exports.getSsoOidcClient = getSsoOidcClient;


/***/ }),

/***/ 52843:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(52664), exports);
tslib_1.__exportStar(__nccwpck_require__(85125), exports);
tslib_1.__exportStar(__nccwpck_require__(63258), exports);
tslib_1.__exportStar(__nccwpck_require__(70195), exports);


/***/ }),

/***/ 70195:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nodeProvider = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const fromSso_1 = __nccwpck_require__(85125);
const nodeProvider = (init = {}) => (0, property_provider_1.memoize)((0, property_provider_1.chain)((0, fromSso_1.fromSso)(init), async () => {
    throw new property_provider_1.TokenProviderError("Could not load token from any providers", false);
}), (token) => token.expiration !== undefined && token.expiration.getTime() - Date.now() < 300000, (token) => token.expiration !== undefined);
exports.nodeProvider = nodeProvider;


/***/ }),

/***/ 28418:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateTokenExpiry = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const constants_1 = __nccwpck_require__(92242);
const validateTokenExpiry = (token) => {
    if (token.expiration && token.expiration.getTime() < Date.now()) {
        throw new property_provider_1.TokenProviderError(`Token is expired. ${constants_1.REFRESH_MESSAGE}`, false);
    }
};
exports.validateTokenExpiry = validateTokenExpiry;


/***/ }),

/***/ 2488:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateTokenKey = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const constants_1 = __nccwpck_require__(92242);
const validateTokenKey = (key, value, forRefresh = false) => {
    if (typeof value === "undefined") {
        throw new property_provider_1.TokenProviderError(`Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${constants_1.REFRESH_MESSAGE}`, false);
    }
};
exports.validateTokenKey = validateTokenKey;


/***/ }),

/***/ 48552:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.writeSSOTokenToFile = void 0;
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const fs_1 = __nccwpck_require__(57147);
const { writeFile } = fs_1.promises;
const writeSSOTokenToFile = (id, ssoToken) => {
    const tokenFilepath = (0, shared_ini_file_loader_1.getSSOTokenFilepath)(id);
    const tokenString = JSON.stringify(ssoToken, null, 2);
    return writeFile(tokenFilepath, tokenString);
};
exports.writeSSOTokenToFile = writeSSOTokenToFile;


/***/ }),

/***/ 85487:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.build = exports.parse = exports.validate = void 0;
const validate = (str) => typeof str === "string" && str.indexOf("arn:") === 0 && str.split(":").length >= 6;
exports.validate = validate;
const parse = (arn) => {
    const segments = arn.split(":");
    if (segments.length < 6 || segments[0] !== "arn")
        throw new Error("Malformed ARN");
    const [, partition, service, region, accountId, ...resource] = segments;
    return {
        partition,
        service,
        region,
        accountId,
        resource: resource.join(":"),
    };
};
exports.parse = parse;
const build = (arnObject) => {
    const { partition = "aws", service, region, accountId, resource } = arnObject;
    if ([service, region, accountId, resource].some((segment) => typeof segment !== "string")) {
        throw new Error("Input ARN object is invalid");
    }
    return `arn:${partition}:${service}:${region}:${accountId}:${resource}`;
};
exports.build = build;


/***/ }),

/***/ 15011:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const util_endpoints_1 = __nccwpck_require__(45473);
const isVirtualHostableS3Bucket_1 = __nccwpck_require__(48079);
const parseArn_1 = __nccwpck_require__(34711);
const partition_1 = __nccwpck_require__(37482);
const awsEndpointFunctions = {
    isVirtualHostableS3Bucket: isVirtualHostableS3Bucket_1.isVirtualHostableS3Bucket,
    parseArn: parseArn_1.parseArn,
    partition: partition_1.partition,
};
util_endpoints_1.customEndpointFunctions.aws = awsEndpointFunctions;


/***/ }),

/***/ 13350:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(15011), exports);
tslib_1.__exportStar(__nccwpck_require__(37482), exports);
tslib_1.__exportStar(__nccwpck_require__(73442), exports);
tslib_1.__exportStar(__nccwpck_require__(36563), exports);
tslib_1.__exportStar(__nccwpck_require__(57433), exports);


/***/ }),

/***/ 48079:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isVirtualHostableS3Bucket = void 0;
const util_endpoints_1 = __nccwpck_require__(45473);
const isIpAddress_1 = __nccwpck_require__(73442);
const isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
    if (allowSubDomains) {
        for (const label of value.split(".")) {
            if (!(0, exports.isVirtualHostableS3Bucket)(label)) {
                return false;
            }
        }
        return true;
    }
    if (!(0, util_endpoints_1.isValidHostLabel)(value)) {
        return false;
    }
    if (value.length < 3 || value.length > 63) {
        return false;
    }
    if (value !== value.toLowerCase()) {
        return false;
    }
    if ((0, isIpAddress_1.isIpAddress)(value)) {
        return false;
    }
    return true;
};
exports.isVirtualHostableS3Bucket = isVirtualHostableS3Bucket;


/***/ }),

/***/ 34711:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseArn = void 0;
const parseArn = (value) => {
    const segments = value.split(":");
    if (segments.length < 6)
        return null;
    const [arn, partition, service, region, accountId, ...resourceId] = segments;
    if (arn !== "arn" || partition === "" || service === "" || resourceId[0] === "")
        return null;
    return {
        partition,
        service,
        region,
        accountId,
        resourceId: resourceId[0].includes("/") ? resourceId[0].split("/") : resourceId,
    };
};
exports.parseArn = parseArn;


/***/ }),

/***/ 37482:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUserAgentPrefix = exports.useDefaultPartitionInfo = exports.setPartitionInfo = exports.partition = void 0;
const tslib_1 = __nccwpck_require__(4351);
const partitions_json_1 = tslib_1.__importDefault(__nccwpck_require__(95367));
let selectedPartitionsInfo = partitions_json_1.default;
let selectedUserAgentPrefix = "";
const partition = (value) => {
    const { partitions } = selectedPartitionsInfo;
    for (const partition of partitions) {
        const { regions, outputs } = partition;
        for (const [region, regionData] of Object.entries(regions)) {
            if (region === value) {
                return {
                    ...outputs,
                    ...regionData,
                };
            }
        }
    }
    for (const partition of partitions) {
        const { regionRegex, outputs } = partition;
        if (new RegExp(regionRegex).test(value)) {
            return {
                ...outputs,
            };
        }
    }
    const DEFAULT_PARTITION = partitions.find((partition) => partition.id === "aws");
    if (!DEFAULT_PARTITION) {
        throw new Error("Provided region was not found in the partition array or regex," +
            " and default partition with id 'aws' doesn't exist.");
    }
    return {
        ...DEFAULT_PARTITION.outputs,
    };
};
exports.partition = partition;
const setPartitionInfo = (partitionsInfo, userAgentPrefix = "") => {
    selectedPartitionsInfo = partitionsInfo;
    selectedUserAgentPrefix = userAgentPrefix;
};
exports.setPartitionInfo = setPartitionInfo;
const useDefaultPartitionInfo = () => {
    (0, exports.setPartitionInfo)(partitions_json_1.default, "");
};
exports.useDefaultPartitionInfo = useDefaultPartitionInfo;
const getUserAgentPrefix = () => selectedUserAgentPrefix;
exports.getUserAgentPrefix = getUserAgentPrefix;


/***/ }),

/***/ 73442:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isIpAddress = void 0;
var util_endpoints_1 = __nccwpck_require__(45473);
Object.defineProperty(exports, "isIpAddress", ({ enumerable: true, get: function () { return util_endpoints_1.isIpAddress; } }));


/***/ }),

/***/ 36563:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveEndpoint = void 0;
var util_endpoints_1 = __nccwpck_require__(45473);
Object.defineProperty(exports, "resolveEndpoint", ({ enumerable: true, get: function () { return util_endpoints_1.resolveEndpoint; } }));


/***/ }),

/***/ 82605:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndpointError = void 0;
var util_endpoints_1 = __nccwpck_require__(45473);
Object.defineProperty(exports, "EndpointError", ({ enumerable: true, get: function () { return util_endpoints_1.EndpointError; } }));


/***/ }),

/***/ 21261:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 20312:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 56083:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 21767:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 57433:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(82605), exports);
tslib_1.__exportStar(__nccwpck_require__(21261), exports);
tslib_1.__exportStar(__nccwpck_require__(20312), exports);
tslib_1.__exportStar(__nccwpck_require__(56083), exports);
tslib_1.__exportStar(__nccwpck_require__(21767), exports);
tslib_1.__exportStar(__nccwpck_require__(41811), exports);


/***/ }),

/***/ 41811:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 5865:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crtAvailability = void 0;
exports.crtAvailability = {
    isCrtAvailable: false,
};


/***/ }),

/***/ 98095:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultUserAgent = exports.UA_APP_ID_INI_NAME = exports.UA_APP_ID_ENV_NAME = exports.crtAvailability = void 0;
const node_config_provider_1 = __nccwpck_require__(33461);
const os_1 = __nccwpck_require__(22037);
const process_1 = __nccwpck_require__(77282);
const is_crt_available_1 = __nccwpck_require__(68390);
var crt_availability_1 = __nccwpck_require__(5865);
Object.defineProperty(exports, "crtAvailability", ({ enumerable: true, get: function () { return crt_availability_1.crtAvailability; } }));
exports.UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
exports.UA_APP_ID_INI_NAME = "sdk-ua-app-id";
const defaultUserAgent = ({ serviceId, clientVersion }) => {
    const sections = [
        ["aws-sdk-js", clientVersion],
        ["ua", "2.0"],
        [`os/${(0, os_1.platform)()}`, (0, os_1.release)()],
        ["lang/js"],
        ["md/nodejs", `${process_1.versions.node}`],
    ];
    const crtAvailable = (0, is_crt_available_1.isCrtAvailable)();
    if (crtAvailable) {
        sections.push(crtAvailable);
    }
    if (serviceId) {
        sections.push([`api/${serviceId}`, clientVersion]);
    }
    if (process_1.env.AWS_EXECUTION_ENV) {
        sections.push([`exec-env/${process_1.env.AWS_EXECUTION_ENV}`]);
    }
    const appIdPromise = (0, node_config_provider_1.loadConfig)({
        environmentVariableSelector: (env) => env[exports.UA_APP_ID_ENV_NAME],
        configFileSelector: (profile) => profile[exports.UA_APP_ID_INI_NAME],
        default: undefined,
    })();
    let resolvedUserAgent = undefined;
    return async () => {
        if (!resolvedUserAgent) {
            const appId = await appIdPromise;
            resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
        }
        return resolvedUserAgent;
    };
};
exports.defaultUserAgent = defaultUserAgent;


/***/ }),

/***/ 68390:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isCrtAvailable = void 0;
const crt_availability_1 = __nccwpck_require__(5865);
const isCrtAvailable = () => {
    if (crt_availability_1.crtAvailability.isCrtAvailable) {
        return ["md/crt-avail"];
    }
    return null;
};
exports.isCrtAvailable = isCrtAvailable;


/***/ }),

/***/ 28172:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toUtf8 = exports.fromUtf8 = void 0;
const pureJs_1 = __nccwpck_require__(21590);
const whatwgEncodingApi_1 = __nccwpck_require__(89215);
const fromUtf8 = (input) => typeof TextEncoder === "function" ? (0, whatwgEncodingApi_1.fromUtf8)(input) : (0, pureJs_1.fromUtf8)(input);
exports.fromUtf8 = fromUtf8;
const toUtf8 = (input) => typeof TextDecoder === "function" ? (0, whatwgEncodingApi_1.toUtf8)(input) : (0, pureJs_1.toUtf8)(input);
exports.toUtf8 = toUtf8;


/***/ }),

/***/ 21590:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toUtf8 = exports.fromUtf8 = void 0;
const fromUtf8 = (input) => {
    const bytes = [];
    for (let i = 0, len = input.length; i < len; i++) {
        const value = input.charCodeAt(i);
        if (value < 0x80) {
            bytes.push(value);
        }
        else if (value < 0x800) {
            bytes.push((value >> 6) | 0b11000000, (value & 0b111111) | 0b10000000);
        }
        else if (i + 1 < input.length && (value & 0xfc00) === 0xd800 && (input.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {
            const surrogatePair = 0x10000 + ((value & 0b1111111111) << 10) + (input.charCodeAt(++i) & 0b1111111111);
            bytes.push((surrogatePair >> 18) | 0b11110000, ((surrogatePair >> 12) & 0b111111) | 0b10000000, ((surrogatePair >> 6) & 0b111111) | 0b10000000, (surrogatePair & 0b111111) | 0b10000000);
        }
        else {
            bytes.push((value >> 12) | 0b11100000, ((value >> 6) & 0b111111) | 0b10000000, (value & 0b111111) | 0b10000000);
        }
    }
    return Uint8Array.from(bytes);
};
exports.fromUtf8 = fromUtf8;
const toUtf8 = (input) => {
    let decoded = "";
    for (let i = 0, len = input.length; i < len; i++) {
        const byte = input[i];
        if (byte < 0x80) {
            decoded += String.fromCharCode(byte);
        }
        else if (0b11000000 <= byte && byte < 0b11100000) {
            const nextByte = input[++i];
            decoded += String.fromCharCode(((byte & 0b11111) << 6) | (nextByte & 0b111111));
        }
        else if (0b11110000 <= byte && byte < 0b101101101) {
            const surrogatePair = [byte, input[++i], input[++i], input[++i]];
            const encoded = "%" + surrogatePair.map((byteValue) => byteValue.toString(16)).join("%");
            decoded += decodeURIComponent(encoded);
        }
        else {
            decoded += String.fromCharCode(((byte & 0b1111) << 12) | ((input[++i] & 0b111111) << 6) | (input[++i] & 0b111111));
        }
    }
    return decoded;
};
exports.toUtf8 = toUtf8;


/***/ }),

/***/ 89215:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toUtf8 = exports.fromUtf8 = void 0;
function fromUtf8(input) {
    return new TextEncoder().encode(input);
}
exports.fromUtf8 = fromUtf8;
function toUtf8(input) {
    return new TextDecoder("utf-8").decode(input);
}
exports.toUtf8 = toUtf8;


/***/ }),

/***/ 74452:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XmlNode = void 0;
const escape_attribute_1 = __nccwpck_require__(16508);
const XmlText_1 = __nccwpck_require__(82656);
class XmlNode {
    static of(name, childText, withName) {
        const node = new XmlNode(name);
        if (childText !== undefined) {
            node.addChildNode(new XmlText_1.XmlText(childText));
        }
        if (withName !== undefined) {
            node.withName(withName);
        }
        return node;
    }
    constructor(name, children = []) {
        this.name = name;
        this.children = children;
        this.attributes = {};
    }
    withName(name) {
        this.name = name;
        return this;
    }
    addAttribute(name, value) {
        this.attributes[name] = value;
        return this;
    }
    addChildNode(child) {
        this.children.push(child);
        return this;
    }
    removeAttribute(name) {
        delete this.attributes[name];
        return this;
    }
    n(name) {
        this.name = name;
        return this;
    }
    c(child) {
        this.children.push(child);
        return this;
    }
    a(name, value) {
        if (value != null) {
            this.attributes[name] = value;
        }
        return this;
    }
    cc(input, field, withName = field) {
        if (input[field] != null) {
            const node = XmlNode.of(field, input[field]).withName(withName);
            this.c(node);
        }
    }
    l(input, listName, memberName, valueProvider) {
        if (input[listName] != null) {
            const nodes = valueProvider();
            nodes.map((node) => {
                node.withName(memberName);
                this.c(node);
            });
        }
    }
    lc(input, listName, memberName, valueProvider) {
        if (input[listName] != null) {
            const nodes = valueProvider();
            const containerNode = new XmlNode(memberName);
            nodes.map((node) => {
                containerNode.c(node);
            });
            this.c(containerNode);
        }
    }
    toString() {
        const hasChildren = Boolean(this.children.length);
        let xmlText = `<${this.name}`;
        const attributes = this.attributes;
        for (const attributeName of Object.keys(attributes)) {
            const attribute = attributes[attributeName];
            if (attribute != null) {
                xmlText += ` ${attributeName}="${(0, escape_attribute_1.escapeAttribute)("" + attribute)}"`;
            }
        }
        return (xmlText += !hasChildren ? "/>" : `>${this.children.map((c) => c.toString()).join("")}</${this.name}>`);
    }
}
exports.XmlNode = XmlNode;


/***/ }),

/***/ 82656:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XmlText = void 0;
const escape_element_1 = __nccwpck_require__(96783);
class XmlText {
    constructor(value) {
        this.value = value;
    }
    toString() {
        return (0, escape_element_1.escapeElement)("" + this.value);
    }
}
exports.XmlText = XmlText;


/***/ }),

/***/ 16508:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeAttribute = void 0;
function escapeAttribute(value) {
    return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}
exports.escapeAttribute = escapeAttribute;


/***/ }),

/***/ 96783:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeElement = void 0;
function escapeElement(value) {
    return value
        .replace(/&/g, "&amp;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&apos;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\r/g, "&#x0D;")
        .replace(/\n/g, "&#x0A;")
        .replace(/\u0085/g, "&#x85;")
        .replace(/\u2028/, "&#x2028;");
}
exports.escapeElement = escapeElement;


/***/ }),

/***/ 42329:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(74452), exports);
tslib_1.__exportStar(__nccwpck_require__(82656), exports);


/***/ }),

/***/ 43779:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = exports.DEFAULT_USE_DUALSTACK_ENDPOINT = exports.CONFIG_USE_DUALSTACK_ENDPOINT = exports.ENV_USE_DUALSTACK_ENDPOINT = void 0;
const util_config_provider_1 = __nccwpck_require__(83375);
exports.ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
exports.CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
exports.DEFAULT_USE_DUALSTACK_ENDPOINT = false;
exports.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => (0, util_config_provider_1.booleanSelector)(env, exports.ENV_USE_DUALSTACK_ENDPOINT, util_config_provider_1.SelectorType.ENV),
    configFileSelector: (profile) => (0, util_config_provider_1.booleanSelector)(profile, exports.CONFIG_USE_DUALSTACK_ENDPOINT, util_config_provider_1.SelectorType.CONFIG),
    default: false,
};


/***/ }),

/***/ 17994:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = exports.DEFAULT_USE_FIPS_ENDPOINT = exports.CONFIG_USE_FIPS_ENDPOINT = exports.ENV_USE_FIPS_ENDPOINT = void 0;
const util_config_provider_1 = __nccwpck_require__(83375);
exports.ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
exports.CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
exports.DEFAULT_USE_FIPS_ENDPOINT = false;
exports.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => (0, util_config_provider_1.booleanSelector)(env, exports.ENV_USE_FIPS_ENDPOINT, util_config_provider_1.SelectorType.ENV),
    configFileSelector: (profile) => (0, util_config_provider_1.booleanSelector)(profile, exports.CONFIG_USE_FIPS_ENDPOINT, util_config_provider_1.SelectorType.CONFIG),
    default: false,
};


/***/ }),

/***/ 18421:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(43779), exports);
tslib_1.__exportStar(__nccwpck_require__(17994), exports);
tslib_1.__exportStar(__nccwpck_require__(37432), exports);
tslib_1.__exportStar(__nccwpck_require__(61892), exports);


/***/ }),

/***/ 37432:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveCustomEndpointsConfig = void 0;
const util_middleware_1 = __nccwpck_require__(2390);
const resolveCustomEndpointsConfig = (input) => {
    var _a, _b;
    const { endpoint, urlParser } = input;
    return {
        ...input,
        tls: (_a = input.tls) !== null && _a !== void 0 ? _a : true,
        endpoint: (0, util_middleware_1.normalizeProvider)(typeof endpoint === "string" ? urlParser(endpoint) : endpoint),
        isCustomEndpoint: true,
        useDualstackEndpoint: (0, util_middleware_1.normalizeProvider)((_b = input.useDualstackEndpoint) !== null && _b !== void 0 ? _b : false),
    };
};
exports.resolveCustomEndpointsConfig = resolveCustomEndpointsConfig;


/***/ }),

/***/ 61892:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveEndpointsConfig = void 0;
const util_middleware_1 = __nccwpck_require__(2390);
const getEndpointFromRegion_1 = __nccwpck_require__(48570);
const resolveEndpointsConfig = (input) => {
    var _a, _b;
    const useDualstackEndpoint = (0, util_middleware_1.normalizeProvider)((_a = input.useDualstackEndpoint) !== null && _a !== void 0 ? _a : false);
    const { endpoint, useFipsEndpoint, urlParser } = input;
    return {
        ...input,
        tls: (_b = input.tls) !== null && _b !== void 0 ? _b : true,
        endpoint: endpoint
            ? (0, util_middleware_1.normalizeProvider)(typeof endpoint === "string" ? urlParser(endpoint) : endpoint)
            : () => (0, getEndpointFromRegion_1.getEndpointFromRegion)({ ...input, useDualstackEndpoint, useFipsEndpoint }),
        isCustomEndpoint: !!endpoint,
        useDualstackEndpoint,
    };
};
exports.resolveEndpointsConfig = resolveEndpointsConfig;


/***/ }),

/***/ 48570:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointFromRegion = void 0;
const getEndpointFromRegion = async (input) => {
    var _a;
    const { tls = true } = input;
    const region = await input.region();
    const dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
    if (!dnsHostRegex.test(region)) {
        throw new Error("Invalid region in client config");
    }
    const useDualstackEndpoint = await input.useDualstackEndpoint();
    const useFipsEndpoint = await input.useFipsEndpoint();
    const { hostname } = (_a = (await input.regionInfoProvider(region, { useDualstackEndpoint, useFipsEndpoint }))) !== null && _a !== void 0 ? _a : {};
    if (!hostname) {
        throw new Error("Cannot resolve hostname from client config");
    }
    return input.urlParser(`${tls ? "https:" : "http:"}//${hostname}`);
};
exports.getEndpointFromRegion = getEndpointFromRegion;


/***/ }),

/***/ 53098:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(18421), exports);
tslib_1.__exportStar(__nccwpck_require__(221), exports);
tslib_1.__exportStar(__nccwpck_require__(86985), exports);


/***/ }),

/***/ 33898:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_REGION_CONFIG_FILE_OPTIONS = exports.NODE_REGION_CONFIG_OPTIONS = exports.REGION_INI_NAME = exports.REGION_ENV_NAME = void 0;
exports.REGION_ENV_NAME = "AWS_REGION";
exports.REGION_INI_NAME = "region";
exports.NODE_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[exports.REGION_ENV_NAME],
    configFileSelector: (profile) => profile[exports.REGION_INI_NAME],
    default: () => {
        throw new Error("Region is missing");
    },
};
exports.NODE_REGION_CONFIG_FILE_OPTIONS = {
    preferredFile: "credentials",
};


/***/ }),

/***/ 49506:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRealRegion = void 0;
const isFipsRegion_1 = __nccwpck_require__(43870);
const getRealRegion = (region) => (0, isFipsRegion_1.isFipsRegion)(region)
    ? ["fips-aws-global", "aws-fips"].includes(region)
        ? "us-east-1"
        : region.replace(/fips-(dkr-|prod-)?|-fips/, "")
    : region;
exports.getRealRegion = getRealRegion;


/***/ }),

/***/ 221:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(33898), exports);
tslib_1.__exportStar(__nccwpck_require__(87065), exports);


/***/ }),

/***/ 43870:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isFipsRegion = void 0;
const isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
exports.isFipsRegion = isFipsRegion;


/***/ }),

/***/ 87065:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveRegionConfig = void 0;
const getRealRegion_1 = __nccwpck_require__(49506);
const isFipsRegion_1 = __nccwpck_require__(43870);
const resolveRegionConfig = (input) => {
    const { region, useFipsEndpoint } = input;
    if (!region) {
        throw new Error("Region is missing");
    }
    return {
        ...input,
        region: async () => {
            if (typeof region === "string") {
                return (0, getRealRegion_1.getRealRegion)(region);
            }
            const providedRegion = await region();
            return (0, getRealRegion_1.getRealRegion)(providedRegion);
        },
        useFipsEndpoint: async () => {
            const providedRegion = typeof region === "string" ? region : await region();
            if ((0, isFipsRegion_1.isFipsRegion)(providedRegion)) {
                return true;
            }
            return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
        },
    };
};
exports.resolveRegionConfig = resolveRegionConfig;


/***/ }),

/***/ 19814:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 14832:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 99760:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHostnameFromVariants = void 0;
const getHostnameFromVariants = (variants = [], { useFipsEndpoint, useDualstackEndpoint }) => {
    var _a;
    return (_a = variants.find(({ tags }) => useFipsEndpoint === tags.includes("fips") && useDualstackEndpoint === tags.includes("dualstack"))) === null || _a === void 0 ? void 0 : _a.hostname;
};
exports.getHostnameFromVariants = getHostnameFromVariants;


/***/ }),

/***/ 77792:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRegionInfo = void 0;
const getHostnameFromVariants_1 = __nccwpck_require__(99760);
const getResolvedHostname_1 = __nccwpck_require__(1487);
const getResolvedPartition_1 = __nccwpck_require__(44441);
const getResolvedSigningRegion_1 = __nccwpck_require__(92281);
const getRegionInfo = (region, { useFipsEndpoint = false, useDualstackEndpoint = false, signingService, regionHash, partitionHash, }) => {
    var _a, _b, _c, _d, _e, _f;
    const partition = (0, getResolvedPartition_1.getResolvedPartition)(region, { partitionHash });
    const resolvedRegion = region in regionHash ? region : (_b = (_a = partitionHash[partition]) === null || _a === void 0 ? void 0 : _a.endpoint) !== null && _b !== void 0 ? _b : region;
    const hostnameOptions = { useFipsEndpoint, useDualstackEndpoint };
    const regionHostname = (0, getHostnameFromVariants_1.getHostnameFromVariants)((_c = regionHash[resolvedRegion]) === null || _c === void 0 ? void 0 : _c.variants, hostnameOptions);
    const partitionHostname = (0, getHostnameFromVariants_1.getHostnameFromVariants)((_d = partitionHash[partition]) === null || _d === void 0 ? void 0 : _d.variants, hostnameOptions);
    const hostname = (0, getResolvedHostname_1.getResolvedHostname)(resolvedRegion, { regionHostname, partitionHostname });
    if (hostname === undefined) {
        throw new Error(`Endpoint resolution failed for: ${{ resolvedRegion, useFipsEndpoint, useDualstackEndpoint }}`);
    }
    const signingRegion = (0, getResolvedSigningRegion_1.getResolvedSigningRegion)(hostname, {
        signingRegion: (_e = regionHash[resolvedRegion]) === null || _e === void 0 ? void 0 : _e.signingRegion,
        regionRegex: partitionHash[partition].regionRegex,
        useFipsEndpoint,
    });
    return {
        partition,
        signingService,
        hostname,
        ...(signingRegion && { signingRegion }),
        ...(((_f = regionHash[resolvedRegion]) === null || _f === void 0 ? void 0 : _f.signingService) && {
            signingService: regionHash[resolvedRegion].signingService,
        }),
    };
};
exports.getRegionInfo = getRegionInfo;


/***/ }),

/***/ 1487:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getResolvedHostname = void 0;
const getResolvedHostname = (resolvedRegion, { regionHostname, partitionHostname }) => regionHostname
    ? regionHostname
    : partitionHostname
        ? partitionHostname.replace("{region}", resolvedRegion)
        : undefined;
exports.getResolvedHostname = getResolvedHostname;


/***/ }),

/***/ 44441:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getResolvedPartition = void 0;
const getResolvedPartition = (region, { partitionHash }) => { var _a; return (_a = Object.keys(partitionHash || {}).find((key) => partitionHash[key].regions.includes(region))) !== null && _a !== void 0 ? _a : "aws"; };
exports.getResolvedPartition = getResolvedPartition;


/***/ }),

/***/ 92281:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getResolvedSigningRegion = void 0;
const getResolvedSigningRegion = (hostname, { signingRegion, regionRegex, useFipsEndpoint }) => {
    if (signingRegion) {
        return signingRegion;
    }
    else if (useFipsEndpoint) {
        const regionRegexJs = regionRegex.replace("\\\\", "\\").replace(/^\^/g, "\\.").replace(/\$$/g, "\\.");
        const regionRegexmatchArray = hostname.match(regionRegexJs);
        if (regionRegexmatchArray) {
            return regionRegexmatchArray[0].slice(1, -1);
        }
    }
};
exports.getResolvedSigningRegion = getResolvedSigningRegion;


/***/ }),

/***/ 86985:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(19814), exports);
tslib_1.__exportStar(__nccwpck_require__(14832), exports);
tslib_1.__exportStar(__nccwpck_require__(77792), exports);


/***/ }),

/***/ 82518:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSmithyContext = void 0;
const types_1 = __nccwpck_require__(55756);
const getSmithyContext = (context) => context[types_1.SMITHY_CONTEXT_KEY] || (context[types_1.SMITHY_CONTEXT_KEY] = {});
exports.getSmithyContext = getSmithyContext;


/***/ }),

/***/ 55829:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createPaginator = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(41822), exports);
tslib_1.__exportStar(__nccwpck_require__(60793), exports);
tslib_1.__exportStar(__nccwpck_require__(17633), exports);
tslib_1.__exportStar(__nccwpck_require__(82518), exports);
tslib_1.__exportStar(__nccwpck_require__(21843), exports);
tslib_1.__exportStar(__nccwpck_require__(54006), exports);
var createPaginator_1 = __nccwpck_require__(96311);
Object.defineProperty(exports, "createPaginator", ({ enumerable: true, get: function () { return createPaginator_1.createPaginator; } }));


/***/ }),

/***/ 19917:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHttpAuthSchemeEndpointRuleSetPlugin = exports.httpAuthSchemeEndpointRuleSetMiddlewareOptions = void 0;
const middleware_endpoint_1 = __nccwpck_require__(82918);
const httpAuthSchemeMiddleware_1 = __nccwpck_require__(63910);
exports.httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: middleware_endpoint_1.endpointMiddlewareOptions.name,
};
const getHttpAuthSchemeEndpointRuleSetPlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider, }) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo((0, httpAuthSchemeMiddleware_1.httpAuthSchemeMiddleware)(config, {
            httpAuthSchemeParametersProvider,
            identityProviderConfigProvider,
        }), exports.httpAuthSchemeEndpointRuleSetMiddlewareOptions);
    },
});
exports.getHttpAuthSchemeEndpointRuleSetPlugin = getHttpAuthSchemeEndpointRuleSetPlugin;


/***/ }),

/***/ 70022:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHttpAuthSchemePlugin = exports.httpAuthSchemeMiddlewareOptions = void 0;
const middleware_serde_1 = __nccwpck_require__(81238);
const httpAuthSchemeMiddleware_1 = __nccwpck_require__(63910);
exports.httpAuthSchemeMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: middleware_serde_1.serializerMiddlewareOption.name,
};
const getHttpAuthSchemePlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider, }) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo((0, httpAuthSchemeMiddleware_1.httpAuthSchemeMiddleware)(config, {
            httpAuthSchemeParametersProvider,
            identityProviderConfigProvider,
        }), exports.httpAuthSchemeMiddlewareOptions);
    },
});
exports.getHttpAuthSchemePlugin = getHttpAuthSchemePlugin;


/***/ }),

/***/ 63910:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.httpAuthSchemeMiddleware = void 0;
const types_1 = __nccwpck_require__(55756);
const util_middleware_1 = __nccwpck_require__(2390);
function convertHttpAuthSchemesToMap(httpAuthSchemes) {
    const map = new Map();
    for (const scheme of httpAuthSchemes) {
        map.set(scheme.schemeId, scheme);
    }
    return map;
}
const httpAuthSchemeMiddleware = (config, mwOptions) => (next, context) => async (args) => {
    var _a;
    const options = config.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config, context, args.input));
    const authSchemes = convertHttpAuthSchemesToMap(config.httpAuthSchemes);
    const smithyContext = (0, util_middleware_1.getSmithyContext)(context);
    const failureReasons = [];
    for (const option of options) {
        const scheme = authSchemes.get(option.schemeId);
        if (!scheme) {
            failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` was not enabled for this service.`);
            continue;
        }
        const identityProvider = scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config));
        if (!identityProvider) {
            failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` did not have an IdentityProvider configured.`);
            continue;
        }
        const { identityProperties = {}, signingProperties = {} } = ((_a = option.propertiesExtractor) === null || _a === void 0 ? void 0 : _a.call(option, config, context)) || {};
        option.identityProperties = Object.assign(option.identityProperties || {}, identityProperties);
        option.signingProperties = Object.assign(option.signingProperties || {}, signingProperties);
        smithyContext.selectedHttpAuthScheme = {
            httpAuthOption: option,
            identity: await identityProvider(option.identityProperties),
            signer: scheme.signer,
        };
        break;
    }
    if (!smithyContext.selectedHttpAuthScheme) {
        throw new Error(failureReasons.join("\n"));
    }
    return next(args);
};
exports.httpAuthSchemeMiddleware = httpAuthSchemeMiddleware;


/***/ }),

/***/ 41822:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(63910), exports);
tslib_1.__exportStar(__nccwpck_require__(19917), exports);
tslib_1.__exportStar(__nccwpck_require__(70022), exports);


/***/ }),

/***/ 96819:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHttpSigningPlugin = exports.httpSigningMiddlewareOptions = void 0;
const middleware_retry_1 = __nccwpck_require__(96039);
const httpSigningMiddleware_1 = __nccwpck_require__(22774);
exports.httpSigningMiddlewareOptions = {
    step: "finalizeRequest",
    tags: ["HTTP_SIGNING"],
    name: "httpSigningMiddleware",
    aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
    override: true,
    relation: "after",
    toMiddleware: middleware_retry_1.retryMiddlewareOptions.name,
};
const getHttpSigningPlugin = (config) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo((0, httpSigningMiddleware_1.httpSigningMiddleware)(config), exports.httpSigningMiddlewareOptions);
    },
});
exports.getHttpSigningPlugin = getHttpSigningPlugin;


/***/ }),

/***/ 22774:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.httpSigningMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const types_1 = __nccwpck_require__(55756);
const util_middleware_1 = __nccwpck_require__(2390);
const defaultErrorHandler = (signingProperties) => (error) => {
    throw error;
};
const defaultSuccessHandler = (httpResponse, signingProperties) => { };
const httpSigningMiddleware = (config) => (next, context) => async (args) => {
    if (!protocol_http_1.HttpRequest.isInstance(args.request)) {
        return next(args);
    }
    const smithyContext = (0, util_middleware_1.getSmithyContext)(context);
    const scheme = smithyContext.selectedHttpAuthScheme;
    if (!scheme) {
        throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
    }
    const { httpAuthOption: { signingProperties = {} }, identity, signer, } = scheme;
    const output = await next({
        ...args,
        request: await signer.sign(args.request, identity, signingProperties),
    }).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));
    (signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);
    return output;
};
exports.httpSigningMiddleware = httpSigningMiddleware;


/***/ }),

/***/ 60793:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(22774), exports);
tslib_1.__exportStar(__nccwpck_require__(96819), exports);


/***/ }),

/***/ 21843:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeProvider = void 0;
const normalizeProvider = (input) => {
    if (typeof input === "function")
        return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
};
exports.normalizeProvider = normalizeProvider;


/***/ }),

/***/ 96311:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createPaginator = void 0;
const makePagedClientRequest = async (CommandCtor, client, input, ...args) => {
    return await client.send(new CommandCtor(input), ...args);
};
function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName, pageSizeTokenName) {
    return async function* paginateOperation(config, input, ...additionalArguments) {
        var _a;
        let token = config.startingToken || undefined;
        let hasNext = true;
        let page;
        while (hasNext) {
            input[inputTokenName] = token;
            if (pageSizeTokenName) {
                input[pageSizeTokenName] = (_a = input[pageSizeTokenName]) !== null && _a !== void 0 ? _a : config.pageSize;
            }
            if (config.client instanceof ClientCtor) {
                page = await makePagedClientRequest(CommandCtor, config.client, input, ...additionalArguments);
            }
            else {
                throw new Error(`Invalid client, expected instance of ${ClientCtor.name}`);
            }
            yield page;
            const prevToken = token;
            token = page[outputTokenName];
            hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
        }
        return undefined;
    };
}
exports.createPaginator = createPaginator;


/***/ }),

/***/ 54006:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestBuilder = exports.requestBuilder = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const smithy_client_1 = __nccwpck_require__(63570);
function requestBuilder(input, context) {
    return new RequestBuilder(input, context);
}
exports.requestBuilder = requestBuilder;
class RequestBuilder {
    constructor(input, context) {
        this.input = input;
        this.context = context;
        this.query = {};
        this.method = "";
        this.headers = {};
        this.path = "";
        this.body = null;
        this.hostname = "";
        this.resolvePathStack = [];
    }
    async build() {
        const { hostname, protocol = "https", port, path: basePath } = await this.context.endpoint();
        this.path = basePath;
        for (const resolvePath of this.resolvePathStack) {
            resolvePath(this.path);
        }
        return new protocol_http_1.HttpRequest({
            protocol,
            hostname: this.hostname || hostname,
            port,
            method: this.method,
            path: this.path,
            query: this.query,
            body: this.body,
            headers: this.headers,
        });
    }
    hn(hostname) {
        this.hostname = hostname;
        return this;
    }
    bp(uriLabel) {
        this.resolvePathStack.push((basePath) => {
            this.path = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + uriLabel;
        });
        return this;
    }
    p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {
        this.resolvePathStack.push((path) => {
            this.path = (0, smithy_client_1.resolvedPath)(path, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);
        });
        return this;
    }
    h(headers) {
        this.headers = headers;
        return this;
    }
    q(query) {
        this.query = query;
        return this;
    }
    b(body) {
        this.body = body;
        return this;
    }
    m(method) {
        this.method = method;
        return this;
    }
}
exports.RequestBuilder = RequestBuilder;


/***/ }),

/***/ 50301:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultIdentityProviderConfig = void 0;
class DefaultIdentityProviderConfig {
    constructor(config) {
        this.authSchemes = new Map();
        for (const [key, value] of Object.entries(config)) {
            if (value !== undefined) {
                this.authSchemes.set(key, value);
            }
        }
    }
    getIdentityProvider(schemeId) {
        return this.authSchemes.get(schemeId);
    }
}
exports.DefaultIdentityProviderConfig = DefaultIdentityProviderConfig;


/***/ }),

/***/ 65906:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpApiKeyAuthSigner = void 0;
const types_1 = __nccwpck_require__(55756);
class HttpApiKeyAuthSigner {
    async sign(httpRequest, identity, signingProperties) {
        if (!signingProperties) {
            throw new Error("request could not be signed with `apiKey` since the `name` and `in` signer properties are missing");
        }
        if (!signingProperties.name) {
            throw new Error("request could not be signed with `apiKey` since the `name` signer property is missing");
        }
        if (!signingProperties.in) {
            throw new Error("request could not be signed with `apiKey` since the `in` signer property is missing");
        }
        if (!identity.apiKey) {
            throw new Error("request could not be signed with `apiKey` since the `apiKey` is not defined");
        }
        const clonedRequest = httpRequest.clone();
        if (signingProperties.in === types_1.HttpApiKeyAuthLocation.QUERY) {
            clonedRequest.query[signingProperties.name] = identity.apiKey;
        }
        else if (signingProperties.in === types_1.HttpApiKeyAuthLocation.HEADER) {
            clonedRequest.headers[signingProperties.name] = signingProperties.scheme
                ? `${signingProperties.scheme} ${identity.apiKey}`
                : identity.apiKey;
        }
        else {
            throw new Error("request can only be signed with `apiKey` locations `query` or `header`, " +
                "but found: `" +
                signingProperties.in +
                "`");
        }
        return clonedRequest;
    }
}
exports.HttpApiKeyAuthSigner = HttpApiKeyAuthSigner;


/***/ }),

/***/ 62414:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpBearerAuthSigner = void 0;
class HttpBearerAuthSigner {
    async sign(httpRequest, identity, signingProperties) {
        const clonedRequest = httpRequest.clone();
        if (!identity.token) {
            throw new Error("request could not be signed with `token` since the `token` is not defined");
        }
        clonedRequest.headers["Authorization"] = `Bearer ${identity.token}`;
        return clonedRequest;
    }
}
exports.HttpBearerAuthSigner = HttpBearerAuthSigner;


/***/ }),

/***/ 86734:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(65906), exports);
tslib_1.__exportStar(__nccwpck_require__(62414), exports);
tslib_1.__exportStar(__nccwpck_require__(62818), exports);


/***/ }),

/***/ 62818:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoAuthSigner = void 0;
class NoAuthSigner {
    async sign(httpRequest, identity, signingProperties) {
        return httpRequest;
    }
}
exports.NoAuthSigner = NoAuthSigner;


/***/ }),

/***/ 17633:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(50301), exports);
tslib_1.__exportStar(__nccwpck_require__(86734), exports);
tslib_1.__exportStar(__nccwpck_require__(69851), exports);


/***/ }),

/***/ 69851:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.memoizeIdentityProvider = exports.doesIdentityRequireRefresh = exports.isIdentityExpired = exports.EXPIRATION_MS = exports.createIsIdentityExpiredFunction = void 0;
const createIsIdentityExpiredFunction = (expirationMs) => (identity) => (0, exports.doesIdentityRequireRefresh)(identity) && identity.expiration.getTime() - Date.now() < expirationMs;
exports.createIsIdentityExpiredFunction = createIsIdentityExpiredFunction;
exports.EXPIRATION_MS = 300000;
exports.isIdentityExpired = (0, exports.createIsIdentityExpiredFunction)(exports.EXPIRATION_MS);
const doesIdentityRequireRefresh = (identity) => identity.expiration !== undefined;
exports.doesIdentityRequireRefresh = doesIdentityRequireRefresh;
const memoizeIdentityProvider = (provider, isExpired, requiresRefresh) => {
    if (provider === undefined) {
        return undefined;
    }
    const normalizedProvider = typeof provider !== "function" ? async () => Promise.resolve(provider) : provider;
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async (options) => {
        if (!pending) {
            pending = normalizedProvider(options);
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        }
        finally {
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options) => {
            if (!hasResult || (options === null || options === void 0 ? void 0 : options.forceRefresh)) {
                resolved = await coalesceProvider(options);
            }
            return resolved;
        };
    }
    return async (options) => {
        if (!hasResult || (options === null || options === void 0 ? void 0 : options.forceRefresh)) {
            resolved = await coalesceProvider(options);
        }
        if (isConstant) {
            return resolved;
        }
        if (!requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider(options);
            return resolved;
        }
        return resolved;
    };
};
exports.memoizeIdentityProvider = memoizeIdentityProvider;


/***/ }),

/***/ 18044:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Endpoint = void 0;
var Endpoint;
(function (Endpoint) {
    Endpoint["IPv4"] = "http://169.254.169.254";
    Endpoint["IPv6"] = "http://[fd00:ec2::254]";
})(Endpoint = exports.Endpoint || (exports.Endpoint = {}));


/***/ }),

/***/ 57342:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ENDPOINT_CONFIG_OPTIONS = exports.CONFIG_ENDPOINT_NAME = exports.ENV_ENDPOINT_NAME = void 0;
exports.ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
exports.CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
exports.ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[exports.ENV_ENDPOINT_NAME],
    configFileSelector: (profile) => profile[exports.CONFIG_ENDPOINT_NAME],
    default: undefined,
};


/***/ }),

/***/ 80991:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndpointMode = void 0;
var EndpointMode;
(function (EndpointMode) {
    EndpointMode["IPv4"] = "IPv4";
    EndpointMode["IPv6"] = "IPv6";
})(EndpointMode = exports.EndpointMode || (exports.EndpointMode = {}));


/***/ }),

/***/ 88337:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ENDPOINT_MODE_CONFIG_OPTIONS = exports.CONFIG_ENDPOINT_MODE_NAME = exports.ENV_ENDPOINT_MODE_NAME = void 0;
const EndpointMode_1 = __nccwpck_require__(80991);
exports.ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
exports.CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
exports.ENDPOINT_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[exports.ENV_ENDPOINT_MODE_NAME],
    configFileSelector: (profile) => profile[exports.CONFIG_ENDPOINT_MODE_NAME],
    default: EndpointMode_1.EndpointMode.IPv4,
};


/***/ }),

/***/ 58232:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InstanceMetadataV1FallbackError = void 0;
const property_provider_1 = __nccwpck_require__(79721);
class InstanceMetadataV1FallbackError extends property_provider_1.CredentialsProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "InstanceMetadataV1FallbackError";
        Object.setPrototypeOf(this, InstanceMetadataV1FallbackError.prototype);
    }
}
exports.InstanceMetadataV1FallbackError = InstanceMetadataV1FallbackError;


/***/ }),

/***/ 89227:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromContainerMetadata = exports.ENV_CMDS_AUTH_TOKEN = exports.ENV_CMDS_RELATIVE_URI = exports.ENV_CMDS_FULL_URI = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const url_1 = __nccwpck_require__(57310);
const httpRequest_1 = __nccwpck_require__(32199);
const ImdsCredentials_1 = __nccwpck_require__(6894);
const RemoteProviderInit_1 = __nccwpck_require__(98533);
const retry_1 = __nccwpck_require__(91351);
exports.ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
exports.ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
exports.ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
const fromContainerMetadata = (init = {}) => {
    const { timeout, maxRetries } = (0, RemoteProviderInit_1.providerConfigFromInit)(init);
    return () => (0, retry_1.retry)(async () => {
        const requestOptions = await getCmdsUri();
        const credsResponse = JSON.parse(await requestFromEcsImds(timeout, requestOptions));
        if (!(0, ImdsCredentials_1.isImdsCredentials)(credsResponse)) {
            throw new property_provider_1.CredentialsProviderError("Invalid response received from instance metadata service.");
        }
        return (0, ImdsCredentials_1.fromImdsCredentials)(credsResponse);
    }, maxRetries);
};
exports.fromContainerMetadata = fromContainerMetadata;
const requestFromEcsImds = async (timeout, options) => {
    if (process.env[exports.ENV_CMDS_AUTH_TOKEN]) {
        options.headers = {
            ...options.headers,
            Authorization: process.env[exports.ENV_CMDS_AUTH_TOKEN],
        };
    }
    const buffer = await (0, httpRequest_1.httpRequest)({
        ...options,
        timeout,
    });
    return buffer.toString();
};
const CMDS_IP = "169.254.170.2";
const GREENGRASS_HOSTS = {
    localhost: true,
    "127.0.0.1": true,
};
const GREENGRASS_PROTOCOLS = {
    "http:": true,
    "https:": true,
};
const getCmdsUri = async () => {
    if (process.env[exports.ENV_CMDS_RELATIVE_URI]) {
        return {
            hostname: CMDS_IP,
            path: process.env[exports.ENV_CMDS_RELATIVE_URI],
        };
    }
    if (process.env[exports.ENV_CMDS_FULL_URI]) {
        const parsed = (0, url_1.parse)(process.env[exports.ENV_CMDS_FULL_URI]);
        if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
            throw new property_provider_1.CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, false);
        }
        if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
            throw new property_provider_1.CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, false);
        }
        return {
            ...parsed,
            port: parsed.port ? parseInt(parsed.port, 10) : undefined,
        };
    }
    throw new property_provider_1.CredentialsProviderError("The container metadata credential provider cannot be used unless" +
        ` the ${exports.ENV_CMDS_RELATIVE_URI} or ${exports.ENV_CMDS_FULL_URI} environment` +
        " variable is set", false);
};


/***/ }),

/***/ 52207:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromInstanceMetadata = void 0;
const node_config_provider_1 = __nccwpck_require__(33461);
const property_provider_1 = __nccwpck_require__(79721);
const InstanceMetadataV1FallbackError_1 = __nccwpck_require__(58232);
const httpRequest_1 = __nccwpck_require__(32199);
const ImdsCredentials_1 = __nccwpck_require__(6894);
const RemoteProviderInit_1 = __nccwpck_require__(98533);
const retry_1 = __nccwpck_require__(91351);
const getInstanceMetadataEndpoint_1 = __nccwpck_require__(92460);
const staticStabilityProvider_1 = __nccwpck_require__(74035);
const IMDS_PATH = "/latest/meta-data/iam/security-credentials/";
const IMDS_TOKEN_PATH = "/latest/api/token";
const AWS_EC2_METADATA_V1_DISABLED = "AWS_EC2_METADATA_V1_DISABLED";
const PROFILE_AWS_EC2_METADATA_V1_DISABLED = "ec2_metadata_v1_disabled";
const X_AWS_EC2_METADATA_TOKEN = "x-aws-ec2-metadata-token";
const fromInstanceMetadata = (init = {}) => (0, staticStabilityProvider_1.staticStabilityProvider)(getInstanceImdsProvider(init), { logger: init.logger });
exports.fromInstanceMetadata = fromInstanceMetadata;
const getInstanceImdsProvider = (init) => {
    let disableFetchToken = false;
    const { logger, profile } = init;
    const { timeout, maxRetries } = (0, RemoteProviderInit_1.providerConfigFromInit)(init);
    const getCredentials = async (maxRetries, options) => {
        var _a;
        const isImdsV1Fallback = disableFetchToken || ((_a = options.headers) === null || _a === void 0 ? void 0 : _a[X_AWS_EC2_METADATA_TOKEN]) == null;
        if (isImdsV1Fallback) {
            let fallbackBlockedFromProfile = false;
            let fallbackBlockedFromProcessEnv = false;
            const configValue = await (0, node_config_provider_1.loadConfig)({
                environmentVariableSelector: (env) => {
                    const envValue = env[AWS_EC2_METADATA_V1_DISABLED];
                    fallbackBlockedFromProcessEnv = !!envValue && envValue !== "false";
                    if (envValue === undefined) {
                        throw new property_provider_1.CredentialsProviderError(`${AWS_EC2_METADATA_V1_DISABLED} not set in env, checking config file next.`);
                    }
                    return fallbackBlockedFromProcessEnv;
                },
                configFileSelector: (profile) => {
                    const profileValue = profile[PROFILE_AWS_EC2_METADATA_V1_DISABLED];
                    fallbackBlockedFromProfile = !!profileValue && profileValue !== "false";
                    return fallbackBlockedFromProfile;
                },
                default: false,
            }, {
                profile,
            })();
            if (init.ec2MetadataV1Disabled || configValue) {
                const causes = [];
                if (init.ec2MetadataV1Disabled)
                    causes.push("credential provider initialization (runtime option ec2MetadataV1Disabled)");
                if (fallbackBlockedFromProfile)
                    causes.push(`config file profile (${PROFILE_AWS_EC2_METADATA_V1_DISABLED})`);
                if (fallbackBlockedFromProcessEnv)
                    causes.push(`process environment variable (${AWS_EC2_METADATA_V1_DISABLED})`);
                throw new InstanceMetadataV1FallbackError_1.InstanceMetadataV1FallbackError(`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${causes.join(", ")}].`);
            }
        }
        const imdsProfile = (await (0, retry_1.retry)(async () => {
            let profile;
            try {
                profile = await getProfile(options);
            }
            catch (err) {
                if (err.statusCode === 401) {
                    disableFetchToken = false;
                }
                throw err;
            }
            return profile;
        }, maxRetries)).trim();
        return (0, retry_1.retry)(async () => {
            let creds;
            try {
                creds = await getCredentialsFromProfile(imdsProfile, options);
            }
            catch (err) {
                if (err.statusCode === 401) {
                    disableFetchToken = false;
                }
                throw err;
            }
            return creds;
        }, maxRetries);
    };
    return async () => {
        const endpoint = await (0, getInstanceMetadataEndpoint_1.getInstanceMetadataEndpoint)();
        if (disableFetchToken) {
            logger === null || logger === void 0 ? void 0 : logger.debug("AWS SDK Instance Metadata", "using v1 fallback (no token fetch)");
            return getCredentials(maxRetries, { ...endpoint, timeout });
        }
        else {
            let token;
            try {
                token = (await getMetadataToken({ ...endpoint, timeout })).toString();
            }
            catch (error) {
                if ((error === null || error === void 0 ? void 0 : error.statusCode) === 400) {
                    throw Object.assign(error, {
                        message: "EC2 Metadata token request returned error",
                    });
                }
                else if (error.message === "TimeoutError" || [403, 404, 405].includes(error.statusCode)) {
                    disableFetchToken = true;
                }
                logger === null || logger === void 0 ? void 0 : logger.debug("AWS SDK Instance Metadata", "using v1 fallback (initial)");
                return getCredentials(maxRetries, { ...endpoint, timeout });
            }
            return getCredentials(maxRetries, {
                ...endpoint,
                headers: {
                    [X_AWS_EC2_METADATA_TOKEN]: token,
                },
                timeout,
            });
        }
    };
};
const getMetadataToken = async (options) => (0, httpRequest_1.httpRequest)({
    ...options,
    path: IMDS_TOKEN_PATH,
    method: "PUT",
    headers: {
        "x-aws-ec2-metadata-token-ttl-seconds": "21600",
    },
});
const getProfile = async (options) => (await (0, httpRequest_1.httpRequest)({ ...options, path: IMDS_PATH })).toString();
const getCredentialsFromProfile = async (profile, options) => {
    const credsResponse = JSON.parse((await (0, httpRequest_1.httpRequest)({
        ...options,
        path: IMDS_PATH + profile,
    })).toString());
    if (!(0, ImdsCredentials_1.isImdsCredentials)(credsResponse)) {
        throw new property_provider_1.CredentialsProviderError("Invalid response received from instance metadata service.");
    }
    return (0, ImdsCredentials_1.fromImdsCredentials)(credsResponse);
};


/***/ }),

/***/ 7477:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getInstanceMetadataEndpoint = exports.httpRequest = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(89227), exports);
tslib_1.__exportStar(__nccwpck_require__(52207), exports);
tslib_1.__exportStar(__nccwpck_require__(98533), exports);
tslib_1.__exportStar(__nccwpck_require__(45036), exports);
var httpRequest_1 = __nccwpck_require__(32199);
Object.defineProperty(exports, "httpRequest", ({ enumerable: true, get: function () { return httpRequest_1.httpRequest; } }));
var getInstanceMetadataEndpoint_1 = __nccwpck_require__(92460);
Object.defineProperty(exports, "getInstanceMetadataEndpoint", ({ enumerable: true, get: function () { return getInstanceMetadataEndpoint_1.getInstanceMetadataEndpoint; } }));


/***/ }),

/***/ 6894:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromImdsCredentials = exports.isImdsCredentials = void 0;
const isImdsCredentials = (arg) => Boolean(arg) &&
    typeof arg === "object" &&
    typeof arg.AccessKeyId === "string" &&
    typeof arg.SecretAccessKey === "string" &&
    typeof arg.Token === "string" &&
    typeof arg.Expiration === "string";
exports.isImdsCredentials = isImdsCredentials;
const fromImdsCredentials = (creds) => ({
    accessKeyId: creds.AccessKeyId,
    secretAccessKey: creds.SecretAccessKey,
    sessionToken: creds.Token,
    expiration: new Date(creds.Expiration),
});
exports.fromImdsCredentials = fromImdsCredentials;


/***/ }),

/***/ 98533:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.providerConfigFromInit = exports.DEFAULT_MAX_RETRIES = exports.DEFAULT_TIMEOUT = void 0;
exports.DEFAULT_TIMEOUT = 1000;
exports.DEFAULT_MAX_RETRIES = 0;
const providerConfigFromInit = ({ maxRetries = exports.DEFAULT_MAX_RETRIES, timeout = exports.DEFAULT_TIMEOUT, }) => ({ maxRetries, timeout });
exports.providerConfigFromInit = providerConfigFromInit;


/***/ }),

/***/ 32199:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.httpRequest = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const buffer_1 = __nccwpck_require__(14300);
const http_1 = __nccwpck_require__(13685);
function httpRequest(options) {
    return new Promise((resolve, reject) => {
        var _a;
        const req = (0, http_1.request)({
            method: "GET",
            ...options,
            hostname: (_a = options.hostname) === null || _a === void 0 ? void 0 : _a.replace(/^\[(.+)\]$/, "$1"),
        });
        req.on("error", (err) => {
            reject(Object.assign(new property_provider_1.ProviderError("Unable to connect to instance metadata service"), err));
            req.destroy();
        });
        req.on("timeout", () => {
            reject(new property_provider_1.ProviderError("TimeoutError from instance metadata service"));
            req.destroy();
        });
        req.on("response", (res) => {
            const { statusCode = 400 } = res;
            if (statusCode < 200 || 300 <= statusCode) {
                reject(Object.assign(new property_provider_1.ProviderError("Error response received from instance metadata service"), { statusCode }));
                req.destroy();
            }
            const chunks = [];
            res.on("data", (chunk) => {
                chunks.push(chunk);
            });
            res.on("end", () => {
                resolve(buffer_1.Buffer.concat(chunks));
                req.destroy();
            });
        });
        req.end();
    });
}
exports.httpRequest = httpRequest;


/***/ }),

/***/ 91351:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.retry = void 0;
const retry = (toRetry, maxRetries) => {
    let promise = toRetry();
    for (let i = 0; i < maxRetries; i++) {
        promise = promise.catch(toRetry);
    }
    return promise;
};
exports.retry = retry;


/***/ }),

/***/ 45036:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 22666:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getExtendedInstanceMetadataCredentials = void 0;
const STATIC_STABILITY_REFRESH_INTERVAL_SECONDS = 5 * 60;
const STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS = 5 * 60;
const STATIC_STABILITY_DOC_URL = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html";
const getExtendedInstanceMetadataCredentials = (credentials, logger) => {
    var _a;
    const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS +
        Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS);
    const newExpiration = new Date(Date.now() + refreshInterval * 1000);
    logger.warn("Attempting credential expiration extension due to a credential service availability issue. A refresh of these " +
        "credentials will be attempted after ${new Date(newExpiration)}.\nFor more information, please visit: " +
        STATIC_STABILITY_DOC_URL);
    const originalExpiration = (_a = credentials.originalExpiration) !== null && _a !== void 0 ? _a : credentials.expiration;
    return {
        ...credentials,
        ...(originalExpiration ? { originalExpiration } : {}),
        expiration: newExpiration,
    };
};
exports.getExtendedInstanceMetadataCredentials = getExtendedInstanceMetadataCredentials;


/***/ }),

/***/ 92460:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getInstanceMetadataEndpoint = void 0;
const node_config_provider_1 = __nccwpck_require__(33461);
const url_parser_1 = __nccwpck_require__(14681);
const Endpoint_1 = __nccwpck_require__(18044);
const EndpointConfigOptions_1 = __nccwpck_require__(57342);
const EndpointMode_1 = __nccwpck_require__(80991);
const EndpointModeConfigOptions_1 = __nccwpck_require__(88337);
const getInstanceMetadataEndpoint = async () => (0, url_parser_1.parseUrl)((await getFromEndpointConfig()) || (await getFromEndpointModeConfig()));
exports.getInstanceMetadataEndpoint = getInstanceMetadataEndpoint;
const getFromEndpointConfig = async () => (0, node_config_provider_1.loadConfig)(EndpointConfigOptions_1.ENDPOINT_CONFIG_OPTIONS)();
const getFromEndpointModeConfig = async () => {
    const endpointMode = await (0, node_config_provider_1.loadConfig)(EndpointModeConfigOptions_1.ENDPOINT_MODE_CONFIG_OPTIONS)();
    switch (endpointMode) {
        case EndpointMode_1.EndpointMode.IPv4:
            return Endpoint_1.Endpoint.IPv4;
        case EndpointMode_1.EndpointMode.IPv6:
            return Endpoint_1.Endpoint.IPv6;
        default:
            throw new Error(`Unsupported endpoint mode: ${endpointMode}.` + ` Select from ${Object.values(EndpointMode_1.EndpointMode)}`);
    }
};


/***/ }),

/***/ 74035:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.staticStabilityProvider = void 0;
const getExtendedInstanceMetadataCredentials_1 = __nccwpck_require__(22666);
const staticStabilityProvider = (provider, options = {}) => {
    const logger = (options === null || options === void 0 ? void 0 : options.logger) || console;
    let pastCredentials;
    return async () => {
        let credentials;
        try {
            credentials = await provider();
            if (credentials.expiration && credentials.expiration.getTime() < Date.now()) {
                credentials = (0, getExtendedInstanceMetadataCredentials_1.getExtendedInstanceMetadataCredentials)(credentials, logger);
            }
        }
        catch (e) {
            if (pastCredentials) {
                logger.warn("Credential renew failed: ", e);
                credentials = (0, getExtendedInstanceMetadataCredentials_1.getExtendedInstanceMetadataCredentials)(pastCredentials, logger);
            }
            else {
                throw e;
            }
        }
        pastCredentials = credentials;
        return credentials;
    };
};
exports.staticStabilityProvider = staticStabilityProvider;


/***/ }),

/***/ 11014:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventStreamCodec = void 0;
const crc32_1 = __nccwpck_require__(47327);
const HeaderMarshaller_1 = __nccwpck_require__(74712);
const splitMessage_1 = __nccwpck_require__(20597);
class EventStreamCodec {
    constructor(toUtf8, fromUtf8) {
        this.headerMarshaller = new HeaderMarshaller_1.HeaderMarshaller(toUtf8, fromUtf8);
        this.messageBuffer = [];
        this.isEndOfStream = false;
    }
    feed(message) {
        this.messageBuffer.push(this.decode(message));
    }
    endOfStream() {
        this.isEndOfStream = true;
    }
    getMessage() {
        const message = this.messageBuffer.pop();
        const isEndOfStream = this.isEndOfStream;
        return {
            getMessage() {
                return message;
            },
            isEndOfStream() {
                return isEndOfStream;
            },
        };
    }
    getAvailableMessages() {
        const messages = this.messageBuffer;
        this.messageBuffer = [];
        const isEndOfStream = this.isEndOfStream;
        return {
            getMessages() {
                return messages;
            },
            isEndOfStream() {
                return isEndOfStream;
            },
        };
    }
    encode({ headers: rawHeaders, body }) {
        const headers = this.headerMarshaller.format(rawHeaders);
        const length = headers.byteLength + body.byteLength + 16;
        const out = new Uint8Array(length);
        const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        const checksum = new crc32_1.Crc32();
        view.setUint32(0, length, false);
        view.setUint32(4, headers.byteLength, false);
        view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
        out.set(headers, 12);
        out.set(body, headers.byteLength + 12);
        view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);
        return out;
    }
    decode(message) {
        const { headers, body } = (0, splitMessage_1.splitMessage)(message);
        return { headers: this.headerMarshaller.parse(headers), body };
    }
    formatHeaders(rawHeaders) {
        return this.headerMarshaller.format(rawHeaders);
    }
}
exports.EventStreamCodec = EventStreamCodec;


/***/ }),

/***/ 74712:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HeaderMarshaller = void 0;
const util_hex_encoding_1 = __nccwpck_require__(45364);
const Int64_1 = __nccwpck_require__(46086);
class HeaderMarshaller {
    constructor(toUtf8, fromUtf8) {
        this.toUtf8 = toUtf8;
        this.fromUtf8 = fromUtf8;
    }
    format(headers) {
        const chunks = [];
        for (const headerName of Object.keys(headers)) {
            const bytes = this.fromUtf8(headerName);
            chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
        }
        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
        let position = 0;
        for (const chunk of chunks) {
            out.set(chunk, position);
            position += chunk.byteLength;
        }
        return out;
    }
    formatHeaderValue(header) {
        switch (header.type) {
            case "boolean":
                return Uint8Array.from([header.value ? 0 : 1]);
            case "byte":
                return Uint8Array.from([2, header.value]);
            case "short":
                const shortView = new DataView(new ArrayBuffer(3));
                shortView.setUint8(0, 3);
                shortView.setInt16(1, header.value, false);
                return new Uint8Array(shortView.buffer);
            case "integer":
                const intView = new DataView(new ArrayBuffer(5));
                intView.setUint8(0, 4);
                intView.setInt32(1, header.value, false);
                return new Uint8Array(intView.buffer);
            case "long":
                const longBytes = new Uint8Array(9);
                longBytes[0] = 5;
                longBytes.set(header.value.bytes, 1);
                return longBytes;
            case "binary":
                const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
                binView.setUint8(0, 6);
                binView.setUint16(1, header.value.byteLength, false);
                const binBytes = new Uint8Array(binView.buffer);
                binBytes.set(header.value, 3);
                return binBytes;
            case "string":
                const utf8Bytes = this.fromUtf8(header.value);
                const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
                strView.setUint8(0, 7);
                strView.setUint16(1, utf8Bytes.byteLength, false);
                const strBytes = new Uint8Array(strView.buffer);
                strBytes.set(utf8Bytes, 3);
                return strBytes;
            case "timestamp":
                const tsBytes = new Uint8Array(9);
                tsBytes[0] = 8;
                tsBytes.set(Int64_1.Int64.fromNumber(header.value.valueOf()).bytes, 1);
                return tsBytes;
            case "uuid":
                if (!UUID_PATTERN.test(header.value)) {
                    throw new Error(`Invalid UUID received: ${header.value}`);
                }
                const uuidBytes = new Uint8Array(17);
                uuidBytes[0] = 9;
                uuidBytes.set((0, util_hex_encoding_1.fromHex)(header.value.replace(/\-/g, "")), 1);
                return uuidBytes;
        }
    }
    parse(headers) {
        const out = {};
        let position = 0;
        while (position < headers.byteLength) {
            const nameLength = headers.getUint8(position++);
            const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
            position += nameLength;
            switch (headers.getUint8(position++)) {
                case 0:
                    out[name] = {
                        type: BOOLEAN_TAG,
                        value: true,
                    };
                    break;
                case 1:
                    out[name] = {
                        type: BOOLEAN_TAG,
                        value: false,
                    };
                    break;
                case 2:
                    out[name] = {
                        type: BYTE_TAG,
                        value: headers.getInt8(position++),
                    };
                    break;
                case 3:
                    out[name] = {
                        type: SHORT_TAG,
                        value: headers.getInt16(position, false),
                    };
                    position += 2;
                    break;
                case 4:
                    out[name] = {
                        type: INT_TAG,
                        value: headers.getInt32(position, false),
                    };
                    position += 4;
                    break;
                case 5:
                    out[name] = {
                        type: LONG_TAG,
                        value: new Int64_1.Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)),
                    };
                    position += 8;
                    break;
                case 6:
                    const binaryLength = headers.getUint16(position, false);
                    position += 2;
                    out[name] = {
                        type: BINARY_TAG,
                        value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength),
                    };
                    position += binaryLength;
                    break;
                case 7:
                    const stringLength = headers.getUint16(position, false);
                    position += 2;
                    out[name] = {
                        type: STRING_TAG,
                        value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength)),
                    };
                    position += stringLength;
                    break;
                case 8:
                    out[name] = {
                        type: TIMESTAMP_TAG,
                        value: new Date(new Int64_1.Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf()),
                    };
                    position += 8;
                    break;
                case 9:
                    const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
                    position += 16;
                    out[name] = {
                        type: UUID_TAG,
                        value: `${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(0, 4))}-${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(4, 6))}-${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(6, 8))}-${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(8, 10))}-${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(10))}`,
                    };
                    break;
                default:
                    throw new Error(`Unrecognized header type tag`);
            }
        }
        return out;
    }
}
exports.HeaderMarshaller = HeaderMarshaller;
var HEADER_VALUE_TYPE;
(function (HEADER_VALUE_TYPE) {
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolTrue"] = 0] = "boolTrue";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolFalse"] = 1] = "boolFalse";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byte"] = 2] = "byte";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["short"] = 3] = "short";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["integer"] = 4] = "integer";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["long"] = 5] = "long";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byteArray"] = 6] = "byteArray";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["string"] = 7] = "string";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["timestamp"] = 8] = "timestamp";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
const BOOLEAN_TAG = "boolean";
const BYTE_TAG = "byte";
const SHORT_TAG = "short";
const INT_TAG = "integer";
const LONG_TAG = "long";
const BINARY_TAG = "binary";
const STRING_TAG = "string";
const TIMESTAMP_TAG = "timestamp";
const UUID_TAG = "uuid";
const UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;


/***/ }),

/***/ 46086:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Int64 = void 0;
const util_hex_encoding_1 = __nccwpck_require__(45364);
class Int64 {
    constructor(bytes) {
        this.bytes = bytes;
        if (bytes.byteLength !== 8) {
            throw new Error("Int64 buffers must be exactly 8 bytes");
        }
    }
    static fromNumber(number) {
        if (number > 9223372036854776000 || number < -9223372036854776000) {
            throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
        }
        const bytes = new Uint8Array(8);
        for (let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {
            bytes[i] = remaining;
        }
        if (number < 0) {
            negate(bytes);
        }
        return new Int64(bytes);
    }
    valueOf() {
        const bytes = this.bytes.slice(0);
        const negative = bytes[0] & 0b10000000;
        if (negative) {
            negate(bytes);
        }
        return parseInt((0, util_hex_encoding_1.toHex)(bytes), 16) * (negative ? -1 : 1);
    }
    toString() {
        return String(this.valueOf());
    }
}
exports.Int64 = Int64;
function negate(bytes) {
    for (let i = 0; i < 8; i++) {
        bytes[i] ^= 0xff;
    }
    for (let i = 7; i > -1; i--) {
        bytes[i]++;
        if (bytes[i] !== 0)
            break;
    }
}


/***/ }),

/***/ 73684:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 57255:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageDecoderStream = void 0;
class MessageDecoderStream {
    constructor(options) {
        this.options = options;
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }
    async *asyncIterator() {
        for await (const bytes of this.options.inputStream) {
            const decoded = this.options.decoder.decode(bytes);
            yield decoded;
        }
    }
}
exports.MessageDecoderStream = MessageDecoderStream;


/***/ }),

/***/ 52362:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageEncoderStream = void 0;
class MessageEncoderStream {
    constructor(options) {
        this.options = options;
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }
    async *asyncIterator() {
        for await (const msg of this.options.messageStream) {
            const encoded = this.options.encoder.encode(msg);
            yield encoded;
        }
        if (this.options.includeEndFrame) {
            yield new Uint8Array(0);
        }
    }
}
exports.MessageEncoderStream = MessageEncoderStream;


/***/ }),

/***/ 62379:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmithyMessageDecoderStream = void 0;
class SmithyMessageDecoderStream {
    constructor(options) {
        this.options = options;
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }
    async *asyncIterator() {
        for await (const message of this.options.messageStream) {
            const deserialized = await this.options.deserializer(message);
            if (deserialized === undefined)
                continue;
            yield deserialized;
        }
    }
}
exports.SmithyMessageDecoderStream = SmithyMessageDecoderStream;


/***/ }),

/***/ 12484:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmithyMessageEncoderStream = void 0;
class SmithyMessageEncoderStream {
    constructor(options) {
        this.options = options;
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }
    async *asyncIterator() {
        for await (const chunk of this.options.inputStream) {
            const payloadBuf = this.options.serializer(chunk);
            yield payloadBuf;
        }
    }
}
exports.SmithyMessageEncoderStream = SmithyMessageEncoderStream;


/***/ }),

/***/ 56459:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(11014), exports);
tslib_1.__exportStar(__nccwpck_require__(74712), exports);
tslib_1.__exportStar(__nccwpck_require__(46086), exports);
tslib_1.__exportStar(__nccwpck_require__(73684), exports);
tslib_1.__exportStar(__nccwpck_require__(57255), exports);
tslib_1.__exportStar(__nccwpck_require__(52362), exports);
tslib_1.__exportStar(__nccwpck_require__(62379), exports);
tslib_1.__exportStar(__nccwpck_require__(12484), exports);


/***/ }),

/***/ 20597:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.splitMessage = void 0;
const crc32_1 = __nccwpck_require__(47327);
const PRELUDE_MEMBER_LENGTH = 4;
const PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
const CHECKSUM_LENGTH = 4;
const MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
function splitMessage({ byteLength, byteOffset, buffer }) {
    if (byteLength < MINIMUM_MESSAGE_LENGTH) {
        throw new Error("Provided message too short to accommodate event stream message overhead");
    }
    const view = new DataView(buffer, byteOffset, byteLength);
    const messageLength = view.getUint32(0, false);
    if (byteLength !== messageLength) {
        throw new Error("Reported message length does not match received message length");
    }
    const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
    const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
    const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);
    const checksummer = new crc32_1.Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
    if (expectedPreludeChecksum !== checksummer.digest()) {
        throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
    }
    checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
    if (expectedMessageChecksum !== checksummer.digest()) {
        throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
    }
    return {
        headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
        body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH)),
    };
}
exports.splitMessage = splitMessage;


/***/ }),

/***/ 33193:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveEventStreamSerdeConfig = void 0;
const resolveEventStreamSerdeConfig = (input) => ({
    ...input,
    eventStreamMarshaller: input.eventStreamSerdeProvider(input),
});
exports.resolveEventStreamSerdeConfig = resolveEventStreamSerdeConfig;


/***/ }),

/***/ 16181:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(33193), exports);


/***/ }),

/***/ 76865:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventStreamMarshaller = void 0;
const eventstream_serde_universal_1 = __nccwpck_require__(66673);
const stream_1 = __nccwpck_require__(12781);
const utils_1 = __nccwpck_require__(58047);
class EventStreamMarshaller {
    constructor({ utf8Encoder, utf8Decoder }) {
        this.universalMarshaller = new eventstream_serde_universal_1.EventStreamMarshaller({
            utf8Decoder,
            utf8Encoder,
        });
    }
    deserialize(body, deserializer) {
        const bodyIterable = typeof body[Symbol.asyncIterator] === "function" ? body : (0, utils_1.readabletoIterable)(body);
        return this.universalMarshaller.deserialize(bodyIterable, deserializer);
    }
    serialize(input, serializer) {
        return stream_1.Readable.from(this.universalMarshaller.serialize(input, serializer));
    }
}
exports.EventStreamMarshaller = EventStreamMarshaller;


/***/ }),

/***/ 77682:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(76865), exports);
tslib_1.__exportStar(__nccwpck_require__(56887), exports);


/***/ }),

/***/ 56887:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.eventStreamSerdeProvider = void 0;
const EventStreamMarshaller_1 = __nccwpck_require__(76865);
const eventStreamSerdeProvider = (options) => new EventStreamMarshaller_1.EventStreamMarshaller(options);
exports.eventStreamSerdeProvider = eventStreamSerdeProvider;


/***/ }),

/***/ 58047:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readabletoIterable = void 0;
async function* readabletoIterable(readStream) {
    let streamEnded = false;
    let generationEnded = false;
    const records = new Array();
    readStream.on("error", (err) => {
        if (!streamEnded) {
            streamEnded = true;
        }
        if (err) {
            throw err;
        }
    });
    readStream.on("data", (data) => {
        records.push(data);
    });
    readStream.on("end", () => {
        streamEnded = true;
    });
    while (!generationEnded) {
        const value = await new Promise((resolve) => setTimeout(() => resolve(records.shift()), 0));
        if (value) {
            yield value;
        }
        generationEnded = streamEnded && records.length === 0;
    }
}
exports.readabletoIterable = readabletoIterable;


/***/ }),

/***/ 84340:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventStreamMarshaller = void 0;
const eventstream_codec_1 = __nccwpck_require__(56459);
const getChunkedStream_1 = __nccwpck_require__(2453);
const getUnmarshalledStream_1 = __nccwpck_require__(43597);
class EventStreamMarshaller {
    constructor({ utf8Encoder, utf8Decoder }) {
        this.eventStreamCodec = new eventstream_codec_1.EventStreamCodec(utf8Encoder, utf8Decoder);
        this.utfEncoder = utf8Encoder;
    }
    deserialize(body, deserializer) {
        const inputStream = (0, getChunkedStream_1.getChunkedStream)(body);
        return new eventstream_codec_1.SmithyMessageDecoderStream({
            messageStream: new eventstream_codec_1.MessageDecoderStream({ inputStream, decoder: this.eventStreamCodec }),
            deserializer: (0, getUnmarshalledStream_1.getMessageUnmarshaller)(deserializer, this.utfEncoder),
        });
    }
    serialize(inputStream, serializer) {
        return new eventstream_codec_1.MessageEncoderStream({
            messageStream: new eventstream_codec_1.SmithyMessageEncoderStream({ inputStream, serializer }),
            encoder: this.eventStreamCodec,
            includeEndFrame: true,
        });
    }
}
exports.EventStreamMarshaller = EventStreamMarshaller;


/***/ }),

/***/ 2453:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getChunkedStream = void 0;
function getChunkedStream(source) {
    let currentMessageTotalLength = 0;
    let currentMessagePendingLength = 0;
    let currentMessage = null;
    let messageLengthBuffer = null;
    const allocateMessage = (size) => {
        if (typeof size !== "number") {
            throw new Error("Attempted to allocate an event message where size was not a number: " + size);
        }
        currentMessageTotalLength = size;
        currentMessagePendingLength = 4;
        currentMessage = new Uint8Array(size);
        const currentMessageView = new DataView(currentMessage.buffer);
        currentMessageView.setUint32(0, size, false);
    };
    const iterator = async function* () {
        const sourceIterator = source[Symbol.asyncIterator]();
        while (true) {
            const { value, done } = await sourceIterator.next();
            if (done) {
                if (!currentMessageTotalLength) {
                    return;
                }
                else if (currentMessageTotalLength === currentMessagePendingLength) {
                    yield currentMessage;
                }
                else {
                    throw new Error("Truncated event message received.");
                }
                return;
            }
            const chunkLength = value.length;
            let currentOffset = 0;
            while (currentOffset < chunkLength) {
                if (!currentMessage) {
                    const bytesRemaining = chunkLength - currentOffset;
                    if (!messageLengthBuffer) {
                        messageLengthBuffer = new Uint8Array(4);
                    }
                    const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);
                    messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);
                    currentMessagePendingLength += numBytesForTotal;
                    currentOffset += numBytesForTotal;
                    if (currentMessagePendingLength < 4) {
                        break;
                    }
                    allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));
                    messageLengthBuffer = null;
                }
                const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);
                currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);
                currentMessagePendingLength += numBytesToWrite;
                currentOffset += numBytesToWrite;
                if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {
                    yield currentMessage;
                    currentMessage = null;
                    currentMessageTotalLength = 0;
                    currentMessagePendingLength = 0;
                }
            }
        }
    };
    return {
        [Symbol.asyncIterator]: iterator,
    };
}
exports.getChunkedStream = getChunkedStream;


/***/ }),

/***/ 43597:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getMessageUnmarshaller = exports.getUnmarshalledStream = void 0;
function getUnmarshalledStream(source, options) {
    const messageUnmarshaller = getMessageUnmarshaller(options.deserializer, options.toUtf8);
    return {
        [Symbol.asyncIterator]: async function* () {
            for await (const chunk of source) {
                const message = options.eventStreamCodec.decode(chunk);
                const type = await messageUnmarshaller(message);
                if (type === undefined)
                    continue;
                yield type;
            }
        },
    };
}
exports.getUnmarshalledStream = getUnmarshalledStream;
function getMessageUnmarshaller(deserializer, toUtf8) {
    return async function (message) {
        const { value: messageType } = message.headers[":message-type"];
        if (messageType === "error") {
            const unmodeledError = new Error(message.headers[":error-message"].value || "UnknownError");
            unmodeledError.name = message.headers[":error-code"].value;
            throw unmodeledError;
        }
        else if (messageType === "exception") {
            const code = message.headers[":exception-type"].value;
            const exception = { [code]: message };
            const deserializedException = await deserializer(exception);
            if (deserializedException.$unknown) {
                const error = new Error(toUtf8(message.body));
                error.name = code;
                throw error;
            }
            throw deserializedException[code];
        }
        else if (messageType === "event") {
            const event = {
                [message.headers[":event-type"].value]: message,
            };
            const deserialized = await deserializer(event);
            if (deserialized.$unknown)
                return;
            return deserialized;
        }
        else {
            throw Error(`Unrecognizable event type: ${message.headers[":event-type"].value}`);
        }
    };
}
exports.getMessageUnmarshaller = getMessageUnmarshaller;


/***/ }),

/***/ 66673:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(84340), exports);
tslib_1.__exportStar(__nccwpck_require__(40721), exports);


/***/ }),

/***/ 40721:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.eventStreamSerdeProvider = void 0;
const EventStreamMarshaller_1 = __nccwpck_require__(84340);
const eventStreamSerdeProvider = (options) => new EventStreamMarshaller_1.EventStreamMarshaller(options);
exports.eventStreamSerdeProvider = eventStreamSerdeProvider;


/***/ }),

/***/ 3081:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hash = void 0;
const util_buffer_from_1 = __nccwpck_require__(31381);
const util_utf8_1 = __nccwpck_require__(41895);
const buffer_1 = __nccwpck_require__(14300);
const crypto_1 = __nccwpck_require__(6113);
class Hash {
    constructor(algorithmIdentifier, secret) {
        this.algorithmIdentifier = algorithmIdentifier;
        this.secret = secret;
        this.reset();
    }
    update(toHash, encoding) {
        this.hash.update((0, util_utf8_1.toUint8Array)(castSourceData(toHash, encoding)));
    }
    digest() {
        return Promise.resolve(this.hash.digest());
    }
    reset() {
        this.hash = this.secret
            ? (0, crypto_1.createHmac)(this.algorithmIdentifier, castSourceData(this.secret))
            : (0, crypto_1.createHash)(this.algorithmIdentifier);
    }
}
exports.Hash = Hash;
function castSourceData(toCast, encoding) {
    if (buffer_1.Buffer.isBuffer(toCast)) {
        return toCast;
    }
    if (typeof toCast === "string") {
        return (0, util_buffer_from_1.fromString)(toCast, encoding);
    }
    if (ArrayBuffer.isView(toCast)) {
        return (0, util_buffer_from_1.fromArrayBuffer)(toCast.buffer, toCast.byteOffset, toCast.byteLength);
    }
    return (0, util_buffer_from_1.fromArrayBuffer)(toCast);
}


/***/ }),

/***/ 4671:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HashCalculator = void 0;
const util_utf8_1 = __nccwpck_require__(41895);
const stream_1 = __nccwpck_require__(12781);
class HashCalculator extends stream_1.Writable {
    constructor(hash, options) {
        super(options);
        this.hash = hash;
    }
    _write(chunk, encoding, callback) {
        try {
            this.hash.update((0, util_utf8_1.toUint8Array)(chunk));
        }
        catch (err) {
            return callback(err);
        }
        callback();
    }
}
exports.HashCalculator = HashCalculator;


/***/ }),

/***/ 80075:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fileStreamHasher = void 0;
const fs_1 = __nccwpck_require__(57147);
const HashCalculator_1 = __nccwpck_require__(4671);
const fileStreamHasher = (hashCtor, fileStream) => new Promise((resolve, reject) => {
    if (!isReadStream(fileStream)) {
        reject(new Error("Unable to calculate hash for non-file streams."));
        return;
    }
    const fileStreamTee = (0, fs_1.createReadStream)(fileStream.path, {
        start: fileStream.start,
        end: fileStream.end,
    });
    const hash = new hashCtor();
    const hashCalculator = new HashCalculator_1.HashCalculator(hash);
    fileStreamTee.pipe(hashCalculator);
    fileStreamTee.on("error", (err) => {
        hashCalculator.end();
        reject(err);
    });
    hashCalculator.on("error", reject);
    hashCalculator.on("finish", function () {
        hash.digest().then(resolve).catch(reject);
    });
});
exports.fileStreamHasher = fileStreamHasher;
const isReadStream = (stream) => typeof stream.path === "string";


/***/ }),

/***/ 48866:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(80075), exports);
tslib_1.__exportStar(__nccwpck_require__(87715), exports);


/***/ }),

/***/ 87715:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readableStreamHasher = void 0;
const HashCalculator_1 = __nccwpck_require__(4671);
const readableStreamHasher = (hashCtor, readableStream) => {
    if (readableStream.readableFlowing !== null) {
        throw new Error("Unable to calculate hash for flowing readable stream");
    }
    const hash = new hashCtor();
    const hashCalculator = new HashCalculator_1.HashCalculator(hash);
    readableStream.pipe(hashCalculator);
    return new Promise((resolve, reject) => {
        readableStream.on("error", (err) => {
            hashCalculator.end();
            reject(err);
        });
        hashCalculator.on("error", reject);
        hashCalculator.on("finish", () => {
            hash.digest().then(resolve).catch(reject);
        });
    });
};
exports.readableStreamHasher = readableStreamHasher;


/***/ }),

/***/ 10780:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isArrayBuffer = void 0;
const isArrayBuffer = (arg) => (typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer) ||
    Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
exports.isArrayBuffer = isArrayBuffer;


/***/ }),

/***/ 82800:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getContentLengthPlugin = exports.contentLengthMiddlewareOptions = exports.contentLengthMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const CONTENT_LENGTH_HEADER = "content-length";
function contentLengthMiddleware(bodyLengthChecker) {
    return (next) => async (args) => {
        const request = args.request;
        if (protocol_http_1.HttpRequest.isInstance(request)) {
            const { body, headers } = request;
            if (body &&
                Object.keys(headers)
                    .map((str) => str.toLowerCase())
                    .indexOf(CONTENT_LENGTH_HEADER) === -1) {
                try {
                    const length = bodyLengthChecker(body);
                    request.headers = {
                        ...request.headers,
                        [CONTENT_LENGTH_HEADER]: String(length),
                    };
                }
                catch (error) {
                }
            }
        }
        return next({
            ...args,
            request,
        });
    };
}
exports.contentLengthMiddleware = contentLengthMiddleware;
exports.contentLengthMiddlewareOptions = {
    step: "build",
    tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
    name: "contentLengthMiddleware",
    override: true,
};
const getContentLengthPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), exports.contentLengthMiddlewareOptions);
    },
});
exports.getContentLengthPlugin = getContentLengthPlugin;


/***/ }),

/***/ 465:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConfigValueProvider = void 0;
const createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
    const configProvider = async () => {
        var _a;
        const configValue = (_a = config[configKey]) !== null && _a !== void 0 ? _a : config[canonicalEndpointParamKey];
        if (typeof configValue === "function") {
            return configValue();
        }
        return configValue;
    };
    if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
        return async () => {
            var _a;
            const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
            const configValue = (_a = credentials === null || credentials === void 0 ? void 0 : credentials.credentialScope) !== null && _a !== void 0 ? _a : credentials === null || credentials === void 0 ? void 0 : credentials.CredentialScope;
            return configValue;
        };
    }
    if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
        return async () => {
            const endpoint = await configProvider();
            if (endpoint && typeof endpoint === "object") {
                if ("url" in endpoint) {
                    return endpoint.url.href;
                }
                if ("hostname" in endpoint) {
                    const { protocol, hostname, port, path } = endpoint;
                    return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
                }
            }
            return endpoint;
        };
    }
    return configProvider;
};
exports.createConfigValueProvider = createConfigValueProvider;


/***/ }),

/***/ 31518:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointFromConfig = void 0;
const node_config_provider_1 = __nccwpck_require__(33461);
const getEndpointUrlConfig_1 = __nccwpck_require__(7574);
const getEndpointFromConfig = async (serviceId) => (0, node_config_provider_1.loadConfig)((0, getEndpointUrlConfig_1.getEndpointUrlConfig)(serviceId))();
exports.getEndpointFromConfig = getEndpointFromConfig;


/***/ }),

/***/ 73929:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveParams = exports.getEndpointFromInstructions = void 0;
const service_customizations_1 = __nccwpck_require__(13105);
const createConfigValueProvider_1 = __nccwpck_require__(465);
const getEndpointFromConfig_1 = __nccwpck_require__(31518);
const toEndpointV1_1 = __nccwpck_require__(38938);
const getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
    if (!clientConfig.endpoint) {
        const endpointFromConfig = await (0, getEndpointFromConfig_1.getEndpointFromConfig)(clientConfig.serviceId || "");
        if (endpointFromConfig) {
            clientConfig.endpoint = () => Promise.resolve((0, toEndpointV1_1.toEndpointV1)(endpointFromConfig));
        }
    }
    const endpointParams = await (0, exports.resolveParams)(commandInput, instructionsSupplier, clientConfig);
    if (typeof clientConfig.endpointProvider !== "function") {
        throw new Error("config.endpointProvider is not set.");
    }
    const endpoint = clientConfig.endpointProvider(endpointParams, context);
    return endpoint;
};
exports.getEndpointFromInstructions = getEndpointFromInstructions;
const resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
    var _a;
    const endpointParams = {};
    const instructions = ((_a = instructionsSupplier === null || instructionsSupplier === void 0 ? void 0 : instructionsSupplier.getEndpointParameterInstructions) === null || _a === void 0 ? void 0 : _a.call(instructionsSupplier)) || {};
    for (const [name, instruction] of Object.entries(instructions)) {
        switch (instruction.type) {
            case "staticContextParams":
                endpointParams[name] = instruction.value;
                break;
            case "contextParams":
                endpointParams[name] = commandInput[instruction.name];
                break;
            case "clientContextParams":
            case "builtInParams":
                endpointParams[name] = await (0, createConfigValueProvider_1.createConfigValueProvider)(instruction.name, name, clientConfig)();
                break;
            default:
                throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
        }
    }
    if (Object.keys(instructions).length === 0) {
        Object.assign(endpointParams, clientConfig);
    }
    if (String(clientConfig.serviceId).toLowerCase() === "s3") {
        await (0, service_customizations_1.resolveParamsForS3)(endpointParams);
    }
    return endpointParams;
};
exports.resolveParams = resolveParams;


/***/ }),

/***/ 7574:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointUrlConfig = void 0;
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const ENV_ENDPOINT_URL = "AWS_ENDPOINT_URL";
const CONFIG_ENDPOINT_URL = "endpoint_url";
const getEndpointUrlConfig = (serviceId) => ({
    environmentVariableSelector: (env) => {
        const serviceSuffixParts = serviceId.split(" ").map((w) => w.toUpperCase());
        const serviceEndpointUrl = env[[ENV_ENDPOINT_URL, ...serviceSuffixParts].join("_")];
        if (serviceEndpointUrl)
            return serviceEndpointUrl;
        const endpointUrl = env[ENV_ENDPOINT_URL];
        if (endpointUrl)
            return endpointUrl;
        return undefined;
    },
    configFileSelector: (profile, config) => {
        if (config && profile.services) {
            const servicesSection = config[["services", profile.services].join(shared_ini_file_loader_1.CONFIG_PREFIX_SEPARATOR)];
            if (servicesSection) {
                const servicePrefixParts = serviceId.split(" ").map((w) => w.toLowerCase());
                const endpointUrl = servicesSection[[servicePrefixParts.join("_"), CONFIG_ENDPOINT_URL].join(shared_ini_file_loader_1.CONFIG_PREFIX_SEPARATOR)];
                if (endpointUrl)
                    return endpointUrl;
            }
        }
        const endpointUrl = profile[CONFIG_ENDPOINT_URL];
        if (endpointUrl)
            return endpointUrl;
        return undefined;
    },
    default: undefined,
});
exports.getEndpointUrlConfig = getEndpointUrlConfig;


/***/ }),

/***/ 50890:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(73929), exports);
tslib_1.__exportStar(__nccwpck_require__(38938), exports);


/***/ }),

/***/ 38938:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toEndpointV1 = void 0;
const url_parser_1 = __nccwpck_require__(14681);
const toEndpointV1 = (endpoint) => {
    if (typeof endpoint === "object") {
        if ("url" in endpoint) {
            return (0, url_parser_1.parseUrl)(endpoint.url);
        }
        return endpoint;
    }
    return (0, url_parser_1.parseUrl)(endpoint);
};
exports.toEndpointV1 = toEndpointV1;


/***/ }),

/***/ 55520:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.endpointMiddleware = void 0;
const util_middleware_1 = __nccwpck_require__(2390);
const getEndpointFromInstructions_1 = __nccwpck_require__(73929);
const endpointMiddleware = ({ config, instructions, }) => {
    return (next, context) => async (args) => {
        var _a, _b, _c;
        const endpoint = await (0, getEndpointFromInstructions_1.getEndpointFromInstructions)(args.input, {
            getEndpointParameterInstructions() {
                return instructions;
            },
        }, { ...config }, context);
        context.endpointV2 = endpoint;
        context.authSchemes = (_a = endpoint.properties) === null || _a === void 0 ? void 0 : _a.authSchemes;
        const authScheme = (_b = context.authSchemes) === null || _b === void 0 ? void 0 : _b[0];
        if (authScheme) {
            context["signing_region"] = authScheme.signingRegion;
            context["signing_service"] = authScheme.signingName;
            const smithyContext = (0, util_middleware_1.getSmithyContext)(context);
            const httpAuthOption = (_c = smithyContext === null || smithyContext === void 0 ? void 0 : smithyContext.selectedHttpAuthScheme) === null || _c === void 0 ? void 0 : _c.httpAuthOption;
            if (httpAuthOption) {
                httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
                    signing_region: authScheme.signingRegion,
                    signingRegion: authScheme.signingRegion,
                    signing_service: authScheme.signingName,
                    signingName: authScheme.signingName,
                    signingRegionSet: authScheme.signingRegionSet,
                }, authScheme.properties);
            }
        }
        return next({
            ...args,
        });
    };
};
exports.endpointMiddleware = endpointMiddleware;


/***/ }),

/***/ 71329:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointPlugin = exports.endpointMiddlewareOptions = void 0;
const middleware_serde_1 = __nccwpck_require__(81238);
const endpointMiddleware_1 = __nccwpck_require__(55520);
exports.endpointMiddlewareOptions = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: middleware_serde_1.serializerMiddlewareOption.name,
};
const getEndpointPlugin = (config, instructions) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo((0, endpointMiddleware_1.endpointMiddleware)({
            config,
            instructions,
        }), exports.endpointMiddlewareOptions);
    },
});
exports.getEndpointPlugin = getEndpointPlugin;


/***/ }),

/***/ 82918:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(50890), exports);
tslib_1.__exportStar(__nccwpck_require__(55520), exports);
tslib_1.__exportStar(__nccwpck_require__(71329), exports);
tslib_1.__exportStar(__nccwpck_require__(74139), exports);
tslib_1.__exportStar(__nccwpck_require__(39720), exports);


/***/ }),

/***/ 74139:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveEndpointConfig = void 0;
const util_middleware_1 = __nccwpck_require__(2390);
const toEndpointV1_1 = __nccwpck_require__(38938);
const resolveEndpointConfig = (input) => {
    var _a, _b, _c;
    const tls = (_a = input.tls) !== null && _a !== void 0 ? _a : true;
    const { endpoint } = input;
    const customEndpointProvider = endpoint != null ? async () => (0, toEndpointV1_1.toEndpointV1)(await (0, util_middleware_1.normalizeProvider)(endpoint)()) : undefined;
    const isCustomEndpoint = !!endpoint;
    return {
        ...input,
        endpoint: customEndpointProvider,
        tls,
        isCustomEndpoint,
        useDualstackEndpoint: (0, util_middleware_1.normalizeProvider)((_b = input.useDualstackEndpoint) !== null && _b !== void 0 ? _b : false),
        useFipsEndpoint: (0, util_middleware_1.normalizeProvider)((_c = input.useFipsEndpoint) !== null && _c !== void 0 ? _c : false),
    };
};
exports.resolveEndpointConfig = resolveEndpointConfig;


/***/ }),

/***/ 13105:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(19194), exports);


/***/ }),

/***/ 19194:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isArnBucketName = exports.isDnsCompatibleBucketName = exports.S3_HOSTNAME_PATTERN = exports.DOT_PATTERN = exports.resolveParamsForS3 = void 0;
const resolveParamsForS3 = async (endpointParams) => {
    const bucket = (endpointParams === null || endpointParams === void 0 ? void 0 : endpointParams.Bucket) || "";
    if (typeof endpointParams.Bucket === "string") {
        endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
    }
    if ((0, exports.isArnBucketName)(bucket)) {
        if (endpointParams.ForcePathStyle === true) {
            throw new Error("Path-style addressing cannot be used with ARN buckets");
        }
    }
    else if (!(0, exports.isDnsCompatibleBucketName)(bucket) ||
        (bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:")) ||
        bucket.toLowerCase() !== bucket ||
        bucket.length < 3) {
        endpointParams.ForcePathStyle = true;
    }
    if (endpointParams.DisableMultiRegionAccessPoints) {
        endpointParams.disableMultiRegionAccessPoints = true;
        endpointParams.DisableMRAP = true;
    }
    return endpointParams;
};
exports.resolveParamsForS3 = resolveParamsForS3;
const DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
const IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
const DOTS_PATTERN = /\.\./;
exports.DOT_PATTERN = /\./;
exports.S3_HOSTNAME_PATTERN = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./;
const isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
exports.isDnsCompatibleBucketName = isDnsCompatibleBucketName;
const isArnBucketName = (bucketName) => {
    const [arn, partition, service, region, account, typeOrId] = bucketName.split(":");
    const isArn = arn === "arn" && bucketName.split(":").length >= 6;
    const isValidArn = [arn, partition, service, account, typeOrId].filter(Boolean).length === 5;
    if (isArn && !isValidArn) {
        throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
    }
    return arn === "arn" && !!partition && !!service && !!account && !!typeOrId;
};
exports.isArnBucketName = isArnBucketName;


/***/ }),

/***/ 39720:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 80155:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdaptiveRetryStrategy = void 0;
const util_retry_1 = __nccwpck_require__(84902);
const StandardRetryStrategy_1 = __nccwpck_require__(94582);
class AdaptiveRetryStrategy extends StandardRetryStrategy_1.StandardRetryStrategy {
    constructor(maxAttemptsProvider, options) {
        const { rateLimiter, ...superOptions } = options !== null && options !== void 0 ? options : {};
        super(maxAttemptsProvider, superOptions);
        this.rateLimiter = rateLimiter !== null && rateLimiter !== void 0 ? rateLimiter : new util_retry_1.DefaultRateLimiter();
        this.mode = util_retry_1.RETRY_MODES.ADAPTIVE;
    }
    async retry(next, args) {
        return super.retry(next, args, {
            beforeRequest: async () => {
                return this.rateLimiter.getSendToken();
            },
            afterRequest: (response) => {
                this.rateLimiter.updateClientSendingRate(response);
            },
        });
    }
}
exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy;


/***/ }),

/***/ 94582:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StandardRetryStrategy = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const service_error_classification_1 = __nccwpck_require__(6375);
const util_retry_1 = __nccwpck_require__(84902);
const uuid_1 = __nccwpck_require__(75840);
const defaultRetryQuota_1 = __nccwpck_require__(29991);
const delayDecider_1 = __nccwpck_require__(9465);
const retryDecider_1 = __nccwpck_require__(67653);
const util_1 = __nccwpck_require__(42827);
class StandardRetryStrategy {
    constructor(maxAttemptsProvider, options) {
        var _a, _b, _c;
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.mode = util_retry_1.RETRY_MODES.STANDARD;
        this.retryDecider = (_a = options === null || options === void 0 ? void 0 : options.retryDecider) !== null && _a !== void 0 ? _a : retryDecider_1.defaultRetryDecider;
        this.delayDecider = (_b = options === null || options === void 0 ? void 0 : options.delayDecider) !== null && _b !== void 0 ? _b : delayDecider_1.defaultDelayDecider;
        this.retryQuota = (_c = options === null || options === void 0 ? void 0 : options.retryQuota) !== null && _c !== void 0 ? _c : (0, defaultRetryQuota_1.getDefaultRetryQuota)(util_retry_1.INITIAL_RETRY_TOKENS);
    }
    shouldRetry(error, attempts, maxAttempts) {
        return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);
    }
    async getMaxAttempts() {
        let maxAttempts;
        try {
            maxAttempts = await this.maxAttemptsProvider();
        }
        catch (error) {
            maxAttempts = util_retry_1.DEFAULT_MAX_ATTEMPTS;
        }
        return maxAttempts;
    }
    async retry(next, args, options) {
        let retryTokenAmount;
        let attempts = 0;
        let totalDelay = 0;
        const maxAttempts = await this.getMaxAttempts();
        const { request } = args;
        if (protocol_http_1.HttpRequest.isInstance(request)) {
            request.headers[util_retry_1.INVOCATION_ID_HEADER] = (0, uuid_1.v4)();
        }
        while (true) {
            try {
                if (protocol_http_1.HttpRequest.isInstance(request)) {
                    request.headers[util_retry_1.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
                }
                if (options === null || options === void 0 ? void 0 : options.beforeRequest) {
                    await options.beforeRequest();
                }
                const { response, output } = await next(args);
                if (options === null || options === void 0 ? void 0 : options.afterRequest) {
                    options.afterRequest(response);
                }
                this.retryQuota.releaseRetryTokens(retryTokenAmount);
                output.$metadata.attempts = attempts + 1;
                output.$metadata.totalRetryDelay = totalDelay;
                return { response, output };
            }
            catch (e) {
                const err = (0, util_1.asSdkError)(e);
                attempts++;
                if (this.shouldRetry(err, attempts, maxAttempts)) {
                    retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);
                    const delayFromDecider = this.delayDecider((0, service_error_classification_1.isThrottlingError)(err) ? util_retry_1.THROTTLING_RETRY_DELAY_BASE : util_retry_1.DEFAULT_RETRY_DELAY_BASE, attempts);
                    const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);
                    const delay = Math.max(delayFromResponse || 0, delayFromDecider);
                    totalDelay += delay;
                    await new Promise((resolve) => setTimeout(resolve, delay));
                    continue;
                }
                if (!err.$metadata) {
                    err.$metadata = {};
                }
                err.$metadata.attempts = attempts;
                err.$metadata.totalRetryDelay = totalDelay;
                throw err;
            }
        }
    }
}
exports.StandardRetryStrategy = StandardRetryStrategy;
const getDelayFromRetryAfterHeader = (response) => {
    if (!protocol_http_1.HttpResponse.isInstance(response))
        return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
        return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
        return retryAfterSeconds * 1000;
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate.getTime() - Date.now();
};


/***/ }),

/***/ 58709:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_RETRY_MODE_CONFIG_OPTIONS = exports.CONFIG_RETRY_MODE = exports.ENV_RETRY_MODE = exports.resolveRetryConfig = exports.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = exports.CONFIG_MAX_ATTEMPTS = exports.ENV_MAX_ATTEMPTS = void 0;
const util_middleware_1 = __nccwpck_require__(2390);
const util_retry_1 = __nccwpck_require__(84902);
exports.ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
exports.CONFIG_MAX_ATTEMPTS = "max_attempts";
exports.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => {
        const value = env[exports.ENV_MAX_ATTEMPTS];
        if (!value)
            return undefined;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
            throw new Error(`Environment variable ${exports.ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
    },
    configFileSelector: (profile) => {
        const value = profile[exports.CONFIG_MAX_ATTEMPTS];
        if (!value)
            return undefined;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
            throw new Error(`Shared config file entry ${exports.CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
    },
    default: util_retry_1.DEFAULT_MAX_ATTEMPTS,
};
const resolveRetryConfig = (input) => {
    var _a;
    const { retryStrategy } = input;
    const maxAttempts = (0, util_middleware_1.normalizeProvider)((_a = input.maxAttempts) !== null && _a !== void 0 ? _a : util_retry_1.DEFAULT_MAX_ATTEMPTS);
    return {
        ...input,
        maxAttempts,
        retryStrategy: async () => {
            if (retryStrategy) {
                return retryStrategy;
            }
            const retryMode = await (0, util_middleware_1.normalizeProvider)(input.retryMode)();
            if (retryMode === util_retry_1.RETRY_MODES.ADAPTIVE) {
                return new util_retry_1.AdaptiveRetryStrategy(maxAttempts);
            }
            return new util_retry_1.StandardRetryStrategy(maxAttempts);
        },
    };
};
exports.resolveRetryConfig = resolveRetryConfig;
exports.ENV_RETRY_MODE = "AWS_RETRY_MODE";
exports.CONFIG_RETRY_MODE = "retry_mode";
exports.NODE_RETRY_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[exports.ENV_RETRY_MODE],
    configFileSelector: (profile) => profile[exports.CONFIG_RETRY_MODE],
    default: util_retry_1.DEFAULT_RETRY_MODE,
};


/***/ }),

/***/ 29991:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDefaultRetryQuota = void 0;
const util_retry_1 = __nccwpck_require__(84902);
const getDefaultRetryQuota = (initialRetryTokens, options) => {
    var _a, _b, _c;
    const MAX_CAPACITY = initialRetryTokens;
    const noRetryIncrement = (_a = options === null || options === void 0 ? void 0 : options.noRetryIncrement) !== null && _a !== void 0 ? _a : util_retry_1.NO_RETRY_INCREMENT;
    const retryCost = (_b = options === null || options === void 0 ? void 0 : options.retryCost) !== null && _b !== void 0 ? _b : util_retry_1.RETRY_COST;
    const timeoutRetryCost = (_c = options === null || options === void 0 ? void 0 : options.timeoutRetryCost) !== null && _c !== void 0 ? _c : util_retry_1.TIMEOUT_RETRY_COST;
    let availableCapacity = initialRetryTokens;
    const getCapacityAmount = (error) => (error.name === "TimeoutError" ? timeoutRetryCost : retryCost);
    const hasRetryTokens = (error) => getCapacityAmount(error) <= availableCapacity;
    const retrieveRetryTokens = (error) => {
        if (!hasRetryTokens(error)) {
            throw new Error("No retry token available");
        }
        const capacityAmount = getCapacityAmount(error);
        availableCapacity -= capacityAmount;
        return capacityAmount;
    };
    const releaseRetryTokens = (capacityReleaseAmount) => {
        availableCapacity += capacityReleaseAmount !== null && capacityReleaseAmount !== void 0 ? capacityReleaseAmount : noRetryIncrement;
        availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
    };
    return Object.freeze({
        hasRetryTokens,
        retrieveRetryTokens,
        releaseRetryTokens,
    });
};
exports.getDefaultRetryQuota = getDefaultRetryQuota;


/***/ }),

/***/ 9465:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultDelayDecider = void 0;
const util_retry_1 = __nccwpck_require__(84902);
const defaultDelayDecider = (delayBase, attempts) => Math.floor(Math.min(util_retry_1.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
exports.defaultDelayDecider = defaultDelayDecider;


/***/ }),

/***/ 96039:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(80155), exports);
tslib_1.__exportStar(__nccwpck_require__(94582), exports);
tslib_1.__exportStar(__nccwpck_require__(58709), exports);
tslib_1.__exportStar(__nccwpck_require__(9465), exports);
tslib_1.__exportStar(__nccwpck_require__(76556), exports);
tslib_1.__exportStar(__nccwpck_require__(67653), exports);
tslib_1.__exportStar(__nccwpck_require__(81434), exports);


/***/ }),

/***/ 18977:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isStreamingPayload = void 0;
const stream_1 = __nccwpck_require__(12781);
const isStreamingPayload = (request) => (request === null || request === void 0 ? void 0 : request.body) instanceof stream_1.Readable ||
    (typeof ReadableStream !== "undefined" && (request === null || request === void 0 ? void 0 : request.body) instanceof ReadableStream);
exports.isStreamingPayload = isStreamingPayload;


/***/ }),

/***/ 76556:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOmitRetryHeadersPlugin = exports.omitRetryHeadersMiddlewareOptions = exports.omitRetryHeadersMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const util_retry_1 = __nccwpck_require__(84902);
const omitRetryHeadersMiddleware = () => (next) => async (args) => {
    const { request } = args;
    if (protocol_http_1.HttpRequest.isInstance(request)) {
        delete request.headers[util_retry_1.INVOCATION_ID_HEADER];
        delete request.headers[util_retry_1.REQUEST_HEADER];
    }
    return next(args);
};
exports.omitRetryHeadersMiddleware = omitRetryHeadersMiddleware;
exports.omitRetryHeadersMiddlewareOptions = {
    name: "omitRetryHeadersMiddleware",
    tags: ["RETRY", "HEADERS", "OMIT_RETRY_HEADERS"],
    relation: "before",
    toMiddleware: "awsAuthMiddleware",
    override: true,
};
const getOmitRetryHeadersPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo((0, exports.omitRetryHeadersMiddleware)(), exports.omitRetryHeadersMiddlewareOptions);
    },
});
exports.getOmitRetryHeadersPlugin = getOmitRetryHeadersPlugin;


/***/ }),

/***/ 67653:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultRetryDecider = void 0;
const service_error_classification_1 = __nccwpck_require__(6375);
const defaultRetryDecider = (error) => {
    if (!error) {
        return false;
    }
    return (0, service_error_classification_1.isRetryableByTrait)(error) || (0, service_error_classification_1.isClockSkewError)(error) || (0, service_error_classification_1.isThrottlingError)(error) || (0, service_error_classification_1.isTransientError)(error);
};
exports.defaultRetryDecider = defaultRetryDecider;


/***/ }),

/***/ 81434:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRetryAfterHint = exports.getRetryPlugin = exports.retryMiddlewareOptions = exports.retryMiddleware = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const service_error_classification_1 = __nccwpck_require__(6375);
const smithy_client_1 = __nccwpck_require__(63570);
const util_retry_1 = __nccwpck_require__(84902);
const uuid_1 = __nccwpck_require__(75840);
const isStreamingPayload_1 = __nccwpck_require__(18977);
const util_1 = __nccwpck_require__(42827);
const retryMiddleware = (options) => (next, context) => async (args) => {
    var _a;
    let retryStrategy = await options.retryStrategy();
    const maxAttempts = await options.maxAttempts();
    if (isRetryStrategyV2(retryStrategy)) {
        retryStrategy = retryStrategy;
        let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
        let lastError = new Error();
        let attempts = 0;
        let totalRetryDelay = 0;
        const { request } = args;
        const isRequest = protocol_http_1.HttpRequest.isInstance(request);
        if (isRequest) {
            request.headers[util_retry_1.INVOCATION_ID_HEADER] = (0, uuid_1.v4)();
        }
        while (true) {
            try {
                if (isRequest) {
                    request.headers[util_retry_1.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
                }
                const { response, output } = await next(args);
                retryStrategy.recordSuccess(retryToken);
                output.$metadata.attempts = attempts + 1;
                output.$metadata.totalRetryDelay = totalRetryDelay;
                return { response, output };
            }
            catch (e) {
                const retryErrorInfo = getRetryErrorInfo(e);
                lastError = (0, util_1.asSdkError)(e);
                if (isRequest && (0, isStreamingPayload_1.isStreamingPayload)(request)) {
                    (_a = (context.logger instanceof smithy_client_1.NoOpLogger ? console : context.logger)) === null || _a === void 0 ? void 0 : _a.warn("An error was encountered in a non-retryable streaming request.");
                    throw lastError;
                }
                try {
                    retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
                }
                catch (refreshError) {
                    if (!lastError.$metadata) {
                        lastError.$metadata = {};
                    }
                    lastError.$metadata.attempts = attempts + 1;
                    lastError.$metadata.totalRetryDelay = totalRetryDelay;
                    throw lastError;
                }
                attempts = retryToken.getRetryCount();
                const delay = retryToken.getRetryDelay();
                totalRetryDelay += delay;
                await new Promise((resolve) => setTimeout(resolve, delay));
            }
        }
    }
    else {
        retryStrategy = retryStrategy;
        if (retryStrategy === null || retryStrategy === void 0 ? void 0 : retryStrategy.mode)
            context.userAgent = [...(context.userAgent || []), ["cfg/retry-mode", retryStrategy.mode]];
        return retryStrategy.retry(next, args);
    }
};
exports.retryMiddleware = retryMiddleware;
const isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" &&
    typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" &&
    typeof retryStrategy.recordSuccess !== "undefined";
const getRetryErrorInfo = (error) => {
    const errorInfo = {
        errorType: getRetryErrorType(error),
    };
    const retryAfterHint = (0, exports.getRetryAfterHint)(error.$response);
    if (retryAfterHint) {
        errorInfo.retryAfterHint = retryAfterHint;
    }
    return errorInfo;
};
const getRetryErrorType = (error) => {
    if ((0, service_error_classification_1.isThrottlingError)(error))
        return "THROTTLING";
    if ((0, service_error_classification_1.isTransientError)(error))
        return "TRANSIENT";
    if ((0, service_error_classification_1.isServerError)(error))
        return "SERVER_ERROR";
    return "CLIENT_ERROR";
};
exports.retryMiddlewareOptions = {
    name: "retryMiddleware",
    tags: ["RETRY"],
    step: "finalizeRequest",
    priority: "high",
    override: true,
};
const getRetryPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add((0, exports.retryMiddleware)(options), exports.retryMiddlewareOptions);
    },
});
exports.getRetryPlugin = getRetryPlugin;
const getRetryAfterHint = (response) => {
    if (!protocol_http_1.HttpResponse.isInstance(response))
        return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
        return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
        return new Date(retryAfterSeconds * 1000);
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate;
};
exports.getRetryAfterHint = getRetryAfterHint;


/***/ }),

/***/ 42827:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asSdkError = void 0;
const asSdkError = (error) => {
    if (error instanceof Error)
        return error;
    if (error instanceof Object)
        return Object.assign(new Error(), error);
    if (typeof error === "string")
        return new Error(error);
    return new Error(`AWS SDK error wrapper for ${error}`);
};
exports.asSdkError = asSdkError;


/***/ }),

/***/ 21595:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deserializerMiddleware = void 0;
const deserializerMiddleware = (options, deserializer) => (next, context) => async (args) => {
    const { response } = await next(args);
    try {
        const parsed = await deserializer(response, options);
        return {
            response,
            output: parsed,
        };
    }
    catch (error) {
        Object.defineProperty(error, "$response", {
            value: response,
        });
        if (!("$metadata" in error)) {
            const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
            error.message += "\n  " + hint;
        }
        throw error;
    }
};
exports.deserializerMiddleware = deserializerMiddleware;


/***/ }),

/***/ 81238:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(21595), exports);
tslib_1.__exportStar(__nccwpck_require__(72338), exports);
tslib_1.__exportStar(__nccwpck_require__(23566), exports);


/***/ }),

/***/ 72338:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSerdePlugin = exports.serializerMiddlewareOption = exports.deserializerMiddlewareOption = void 0;
const deserializerMiddleware_1 = __nccwpck_require__(21595);
const serializerMiddleware_1 = __nccwpck_require__(23566);
exports.deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true,
};
exports.serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true,
};
function getSerdePlugin(config, serializer, deserializer) {
    return {
        applyToStack: (commandStack) => {
            commandStack.add((0, deserializerMiddleware_1.deserializerMiddleware)(config, deserializer), exports.deserializerMiddlewareOption);
            commandStack.add((0, serializerMiddleware_1.serializerMiddleware)(config, serializer), exports.serializerMiddlewareOption);
        },
    };
}
exports.getSerdePlugin = getSerdePlugin;


/***/ }),

/***/ 23566:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializerMiddleware = void 0;
const serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
    var _a;
    const endpoint = ((_a = context.endpointV2) === null || _a === void 0 ? void 0 : _a.url) && options.urlParser
        ? async () => options.urlParser(context.endpointV2.url)
        : options.endpoint;
    if (!endpoint) {
        throw new Error("No valid endpoint provider available.");
    }
    const request = await serializer(args.input, { ...options, endpoint });
    return next({
        ...args,
        request,
    });
};
exports.serializerMiddleware = serializerMiddleware;


/***/ }),

/***/ 2404:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.constructStack = void 0;
const getAllAliases = (name, aliases) => {
    const _aliases = [];
    if (name) {
        _aliases.push(name);
    }
    if (aliases) {
        for (const alias of aliases) {
            _aliases.push(alias);
        }
    }
    return _aliases;
};
const getMiddlewareNameWithAliases = (name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
};
const constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = new Set();
    const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] ||
        priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            const aliases = getAllAliases(entry.name, entry.aliases);
            if (aliases.includes(toRemove)) {
                isRemoved = true;
                for (const alias of aliases) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            if (entry.middleware === toRemove) {
                isRemoved = true;
                for (const alias of getAllAliases(entry.name, entry.aliases)) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const cloneTo = (toStack) => {
        var _a;
        absoluteEntries.forEach((entry) => {
            toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
            toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        (_a = toStack.identifyOnResolve) === null || _a === void 0 ? void 0 : _a.call(toStack, stack.identifyOnResolve());
        return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
            if (entry.toMiddleware) {
                const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                if (toMiddleware === undefined) {
                    if (debug) {
                        return;
                    }
                    throw new Error(`${entry.toMiddleware} is not found when adding ` +
                        `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` +
                        `middleware ${entry.relation} ${entry.toMiddleware}`);
                }
                if (entry.relation === "after") {
                    toMiddleware.after.push(entry);
                }
                if (entry.relation === "before") {
                    toMiddleware.before.push(entry);
                }
            }
        });
        const mainChain = sort(normalizedAbsoluteEntries)
            .map(expandRelativeMiddlewareList)
            .reduce((wholeList, expandedMiddlewareList) => {
            wholeList.push(...expandedMiddlewareList);
            return wholeList;
        }, []);
        return mainChain;
    };
    const stack = {
        add: (middleware, options = {}) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                step: "initialize",
                priority: "normal",
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = absoluteEntries.findIndex((entry) => { var _a; return entry.name === alias || ((_a = entry.aliases) === null || _a === void 0 ? void 0 : _a.some((a) => a === alias)); });
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = absoluteEntries[toOverrideIndex];
                        if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` +
                                `${toOverride.priority} priority in ${toOverride.step} step cannot ` +
                                `be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` +
                                `${entry.priority} priority in ${entry.step} step.`);
                        }
                        absoluteEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = relativeEntries.findIndex((entry) => { var _a; return entry.name === alias || ((_a = entry.aliases) === null || _a === void 0 ? void 0 : _a.some((a) => a === alias)); });
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = relativeEntries[toOverrideIndex];
                        if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` +
                                `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                                `by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` +
                                `"${entry.toMiddleware}" middleware.`);
                        }
                        relativeEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            relativeEntries.push(entry);
        },
        clone: () => cloneTo((0, exports.constructStack)()),
        use: (plugin) => {
            plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
            if (typeof toRemove === "string")
                return removeByName(toRemove);
            else
                return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const { tags, name, aliases: _aliases } = entry;
                if (tags && tags.includes(toRemove)) {
                    const aliases = getAllAliases(name, _aliases);
                    for (const alias of aliases) {
                        entriesNameSet.delete(alias);
                    }
                    isRemoved = true;
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        },
        concat: (from) => {
            var _a, _b;
            const cloned = cloneTo((0, exports.constructStack)());
            cloned.use(from);
            cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || ((_b = (_a = from.identifyOnResolve) === null || _a === void 0 ? void 0 : _a.call(from)) !== null && _b !== void 0 ? _b : false));
            return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
            return getMiddlewareList(true).map((mw) => {
                var _a;
                const step = (_a = mw.step) !== null && _a !== void 0 ? _a : mw.relation +
                    " " +
                    mw.toMiddleware;
                return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
            });
        },
        identifyOnResolve(toggle) {
            if (typeof toggle === "boolean")
                identifyOnResolve = toggle;
            return identifyOnResolve;
        },
        resolve: (handler, context) => {
            for (const middleware of getMiddlewareList()
                .map((entry) => entry.middleware)
                .reverse()) {
                handler = middleware(handler, context);
            }
            if (identifyOnResolve) {
                console.log(stack.identify());
            }
            return handler;
        },
    };
    return stack;
};
exports.constructStack = constructStack;
const stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1,
};
const priorityWeights = {
    high: 3,
    normal: 2,
    low: 1,
};


/***/ }),

/***/ 97911:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(2404), exports);


/***/ }),

/***/ 54766:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadConfig = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const fromEnv_1 = __nccwpck_require__(15606);
const fromSharedConfigFiles_1 = __nccwpck_require__(45784);
const fromStatic_1 = __nccwpck_require__(23091);
const loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => (0, property_provider_1.memoize)((0, property_provider_1.chain)((0, fromEnv_1.fromEnv)(environmentVariableSelector), (0, fromSharedConfigFiles_1.fromSharedConfigFiles)(configFileSelector, configuration), (0, fromStatic_1.fromStatic)(defaultValue)));
exports.loadConfig = loadConfig;


/***/ }),

/***/ 15606:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromEnv = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const fromEnv = (envVarSelector) => async () => {
    try {
        const config = envVarSelector(process.env);
        if (config === undefined) {
            throw new Error();
        }
        return config;
    }
    catch (e) {
        throw new property_provider_1.CredentialsProviderError(e.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
    }
};
exports.fromEnv = fromEnv;


/***/ }),

/***/ 45784:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromSharedConfigFiles = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const shared_ini_file_loader_1 = __nccwpck_require__(43507);
const fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
    const profile = (0, shared_ini_file_loader_1.getProfileName)(init);
    const { configFile, credentialsFile } = await (0, shared_ini_file_loader_1.loadSharedConfigFiles)(init);
    const profileFromCredentials = credentialsFile[profile] || {};
    const profileFromConfig = configFile[profile] || {};
    const mergedProfile = preferredFile === "config"
        ? { ...profileFromCredentials, ...profileFromConfig }
        : { ...profileFromConfig, ...profileFromCredentials };
    try {
        const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
        const configValue = configSelector(mergedProfile, cfgFile);
        if (configValue === undefined) {
            throw new Error();
        }
        return configValue;
    }
    catch (e) {
        throw new property_provider_1.CredentialsProviderError(e.message || `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
    }
};
exports.fromSharedConfigFiles = fromSharedConfigFiles;


/***/ }),

/***/ 23091:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromStatic = void 0;
const property_provider_1 = __nccwpck_require__(79721);
const isFunction = (func) => typeof func === "function";
const fromStatic = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : (0, property_provider_1.fromStatic)(defaultValue);
exports.fromStatic = fromStatic;


/***/ }),

/***/ 33461:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(54766), exports);


/***/ }),

/***/ 33946:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODEJS_TIMEOUT_ERROR_CODES = void 0;
exports.NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];


/***/ }),

/***/ 70508:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTransformedHeaders = void 0;
const getTransformedHeaders = (headers) => {
    const transformedHeaders = {};
    for (const name of Object.keys(headers)) {
        const headerValues = headers[name];
        transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
    }
    return transformedHeaders;
};
exports.getTransformedHeaders = getTransformedHeaders;


/***/ }),

/***/ 20258:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(96948), exports);
tslib_1.__exportStar(__nccwpck_require__(46999), exports);
tslib_1.__exportStar(__nccwpck_require__(81030), exports);


/***/ }),

/***/ 96948:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeHttpHandler = exports.DEFAULT_REQUEST_TIMEOUT = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const querystring_builder_1 = __nccwpck_require__(68031);
const http_1 = __nccwpck_require__(13685);
const https_1 = __nccwpck_require__(95687);
const constants_1 = __nccwpck_require__(33946);
const get_transformed_headers_1 = __nccwpck_require__(70508);
const set_connection_timeout_1 = __nccwpck_require__(25545);
const set_socket_keep_alive_1 = __nccwpck_require__(83751);
const set_socket_timeout_1 = __nccwpck_require__(42618);
const write_request_body_1 = __nccwpck_require__(73766);
exports.DEFAULT_REQUEST_TIMEOUT = 0;
class NodeHttpHandler {
    static create(instanceOrOptions) {
        if (typeof (instanceOrOptions === null || instanceOrOptions === void 0 ? void 0 : instanceOrOptions.handle) === "function") {
            return instanceOrOptions;
        }
        return new NodeHttpHandler(instanceOrOptions);
    }
    constructor(options) {
        this.metadata = { handlerProtocol: "http/1.1" };
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((_options) => {
                    resolve(this.resolveDefaultConfig(_options));
                })
                    .catch(reject);
            }
            else {
                resolve(this.resolveDefaultConfig(options));
            }
        });
    }
    resolveDefaultConfig(options) {
        const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
            connectionTimeout,
            requestTimeout: requestTimeout !== null && requestTimeout !== void 0 ? requestTimeout : socketTimeout,
            httpAgent: httpAgent || new http_1.Agent({ keepAlive, maxSockets }),
            httpsAgent: httpsAgent || new https_1.Agent({ keepAlive, maxSockets }),
        };
    }
    destroy() {
        var _a, _b, _c, _d;
        (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.httpAgent) === null || _b === void 0 ? void 0 : _b.destroy();
        (_d = (_c = this.config) === null || _c === void 0 ? void 0 : _c.httpsAgent) === null || _d === void 0 ? void 0 : _d.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        return new Promise((_resolve, _reject) => {
            var _a, _b;
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (!this.config) {
                throw new Error("Node HTTP request handler config is not resolved");
            }
            if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const isSSL = request.protocol === "https:";
            const queryString = (0, querystring_builder_1.buildQueryString)(request.query || {});
            let auth = undefined;
            if (request.username != null || request.password != null) {
                const username = (_a = request.username) !== null && _a !== void 0 ? _a : "";
                const password = (_b = request.password) !== null && _b !== void 0 ? _b : "";
                auth = `${username}:${password}`;
            }
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const nodeHttpsOptions = {
                headers: request.headers,
                host: request.hostname,
                method: request.method,
                path,
                port: request.port,
                agent: isSSL ? this.config.httpsAgent : this.config.httpAgent,
                auth,
            };
            const requestFunc = isSSL ? https_1.request : http_1.request;
            const req = requestFunc(nodeHttpsOptions, (res) => {
                const httpResponse = new protocol_http_1.HttpResponse({
                    statusCode: res.statusCode || -1,
                    reason: res.statusMessage,
                    headers: (0, get_transformed_headers_1.getTransformedHeaders)(res.headers),
                    body: res,
                });
                resolve({ response: httpResponse });
            });
            req.on("error", (err) => {
                if (constants_1.NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
                    reject(Object.assign(err, { name: "TimeoutError" }));
                }
                else {
                    reject(err);
                }
            });
            (0, set_connection_timeout_1.setConnectionTimeout)(req, reject, this.config.connectionTimeout);
            (0, set_socket_timeout_1.setSocketTimeout)(req, reject, this.config.requestTimeout);
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.abort();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }
            const httpAgent = nodeHttpsOptions.agent;
            if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
                (0, set_socket_keep_alive_1.setSocketKeepAlive)(req, {
                    keepAlive: httpAgent.keepAlive,
                    keepAliveMsecs: httpAgent.keepAliveMsecs,
                });
            }
            writeRequestBodyPromise = (0, write_request_body_1.writeRequestBody)(req, request, this.config.requestTimeout).catch(_reject);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        var _a;
        return (_a = this.config) !== null && _a !== void 0 ? _a : {};
    }
}
exports.NodeHttpHandler = NodeHttpHandler;


/***/ }),

/***/ 5771:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeHttp2ConnectionManager = void 0;
const tslib_1 = __nccwpck_require__(4351);
const http2_1 = tslib_1.__importDefault(__nccwpck_require__(85158));
const node_http2_connection_pool_1 = __nccwpck_require__(95157);
class NodeHttp2ConnectionManager {
    constructor(config) {
        this.sessionCache = new Map();
        this.config = config;
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrency must be greater than zero.");
        }
    }
    lease(requestContext, connectionConfiguration) {
        const url = this.getUrlString(requestContext);
        const existingPool = this.sessionCache.get(url);
        if (existingPool) {
            const existingSession = existingPool.poll();
            if (existingSession && !this.config.disableConcurrency) {
                return existingSession;
            }
        }
        const session = http2_1.default.connect(url);
        if (this.config.maxConcurrency) {
            session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
                if (err) {
                    throw new Error("Fail to set maxConcurrentStreams to " +
                        this.config.maxConcurrency +
                        "when creating new session for " +
                        requestContext.destination.toString());
                }
            });
        }
        session.unref();
        const destroySessionCb = () => {
            session.destroy();
            this.deleteSession(url, session);
        };
        session.on("goaway", destroySessionCb);
        session.on("error", destroySessionCb);
        session.on("frameError", destroySessionCb);
        session.on("close", () => this.deleteSession(url, session));
        if (connectionConfiguration.requestTimeout) {
            session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
        }
        const connectionPool = this.sessionCache.get(url) || new node_http2_connection_pool_1.NodeHttp2ConnectionPool();
        connectionPool.offerLast(session);
        this.sessionCache.set(url, connectionPool);
        return session;
    }
    deleteSession(authority, session) {
        const existingConnectionPool = this.sessionCache.get(authority);
        if (!existingConnectionPool) {
            return;
        }
        if (!existingConnectionPool.contains(session)) {
            return;
        }
        existingConnectionPool.remove(session);
        this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session) {
        var _a;
        const cacheKey = this.getUrlString(requestContext);
        (_a = this.sessionCache.get(cacheKey)) === null || _a === void 0 ? void 0 : _a.offerLast(session);
    }
    destroy() {
        for (const [key, connectionPool] of this.sessionCache) {
            for (const session of connectionPool) {
                if (!session.destroyed) {
                    session.destroy();
                }
                connectionPool.remove(session);
            }
            this.sessionCache.delete(key);
        }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrentStreams must be greater than zero.");
        }
        this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
        this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
        return request.destination.toString();
    }
}
exports.NodeHttp2ConnectionManager = NodeHttp2ConnectionManager;


/***/ }),

/***/ 95157:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeHttp2ConnectionPool = void 0;
class NodeHttp2ConnectionPool {
    constructor(sessions) {
        this.sessions = [];
        this.sessions = sessions !== null && sessions !== void 0 ? sessions : [];
    }
    poll() {
        if (this.sessions.length > 0) {
            return this.sessions.shift();
        }
    }
    offerLast(session) {
        this.sessions.push(session);
    }
    contains(session) {
        return this.sessions.includes(session);
    }
    remove(session) {
        this.sessions = this.sessions.filter((s) => s !== session);
    }
    [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
    }
    destroy(connection) {
        for (const session of this.sessions) {
            if (session === connection) {
                if (!session.destroyed) {
                    session.destroy();
                }
            }
        }
    }
}
exports.NodeHttp2ConnectionPool = NodeHttp2ConnectionPool;


/***/ }),

/***/ 46999:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NodeHttp2Handler = void 0;
const protocol_http_1 = __nccwpck_require__(64418);
const querystring_builder_1 = __nccwpck_require__(68031);
const http2_1 = __nccwpck_require__(85158);
const get_transformed_headers_1 = __nccwpck_require__(70508);
const node_http2_connection_manager_1 = __nccwpck_require__(5771);
const write_request_body_1 = __nccwpck_require__(73766);
class NodeHttp2Handler {
    static create(instanceOrOptions) {
        if (typeof (instanceOrOptions === null || instanceOrOptions === void 0 ? void 0 : instanceOrOptions.handle) === "function") {
            return instanceOrOptions;
        }
        return new NodeHttp2Handler(instanceOrOptions);
    }
    constructor(options) {
        this.metadata = { handlerProtocol: "h2" };
        this.connectionManager = new node_http2_connection_manager_1.NodeHttp2ConnectionManager({});
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((opts) => {
                    resolve(opts || {});
                })
                    .catch(reject);
            }
            else {
                resolve(options || {});
            }
        });
    }
    destroy() {
        this.connectionManager.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
            this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
            if (this.config.maxConcurrentStreams) {
                this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
            }
        }
        const { requestTimeout, disableConcurrentStreams } = this.config;
        return new Promise((_resolve, _reject) => {
            var _a, _b, _c;
            let fulfilled = false;
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
                fulfilled = true;
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const { hostname, method, port, protocol, query } = request;
            let auth = "";
            if (request.username != null || request.password != null) {
                const username = (_a = request.username) !== null && _a !== void 0 ? _a : "";
                const password = (_b = request.password) !== null && _b !== void 0 ? _b : "";
                auth = `${username}:${password}@`;
            }
            const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
            const requestContext = { destination: new URL(authority) };
            const session = this.connectionManager.lease(requestContext, {
                requestTimeout: (_c = this.config) === null || _c === void 0 ? void 0 : _c.sessionTimeout,
                disableConcurrentStreams: disableConcurrentStreams || false,
            });
            const rejectWithDestroy = (err) => {
                if (disableConcurrentStreams) {
                    this.destroySession(session);
                }
                fulfilled = true;
                reject(err);
            };
            const queryString = (0, querystring_builder_1.buildQueryString)(query || {});
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const req = session.request({
                ...request.headers,
                [http2_1.constants.HTTP2_HEADER_PATH]: path,
                [http2_1.constants.HTTP2_HEADER_METHOD]: method,
            });
            session.ref();
            req.on("response", (headers) => {
                const httpResponse = new protocol_http_1.HttpResponse({
                    statusCode: headers[":status"] || -1,
                    headers: (0, get_transformed_headers_1.getTransformedHeaders)(headers),
                    body: req,
                });
                fulfilled = true;
                resolve({ response: httpResponse });
                if (disableConcurrentStreams) {
                    session.close();
                    this.connectionManager.deleteSession(authority, session);
                }
            });
            if (requestTimeout) {
                req.setTimeout(requestTimeout, () => {
                    req.close();
                    const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
                    timeoutError.name = "TimeoutError";
                    rejectWithDestroy(timeoutError);
                });
            }
            if (abortSignal) {
                abortSignal.onabort = () => {
                    req.close();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    rejectWithDestroy(abortError);
                };
            }
            req.on("frameError", (type, code, id) => {
                rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
            });
            req.on("error", rejectWithDestroy);
            req.on("aborted", () => {
                rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
            });
            req.on("close", () => {
                session.unref();
                if (disableConcurrentStreams) {
                    session.destroy();
                }
                if (!fulfilled) {
                    rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
                }
            });
            writeRequestBodyPromise = (0, write_request_body_1.writeRequestBody)(req, request, requestTimeout);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        var _a;
        return (_a = this.config) !== null && _a !== void 0 ? _a : {};
    }
    destroySession(session) {
        if (!session.destroyed) {
            session.destroy();
        }
    }
}
exports.NodeHttp2Handler = NodeHttp2Handler;


/***/ }),

/***/ 25545:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setConnectionTimeout = void 0;
const setConnectionTimeout = (request, reject, timeoutInMs = 0) => {
    if (!timeoutInMs) {
        return;
    }
    const timeoutId = setTimeout(() => {
        request.destroy();
        reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
            name: "TimeoutError",
        }));
    }, timeoutInMs);
    request.on("socket", (socket) => {
        if (socket.connecting) {
            socket.on("connect", () => {
                clearTimeout(timeoutId);
            });
        }
        else {
            clearTimeout(timeoutId);
        }
    });
};
exports.setConnectionTimeout = setConnectionTimeout;


/***/ }),

/***/ 83751:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setSocketKeepAlive = void 0;
const setSocketKeepAlive = (request, { keepAlive, keepAliveMsecs }) => {
    if (keepAlive !== true) {
        return;
    }
    request.on("socket", (socket) => {
        socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
    });
};
exports.setSocketKeepAlive = setSocketKeepAlive;


/***/ }),

/***/ 42618:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setSocketTimeout = void 0;
const setSocketTimeout = (request, reject, timeoutInMs = 0) => {
    request.setTimeout(timeoutInMs, () => {
        request.destroy();
        reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), { name: "TimeoutError" }));
    });
};
exports.setSocketTimeout = setSocketTimeout;


/***/ }),

/***/ 23211:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Collector = void 0;
const stream_1 = __nccwpck_require__(12781);
class Collector extends stream_1.Writable {
    constructor() {
        super(...arguments);
        this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
        this.bufferedBytes.push(chunk);
        callback();
    }
}
exports.Collector = Collector;


/***/ }),

/***/ 81030:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.streamCollector = void 0;
const collector_1 = __nccwpck_require__(23211);
const streamCollector = (stream) => new Promise((resolve, reject) => {
    const collector = new collector_1.Collector();
    stream.pipe(collector);
    stream.on("error", (err) => {
        collector.end();
        reject(err);
    });
    collector.on("error", reject);
    collector.on("finish", function () {
        const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
        resolve(bytes);
    });
});
exports.streamCollector = streamCollector;


/***/ }),

/***/ 73766:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.writeRequestBody = void 0;
const stream_1 = __nccwpck_require__(12781);
const MIN_WAIT_TIME = 1000;
async function writeRequestBody(httpRequest, request, maxContinueTimeoutMs = MIN_WAIT_TIME) {
    var _a;
    const headers = (_a = request.headers) !== null && _a !== void 0 ? _a : {};
    const expect = headers["Expect"] || headers["expect"];
    let timeoutId = -1;
    let hasError = false;
    if (expect === "100-continue") {
        await Promise.race([
            new Promise((resolve) => {
                timeoutId = Number(setTimeout(resolve, Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
            }),
            new Promise((resolve) => {
                httpRequest.on("continue", () => {
                    clearTimeout(timeoutId);
                    resolve();
                });
                httpRequest.on("error", () => {
                    hasError = true;
                    clearTimeout(timeoutId);
                    resolve();
                });
            }),
        ]);
    }
    if (!hasError) {
        writeBody(httpRequest, request.body);
    }
}
exports.writeRequestBody = writeRequestBody;
function writeBody(httpRequest, body) {
    if (body instanceof stream_1.Readable) {
        body.pipe(httpRequest);
    }
    else if (body) {
        httpRequest.end(Buffer.from(body));
    }
    else {
        httpRequest.end();
    }
}


/***/ }),

/***/ 63936:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CredentialsProviderError = void 0;
const ProviderError_1 = __nccwpck_require__(23324);
class CredentialsProviderError extends ProviderError_1.ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}
exports.CredentialsProviderError = CredentialsProviderError;


/***/ }),

/***/ 23324:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProviderError = void 0;
class ProviderError extends Error {
    constructor(message, tryNextLink = true) {
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}
exports.ProviderError = ProviderError;


/***/ }),

/***/ 50429:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TokenProviderError = void 0;
const ProviderError_1 = __nccwpck_require__(23324);
class TokenProviderError extends ProviderError_1.ProviderError {
    constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}
exports.TokenProviderError = TokenProviderError;


/***/ }),

/***/ 45079:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.chain = void 0;
const ProviderError_1 = __nccwpck_require__(23324);
const chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError_1.ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err === null || err === void 0 ? void 0 : err.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};
exports.chain = chain;


/***/ }),

/***/ 51322:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromStatic = void 0;
const fromStatic = (staticValue) => () => Promise.resolve(staticValue);
exports.fromStatic = fromStatic;


/***/ }),

/***/ 79721:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(63936), exports);
tslib_1.__exportStar(__nccwpck_require__(23324), exports);
tslib_1.__exportStar(__nccwpck_require__(50429), exports);
tslib_1.__exportStar(__nccwpck_require__(45079), exports);
tslib_1.__exportStar(__nccwpck_require__(51322), exports);
tslib_1.__exportStar(__nccwpck_require__(49762), exports);


/***/ }),

/***/ 49762:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.memoize = void 0;
const memoize = (provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async () => {
        if (!pending) {
            pending = provider();
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        }
        finally {
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options) => {
            if (!hasResult || (options === null || options === void 0 ? void 0 : options.forceRefresh)) {
                resolved = await coalesceProvider();
            }
            return resolved;
        };
    }
    return async (options) => {
        if (!hasResult || (options === null || options === void 0 ? void 0 : options.forceRefresh)) {
            resolved = await coalesceProvider();
        }
        if (isConstant) {
            return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider();
            return resolved;
        }
        return resolved;
    };
};
exports.memoize = memoize;


/***/ }),

/***/ 89179:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Field = void 0;
const types_1 = __nccwpck_require__(55756);
class Field {
    constructor({ name, kind = types_1.FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v) => v !== value);
    }
    toString() {
        return this.values.map((v) => (v.includes(",") || v.includes(" ") ? `"${v}"` : v)).join(", ");
    }
    get() {
        return this.values;
    }
}
exports.Field = Field;


/***/ }),

/***/ 99242:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Fields = void 0;
class Fields {
    constructor({ fields = [], encoding = "utf-8" }) {
        this.entries = {};
        fields.forEach(this.setField.bind(this));
        this.encoding = encoding;
    }
    setField(field) {
        this.entries[field.name.toLowerCase()] = field;
    }
    getField(name) {
        return this.entries[name.toLowerCase()];
    }
    removeField(name) {
        delete this.entries[name.toLowerCase()];
    }
    getByType(kind) {
        return Object.values(this.entries).filter((field) => field.kind === kind);
    }
}
exports.Fields = Fields;


/***/ }),

/***/ 22474:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveHttpHandlerRuntimeConfig = exports.getHttpHandlerExtensionConfiguration = void 0;
const getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
    let httpHandler = runtimeConfig.httpHandler;
    return {
        setHttpHandler(handler) {
            httpHandler = handler;
        },
        httpHandler() {
            return httpHandler;
        },
        updateHttpClientConfig(key, value) {
            httpHandler.updateHttpClientConfig(key, value);
        },
        httpHandlerConfigs() {
            return httpHandler.httpHandlerConfigs();
        },
    };
};
exports.getHttpHandlerExtensionConfiguration = getHttpHandlerExtensionConfiguration;
const resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
    return {
        httpHandler: httpHandlerExtensionConfiguration.httpHandler(),
    };
};
exports.resolveHttpHandlerRuntimeConfig = resolveHttpHandlerRuntimeConfig;


/***/ }),

/***/ 91654:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(22474), exports);


/***/ }),

/***/ 63206:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 38746:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpRequest = void 0;
class HttpRequest {
    constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol
            ? options.protocol.slice(-1) !== ":"
                ? `${options.protocol}:`
                : options.protocol
            : "https:";
        this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
    }
    static isInstance(request) {
        if (!request)
            return false;
        const req = request;
        return ("method" in req &&
            "protocol" in req &&
            "hostname" in req &&
            "path" in req &&
            typeof req["query"] === "object" &&
            typeof req["headers"] === "object");
    }
    clone() {
        const cloned = new HttpRequest({
            ...this,
            headers: { ...this.headers },
        });
        if (cloned.query)
            cloned.query = cloneQuery(cloned.query);
        return cloned;
    }
}
exports.HttpRequest = HttpRequest;
function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [...param] : param,
        };
    }, {});
}


/***/ }),

/***/ 26322:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpResponse = void 0;
class HttpResponse {
    constructor(options) {
        this.statusCode = options.statusCode;
        this.reason = options.reason;
        this.headers = options.headers || {};
        this.body = options.body;
    }
    static isInstance(response) {
        if (!response)
            return false;
        const resp = response;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
}
exports.HttpResponse = HttpResponse;


/***/ }),

/***/ 64418:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(91654), exports);
tslib_1.__exportStar(__nccwpck_require__(89179), exports);
tslib_1.__exportStar(__nccwpck_require__(99242), exports);
tslib_1.__exportStar(__nccwpck_require__(63206), exports);
tslib_1.__exportStar(__nccwpck_require__(38746), exports);
tslib_1.__exportStar(__nccwpck_require__(26322), exports);
tslib_1.__exportStar(__nccwpck_require__(61466), exports);
tslib_1.__exportStar(__nccwpck_require__(19135), exports);


/***/ }),

/***/ 61466:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isValidHostname = void 0;
function isValidHostname(hostname) {
    const hostPattern = /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/;
    return hostPattern.test(hostname);
}
exports.isValidHostname = isValidHostname;


/***/ }),

/***/ 19135:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 68031:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildQueryString = void 0;
const util_uri_escape_1 = __nccwpck_require__(54197);
function buildQueryString(query) {
    const parts = [];
    for (let key of Object.keys(query).sort()) {
        const value = query[key];
        key = (0, util_uri_escape_1.escapeUri)(key);
        if (Array.isArray(value)) {
            for (let i = 0, iLen = value.length; i < iLen; i++) {
                parts.push(`${key}=${(0, util_uri_escape_1.escapeUri)(value[i])}`);
            }
        }
        else {
            let qsEntry = key;
            if (value || typeof value === "string") {
                qsEntry += `=${(0, util_uri_escape_1.escapeUri)(value)}`;
            }
            parts.push(qsEntry);
        }
    }
    return parts.join("&");
}
exports.buildQueryString = buildQueryString;


/***/ }),

/***/ 4769:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseQueryString = void 0;
function parseQueryString(querystring) {
    const query = {};
    querystring = querystring.replace(/^\?/, "");
    if (querystring) {
        for (const pair of querystring.split("&")) {
            let [key, value = null] = pair.split("=");
            key = decodeURIComponent(key);
            if (value) {
                value = decodeURIComponent(value);
            }
            if (!(key in query)) {
                query[key] = value;
            }
            else if (Array.isArray(query[key])) {
                query[key].push(value);
            }
            else {
                query[key] = [query[key], value];
            }
        }
    }
    return query;
}
exports.parseQueryString = parseQueryString;


/***/ }),

/***/ 68415:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODEJS_TIMEOUT_ERROR_CODES = exports.TRANSIENT_ERROR_STATUS_CODES = exports.TRANSIENT_ERROR_CODES = exports.THROTTLING_ERROR_CODES = exports.CLOCK_SKEW_ERROR_CODES = void 0;
exports.CLOCK_SKEW_ERROR_CODES = [
    "AuthFailure",
    "InvalidSignatureException",
    "RequestExpired",
    "RequestInTheFuture",
    "RequestTimeTooSkewed",
    "SignatureDoesNotMatch",
];
exports.THROTTLING_ERROR_CODES = [
    "BandwidthLimitExceeded",
    "EC2ThrottledException",
    "LimitExceededException",
    "PriorRequestNotComplete",
    "ProvisionedThroughputExceededException",
    "RequestLimitExceeded",
    "RequestThrottled",
    "RequestThrottledException",
    "SlowDown",
    "ThrottledException",
    "Throttling",
    "ThrottlingException",
    "TooManyRequestsException",
    "TransactionInProgressException",
];
exports.TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
exports.TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
exports.NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];


/***/ }),

/***/ 6375:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isServerError = exports.isTransientError = exports.isThrottlingError = exports.isClockSkewError = exports.isRetryableByTrait = void 0;
const constants_1 = __nccwpck_require__(68415);
const isRetryableByTrait = (error) => error.$retryable !== undefined;
exports.isRetryableByTrait = isRetryableByTrait;
const isClockSkewError = (error) => constants_1.CLOCK_SKEW_ERROR_CODES.includes(error.name);
exports.isClockSkewError = isClockSkewError;
const isThrottlingError = (error) => {
    var _a, _b;
    return ((_a = error.$metadata) === null || _a === void 0 ? void 0 : _a.httpStatusCode) === 429 ||
        constants_1.THROTTLING_ERROR_CODES.includes(error.name) ||
        ((_b = error.$retryable) === null || _b === void 0 ? void 0 : _b.throttling) == true;
};
exports.isThrottlingError = isThrottlingError;
const isTransientError = (error) => {
    var _a;
    return constants_1.TRANSIENT_ERROR_CODES.includes(error.name) ||
        constants_1.NODEJS_TIMEOUT_ERROR_CODES.includes((error === null || error === void 0 ? void 0 : error.code) || "") ||
        constants_1.TRANSIENT_ERROR_STATUS_CODES.includes(((_a = error.$metadata) === null || _a === void 0 ? void 0 : _a.httpStatusCode) || 0);
};
exports.isTransientError = isTransientError;
const isServerError = (error) => {
    var _a;
    if (((_a = error.$metadata) === null || _a === void 0 ? void 0 : _a.httpStatusCode) !== undefined) {
        const statusCode = error.$metadata.httpStatusCode;
        if (500 <= statusCode && statusCode <= 599 && !(0, exports.isTransientError)(error)) {
            return true;
        }
        return false;
    }
    return false;
};
exports.isServerError = isServerError;


/***/ }),

/***/ 46062:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getConfigData = void 0;
const types_1 = __nccwpck_require__(55756);
const loadSharedConfigFiles_1 = __nccwpck_require__(41879);
const getConfigData = (data) => Object.entries(data)
    .filter(([key]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_1.CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
        return false;
    }
    return Object.values(types_1.IniSectionType).includes(key.substring(0, indexOfSeparator));
})
    .reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(loadSharedConfigFiles_1.CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === types_1.IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
}, {
    ...(data.default && { default: data.default }),
});
exports.getConfigData = getConfigData;


/***/ }),

/***/ 47237:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getConfigFilepath = exports.ENV_CONFIG_PATH = void 0;
const path_1 = __nccwpck_require__(71017);
const getHomeDir_1 = __nccwpck_require__(68340);
exports.ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath = () => process.env[exports.ENV_CONFIG_PATH] || (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "config");
exports.getConfigFilepath = getConfigFilepath;


/***/ }),

/***/ 99036:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCredentialsFilepath = exports.ENV_CREDENTIALS_PATH = void 0;
const path_1 = __nccwpck_require__(71017);
const getHomeDir_1 = __nccwpck_require__(68340);
exports.ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath = () => process.env[exports.ENV_CREDENTIALS_PATH] || (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "credentials");
exports.getCredentialsFilepath = getCredentialsFilepath;


/***/ }),

/***/ 68340:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHomeDir = void 0;
const os_1 = __nccwpck_require__(22037);
const path_1 = __nccwpck_require__(71017);
const homeDirCache = {};
const getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
        return `${process.geteuid()}`;
    }
    return "DEFAULT";
};
const getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${path_1.sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey])
        homeDirCache[homeDirCacheKey] = (0, os_1.homedir)();
    return homeDirCache[homeDirCacheKey];
};
exports.getHomeDir = getHomeDir;


/***/ }),

/***/ 52802:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getProfileName = exports.DEFAULT_PROFILE = exports.ENV_PROFILE = void 0;
exports.ENV_PROFILE = "AWS_PROFILE";
exports.DEFAULT_PROFILE = "default";
const getProfileName = (init) => init.profile || process.env[exports.ENV_PROFILE] || exports.DEFAULT_PROFILE;
exports.getProfileName = getProfileName;


/***/ }),

/***/ 24740:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSSOTokenFilepath = void 0;
const crypto_1 = __nccwpck_require__(6113);
const path_1 = __nccwpck_require__(71017);
const getHomeDir_1 = __nccwpck_require__(68340);
const getSSOTokenFilepath = (id) => {
    const hasher = (0, crypto_1.createHash)("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "sso", "cache", `${cacheName}.json`);
};
exports.getSSOTokenFilepath = getSSOTokenFilepath;


/***/ }),

/***/ 69678:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSSOTokenFromFile = void 0;
const fs_1 = __nccwpck_require__(57147);
const getSSOTokenFilepath_1 = __nccwpck_require__(24740);
const { readFile } = fs_1.promises;
const getSSOTokenFromFile = async (id) => {
    const ssoTokenFilepath = (0, getSSOTokenFilepath_1.getSSOTokenFilepath)(id);
    const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};
exports.getSSOTokenFromFile = getSSOTokenFromFile;


/***/ }),

/***/ 82820:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSsoSessionData = void 0;
const types_1 = __nccwpck_require__(55756);
const loadSharedConfigFiles_1 = __nccwpck_require__(41879);
const getSsoSessionData = (data) => Object.entries(data)
    .filter(([key]) => key.startsWith(types_1.IniSectionType.SSO_SESSION + loadSharedConfigFiles_1.CONFIG_PREFIX_SEPARATOR))
    .reduce((acc, [key, value]) => ({ ...acc, [key.split(loadSharedConfigFiles_1.CONFIG_PREFIX_SEPARATOR)[1]]: value }), {});
exports.getSsoSessionData = getSsoSessionData;


/***/ }),

/***/ 43507:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(68340), exports);
tslib_1.__exportStar(__nccwpck_require__(52802), exports);
tslib_1.__exportStar(__nccwpck_require__(24740), exports);
tslib_1.__exportStar(__nccwpck_require__(69678), exports);
tslib_1.__exportStar(__nccwpck_require__(41879), exports);
tslib_1.__exportStar(__nccwpck_require__(34649), exports);
tslib_1.__exportStar(__nccwpck_require__(2546), exports);
tslib_1.__exportStar(__nccwpck_require__(63191), exports);


/***/ }),

/***/ 41879:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadSharedConfigFiles = exports.CONFIG_PREFIX_SEPARATOR = void 0;
const getConfigData_1 = __nccwpck_require__(46062);
const getConfigFilepath_1 = __nccwpck_require__(47237);
const getCredentialsFilepath_1 = __nccwpck_require__(99036);
const parseIni_1 = __nccwpck_require__(54262);
const slurpFile_1 = __nccwpck_require__(19155);
const swallowError = () => ({});
exports.CONFIG_PREFIX_SEPARATOR = ".";
const loadSharedConfigFiles = async (init = {}) => {
    const { filepath = (0, getCredentialsFilepath_1.getCredentialsFilepath)(), configFilepath = (0, getConfigFilepath_1.getConfigFilepath)() } = init;
    const parsedFiles = await Promise.all([
        (0, slurpFile_1.slurpFile)(configFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_1.parseIni)
            .then(getConfigData_1.getConfigData)
            .catch(swallowError),
        (0, slurpFile_1.slurpFile)(filepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni_1.parseIni)
            .catch(swallowError),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};
exports.loadSharedConfigFiles = loadSharedConfigFiles;


/***/ }),

/***/ 34649:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadSsoSessionData = void 0;
const getConfigFilepath_1 = __nccwpck_require__(47237);
const getSsoSessionData_1 = __nccwpck_require__(82820);
const parseIni_1 = __nccwpck_require__(54262);
const slurpFile_1 = __nccwpck_require__(19155);
const swallowError = () => ({});
const loadSsoSessionData = async (init = {}) => {
    var _a;
    return (0, slurpFile_1.slurpFile)((_a = init.configFilepath) !== null && _a !== void 0 ? _a : (0, getConfigFilepath_1.getConfigFilepath)())
        .then(parseIni_1.parseIni)
        .then(getSsoSessionData_1.getSsoSessionData)
        .catch(swallowError);
};
exports.loadSsoSessionData = loadSsoSessionData;


/***/ }),

/***/ 19447:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mergeConfigFiles = void 0;
const mergeConfigFiles = (...files) => {
    const merged = {};
    for (const file of files) {
        for (const [key, values] of Object.entries(file)) {
            if (merged[key] !== undefined) {
                Object.assign(merged[key], values);
            }
            else {
                merged[key] = values;
            }
        }
    }
    return merged;
};
exports.mergeConfigFiles = mergeConfigFiles;


/***/ }),

/***/ 54262:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseIni = void 0;
const types_1 = __nccwpck_require__(55756);
const loadSharedConfigFiles_1 = __nccwpck_require__(41879);
const prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
const profileNameBlockList = ["__proto__", "profile __proto__"];
const parseIni = (iniData) => {
    const map = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
            currentSection = undefined;
            currentSubSection = undefined;
            const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
            const matches = prefixKeyRegex.exec(sectionName);
            if (matches) {
                const [, prefix, , name] = matches;
                if (Object.values(types_1.IniSectionType).includes(prefix)) {
                    currentSection = [prefix, name].join(loadSharedConfigFiles_1.CONFIG_PREFIX_SEPARATOR);
                }
            }
            else {
                currentSection = sectionName;
            }
            if (profileNameBlockList.includes(sectionName)) {
                throw new Error(`Found invalid profile name "${sectionName}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = trimmedLine.indexOf("=");
            if (![0, -1].includes(indexOfEqualsSign)) {
                const [name, value] = [
                    trimmedLine.substring(0, indexOfEqualsSign).trim(),
                    trimmedLine.substring(indexOfEqualsSign + 1).trim(),
                ];
                if (value === "") {
                    currentSubSection = name;
                }
                else {
                    if (currentSubSection && iniLine.trimStart() === iniLine) {
                        currentSubSection = undefined;
                    }
                    map[currentSection] = map[currentSection] || {};
                    const key = currentSubSection ? [currentSubSection, name].join(loadSharedConfigFiles_1.CONFIG_PREFIX_SEPARATOR) : name;
                    map[currentSection][key] = value;
                }
            }
        }
    }
    return map;
};
exports.parseIni = parseIni;


/***/ }),

/***/ 2546:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseKnownFiles = void 0;
const loadSharedConfigFiles_1 = __nccwpck_require__(41879);
const mergeConfigFiles_1 = __nccwpck_require__(19447);
const parseKnownFiles = async (init) => {
    const parsedFiles = await (0, loadSharedConfigFiles_1.loadSharedConfigFiles)(init);
    return (0, mergeConfigFiles_1.mergeConfigFiles)(parsedFiles.configFile, parsedFiles.credentialsFile);
};
exports.parseKnownFiles = parseKnownFiles;


/***/ }),

/***/ 19155:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.slurpFile = void 0;
const fs_1 = __nccwpck_require__(57147);
const { readFile } = fs_1.promises;
const filePromisesHash = {};
const slurpFile = (path, options) => {
    if (!filePromisesHash[path] || (options === null || options === void 0 ? void 0 : options.ignoreCache)) {
        filePromisesHash[path] = readFile(path, "utf8");
    }
    return filePromisesHash[path];
};
exports.slurpFile = slurpFile;


/***/ }),

/***/ 63191:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 39733:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignatureV4 = void 0;
const eventstream_codec_1 = __nccwpck_require__(56459);
const util_hex_encoding_1 = __nccwpck_require__(45364);
const util_middleware_1 = __nccwpck_require__(2390);
const util_utf8_1 = __nccwpck_require__(41895);
const constants_1 = __nccwpck_require__(48644);
const credentialDerivation_1 = __nccwpck_require__(19623);
const getCanonicalHeaders_1 = __nccwpck_require__(51393);
const getCanonicalQuery_1 = __nccwpck_require__(33243);
const getPayloadHash_1 = __nccwpck_require__(48545);
const headerUtil_1 = __nccwpck_require__(62179);
const moveHeadersToQuery_1 = __nccwpck_require__(49828);
const prepareRequest_1 = __nccwpck_require__(60075);
const utilDate_1 = __nccwpck_require__(39299);
class SignatureV4 {
    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {
        this.headerMarshaller = new eventstream_codec_1.HeaderMarshaller(util_utf8_1.toUtf8, util_utf8_1.fromUtf8);
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
        this.regionProvider = (0, util_middleware_1.normalizeProvider)(region);
        this.credentialProvider = (0, util_middleware_1.normalizeProvider)(credentials);
    }
    async presign(originalRequest, options = {}) {
        const { signingDate = new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService, } = options;
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());
        const { longDate, shortDate } = formatDate(signingDate);
        if (expiresIn > constants_1.MAX_PRESIGNED_TTL) {
            return Promise.reject("Signature version 4 presigned URLs" + " must have an expiration date less than one week in" + " the future");
        }
        const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
        const request = (0, moveHeadersToQuery_1.moveHeadersToQuery)((0, prepareRequest_1.prepareRequest)(originalRequest), { unhoistableHeaders });
        if (credentials.sessionToken) {
            request.query[constants_1.TOKEN_QUERY_PARAM] = credentials.sessionToken;
        }
        request.query[constants_1.ALGORITHM_QUERY_PARAM] = constants_1.ALGORITHM_IDENTIFIER;
        request.query[constants_1.CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
        request.query[constants_1.AMZ_DATE_QUERY_PARAM] = longDate;
        request.query[constants_1.EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
        const canonicalHeaders = (0, getCanonicalHeaders_1.getCanonicalHeaders)(request, unsignableHeaders, signableHeaders);
        request.query[constants_1.SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
        request.query[constants_1.SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await (0, getPayloadHash_1.getPayloadHash)(originalRequest, this.sha256)));
        return request;
    }
    async sign(toSign, options) {
        if (typeof toSign === "string") {
            return this.signString(toSign, options);
        }
        else if (toSign.headers && toSign.payload) {
            return this.signEvent(toSign, options);
        }
        else if (toSign.message) {
            return this.signMessage(toSign, options);
        }
        else {
            return this.signRequest(toSign, options);
        }
    }
    async signEvent({ headers, payload }, { signingDate = new Date(), priorSignature, signingRegion, signingService }) {
        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());
        const { shortDate, longDate } = formatDate(signingDate);
        const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
        const hashedPayload = await (0, getPayloadHash_1.getPayloadHash)({ headers: {}, body: payload }, this.sha256);
        const hash = new this.sha256();
        hash.update(headers);
        const hashedHeaders = (0, util_hex_encoding_1.toHex)(await hash.digest());
        const stringToSign = [
            constants_1.EVENT_ALGORITHM_IDENTIFIER,
            longDate,
            scope,
            priorSignature,
            hashedHeaders,
            hashedPayload,
        ].join("\n");
        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
    }
    async signMessage(signableMessage, { signingDate = new Date(), signingRegion, signingService }) {
        const promise = this.signEvent({
            headers: this.headerMarshaller.format(signableMessage.message.headers),
            payload: signableMessage.message.body,
        }, {
            signingDate,
            signingRegion,
            signingService,
            priorSignature: signableMessage.priorSignature,
        });
        return promise.then((signature) => {
            return { message: signableMessage.message, signature };
        });
    }
    async signString(stringToSign, { signingDate = new Date(), signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());
        const { shortDate } = formatDate(signingDate);
        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
        hash.update((0, util_utf8_1.toUint8Array)(stringToSign));
        return (0, util_hex_encoding_1.toHex)(await hash.digest());
    }
    async signRequest(requestToSign, { signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService, } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());
        const request = (0, prepareRequest_1.prepareRequest)(requestToSign);
        const { longDate, shortDate } = formatDate(signingDate);
        const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
        request.headers[constants_1.AMZ_DATE_HEADER] = longDate;
        if (credentials.sessionToken) {
            request.headers[constants_1.TOKEN_HEADER] = credentials.sessionToken;
        }
        const payloadHash = await (0, getPayloadHash_1.getPayloadHash)(request, this.sha256);
        if (!(0, headerUtil_1.hasHeader)(constants_1.SHA256_HEADER, request.headers) && this.applyChecksum) {
            request.headers[constants_1.SHA256_HEADER] = payloadHash;
        }
        const canonicalHeaders = (0, getCanonicalHeaders_1.getCanonicalHeaders)(request, unsignableHeaders, signableHeaders);
        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
        request.headers[constants_1.AUTH_HEADER] =
            `${constants_1.ALGORITHM_IDENTIFIER} ` +
                `Credential=${credentials.accessKeyId}/${scope}, ` +
                `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` +
                `Signature=${signature}`;
        return request;
    }
    createCanonicalRequest(request, canonicalHeaders, payloadHash) {
        const sortedHeaders = Object.keys(canonicalHeaders).sort();
        return `${request.method}
${this.getCanonicalPath(request)}
${(0, getCanonicalQuery_1.getCanonicalQuery)(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
    }
    async createStringToSign(longDate, credentialScope, canonicalRequest) {
        const hash = new this.sha256();
        hash.update((0, util_utf8_1.toUint8Array)(canonicalRequest));
        const hashedRequest = await hash.digest();
        return `${constants_1.ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${(0, util_hex_encoding_1.toHex)(hashedRequest)}`;
    }
    getCanonicalPath({ path }) {
        if (this.uriEscapePath) {
            const normalizedPathSegments = [];
            for (const pathSegment of path.split("/")) {
                if ((pathSegment === null || pathSegment === void 0 ? void 0 : pathSegment.length) === 0)
                    continue;
                if (pathSegment === ".")
                    continue;
                if (pathSegment === "..") {
                    normalizedPathSegments.pop();
                }
                else {
                    normalizedPathSegments.push(pathSegment);
                }
            }
            const normalizedPath = `${(path === null || path === void 0 ? void 0 : path.startsWith("/")) ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && (path === null || path === void 0 ? void 0 : path.endsWith("/")) ? "/" : ""}`;
            const doubleEncoded = encodeURIComponent(normalizedPath);
            return doubleEncoded.replace(/%2F/g, "/");
        }
        return path;
    }
    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
        const hash = new this.sha256(await keyPromise);
        hash.update((0, util_utf8_1.toUint8Array)(stringToSign));
        return (0, util_hex_encoding_1.toHex)(await hash.digest());
    }
    getSigningKey(credentials, region, shortDate, service) {
        return (0, credentialDerivation_1.getSigningKey)(this.sha256, credentials, shortDate, region, service || this.service);
    }
    validateResolvedCredentials(credentials) {
        if (typeof credentials !== "object" ||
            typeof credentials.accessKeyId !== "string" ||
            typeof credentials.secretAccessKey !== "string") {
            throw new Error("Resolved credential object is not valid");
        }
    }
}
exports.SignatureV4 = SignatureV4;
const formatDate = (now) => {
    const longDate = (0, utilDate_1.iso8601)(now).replace(/[\-:]/g, "");
    return {
        longDate,
        shortDate: longDate.slice(0, 8),
    };
};
const getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(";");


/***/ }),

/***/ 69098:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cloneQuery = exports.cloneRequest = void 0;
const cloneRequest = ({ headers, query, ...rest }) => ({
    ...rest,
    headers: { ...headers },
    query: query ? (0, exports.cloneQuery)(query) : undefined,
});
exports.cloneRequest = cloneRequest;
const cloneQuery = (query) => Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
        ...carry,
        [paramName]: Array.isArray(param) ? [...param] : param,
    };
}, {});
exports.cloneQuery = cloneQuery;


/***/ }),

/***/ 48644:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MAX_PRESIGNED_TTL = exports.KEY_TYPE_IDENTIFIER = exports.MAX_CACHE_SIZE = exports.UNSIGNED_PAYLOAD = exports.EVENT_ALGORITHM_IDENTIFIER = exports.ALGORITHM_IDENTIFIER_V4A = exports.ALGORITHM_IDENTIFIER = exports.UNSIGNABLE_PATTERNS = exports.SEC_HEADER_PATTERN = exports.PROXY_HEADER_PATTERN = exports.ALWAYS_UNSIGNABLE_HEADERS = exports.HOST_HEADER = exports.TOKEN_HEADER = exports.SHA256_HEADER = exports.SIGNATURE_HEADER = exports.GENERATED_HEADERS = exports.DATE_HEADER = exports.AMZ_DATE_HEADER = exports.AUTH_HEADER = exports.REGION_SET_PARAM = exports.TOKEN_QUERY_PARAM = exports.SIGNATURE_QUERY_PARAM = exports.EXPIRES_QUERY_PARAM = exports.SIGNED_HEADERS_QUERY_PARAM = exports.AMZ_DATE_QUERY_PARAM = exports.CREDENTIAL_QUERY_PARAM = exports.ALGORITHM_QUERY_PARAM = void 0;
exports.ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
exports.CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
exports.AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
exports.SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
exports.EXPIRES_QUERY_PARAM = "X-Amz-Expires";
exports.SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
exports.TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
exports.REGION_SET_PARAM = "X-Amz-Region-Set";
exports.AUTH_HEADER = "authorization";
exports.AMZ_DATE_HEADER = exports.AMZ_DATE_QUERY_PARAM.toLowerCase();
exports.DATE_HEADER = "date";
exports.GENERATED_HEADERS = [exports.AUTH_HEADER, exports.AMZ_DATE_HEADER, exports.DATE_HEADER];
exports.SIGNATURE_HEADER = exports.SIGNATURE_QUERY_PARAM.toLowerCase();
exports.SHA256_HEADER = "x-amz-content-sha256";
exports.TOKEN_HEADER = exports.TOKEN_QUERY_PARAM.toLowerCase();
exports.HOST_HEADER = "host";
exports.ALWAYS_UNSIGNABLE_HEADERS = {
    authorization: true,
    "cache-control": true,
    connection: true,
    expect: true,
    from: true,
    "keep-alive": true,
    "max-forwards": true,
    pragma: true,
    referer: true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true,
    "user-agent": true,
    "x-amzn-trace-id": true,
};
exports.PROXY_HEADER_PATTERN = /^proxy-/;
exports.SEC_HEADER_PATTERN = /^sec-/;
exports.UNSIGNABLE_PATTERNS = [/^proxy-/i, /^sec-/i];
exports.ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
exports.ALGORITHM_IDENTIFIER_V4A = "AWS4-ECDSA-P256-SHA256";
exports.EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
exports.UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
exports.MAX_CACHE_SIZE = 50;
exports.KEY_TYPE_IDENTIFIER = "aws4_request";
exports.MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;


/***/ }),

/***/ 19623:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clearCredentialCache = exports.getSigningKey = exports.createScope = void 0;
const util_hex_encoding_1 = __nccwpck_require__(45364);
const util_utf8_1 = __nccwpck_require__(41895);
const constants_1 = __nccwpck_require__(48644);
const signingKeyCache = {};
const cacheQueue = [];
const createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${constants_1.KEY_TYPE_IDENTIFIER}`;
exports.createScope = createScope;
const getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
    const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
    const cacheKey = `${shortDate}:${region}:${service}:${(0, util_hex_encoding_1.toHex)(credsHash)}:${credentials.sessionToken}`;
    if (cacheKey in signingKeyCache) {
        return signingKeyCache[cacheKey];
    }
    cacheQueue.push(cacheKey);
    while (cacheQueue.length > constants_1.MAX_CACHE_SIZE) {
        delete signingKeyCache[cacheQueue.shift()];
    }
    let key = `AWS4${credentials.secretAccessKey}`;
    for (const signable of [shortDate, region, service, constants_1.KEY_TYPE_IDENTIFIER]) {
        key = await hmac(sha256Constructor, key, signable);
    }
    return (signingKeyCache[cacheKey] = key);
};
exports.getSigningKey = getSigningKey;
const clearCredentialCache = () => {
    cacheQueue.length = 0;
    Object.keys(signingKeyCache).forEach((cacheKey) => {
        delete signingKeyCache[cacheKey];
    });
};
exports.clearCredentialCache = clearCredentialCache;
const hmac = (ctor, secret, data) => {
    const hash = new ctor(secret);
    hash.update((0, util_utf8_1.toUint8Array)(data));
    return hash.digest();
};


/***/ }),

/***/ 51393:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCanonicalHeaders = void 0;
const constants_1 = __nccwpck_require__(48644);
const getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
    const canonical = {};
    for (const headerName of Object.keys(headers).sort()) {
        if (headers[headerName] == undefined) {
            continue;
        }
        const canonicalHeaderName = headerName.toLowerCase();
        if (canonicalHeaderName in constants_1.ALWAYS_UNSIGNABLE_HEADERS ||
            (unsignableHeaders === null || unsignableHeaders === void 0 ? void 0 : unsignableHeaders.has(canonicalHeaderName)) ||
            constants_1.PROXY_HEADER_PATTERN.test(canonicalHeaderName) ||
            constants_1.SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
            if (!signableHeaders || (signableHeaders && !signableHeaders.has(canonicalHeaderName))) {
                continue;
            }
        }
        canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
    }
    return canonical;
};
exports.getCanonicalHeaders = getCanonicalHeaders;


/***/ }),

/***/ 33243:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCanonicalQuery = void 0;
const util_uri_escape_1 = __nccwpck_require__(54197);
const constants_1 = __nccwpck_require__(48644);
const getCanonicalQuery = ({ query = {} }) => {
    const keys = [];
    const serialized = {};
    for (const key of Object.keys(query).sort()) {
        if (key.toLowerCase() === constants_1.SIGNATURE_HEADER) {
            continue;
        }
        keys.push(key);
        const value = query[key];
        if (typeof value === "string") {
            serialized[key] = `${(0, util_uri_escape_1.escapeUri)(key)}=${(0, util_uri_escape_1.escapeUri)(value)}`;
        }
        else if (Array.isArray(value)) {
            serialized[key] = value
                .slice(0)
                .reduce((encoded, value) => encoded.concat([`${(0, util_uri_escape_1.escapeUri)(key)}=${(0, util_uri_escape_1.escapeUri)(value)}`]), [])
                .sort()
                .join("&");
        }
    }
    return keys
        .map((key) => serialized[key])
        .filter((serialized) => serialized)
        .join("&");
};
exports.getCanonicalQuery = getCanonicalQuery;


/***/ }),

/***/ 48545:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPayloadHash = void 0;
const is_array_buffer_1 = __nccwpck_require__(10780);
const util_hex_encoding_1 = __nccwpck_require__(45364);
const util_utf8_1 = __nccwpck_require__(41895);
const constants_1 = __nccwpck_require__(48644);
const getPayloadHash = async ({ headers, body }, hashConstructor) => {
    for (const headerName of Object.keys(headers)) {
        if (headerName.toLowerCase() === constants_1.SHA256_HEADER) {
            return headers[headerName];
        }
    }
    if (body == undefined) {
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    }
    else if (typeof body === "string" || ArrayBuffer.isView(body) || (0, is_array_buffer_1.isArrayBuffer)(body)) {
        const hashCtor = new hashConstructor();
        hashCtor.update((0, util_utf8_1.toUint8Array)(body));
        return (0, util_hex_encoding_1.toHex)(await hashCtor.digest());
    }
    return constants_1.UNSIGNED_PAYLOAD;
};
exports.getPayloadHash = getPayloadHash;


/***/ }),

/***/ 62179:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteHeader = exports.getHeaderValue = exports.hasHeader = void 0;
const hasHeader = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
            return true;
        }
    }
    return false;
};
exports.hasHeader = hasHeader;
const getHeaderValue = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
            return headers[headerName];
        }
    }
    return undefined;
};
exports.getHeaderValue = getHeaderValue;
const deleteHeader = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
            delete headers[headerName];
        }
    }
};
exports.deleteHeader = deleteHeader;


/***/ }),

/***/ 11528:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareRequest = exports.moveHeadersToQuery = exports.getPayloadHash = exports.getCanonicalQuery = exports.getCanonicalHeaders = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(39733), exports);
var getCanonicalHeaders_1 = __nccwpck_require__(51393);
Object.defineProperty(exports, "getCanonicalHeaders", ({ enumerable: true, get: function () { return getCanonicalHeaders_1.getCanonicalHeaders; } }));
var getCanonicalQuery_1 = __nccwpck_require__(33243);
Object.defineProperty(exports, "getCanonicalQuery", ({ enumerable: true, get: function () { return getCanonicalQuery_1.getCanonicalQuery; } }));
var getPayloadHash_1 = __nccwpck_require__(48545);
Object.defineProperty(exports, "getPayloadHash", ({ enumerable: true, get: function () { return getPayloadHash_1.getPayloadHash; } }));
var moveHeadersToQuery_1 = __nccwpck_require__(49828);
Object.defineProperty(exports, "moveHeadersToQuery", ({ enumerable: true, get: function () { return moveHeadersToQuery_1.moveHeadersToQuery; } }));
var prepareRequest_1 = __nccwpck_require__(60075);
Object.defineProperty(exports, "prepareRequest", ({ enumerable: true, get: function () { return prepareRequest_1.prepareRequest; } }));
tslib_1.__exportStar(__nccwpck_require__(19623), exports);


/***/ }),

/***/ 49828:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.moveHeadersToQuery = void 0;
const cloneRequest_1 = __nccwpck_require__(69098);
const moveHeadersToQuery = (request, options = {}) => {
    var _a;
    const { headers, query = {} } = typeof request.clone === "function" ? request.clone() : (0, cloneRequest_1.cloneRequest)(request);
    for (const name of Object.keys(headers)) {
        const lname = name.toLowerCase();
        if (lname.slice(0, 6) === "x-amz-" && !((_a = options.unhoistableHeaders) === null || _a === void 0 ? void 0 : _a.has(lname))) {
            query[name] = headers[name];
            delete headers[name];
        }
    }
    return {
        ...request,
        headers,
        query,
    };
};
exports.moveHeadersToQuery = moveHeadersToQuery;


/***/ }),

/***/ 60075:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareRequest = void 0;
const cloneRequest_1 = __nccwpck_require__(69098);
const constants_1 = __nccwpck_require__(48644);
const prepareRequest = (request) => {
    request = typeof request.clone === "function" ? request.clone() : (0, cloneRequest_1.cloneRequest)(request);
    for (const headerName of Object.keys(request.headers)) {
        if (constants_1.GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
            delete request.headers[headerName];
        }
    }
    return request;
};
exports.prepareRequest = prepareRequest;


/***/ }),

/***/ 39299:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toDate = exports.iso8601 = void 0;
const iso8601 = (time) => (0, exports.toDate)(time)
    .toISOString()
    .replace(/\.\d{3}Z$/, "Z");
exports.iso8601 = iso8601;
const toDate = (time) => {
    if (typeof time === "number") {
        return new Date(time * 1000);
    }
    if (typeof time === "string") {
        if (Number(time)) {
            return new Date(Number(time) * 1000);
        }
        return new Date(time);
    }
    return time;
};
exports.toDate = toDate;


/***/ }),

/***/ 70438:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoOpLogger = void 0;
class NoOpLogger {
    trace() { }
    debug() { }
    info() { }
    warn() { }
    error() { }
}
exports.NoOpLogger = NoOpLogger;


/***/ }),

/***/ 61600:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Client = void 0;
const middleware_stack_1 = __nccwpck_require__(97911);
class Client {
    constructor(config) {
        this.middlewareStack = (0, middleware_stack_1.constructStack)();
        this.config = config;
    }
    send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        if (callback) {
            handler(command)
                .then((result) => callback(null, result.output), (err) => callback(err))
                .catch(() => { });
        }
        else {
            return handler(command).then((result) => result.output);
        }
    }
    destroy() {
        if (this.config.requestHandler.destroy)
            this.config.requestHandler.destroy();
    }
}
exports.Client = Client;


/***/ }),

/***/ 32813:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.collectBody = void 0;
const util_stream_1 = __nccwpck_require__(96607);
const collectBody = async (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return util_stream_1.Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
        return util_stream_1.Uint8ArrayBlobAdapter.mutate(new Uint8Array());
    }
    const fromContext = context.streamCollector(streamBody);
    return util_stream_1.Uint8ArrayBlobAdapter.mutate(await fromContext);
};
exports.collectBody = collectBody;


/***/ }),

/***/ 75414:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Command = void 0;
const middleware_stack_1 = __nccwpck_require__(97911);
const types_1 = __nccwpck_require__(55756);
class Command {
    constructor() {
        this.middlewareStack = (0, middleware_stack_1.constructStack)();
    }
    static classBuilder() {
        return new ClassBuilder();
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }) {
        for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
            this.middlewareStack.use(mw);
        }
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog,
            outputFilterSensitiveLog,
            [types_1.SMITHY_CONTEXT_KEY]: {
                ...smithyContext,
            },
            ...additionalContext,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
}
exports.Command = Command;
class ClassBuilder {
    constructor() {
        this._init = () => { };
        this._ep = {};
        this._middlewareFn = () => [];
        this._commandName = "";
        this._clientName = "";
        this._additionalContext = {};
        this._smithyContext = {};
        this._inputFilterSensitiveLog = (_) => _;
        this._outputFilterSensitiveLog = (_) => _;
        this._serializer = null;
        this._deserializer = null;
    }
    init(cb) {
        this._init = cb;
    }
    ep(endpointParameterInstructions) {
        this._ep = endpointParameterInstructions;
        return this;
    }
    m(middlewareSupplier) {
        this._middlewareFn = middlewareSupplier;
        return this;
    }
    s(service, operation, smithyContext = {}) {
        this._smithyContext = {
            service,
            operation,
            ...smithyContext,
        };
        return this;
    }
    c(additionalContext = {}) {
        this._additionalContext = additionalContext;
        return this;
    }
    n(clientName, commandName) {
        this._clientName = clientName;
        this._commandName = commandName;
        return this;
    }
    f(inputFilter = (_) => _, outputFilter = (_) => _) {
        this._inputFilterSensitiveLog = inputFilter;
        this._outputFilterSensitiveLog = outputFilter;
        return this;
    }
    ser(serializer) {
        this._serializer = serializer;
        return this;
    }
    de(deserializer) {
        this._deserializer = deserializer;
        return this;
    }
    build() {
        const closure = this;
        let CommandRef;
        return (CommandRef = class extends Command {
            static getEndpointParameterInstructions() {
                return closure._ep;
            }
            constructor(input) {
                super();
                this.input = input;
                this.serialize = closure._serializer;
                this.deserialize = closure._deserializer;
                closure._init(this);
            }
            resolveMiddleware(stack, configuration, options) {
                return this.resolveMiddlewareWithContext(stack, configuration, options, {
                    CommandCtor: CommandRef,
                    middlewareFn: closure._middlewareFn,
                    clientName: closure._clientName,
                    commandName: closure._commandName,
                    inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
                    outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
                    smithyContext: closure._smithyContext,
                    additionalContext: closure._additionalContext,
                });
            }
        });
    }
}


/***/ }),

/***/ 92541:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SENSITIVE_STRING = void 0;
exports.SENSITIVE_STRING = "***SensitiveInformation***";


/***/ }),

/***/ 56929:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createAggregatedClient = void 0;
const createAggregatedClient = (commands, Client) => {
    for (const command of Object.keys(commands)) {
        const CommandCtor = commands[command];
        const methodImpl = async function (args, optionsOrCb, cb) {
            const command = new CommandCtor(args);
            if (typeof optionsOrCb === "function") {
                this.send(command, optionsOrCb);
            }
            else if (typeof cb === "function") {
                if (typeof optionsOrCb !== "object")
                    throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
                this.send(command, optionsOrCb || {}, cb);
            }
            else {
                return this.send(command, optionsOrCb);
            }
        };
        const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
        Client.prototype[methodName] = methodImpl;
    }
};
exports.createAggregatedClient = createAggregatedClient;


/***/ }),

/***/ 21737:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseEpochTimestamp = exports.parseRfc7231DateTime = exports.parseRfc3339DateTimeWithOffset = exports.parseRfc3339DateTime = exports.dateToUtcString = void 0;
const parse_utils_1 = __nccwpck_require__(74857);
const DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
const MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
exports.dateToUtcString = dateToUtcString;
const RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
const parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = (0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
};
exports.parseRfc3339DateTime = parseRfc3339DateTime;
const RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
const parseRfc3339DateTimeWithOffset = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = (0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
        date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date;
};
exports.parseRfc3339DateTimeWithOffset = parseRfc3339DateTimeWithOffset;
const IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
const RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
const ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
const parseRfc7231DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return buildDate((0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = RFC_850_DATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds,
        }));
    }
    match = ASC_TIME.exec(value);
    if (match) {
        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
        return buildDate((0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
};
exports.parseRfc7231DateTime = parseRfc7231DateTime;
const parseEpochTimestamp = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    let valueAsDouble;
    if (typeof value === "number") {
        valueAsDouble = value;
    }
    else if (typeof value === "string") {
        valueAsDouble = (0, parse_utils_1.strictParseDouble)(value);
    }
    else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
};
exports.parseEpochTimestamp = parseEpochTimestamp;
const buildDate = (year, month, day, time) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
};
const parseTwoDigitYear = (value) => {
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + (0, parse_utils_1.strictParseShort)(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
    }
    return valueInThisCentury;
};
const FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;
const adjustRfc850Year = (input) => {
    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
};
const parseMonthByShortName = (value) => {
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
};
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const validateDayOfMonth = (year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
    }
    if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
};
const isLeapYear = (year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
const parseDateValue = (value, type, lower, upper) => {
    const dateVal = (0, parse_utils_1.strictParseByte)(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
};
const parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
        return 0;
    }
    return (0, parse_utils_1.strictParseFloat32)("0." + value) * 1000;
};
const parseOffsetToMilliseconds = (value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
        direction = 1;
    }
    else if (directionStr == "-") {
        direction = -1;
    }
    else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
};
const stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
    }
    if (idx === 0) {
        return value;
    }
    return value.slice(idx);
};


/***/ }),

/***/ 9681:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withBaseException = exports.throwDefaultError = void 0;
const exceptions_1 = __nccwpck_require__(88074);
const throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
        name: (parsedBody === null || parsedBody === void 0 ? void 0 : parsedBody.code) || (parsedBody === null || parsedBody === void 0 ? void 0 : parsedBody.Code) || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata,
    });
    throw (0, exceptions_1.decorateServiceException)(response, parsedBody);
};
exports.throwDefaultError = throwDefaultError;
const withBaseException = (ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
        (0, exports.throwDefaultError)({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
};
exports.withBaseException = withBaseException;
const deserializeMetadata = (output) => {
    var _a, _b;
    return ({
        httpStatusCode: output.statusCode,
        requestId: (_b = (_a = output.headers["x-amzn-requestid"]) !== null && _a !== void 0 ? _a : output.headers["x-amzn-request-id"]) !== null && _b !== void 0 ? _b : output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"],
    });
};


/***/ }),

/***/ 11163:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadConfigsForDefaultMode = void 0;
const loadConfigsForDefaultMode = (mode) => {
    switch (mode) {
        case "standard":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "in-region":
            return {
                retryMode: "standard",
                connectionTimeout: 1100,
            };
        case "cross-region":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "mobile":
            return {
                retryMode: "standard",
                connectionTimeout: 30000,
            };
        default:
            return {};
    }
};
exports.loadConfigsForDefaultMode = loadConfigsForDefaultMode;


/***/ }),

/***/ 91809:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.emitWarningIfUnsupportedVersion = void 0;
let warningEmitted = false;
const emitWarningIfUnsupportedVersion = (version) => {
    if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 14) {
        warningEmitted = true;
    }
};
exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion;


/***/ }),

/***/ 88074:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decorateServiceException = exports.ServiceException = void 0;
class ServiceException extends Error {
    constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, ServiceException.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
    }
}
exports.ServiceException = ServiceException;
const decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions)
        .filter(([, v]) => v !== undefined)
        .forEach(([k, v]) => {
        if (exception[k] == undefined || exception[k] === "") {
            exception[k] = v;
        }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
};
exports.decorateServiceException = decorateServiceException;


/***/ }),

/***/ 76016:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extendedEncodeURIComponent = void 0;
function extendedEncodeURIComponent(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
}
exports.extendedEncodeURIComponent = extendedEncodeURIComponent;


/***/ }),

/***/ 30941:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveChecksumRuntimeConfig = exports.getChecksumConfiguration = exports.AlgorithmId = void 0;
const types_1 = __nccwpck_require__(55756);
Object.defineProperty(exports, "AlgorithmId", ({ enumerable: true, get: function () { return types_1.AlgorithmId; } }));
const getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in types_1.AlgorithmId) {
        const algorithmId = types_1.AlgorithmId[id];
        if (runtimeConfig[algorithmId] === undefined) {
            continue;
        }
        checksumAlgorithms.push({
            algorithmId: () => algorithmId,
            checksumConstructor: () => runtimeConfig[algorithmId],
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
exports.getChecksumConfiguration = getChecksumConfiguration;
const resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};
exports.resolveChecksumRuntimeConfig = resolveChecksumRuntimeConfig;


/***/ }),

/***/ 78643:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveDefaultRuntimeConfig = exports.getDefaultClientConfiguration = exports.getDefaultExtensionConfiguration = void 0;
const checksum_1 = __nccwpck_require__(30941);
const retry_1 = __nccwpck_require__(67367);
const getDefaultExtensionConfiguration = (runtimeConfig) => {
    return {
        ...(0, checksum_1.getChecksumConfiguration)(runtimeConfig),
        ...(0, retry_1.getRetryConfiguration)(runtimeConfig),
    };
};
exports.getDefaultExtensionConfiguration = getDefaultExtensionConfiguration;
exports.getDefaultClientConfiguration = exports.getDefaultExtensionConfiguration;
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...(0, checksum_1.resolveChecksumRuntimeConfig)(config),
        ...(0, retry_1.resolveRetryRuntimeConfig)(config),
    };
};
exports.resolveDefaultRuntimeConfig = resolveDefaultRuntimeConfig;


/***/ }),

/***/ 1822:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(78643), exports);


/***/ }),

/***/ 67367:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveRetryRuntimeConfig = exports.getRetryConfiguration = void 0;
const getRetryConfiguration = (runtimeConfig) => {
    let _retryStrategy = runtimeConfig.retryStrategy;
    return {
        setRetryStrategy(retryStrategy) {
            _retryStrategy = retryStrategy;
        },
        retryStrategy() {
            return _retryStrategy;
        },
    };
};
exports.getRetryConfiguration = getRetryConfiguration;
const resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
    const runtimeConfig = {};
    runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
    return runtimeConfig;
};
exports.resolveRetryRuntimeConfig = resolveRetryRuntimeConfig;


/***/ }),

/***/ 42638:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getArrayIfSingleItem = void 0;
const getArrayIfSingleItem = (mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray];
exports.getArrayIfSingleItem = getArrayIfSingleItem;


/***/ }),

/***/ 92188:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getValueFromTextNode = void 0;
const getValueFromTextNode = (obj) => {
    const textNodeName = "#text";
    for (const key in obj) {
        if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== undefined) {
            obj[key] = obj[key][textNodeName];
        }
        else if (typeof obj[key] === "object" && obj[key] !== null) {
            obj[key] = (0, exports.getValueFromTextNode)(obj[key]);
        }
    }
    return obj;
};
exports.getValueFromTextNode = getValueFromTextNode;


/***/ }),

/***/ 63570:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(70438), exports);
tslib_1.__exportStar(__nccwpck_require__(61600), exports);
tslib_1.__exportStar(__nccwpck_require__(32813), exports);
tslib_1.__exportStar(__nccwpck_require__(75414), exports);
tslib_1.__exportStar(__nccwpck_require__(92541), exports);
tslib_1.__exportStar(__nccwpck_require__(56929), exports);
tslib_1.__exportStar(__nccwpck_require__(21737), exports);
tslib_1.__exportStar(__nccwpck_require__(9681), exports);
tslib_1.__exportStar(__nccwpck_require__(11163), exports);
tslib_1.__exportStar(__nccwpck_require__(91809), exports);
tslib_1.__exportStar(__nccwpck_require__(1822), exports);
tslib_1.__exportStar(__nccwpck_require__(88074), exports);
tslib_1.__exportStar(__nccwpck_require__(76016), exports);
tslib_1.__exportStar(__nccwpck_require__(42638), exports);
tslib_1.__exportStar(__nccwpck_require__(92188), exports);
tslib_1.__exportStar(__nccwpck_require__(32964), exports);
tslib_1.__exportStar(__nccwpck_require__(83495), exports);
tslib_1.__exportStar(__nccwpck_require__(74857), exports);
tslib_1.__exportStar(__nccwpck_require__(15342), exports);
tslib_1.__exportStar(__nccwpck_require__(59796), exports);
tslib_1.__exportStar(__nccwpck_require__(1752), exports);
tslib_1.__exportStar(__nccwpck_require__(92480), exports);


/***/ }),

/***/ 32964:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LazyJsonString = exports.StringWrapper = void 0;
const StringWrapper = function () {
    const Class = Object.getPrototypeOf(this).constructor;
    const Constructor = Function.bind.apply(String, [null, ...arguments]);
    const instance = new Constructor();
    Object.setPrototypeOf(instance, Class.prototype);
    return instance;
};
exports.StringWrapper = StringWrapper;
exports.StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
        value: exports.StringWrapper,
        enumerable: false,
        writable: true,
        configurable: true,
    },
});
Object.setPrototypeOf(exports.StringWrapper, String);
class LazyJsonString extends exports.StringWrapper {
    deserializeJSON() {
        return JSON.parse(super.toString());
    }
    toJSON() {
        return super.toString();
    }
    static fromObject(object) {
        if (object instanceof LazyJsonString) {
            return object;
        }
        else if (object instanceof String || typeof object === "string") {
            return new LazyJsonString(object);
        }
        return new LazyJsonString(JSON.stringify(object));
    }
}
exports.LazyJsonString = LazyJsonString;


/***/ }),

/***/ 83495:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.take = exports.convertMap = exports.map = void 0;
function map(arg0, arg1, arg2) {
    let target;
    let filter;
    let instructions;
    if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
        target = {};
        instructions = arg0;
    }
    else {
        target = arg0;
        if (typeof arg1 === "function") {
            filter = arg1;
            instructions = arg2;
            return mapWithFilter(target, filter, instructions);
        }
        else {
            instructions = arg1;
        }
    }
    for (const key of Object.keys(instructions)) {
        if (!Array.isArray(instructions[key])) {
            target[key] = instructions[key];
            continue;
        }
        applyInstruction(target, null, instructions, key);
    }
    return target;
}
exports.map = map;
const convertMap = (target) => {
    const output = {};
    for (const [k, v] of Object.entries(target || {})) {
        output[k] = [, v];
    }
    return output;
};
exports.convertMap = convertMap;
const take = (source, instructions) => {
    const out = {};
    for (const key in instructions) {
        applyInstruction(out, source, instructions, key);
    }
    return out;
};
exports.take = take;
const mapWithFilter = (target, filter, instructions) => {
    return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
        if (Array.isArray(value)) {
            _instructions[key] = value;
        }
        else {
            if (typeof value === "function") {
                _instructions[key] = [filter, value()];
            }
            else {
                _instructions[key] = [filter, value];
            }
        }
        return _instructions;
    }, {}));
};
const applyInstruction = (target, source, instructions, targetKey) => {
    if (source !== null) {
        let instruction = instructions[targetKey];
        if (typeof instruction === "function") {
            instruction = [, instruction];
        }
        const [filter = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
        if ((typeof filter === "function" && filter(source[sourceKey])) || (typeof filter !== "function" && !!filter)) {
            target[targetKey] = valueFn(source[sourceKey]);
        }
        return;
    }
    let [filter, value] = instructions[targetKey];
    if (typeof value === "function") {
        let _value;
        const defaultFilterPassed = filter === undefined && (_value = value()) != null;
        const customFilterPassed = (typeof filter === "function" && !!filter(void 0)) || (typeof filter !== "function" && !!filter);
        if (defaultFilterPassed) {
            target[targetKey] = _value;
        }
        else if (customFilterPassed) {
            target[targetKey] = value();
        }
    }
    else {
        const defaultFilterPassed = filter === undefined && value != null;
        const customFilterPassed = (typeof filter === "function" && !!filter(value)) || (typeof filter !== "function" && !!filter);
        if (defaultFilterPassed || customFilterPassed) {
            target[targetKey] = value;
        }
    }
};
const nonNullish = (_) => _ != null;
const pass = (_) => _;


/***/ }),

/***/ 74857:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.logger = exports.strictParseByte = exports.strictParseShort = exports.strictParseInt32 = exports.strictParseInt = exports.strictParseLong = exports.limitedParseFloat32 = exports.limitedParseFloat = exports.handleFloat = exports.limitedParseDouble = exports.strictParseFloat32 = exports.strictParseFloat = exports.strictParseDouble = exports.expectUnion = exports.expectString = exports.expectObject = exports.expectNonNull = exports.expectByte = exports.expectShort = exports.expectInt32 = exports.expectInt = exports.expectLong = exports.expectFloat32 = exports.expectNumber = exports.expectBoolean = exports.parseBoolean = void 0;
const parseBoolean = (value) => {
    switch (value) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error(`Unable to parse boolean value "${value}"`);
    }
};
exports.parseBoolean = parseBoolean;
const expectBoolean = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "number") {
        if (value === 0 || value === 1) {
            exports.logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (value === 0) {
            return false;
        }
        if (value === 1) {
            return true;
        }
    }
    if (typeof value === "string") {
        const lower = value.toLowerCase();
        if (lower === "false" || lower === "true") {
            exports.logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (lower === "false") {
            return false;
        }
        if (lower === "true") {
            return true;
        }
    }
    if (typeof value === "boolean") {
        return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
};
exports.expectBoolean = expectBoolean;
const expectNumber = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
            if (String(parsed) !== String(value)) {
                exports.logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
            }
            return parsed;
        }
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
exports.expectNumber = expectNumber;
const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
const expectFloat32 = (value) => {
    const expected = (0, exports.expectNumber)(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
    }
    return expected;
};
exports.expectFloat32 = expectFloat32;
const expectLong = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
exports.expectLong = expectLong;
exports.expectInt = exports.expectLong;
const expectInt32 = (value) => expectSizedInt(value, 32);
exports.expectInt32 = expectInt32;
const expectShort = (value) => expectSizedInt(value, 16);
exports.expectShort = expectShort;
const expectByte = (value) => expectSizedInt(value, 8);
exports.expectByte = expectByte;
const expectSizedInt = (value, size) => {
    const expected = (0, exports.expectLong)(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
};
const castInt = (value, size) => {
    switch (size) {
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
const expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
exports.expectNonNull = expectNonNull;
const expectObject = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
exports.expectObject = expectObject;
const expectString = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
        exports.logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
exports.expectString = expectString;
const expectUnion = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    const asObject = (0, exports.expectObject)(value);
    const setKeys = Object.entries(asObject)
        .filter(([, v]) => v != null)
        .map(([k]) => k);
    if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
};
exports.expectUnion = expectUnion;
const strictParseDouble = (value) => {
    if (typeof value == "string") {
        return (0, exports.expectNumber)(parseNumber(value));
    }
    return (0, exports.expectNumber)(value);
};
exports.strictParseDouble = strictParseDouble;
exports.strictParseFloat = exports.strictParseDouble;
const strictParseFloat32 = (value) => {
    if (typeof value == "string") {
        return (0, exports.expectFloat32)(parseNumber(value));
    }
    return (0, exports.expectFloat32)(value);
};
exports.strictParseFloat32 = strictParseFloat32;
const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
const parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
};
const limitedParseDouble = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return (0, exports.expectNumber)(value);
};
exports.limitedParseDouble = limitedParseDouble;
exports.handleFloat = exports.limitedParseDouble;
exports.limitedParseFloat = exports.limitedParseDouble;
const limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return (0, exports.expectFloat32)(value);
};
exports.limitedParseFloat32 = limitedParseFloat32;
const parseFloatString = (value) => {
    switch (value) {
        case "NaN":
            return NaN;
        case "Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            throw new Error(`Unable to parse float value: ${value}`);
    }
};
const strictParseLong = (value) => {
    if (typeof value === "string") {
        return (0, exports.expectLong)(parseNumber(value));
    }
    return (0, exports.expectLong)(value);
};
exports.strictParseLong = strictParseLong;
exports.strictParseInt = exports.strictParseLong;
const strictParseInt32 = (value) => {
    if (typeof value === "string") {
        return (0, exports.expectInt32)(parseNumber(value));
    }
    return (0, exports.expectInt32)(value);
};
exports.strictParseInt32 = strictParseInt32;
const strictParseShort = (value) => {
    if (typeof value === "string") {
        return (0, exports.expectShort)(parseNumber(value));
    }
    return (0, exports.expectShort)(value);
};
exports.strictParseShort = strictParseShort;
const strictParseByte = (value) => {
    if (typeof value === "string") {
        return (0, exports.expectByte)(parseNumber(value));
    }
    return (0, exports.expectByte)(value);
};
exports.strictParseByte = strictParseByte;
const stackTraceWarning = (message) => {
    return String(new TypeError(message).stack || message)
        .split("\n")
        .slice(0, 5)
        .filter((s) => !s.includes("stackTraceWarning"))
        .join("\n");
};
exports.logger = {
    warn: console.warn,
};


/***/ }),

/***/ 15342:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolvedPath = void 0;
const extended_encode_uri_component_1 = __nccwpck_require__(76016);
const resolvedPath = (resolvedPath, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
    if (input != null && input[memberName] !== undefined) {
        const labelValue = labelValueProvider();
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
        }
        resolvedPath = resolvedPath.replace(uriLabel, isGreedyLabel
            ? labelValue
                .split("/")
                .map((segment) => (0, extended_encode_uri_component_1.extendedEncodeURIComponent)(segment))
                .join("/")
            : (0, extended_encode_uri_component_1.extendedEncodeURIComponent)(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: " + memberName + ".");
    }
    return resolvedPath;
};
exports.resolvedPath = resolvedPath;


/***/ }),

/***/ 59796:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeFloat = void 0;
const serializeFloat = (value) => {
    if (value !== value) {
        return "NaN";
    }
    switch (value) {
        case Infinity:
            return "Infinity";
        case -Infinity:
            return "-Infinity";
        default:
            return value;
    }
};
exports.serializeFloat = serializeFloat;


/***/ }),

/***/ 1752:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._json = void 0;
const _json = (obj) => {
    if (obj == null) {
        return {};
    }
    if (Array.isArray(obj)) {
        return obj.filter((_) => _ != null).map(exports._json);
    }
    if (typeof obj === "object") {
        const target = {};
        for (const key of Object.keys(obj)) {
            if (obj[key] == null) {
                continue;
            }
            target[key] = (0, exports._json)(obj[key]);
        }
        return target;
    }
    return obj;
};
exports._json = _json;


/***/ }),

/***/ 92480:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.splitEvery = void 0;
function splitEvery(value, delimiter, numDelimiters) {
    if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {
        throw new Error("Invalid number of delimiters (" + numDelimiters + ") for splitEvery.");
    }
    const segments = value.split(delimiter);
    if (numDelimiters === 1) {
        return segments;
    }
    const compoundSegments = [];
    let currentSegment = "";
    for (let i = 0; i < segments.length; i++) {
        if (currentSegment === "") {
            currentSegment = segments[i];
        }
        else {
            currentSegment += delimiter + segments[i];
        }
        if ((i + 1) % numDelimiters === 0) {
            compoundSegments.push(currentSegment);
            currentSegment = "";
        }
    }
    if (currentSegment !== "") {
        compoundSegments.push(currentSegment);
    }
    return compoundSegments;
}
exports.splitEvery = splitEvery;


/***/ }),

/***/ 74075:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 93242:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpApiKeyAuthLocation = void 0;
var HttpApiKeyAuthLocation;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(HttpApiKeyAuthLocation = exports.HttpApiKeyAuthLocation || (exports.HttpApiKeyAuthLocation = {}));


/***/ }),

/***/ 81851:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 91530:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 74020:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 52263:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 79467:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpAuthLocation = void 0;
var HttpAuthLocation;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation = exports.HttpAuthLocation || (exports.HttpAuthLocation = {}));


/***/ }),

/***/ 11239:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(79467), exports);
tslib_1.__exportStar(__nccwpck_require__(93242), exports);
tslib_1.__exportStar(__nccwpck_require__(81851), exports);
tslib_1.__exportStar(__nccwpck_require__(91530), exports);
tslib_1.__exportStar(__nccwpck_require__(74020), exports);
tslib_1.__exportStar(__nccwpck_require__(52263), exports);


/***/ }),

/***/ 63274:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 78340:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 4744:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 68270:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 39580:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 57628:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(39580), exports);
tslib_1.__exportStar(__nccwpck_require__(98398), exports);
tslib_1.__exportStar(__nccwpck_require__(76522), exports);


/***/ }),

/***/ 98398:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 76522:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 89035:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 7225:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 54126:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndpointURLScheme = void 0;
var EndpointURLScheme;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme = exports.EndpointURLScheme || (exports.EndpointURLScheme = {}));


/***/ }),

/***/ 55612:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 43084:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 89843:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 63799:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 21550:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(55612), exports);
tslib_1.__exportStar(__nccwpck_require__(43084), exports);
tslib_1.__exportStar(__nccwpck_require__(89843), exports);
tslib_1.__exportStar(__nccwpck_require__(57658), exports);
tslib_1.__exportStar(__nccwpck_require__(63799), exports);


/***/ }),

/***/ 57658:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 88508:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 8947:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveChecksumRuntimeConfig = exports.getChecksumConfiguration = exports.AlgorithmId = void 0;
var AlgorithmId;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId = exports.AlgorithmId || (exports.AlgorithmId = {}));
const getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm(algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return this._checksumAlgorithms;
        },
    };
};
exports.getChecksumConfiguration = getChecksumConfiguration;
const resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};
exports.resolveChecksumRuntimeConfig = resolveChecksumRuntimeConfig;


/***/ }),

/***/ 89169:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveDefaultRuntimeConfig = exports.getDefaultClientConfiguration = void 0;
const checksum_1 = __nccwpck_require__(8947);
const getDefaultClientConfiguration = (runtimeConfig) => {
    return {
        ...(0, checksum_1.getChecksumConfiguration)(runtimeConfig),
    };
};
exports.getDefaultClientConfiguration = getDefaultClientConfiguration;
const resolveDefaultRuntimeConfig = (config) => {
    return {
        ...(0, checksum_1.resolveChecksumRuntimeConfig)(config),
    };
};
exports.resolveDefaultRuntimeConfig = resolveDefaultRuntimeConfig;


/***/ }),

/***/ 32245:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 47447:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlgorithmId = void 0;
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(89169), exports);
tslib_1.__exportStar(__nccwpck_require__(32245), exports);
var checksum_1 = __nccwpck_require__(8947);
Object.defineProperty(exports, "AlgorithmId", ({ enumerable: true, get: function () { return checksum_1.AlgorithmId; } }));


/***/ }),

/***/ 18883:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldPosition = void 0;
var FieldPosition;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(FieldPosition = exports.FieldPosition || (exports.FieldPosition = {}));


/***/ }),

/***/ 12842:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 197:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 7545:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 49123:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 28006:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(197), exports);
tslib_1.__exportStar(__nccwpck_require__(7545), exports);
tslib_1.__exportStar(__nccwpck_require__(49123), exports);
tslib_1.__exportStar(__nccwpck_require__(84476), exports);


/***/ }),

/***/ 84476:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 55756:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(74075), exports);
tslib_1.__exportStar(__nccwpck_require__(11239), exports);
tslib_1.__exportStar(__nccwpck_require__(63274), exports);
tslib_1.__exportStar(__nccwpck_require__(78340), exports);
tslib_1.__exportStar(__nccwpck_require__(4744), exports);
tslib_1.__exportStar(__nccwpck_require__(68270), exports);
tslib_1.__exportStar(__nccwpck_require__(57628), exports);
tslib_1.__exportStar(__nccwpck_require__(89035), exports);
tslib_1.__exportStar(__nccwpck_require__(7225), exports);
tslib_1.__exportStar(__nccwpck_require__(54126), exports);
tslib_1.__exportStar(__nccwpck_require__(21550), exports);
tslib_1.__exportStar(__nccwpck_require__(88508), exports);
tslib_1.__exportStar(__nccwpck_require__(47447), exports);
tslib_1.__exportStar(__nccwpck_require__(18883), exports);
tslib_1.__exportStar(__nccwpck_require__(12842), exports);
tslib_1.__exportStar(__nccwpck_require__(28006), exports);
tslib_1.__exportStar(__nccwpck_require__(52866), exports);
tslib_1.__exportStar(__nccwpck_require__(17756), exports);
tslib_1.__exportStar(__nccwpck_require__(45489), exports);
tslib_1.__exportStar(__nccwpck_require__(26524), exports);
tslib_1.__exportStar(__nccwpck_require__(14603), exports);
tslib_1.__exportStar(__nccwpck_require__(83752), exports);
tslib_1.__exportStar(__nccwpck_require__(30774), exports);
tslib_1.__exportStar(__nccwpck_require__(14089), exports);
tslib_1.__exportStar(__nccwpck_require__(45678), exports);
tslib_1.__exportStar(__nccwpck_require__(69926), exports);
tslib_1.__exportStar(__nccwpck_require__(9945), exports);
tslib_1.__exportStar(__nccwpck_require__(28564), exports);
tslib_1.__exportStar(__nccwpck_require__(61285), exports);
tslib_1.__exportStar(__nccwpck_require__(50364), exports);
tslib_1.__exportStar(__nccwpck_require__(69304), exports);
tslib_1.__exportStar(__nccwpck_require__(46098), exports);
tslib_1.__exportStar(__nccwpck_require__(10375), exports);
tslib_1.__exportStar(__nccwpck_require__(66894), exports);
tslib_1.__exportStar(__nccwpck_require__(57887), exports);
tslib_1.__exportStar(__nccwpck_require__(66255), exports);


/***/ }),

/***/ 52866:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 17756:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SMITHY_CONTEXT_KEY = void 0;
exports.SMITHY_CONTEXT_KEY = "__smithy_context";


/***/ }),

/***/ 45489:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 26524:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IniSectionType = void 0;
var IniSectionType;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(IniSectionType = exports.IniSectionType || (exports.IniSectionType = {}));


/***/ }),

/***/ 14603:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 83752:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 30774:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 14089:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 45678:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 69926:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 9945:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 28564:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 61285:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 50364:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestHandlerProtocol = void 0;
var RequestHandlerProtocol;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol = exports.RequestHandlerProtocol || (exports.RequestHandlerProtocol = {}));


/***/ }),

/***/ 69304:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 46098:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 10375:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 66894:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 57887:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 66255:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 14681:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseUrl = void 0;
const querystring_parser_1 = __nccwpck_require__(4769);
const parseUrl = (url) => {
    if (typeof url === "string") {
        return (0, exports.parseUrl)(new URL(url));
    }
    const { hostname, pathname, port, protocol, search } = url;
    let query;
    if (search) {
        query = (0, querystring_parser_1.parseQueryString)(search);
    }
    return {
        hostname,
        port: port ? parseInt(port) : undefined,
        protocol,
        path: pathname,
        query,
    };
};
exports.parseUrl = parseUrl;


/***/ }),

/***/ 30305:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromBase64 = void 0;
const util_buffer_from_1 = __nccwpck_require__(31381);
const BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
const fromBase64 = (input) => {
    if ((input.length * 3) % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = (0, util_buffer_from_1.fromString)(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};
exports.fromBase64 = fromBase64;


/***/ }),

/***/ 75600:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(30305), exports);
tslib_1.__exportStar(__nccwpck_require__(74730), exports);


/***/ }),

/***/ 74730:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toBase64 = void 0;
const util_buffer_from_1 = __nccwpck_require__(31381);
const toBase64 = (input) => (0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("base64");
exports.toBase64 = toBase64;


/***/ }),

/***/ 54880:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.calculateBodyLength = void 0;
const fs_1 = __nccwpck_require__(57147);
const calculateBodyLength = (body) => {
    if (!body) {
        return 0;
    }
    if (typeof body === "string") {
        return Buffer.from(body).length;
    }
    else if (typeof body.byteLength === "number") {
        return body.byteLength;
    }
    else if (typeof body.size === "number") {
        return body.size;
    }
    else if (typeof body.start === "number" && typeof body.end === "number") {
        return body.end + 1 - body.start;
    }
    else if (typeof body.path === "string" || Buffer.isBuffer(body.path)) {
        return (0, fs_1.lstatSync)(body.path).size;
    }
    else if (typeof body.fd === "number") {
        return (0, fs_1.fstatSync)(body.fd).size;
    }
    throw new Error(`Body Length computation failed for ${body}`);
};
exports.calculateBodyLength = calculateBodyLength;


/***/ }),

/***/ 68075:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(54880), exports);


/***/ }),

/***/ 31381:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromString = exports.fromArrayBuffer = void 0;
const is_array_buffer_1 = __nccwpck_require__(10780);
const buffer_1 = __nccwpck_require__(14300);
const fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
    if (!(0, is_array_buffer_1.isArrayBuffer)(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return buffer_1.Buffer.from(input, offset, length);
};
exports.fromArrayBuffer = fromArrayBuffer;
const fromString = (input, encoding) => {
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? buffer_1.Buffer.from(input, encoding) : buffer_1.Buffer.from(input);
};
exports.fromString = fromString;


/***/ }),

/***/ 42491:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.booleanSelector = void 0;
const booleanSelector = (obj, key, type) => {
    if (!(key in obj))
        return undefined;
    if (obj[key] === "true")
        return true;
    if (obj[key] === "false")
        return false;
    throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
};
exports.booleanSelector = booleanSelector;


/***/ }),

/***/ 83375:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(42491), exports);
tslib_1.__exportStar(__nccwpck_require__(94962), exports);
tslib_1.__exportStar(__nccwpck_require__(818), exports);


/***/ }),

/***/ 94962:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.numberSelector = void 0;
const numberSelector = (obj, key, type) => {
    if (!(key in obj))
        return undefined;
    const numberValue = parseInt(obj[key], 10);
    if (Number.isNaN(numberValue)) {
        throw new TypeError(`Cannot load ${type} '${key}'. Expected number, got '${obj[key]}'.`);
    }
    return numberValue;
};
exports.numberSelector = numberSelector;


/***/ }),

/***/ 818:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectorType = void 0;
var SelectorType;
(function (SelectorType) {
    SelectorType["ENV"] = "env";
    SelectorType["CONFIG"] = "shared config entry";
})(SelectorType = exports.SelectorType || (exports.SelectorType = {}));


/***/ }),

/***/ 56470:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IMDS_REGION_PATH = exports.DEFAULTS_MODE_OPTIONS = exports.ENV_IMDS_DISABLED = exports.AWS_DEFAULT_REGION_ENV = exports.AWS_REGION_ENV = exports.AWS_EXECUTION_ENV = void 0;
exports.AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
exports.AWS_REGION_ENV = "AWS_REGION";
exports.AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
exports.ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
exports.DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
exports.IMDS_REGION_PATH = "/latest/meta-data/placement/region";


/***/ }),

/***/ 15577:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NODE_DEFAULTS_MODE_CONFIG_OPTIONS = void 0;
const AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE";
const AWS_DEFAULTS_MODE_CONFIG = "defaults_mode";
exports.NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => {
        return env[AWS_DEFAULTS_MODE_ENV];
    },
    configFileSelector: (profile) => {
        return profile[AWS_DEFAULTS_MODE_CONFIG];
    },
    default: "legacy",
};


/***/ }),

/***/ 72429:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(46217), exports);


/***/ }),

/***/ 46217:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveDefaultsModeConfig = void 0;
const config_resolver_1 = __nccwpck_require__(53098);
const credential_provider_imds_1 = __nccwpck_require__(7477);
const node_config_provider_1 = __nccwpck_require__(33461);
const property_provider_1 = __nccwpck_require__(79721);
const constants_1 = __nccwpck_require__(56470);
const defaultsModeConfig_1 = __nccwpck_require__(15577);
const resolveDefaultsModeConfig = ({ region = (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS), defaultsMode = (0, node_config_provider_1.loadConfig)(defaultsModeConfig_1.NODE_DEFAULTS_MODE_CONFIG_OPTIONS), } = {}) => (0, property_provider_1.memoize)(async () => {
    const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
    switch (mode === null || mode === void 0 ? void 0 : mode.toLowerCase()) {
        case "auto":
            return resolveNodeDefaultsModeAuto(region);
        case "in-region":
        case "cross-region":
        case "mobile":
        case "standard":
        case "legacy":
            return Promise.resolve(mode === null || mode === void 0 ? void 0 : mode.toLocaleLowerCase());
        case undefined:
            return Promise.resolve("legacy");
        default:
            throw new Error(`Invalid parameter for "defaultsMode", expect ${constants_1.DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
    }
});
exports.resolveDefaultsModeConfig = resolveDefaultsModeConfig;
const resolveNodeDefaultsModeAuto = async (clientRegion) => {
    if (clientRegion) {
        const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
        const inferredRegion = await inferPhysicalRegion();
        if (!inferredRegion) {
            return "standard";
        }
        if (resolvedRegion === inferredRegion) {
            return "in-region";
        }
        else {
            return "cross-region";
        }
    }
    return "standard";
};
const inferPhysicalRegion = async () => {
    var _a;
    if (process.env[constants_1.AWS_EXECUTION_ENV] && (process.env[constants_1.AWS_REGION_ENV] || process.env[constants_1.AWS_DEFAULT_REGION_ENV])) {
        return (_a = process.env[constants_1.AWS_REGION_ENV]) !== null && _a !== void 0 ? _a : process.env[constants_1.AWS_DEFAULT_REGION_ENV];
    }
    if (!process.env[constants_1.ENV_IMDS_DISABLED]) {
        try {
            const endpoint = await (0, credential_provider_imds_1.getInstanceMetadataEndpoint)();
            return (await (0, credential_provider_imds_1.httpRequest)({ ...endpoint, path: constants_1.IMDS_REGION_PATH })).toString();
        }
        catch (e) {
        }
    }
};


/***/ }),

/***/ 71280:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.debugId = void 0;
exports.debugId = "endpoints";


/***/ }),

/***/ 30540:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(71280), exports);
tslib_1.__exportStar(__nccwpck_require__(48927), exports);


/***/ }),

/***/ 48927:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toDebugString = void 0;
function toDebugString(input) {
    if (typeof input !== "object" || input == null) {
        return input;
    }
    if ("ref" in input) {
        return `$${toDebugString(input.ref)}`;
    }
    if ("fn" in input) {
        return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
    }
    return JSON.stringify(input, null, 2);
}
exports.toDebugString = toDebugString;


/***/ }),

/***/ 45473:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(55402), exports);
tslib_1.__exportStar(__nccwpck_require__(55021), exports);
tslib_1.__exportStar(__nccwpck_require__(38824), exports);
tslib_1.__exportStar(__nccwpck_require__(78693), exports);
tslib_1.__exportStar(__nccwpck_require__(75442), exports);


/***/ }),

/***/ 29132:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.booleanEquals = void 0;
const booleanEquals = (value1, value2) => value1 === value2;
exports.booleanEquals = booleanEquals;


/***/ }),

/***/ 84624:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAttr = void 0;
const types_1 = __nccwpck_require__(75442);
const getAttrPathList_1 = __nccwpck_require__(91311);
const getAttr = (value, path) => (0, getAttrPathList_1.getAttrPathList)(path).reduce((acc, index) => {
    if (typeof acc !== "object") {
        throw new types_1.EndpointError(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
    }
    else if (Array.isArray(acc)) {
        return acc[parseInt(index)];
    }
    return acc[index];
}, value);
exports.getAttr = getAttr;


/***/ }),

/***/ 91311:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAttrPathList = void 0;
const types_1 = __nccwpck_require__(75442);
const getAttrPathList = (path) => {
    const parts = path.split(".");
    const pathList = [];
    for (const part of parts) {
        const squareBracketIndex = part.indexOf("[");
        if (squareBracketIndex !== -1) {
            if (part.indexOf("]") !== part.length - 1) {
                throw new types_1.EndpointError(`Path: '${path}' does not end with ']'`);
            }
            const arrayIndex = part.slice(squareBracketIndex + 1, -1);
            if (Number.isNaN(parseInt(arrayIndex))) {
                throw new types_1.EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
            }
            if (squareBracketIndex !== 0) {
                pathList.push(part.slice(0, squareBracketIndex));
            }
            pathList.push(arrayIndex);
        }
        else {
            pathList.push(part);
        }
    }
    return pathList;
};
exports.getAttrPathList = getAttrPathList;


/***/ }),

/***/ 36559:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(29132), exports);
tslib_1.__exportStar(__nccwpck_require__(84624), exports);
tslib_1.__exportStar(__nccwpck_require__(71231), exports);
tslib_1.__exportStar(__nccwpck_require__(55021), exports);
tslib_1.__exportStar(__nccwpck_require__(42249), exports);
tslib_1.__exportStar(__nccwpck_require__(84654), exports);
tslib_1.__exportStar(__nccwpck_require__(72512), exports);
tslib_1.__exportStar(__nccwpck_require__(49245), exports);
tslib_1.__exportStar(__nccwpck_require__(51482), exports);


/***/ }),

/***/ 55402:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isIpAddress = void 0;
const IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
const isIpAddress = (value) => IP_V4_REGEX.test(value) || (value.startsWith("[") && value.endsWith("]"));
exports.isIpAddress = isIpAddress;


/***/ }),

/***/ 71231:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSet = void 0;
const isSet = (value) => value != null;
exports.isSet = isSet;


/***/ }),

/***/ 55021:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isValidHostLabel = void 0;
const VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
const isValidHostLabel = (value, allowSubDomains = false) => {
    if (!allowSubDomains) {
        return VALID_HOST_LABEL_REGEX.test(value);
    }
    const labels = value.split(".");
    for (const label of labels) {
        if (!(0, exports.isValidHostLabel)(label)) {
            return false;
        }
    }
    return true;
};
exports.isValidHostLabel = isValidHostLabel;


/***/ }),

/***/ 42249:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.not = void 0;
const not = (value) => !value;
exports.not = not;


/***/ }),

/***/ 84654:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseURL = void 0;
const types_1 = __nccwpck_require__(55756);
const isIpAddress_1 = __nccwpck_require__(55402);
const DEFAULT_PORTS = {
    [types_1.EndpointURLScheme.HTTP]: 80,
    [types_1.EndpointURLScheme.HTTPS]: 443,
};
const parseURL = (value) => {
    const whatwgURL = (() => {
        try {
            if (value instanceof URL) {
                return value;
            }
            if (typeof value === "object" && "hostname" in value) {
                const { hostname, port, protocol = "", path = "", query = {} } = value;
                const url = new URL(`${protocol}//${hostname}${port ? `:${port}` : ""}${path}`);
                url.search = Object.entries(query)
                    .map(([k, v]) => `${k}=${v}`)
                    .join("&");
                return url;
            }
            return new URL(value);
        }
        catch (error) {
            return null;
        }
    })();
    if (!whatwgURL) {
        console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
        return null;
    }
    const urlString = whatwgURL.href;
    const { host, hostname, pathname, protocol, search } = whatwgURL;
    if (search) {
        return null;
    }
    const scheme = protocol.slice(0, -1);
    if (!Object.values(types_1.EndpointURLScheme).includes(scheme)) {
        return null;
    }
    const isIp = (0, isIpAddress_1.isIpAddress)(hostname);
    const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) ||
        (typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`));
    const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
    return {
        scheme,
        authority,
        path: pathname,
        normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
        isIp,
    };
};
exports.parseURL = parseURL;


/***/ }),

/***/ 72512:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringEquals = void 0;
const stringEquals = (value1, value2) => value1 === value2;
exports.stringEquals = stringEquals;


/***/ }),

/***/ 49245:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.substring = void 0;
const substring = (input, start, stop, reverse) => {
    if (start >= stop || input.length < stop) {
        return null;
    }
    if (!reverse) {
        return input.substring(start, stop);
    }
    return input.substring(input.length - stop, input.length - start);
};
exports.substring = substring;


/***/ }),

/***/ 51482:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uriEncode = void 0;
const uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);
exports.uriEncode = uriEncode;


/***/ }),

/***/ 78693:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveEndpoint = void 0;
const debug_1 = __nccwpck_require__(30540);
const types_1 = __nccwpck_require__(75442);
const utils_1 = __nccwpck_require__(96871);
const resolveEndpoint = (ruleSetObject, options) => {
    var _a, _b, _c, _d, _e, _f;
    const { endpointParams, logger } = options;
    const { parameters, rules } = ruleSetObject;
    (_b = (_a = options.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, `${debug_1.debugId} Initial EndpointParams: ${(0, debug_1.toDebugString)(endpointParams)}`);
    const paramsWithDefault = Object.entries(parameters)
        .filter(([, v]) => v.default != null)
        .map(([k, v]) => [k, v.default]);
    if (paramsWithDefault.length > 0) {
        for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
            endpointParams[paramKey] = (_c = endpointParams[paramKey]) !== null && _c !== void 0 ? _c : paramDefaultValue;
        }
    }
    const requiredParams = Object.entries(parameters)
        .filter(([, v]) => v.required)
        .map(([k]) => k);
    for (const requiredParam of requiredParams) {
        if (endpointParams[requiredParam] == null) {
            throw new types_1.EndpointError(`Missing required parameter: '${requiredParam}'`);
        }
    }
    const endpoint = (0, utils_1.evaluateRules)(rules, { endpointParams, logger, referenceRecord: {} });
    if ((_d = options.endpointParams) === null || _d === void 0 ? void 0 : _d.Endpoint) {
        try {
            const givenEndpoint = new URL(options.endpointParams.Endpoint);
            const { protocol, port } = givenEndpoint;
            endpoint.url.protocol = protocol;
            endpoint.url.port = port;
        }
        catch (e) {
        }
    }
    (_f = (_e = options.logger) === null || _e === void 0 ? void 0 : _e.debug) === null || _f === void 0 ? void 0 : _f.call(_e, `${debug_1.debugId} Resolved endpoint: ${(0, debug_1.toDebugString)(endpoint)}`);
    return endpoint;
};
exports.resolveEndpoint = resolveEndpoint;


/***/ }),

/***/ 84213:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndpointError = void 0;
class EndpointError extends Error {
    constructor(message) {
        super(message);
        this.name = "EndpointError";
    }
}
exports.EndpointError = EndpointError;


/***/ }),

/***/ 34073:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 72533:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 63135:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 19136:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 28344:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 75442:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(84213), exports);
tslib_1.__exportStar(__nccwpck_require__(34073), exports);
tslib_1.__exportStar(__nccwpck_require__(72533), exports);
tslib_1.__exportStar(__nccwpck_require__(63135), exports);
tslib_1.__exportStar(__nccwpck_require__(19136), exports);
tslib_1.__exportStar(__nccwpck_require__(28344), exports);
tslib_1.__exportStar(__nccwpck_require__(42535), exports);


/***/ }),

/***/ 42535:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 66318:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.callFunction = void 0;
const customEndpointFunctions_1 = __nccwpck_require__(38824);
const endpointFunctions_1 = __nccwpck_require__(70953);
const evaluateExpression_1 = __nccwpck_require__(91692);
const callFunction = ({ fn, argv }, options) => {
    const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : (0, evaluateExpression_1.evaluateExpression)(arg, "arg", options));
    const fnSegments = fn.split(".");
    if (fnSegments[0] in customEndpointFunctions_1.customEndpointFunctions && fnSegments[1] != null) {
        return customEndpointFunctions_1.customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
    }
    return endpointFunctions_1.endpointFunctions[fn](...evaluatedArgs);
};
exports.callFunction = callFunction;


/***/ }),

/***/ 38824:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.customEndpointFunctions = void 0;
exports.customEndpointFunctions = {};


/***/ }),

/***/ 70953:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.endpointFunctions = void 0;
const lib_1 = __nccwpck_require__(36559);
exports.endpointFunctions = {
    booleanEquals: lib_1.booleanEquals,
    getAttr: lib_1.getAttr,
    isSet: lib_1.isSet,
    isValidHostLabel: lib_1.isValidHostLabel,
    not: lib_1.not,
    parseURL: lib_1.parseURL,
    stringEquals: lib_1.stringEquals,
    substring: lib_1.substring,
    uriEncode: lib_1.uriEncode,
};


/***/ }),

/***/ 42138:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateCondition = void 0;
const debug_1 = __nccwpck_require__(30540);
const types_1 = __nccwpck_require__(75442);
const callFunction_1 = __nccwpck_require__(66318);
const evaluateCondition = ({ assign, ...fnArgs }, options) => {
    var _a, _b;
    if (assign && assign in options.referenceRecord) {
        throw new types_1.EndpointError(`'${assign}' is already defined in Reference Record.`);
    }
    const value = (0, callFunction_1.callFunction)(fnArgs, options);
    (_b = (_a = options.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, debug_1.debugId, `evaluateCondition: ${(0, debug_1.toDebugString)(fnArgs)} = ${(0, debug_1.toDebugString)(value)}`);
    return {
        result: value === "" ? true : !!value,
        ...(assign != null && { toAssign: { name: assign, value } }),
    };
};
exports.evaluateCondition = evaluateCondition;


/***/ }),

/***/ 69584:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateConditions = void 0;
const debug_1 = __nccwpck_require__(30540);
const evaluateCondition_1 = __nccwpck_require__(42138);
const evaluateConditions = (conditions = [], options) => {
    var _a, _b;
    const conditionsReferenceRecord = {};
    for (const condition of conditions) {
        const { result, toAssign } = (0, evaluateCondition_1.evaluateCondition)(condition, {
            ...options,
            referenceRecord: {
                ...options.referenceRecord,
                ...conditionsReferenceRecord,
            },
        });
        if (!result) {
            return { result };
        }
        if (toAssign) {
            conditionsReferenceRecord[toAssign.name] = toAssign.value;
            (_b = (_a = options.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, debug_1.debugId, `assign: ${toAssign.name} := ${(0, debug_1.toDebugString)(toAssign.value)}`);
        }
    }
    return { result: true, referenceRecord: conditionsReferenceRecord };
};
exports.evaluateConditions = evaluateConditions;


/***/ }),

/***/ 14405:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateEndpointRule = void 0;
const debug_1 = __nccwpck_require__(30540);
const evaluateConditions_1 = __nccwpck_require__(69584);
const getEndpointHeaders_1 = __nccwpck_require__(57225);
const getEndpointProperties_1 = __nccwpck_require__(83067);
const getEndpointUrl_1 = __nccwpck_require__(25672);
const evaluateEndpointRule = (endpointRule, options) => {
    var _a, _b;
    const { conditions, endpoint } = endpointRule;
    const { result, referenceRecord } = (0, evaluateConditions_1.evaluateConditions)(conditions, options);
    if (!result) {
        return;
    }
    const endpointRuleOptions = {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord },
    };
    const { url, properties, headers } = endpoint;
    (_b = (_a = options.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, debug_1.debugId, `Resolving endpoint from template: ${(0, debug_1.toDebugString)(endpoint)}`);
    return {
        ...(headers != undefined && {
            headers: (0, getEndpointHeaders_1.getEndpointHeaders)(headers, endpointRuleOptions),
        }),
        ...(properties != undefined && {
            properties: (0, getEndpointProperties_1.getEndpointProperties)(properties, endpointRuleOptions),
        }),
        url: (0, getEndpointUrl_1.getEndpointUrl)(url, endpointRuleOptions),
    };
};
exports.evaluateEndpointRule = evaluateEndpointRule;


/***/ }),

/***/ 57563:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateErrorRule = void 0;
const types_1 = __nccwpck_require__(75442);
const evaluateConditions_1 = __nccwpck_require__(69584);
const evaluateExpression_1 = __nccwpck_require__(91692);
const evaluateErrorRule = (errorRule, options) => {
    const { conditions, error } = errorRule;
    const { result, referenceRecord } = (0, evaluateConditions_1.evaluateConditions)(conditions, options);
    if (!result) {
        return;
    }
    throw new types_1.EndpointError((0, evaluateExpression_1.evaluateExpression)(error, "Error", {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord },
    }));
};
exports.evaluateErrorRule = evaluateErrorRule;


/***/ }),

/***/ 91692:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateExpression = void 0;
const types_1 = __nccwpck_require__(75442);
const callFunction_1 = __nccwpck_require__(66318);
const evaluateTemplate_1 = __nccwpck_require__(21922);
const getReferenceValue_1 = __nccwpck_require__(17142);
const evaluateExpression = (obj, keyName, options) => {
    if (typeof obj === "string") {
        return (0, evaluateTemplate_1.evaluateTemplate)(obj, options);
    }
    else if (obj["fn"]) {
        return (0, callFunction_1.callFunction)(obj, options);
    }
    else if (obj["ref"]) {
        return (0, getReferenceValue_1.getReferenceValue)(obj, options);
    }
    throw new types_1.EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
};
exports.evaluateExpression = evaluateExpression;


/***/ }),

/***/ 48830:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateRules = void 0;
const types_1 = __nccwpck_require__(75442);
const evaluateEndpointRule_1 = __nccwpck_require__(14405);
const evaluateErrorRule_1 = __nccwpck_require__(57563);
const evaluateTreeRule_1 = __nccwpck_require__(55085);
const evaluateRules = (rules, options) => {
    for (const rule of rules) {
        if (rule.type === "endpoint") {
            const endpointOrUndefined = (0, evaluateEndpointRule_1.evaluateEndpointRule)(rule, options);
            if (endpointOrUndefined) {
                return endpointOrUndefined;
            }
        }
        else if (rule.type === "error") {
            (0, evaluateErrorRule_1.evaluateErrorRule)(rule, options);
        }
        else if (rule.type === "tree") {
            const endpointOrUndefined = (0, evaluateTreeRule_1.evaluateTreeRule)(rule, options);
            if (endpointOrUndefined) {
                return endpointOrUndefined;
            }
        }
        else {
            throw new types_1.EndpointError(`Unknown endpoint rule: ${rule}`);
        }
    }
    throw new types_1.EndpointError(`Rules evaluation failed`);
};
exports.evaluateRules = evaluateRules;


/***/ }),

/***/ 21922:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateTemplate = void 0;
const lib_1 = __nccwpck_require__(36559);
const evaluateTemplate = (template, options) => {
    const evaluatedTemplateArr = [];
    const templateContext = {
        ...options.endpointParams,
        ...options.referenceRecord,
    };
    let currentIndex = 0;
    while (currentIndex < template.length) {
        const openingBraceIndex = template.indexOf("{", currentIndex);
        if (openingBraceIndex === -1) {
            evaluatedTemplateArr.push(template.slice(currentIndex));
            break;
        }
        evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
        const closingBraceIndex = template.indexOf("}", openingBraceIndex);
        if (closingBraceIndex === -1) {
            evaluatedTemplateArr.push(template.slice(openingBraceIndex));
            break;
        }
        if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
            evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
            currentIndex = closingBraceIndex + 2;
        }
        const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
        if (parameterName.includes("#")) {
            const [refName, attrName] = parameterName.split("#");
            evaluatedTemplateArr.push((0, lib_1.getAttr)(templateContext[refName], attrName));
        }
        else {
            evaluatedTemplateArr.push(templateContext[parameterName]);
        }
        currentIndex = closingBraceIndex + 1;
    }
    return evaluatedTemplateArr.join("");
};
exports.evaluateTemplate = evaluateTemplate;


/***/ }),

/***/ 55085:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.evaluateTreeRule = void 0;
const evaluateConditions_1 = __nccwpck_require__(69584);
const evaluateRules_1 = __nccwpck_require__(48830);
const evaluateTreeRule = (treeRule, options) => {
    const { conditions, rules } = treeRule;
    const { result, referenceRecord } = (0, evaluateConditions_1.evaluateConditions)(conditions, options);
    if (!result) {
        return;
    }
    return (0, evaluateRules_1.evaluateRules)(rules, {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord },
    });
};
exports.evaluateTreeRule = evaluateTreeRule;


/***/ }),

/***/ 57225:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointHeaders = void 0;
const types_1 = __nccwpck_require__(75442);
const evaluateExpression_1 = __nccwpck_require__(91692);
const getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
    ...acc,
    [headerKey]: headerVal.map((headerValEntry) => {
        const processedExpr = (0, evaluateExpression_1.evaluateExpression)(headerValEntry, "Header value entry", options);
        if (typeof processedExpr !== "string") {
            throw new types_1.EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
        }
        return processedExpr;
    }),
}), {});
exports.getEndpointHeaders = getEndpointHeaders;


/***/ }),

/***/ 83067:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointProperties = void 0;
const getEndpointProperty_1 = __nccwpck_require__(26152);
const getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
    ...acc,
    [propertyKey]: (0, getEndpointProperty_1.getEndpointProperty)(propertyVal, options),
}), {});
exports.getEndpointProperties = getEndpointProperties;


/***/ }),

/***/ 26152:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointProperty = void 0;
const types_1 = __nccwpck_require__(75442);
const evaluateTemplate_1 = __nccwpck_require__(21922);
const getEndpointProperties_1 = __nccwpck_require__(83067);
const getEndpointProperty = (property, options) => {
    if (Array.isArray(property)) {
        return property.map((propertyEntry) => (0, exports.getEndpointProperty)(propertyEntry, options));
    }
    switch (typeof property) {
        case "string":
            return (0, evaluateTemplate_1.evaluateTemplate)(property, options);
        case "object":
            if (property === null) {
                throw new types_1.EndpointError(`Unexpected endpoint property: ${property}`);
            }
            return (0, getEndpointProperties_1.getEndpointProperties)(property, options);
        case "boolean":
            return property;
        default:
            throw new types_1.EndpointError(`Unexpected endpoint property type: ${typeof property}`);
    }
};
exports.getEndpointProperty = getEndpointProperty;


/***/ }),

/***/ 25672:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointUrl = void 0;
const types_1 = __nccwpck_require__(75442);
const evaluateExpression_1 = __nccwpck_require__(91692);
const getEndpointUrl = (endpointUrl, options) => {
    const expression = (0, evaluateExpression_1.evaluateExpression)(endpointUrl, "Endpoint URL", options);
    if (typeof expression === "string") {
        try {
            return new URL(expression);
        }
        catch (error) {
            console.error(`Failed to construct URL with ${expression}`, error);
            throw error;
        }
    }
    throw new types_1.EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
};
exports.getEndpointUrl = getEndpointUrl;


/***/ }),

/***/ 17142:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getReferenceValue = void 0;
const getReferenceValue = ({ ref }, options) => {
    const referenceRecord = {
        ...options.endpointParams,
        ...options.referenceRecord,
    };
    return referenceRecord[ref];
};
exports.getReferenceValue = getReferenceValue;


/***/ }),

/***/ 96871:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(38824), exports);
tslib_1.__exportStar(__nccwpck_require__(48830), exports);


/***/ }),

/***/ 45364:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toHex = exports.fromHex = void 0;
const SHORT_TO_HEX = {};
const HEX_TO_SHORT = {};
for (let i = 0; i < 256; i++) {
    let encodedByte = i.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i;
}
function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i = 0; i < encoded.length; i += 2) {
        const encodedByte = encoded.slice(i, i + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
            out[i / 2] = HEX_TO_SHORT[encodedByte];
        }
        else {
            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
    }
    return out;
}
exports.fromHex = fromHex;
function toHex(bytes) {
    let out = "";
    for (let i = 0; i < bytes.byteLength; i++) {
        out += SHORT_TO_HEX[bytes[i]];
    }
    return out;
}
exports.toHex = toHex;


/***/ }),

/***/ 85730:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSmithyContext = void 0;
const types_1 = __nccwpck_require__(55756);
const getSmithyContext = (context) => context[types_1.SMITHY_CONTEXT_KEY] || (context[types_1.SMITHY_CONTEXT_KEY] = {});
exports.getSmithyContext = getSmithyContext;


/***/ }),

/***/ 2390:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(85730), exports);
tslib_1.__exportStar(__nccwpck_require__(80149), exports);


/***/ }),

/***/ 80149:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeProvider = void 0;
const normalizeProvider = (input) => {
    if (typeof input === "function")
        return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
};
exports.normalizeProvider = normalizeProvider;


/***/ }),

/***/ 65053:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdaptiveRetryStrategy = void 0;
const config_1 = __nccwpck_require__(93435);
const DefaultRateLimiter_1 = __nccwpck_require__(22234);
const StandardRetryStrategy_1 = __nccwpck_require__(48361);
class AdaptiveRetryStrategy {
    constructor(maxAttemptsProvider, options) {
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.mode = config_1.RETRY_MODES.ADAPTIVE;
        const { rateLimiter } = options !== null && options !== void 0 ? options : {};
        this.rateLimiter = rateLimiter !== null && rateLimiter !== void 0 ? rateLimiter : new DefaultRateLimiter_1.DefaultRateLimiter();
        this.standardRetryStrategy = new StandardRetryStrategy_1.StandardRetryStrategy(maxAttemptsProvider);
    }
    async acquireInitialRetryToken(retryTokenScope) {
        await this.rateLimiter.getSendToken();
        return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        this.rateLimiter.updateClientSendingRate(errorInfo);
        return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
    }
    recordSuccess(token) {
        this.rateLimiter.updateClientSendingRate({});
        this.standardRetryStrategy.recordSuccess(token);
    }
}
exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy;


/***/ }),

/***/ 25689:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfiguredRetryStrategy = void 0;
const constants_1 = __nccwpck_require__(66302);
const StandardRetryStrategy_1 = __nccwpck_require__(48361);
class ConfiguredRetryStrategy extends StandardRetryStrategy_1.StandardRetryStrategy {
    constructor(maxAttempts, computeNextBackoffDelay = constants_1.DEFAULT_RETRY_DELAY_BASE) {
        super(typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts);
        if (typeof computeNextBackoffDelay === "number") {
            this.computeNextBackoffDelay = () => computeNextBackoffDelay;
        }
        else {
            this.computeNextBackoffDelay = computeNextBackoffDelay;
        }
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        const token = await super.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
        token.getRetryDelay = () => this.computeNextBackoffDelay(token.getRetryCount());
        return token;
    }
}
exports.ConfiguredRetryStrategy = ConfiguredRetryStrategy;


/***/ }),

/***/ 22234:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultRateLimiter = void 0;
const service_error_classification_1 = __nccwpck_require__(6375);
class DefaultRateLimiter {
    constructor(options) {
        var _a, _b, _c, _d, _e;
        this.currentCapacity = 0;
        this.enabled = false;
        this.lastMaxRate = 0;
        this.measuredTxRate = 0;
        this.requestCount = 0;
        this.lastTimestamp = 0;
        this.timeWindow = 0;
        this.beta = (_a = options === null || options === void 0 ? void 0 : options.beta) !== null && _a !== void 0 ? _a : 0.7;
        this.minCapacity = (_b = options === null || options === void 0 ? void 0 : options.minCapacity) !== null && _b !== void 0 ? _b : 1;
        this.minFillRate = (_c = options === null || options === void 0 ? void 0 : options.minFillRate) !== null && _c !== void 0 ? _c : 0.5;
        this.scaleConstant = (_d = options === null || options === void 0 ? void 0 : options.scaleConstant) !== null && _d !== void 0 ? _d : 0.4;
        this.smooth = (_e = options === null || options === void 0 ? void 0 : options.smooth) !== null && _e !== void 0 ? _e : 0.8;
        const currentTimeInSeconds = this.getCurrentTimeInSeconds();
        this.lastThrottleTime = currentTimeInSeconds;
        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
        this.fillRate = this.minFillRate;
        this.maxCapacity = this.minCapacity;
    }
    getCurrentTimeInSeconds() {
        return Date.now() / 1000;
    }
    async getSendToken() {
        return this.acquireTokenBucket(1);
    }
    async acquireTokenBucket(amount) {
        if (!this.enabled) {
            return;
        }
        this.refillTokenBucket();
        if (amount > this.currentCapacity) {
            const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;
            await new Promise((resolve) => setTimeout(resolve, delay));
        }
        this.currentCapacity = this.currentCapacity - amount;
    }
    refillTokenBucket() {
        const timestamp = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
            this.lastTimestamp = timestamp;
            return;
        }
        const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
        this.lastTimestamp = timestamp;
    }
    updateClientSendingRate(response) {
        let calculatedRate;
        this.updateMeasuredRate();
        if ((0, service_error_classification_1.isThrottlingError)(response)) {
            const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
            this.lastMaxRate = rateToUse;
            this.calculateTimeWindow();
            this.lastThrottleTime = this.getCurrentTimeInSeconds();
            calculatedRate = this.cubicThrottle(rateToUse);
            this.enableTokenBucket();
        }
        else {
            this.calculateTimeWindow();
            calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
        }
        const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(newRate);
    }
    calculateTimeWindow() {
        this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));
    }
    cubicThrottle(rateToUse) {
        return this.getPrecise(rateToUse * this.beta);
    }
    cubicSuccess(timestamp) {
        return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
    }
    enableTokenBucket() {
        this.enabled = true;
    }
    updateTokenBucketRate(newRate) {
        this.refillTokenBucket();
        this.fillRate = Math.max(newRate, this.minFillRate);
        this.maxCapacity = Math.max(newRate, this.minCapacity);
        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
    }
    updateMeasuredRate() {
        const t = this.getCurrentTimeInSeconds();
        const timeBucket = Math.floor(t * 2) / 2;
        this.requestCount++;
        if (timeBucket > this.lastTxRateBucket) {
            const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
            this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
            this.requestCount = 0;
            this.lastTxRateBucket = timeBucket;
        }
    }
    getPrecise(num) {
        return parseFloat(num.toFixed(8));
    }
}
exports.DefaultRateLimiter = DefaultRateLimiter;


/***/ }),

/***/ 48361:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StandardRetryStrategy = void 0;
const config_1 = __nccwpck_require__(93435);
const constants_1 = __nccwpck_require__(66302);
const defaultRetryBackoffStrategy_1 = __nccwpck_require__(21337);
const defaultRetryToken_1 = __nccwpck_require__(1127);
class StandardRetryStrategy {
    constructor(maxAttempts) {
        this.maxAttempts = maxAttempts;
        this.mode = config_1.RETRY_MODES.STANDARD;
        this.capacity = constants_1.INITIAL_RETRY_TOKENS;
        this.retryBackoffStrategy = (0, defaultRetryBackoffStrategy_1.getDefaultRetryBackoffStrategy)();
        this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
    }
    async acquireInitialRetryToken(retryTokenScope) {
        return (0, defaultRetryToken_1.createDefaultRetryToken)({
            retryDelay: constants_1.DEFAULT_RETRY_DELAY_BASE,
            retryCount: 0,
        });
    }
    async refreshRetryTokenForRetry(token, errorInfo) {
        const maxAttempts = await this.getMaxAttempts();
        if (this.shouldRetry(token, errorInfo, maxAttempts)) {
            const errorType = errorInfo.errorType;
            this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? constants_1.THROTTLING_RETRY_DELAY_BASE : constants_1.DEFAULT_RETRY_DELAY_BASE);
            const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
            const retryDelay = errorInfo.retryAfterHint
                ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType)
                : delayFromErrorType;
            const capacityCost = this.getCapacityCost(errorType);
            this.capacity -= capacityCost;
            return (0, defaultRetryToken_1.createDefaultRetryToken)({
                retryDelay,
                retryCount: token.getRetryCount() + 1,
                retryCost: capacityCost,
            });
        }
        throw new Error("No retry token available");
    }
    recordSuccess(token) {
        var _a;
        this.capacity = Math.max(constants_1.INITIAL_RETRY_TOKENS, this.capacity + ((_a = token.getRetryCost()) !== null && _a !== void 0 ? _a : constants_1.NO_RETRY_INCREMENT));
    }
    getCapacity() {
        return this.capacity;
    }
    async getMaxAttempts() {
        try {
            return await this.maxAttemptsProvider();
        }
        catch (error) {
            console.warn(`Max attempts provider could not resolve. Using default of ${config_1.DEFAULT_MAX_ATTEMPTS}`);
            return config_1.DEFAULT_MAX_ATTEMPTS;
        }
    }
    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
        const attempts = tokenToRenew.getRetryCount() + 1;
        return (attempts < maxAttempts &&
            this.capacity >= this.getCapacityCost(errorInfo.errorType) &&
            this.isRetryableError(errorInfo.errorType));
    }
    getCapacityCost(errorType) {
        return errorType === "TRANSIENT" ? constants_1.TIMEOUT_RETRY_COST : constants_1.RETRY_COST;
    }
    isRetryableError(errorType) {
        return errorType === "THROTTLING" || errorType === "TRANSIENT";
    }
}
exports.StandardRetryStrategy = StandardRetryStrategy;


/***/ }),

/***/ 93435:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_RETRY_MODE = exports.DEFAULT_MAX_ATTEMPTS = exports.RETRY_MODES = void 0;
var RETRY_MODES;
(function (RETRY_MODES) {
    RETRY_MODES["STANDARD"] = "standard";
    RETRY_MODES["ADAPTIVE"] = "adaptive";
})(RETRY_MODES = exports.RETRY_MODES || (exports.RETRY_MODES = {}));
exports.DEFAULT_MAX_ATTEMPTS = 3;
exports.DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;


/***/ }),

/***/ 66302:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.REQUEST_HEADER = exports.INVOCATION_ID_HEADER = exports.NO_RETRY_INCREMENT = exports.TIMEOUT_RETRY_COST = exports.RETRY_COST = exports.INITIAL_RETRY_TOKENS = exports.THROTTLING_RETRY_DELAY_BASE = exports.MAXIMUM_RETRY_DELAY = exports.DEFAULT_RETRY_DELAY_BASE = void 0;
exports.DEFAULT_RETRY_DELAY_BASE = 100;
exports.MAXIMUM_RETRY_DELAY = 20 * 1000;
exports.THROTTLING_RETRY_DELAY_BASE = 500;
exports.INITIAL_RETRY_TOKENS = 500;
exports.RETRY_COST = 5;
exports.TIMEOUT_RETRY_COST = 10;
exports.NO_RETRY_INCREMENT = 1;
exports.INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
exports.REQUEST_HEADER = "amz-sdk-request";


/***/ }),

/***/ 21337:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDefaultRetryBackoffStrategy = void 0;
const constants_1 = __nccwpck_require__(66302);
const getDefaultRetryBackoffStrategy = () => {
    let delayBase = constants_1.DEFAULT_RETRY_DELAY_BASE;
    const computeNextBackoffDelay = (attempts) => {
        return Math.floor(Math.min(constants_1.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
    };
    const setDelayBase = (delay) => {
        delayBase = delay;
    };
    return {
        computeNextBackoffDelay,
        setDelayBase,
    };
};
exports.getDefaultRetryBackoffStrategy = getDefaultRetryBackoffStrategy;


/***/ }),

/***/ 1127:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDefaultRetryToken = void 0;
const constants_1 = __nccwpck_require__(66302);
const createDefaultRetryToken = ({ retryDelay, retryCount, retryCost, }) => {
    const getRetryCount = () => retryCount;
    const getRetryDelay = () => Math.min(constants_1.MAXIMUM_RETRY_DELAY, retryDelay);
    const getRetryCost = () => retryCost;
    return {
        getRetryCount,
        getRetryDelay,
        getRetryCost,
    };
};
exports.createDefaultRetryToken = createDefaultRetryToken;


/***/ }),

/***/ 84902:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(65053), exports);
tslib_1.__exportStar(__nccwpck_require__(25689), exports);
tslib_1.__exportStar(__nccwpck_require__(22234), exports);
tslib_1.__exportStar(__nccwpck_require__(48361), exports);
tslib_1.__exportStar(__nccwpck_require__(93435), exports);
tslib_1.__exportStar(__nccwpck_require__(66302), exports);
tslib_1.__exportStar(__nccwpck_require__(75427), exports);


/***/ }),

/***/ 75427:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 22094:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Uint8ArrayBlobAdapter = void 0;
const transforms_1 = __nccwpck_require__(82098);
class Uint8ArrayBlobAdapter extends Uint8Array {
    static fromString(source, encoding = "utf-8") {
        switch (typeof source) {
            case "string":
                return (0, transforms_1.transformFromString)(source, encoding);
            default:
                throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
        }
    }
    static mutate(source) {
        Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
        return source;
    }
    transformToString(encoding = "utf-8") {
        return (0, transforms_1.transformToString)(this, encoding);
    }
}
exports.Uint8ArrayBlobAdapter = Uint8ArrayBlobAdapter;


/***/ }),

/***/ 82098:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.transformFromString = exports.transformToString = void 0;
const util_base64_1 = __nccwpck_require__(75600);
const util_utf8_1 = __nccwpck_require__(41895);
const Uint8ArrayBlobAdapter_1 = __nccwpck_require__(22094);
function transformToString(payload, encoding = "utf-8") {
    if (encoding === "base64") {
        return (0, util_base64_1.toBase64)(payload);
    }
    return (0, util_utf8_1.toUtf8)(payload);
}
exports.transformToString = transformToString;
function transformFromString(str, encoding) {
    if (encoding === "base64") {
        return Uint8ArrayBlobAdapter_1.Uint8ArrayBlobAdapter.mutate((0, util_base64_1.fromBase64)(str));
    }
    return Uint8ArrayBlobAdapter_1.Uint8ArrayBlobAdapter.mutate((0, util_utf8_1.fromUtf8)(str));
}
exports.transformFromString = transformFromString;


/***/ }),

/***/ 23636:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAwsChunkedEncodingStream = void 0;
const stream_1 = __nccwpck_require__(12781);
const getAwsChunkedEncodingStream = (readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined &&
        checksumAlgorithmFn !== undefined &&
        checksumLocationName !== undefined &&
        streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const awsChunkedEncodingStream = new stream_1.Readable({ read: () => { } });
    readableStream.on("data", (data) => {
        const length = bodyLengthChecker(data) || 0;
        awsChunkedEncodingStream.push(`${length.toString(16)}\r\n`);
        awsChunkedEncodingStream.push(data);
        awsChunkedEncodingStream.push("\r\n");
    });
    readableStream.on("end", async () => {
        awsChunkedEncodingStream.push(`0\r\n`);
        if (checksumRequired) {
            const checksum = base64Encoder(await digest);
            awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r\n`);
            awsChunkedEncodingStream.push(`\r\n`);
        }
        awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
};
exports.getAwsChunkedEncodingStream = getAwsChunkedEncodingStream;


/***/ }),

/***/ 96607:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(22094), exports);
tslib_1.__exportStar(__nccwpck_require__(23636), exports);
tslib_1.__exportStar(__nccwpck_require__(4515), exports);


/***/ }),

/***/ 4515:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sdkStreamMixin = void 0;
const node_http_handler_1 = __nccwpck_require__(20258);
const util_buffer_from_1 = __nccwpck_require__(31381);
const stream_1 = __nccwpck_require__(12781);
const util_1 = __nccwpck_require__(73837);
const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdkStreamMixin = (stream) => {
    var _a, _b;
    if (!(stream instanceof stream_1.Readable)) {
        const name = ((_b = (_a = stream === null || stream === void 0 ? void 0 : stream.__proto__) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) || stream;
        throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await (0, node_http_handler_1.streamCollector)(stream);
    };
    return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === undefined || Buffer.isEncoding(encoding)) {
                return (0, util_buffer_from_1.fromArrayBuffer)(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
            }
            else {
                const decoder = new util_1.TextDecoder(encoding);
                return decoder.decode(buf);
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            if (stream.readableFlowing !== null) {
                throw new Error("The stream has been consumed by other callbacks.");
            }
            if (typeof stream_1.Readable.toWeb !== "function") {
                throw new Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");
            }
            transformed = true;
            return stream_1.Readable.toWeb(stream);
        },
    });
};
exports.sdkStreamMixin = sdkStreamMixin;


/***/ }),

/***/ 26174:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeUriPath = void 0;
const escape_uri_1 = __nccwpck_require__(60010);
const escapeUriPath = (uri) => uri.split("/").map(escape_uri_1.escapeUri).join("/");
exports.escapeUriPath = escapeUriPath;


/***/ }),

/***/ 60010:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeUri = void 0;
const escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
exports.escapeUri = escapeUri;
const hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;


/***/ }),

/***/ 54197:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(60010), exports);
tslib_1.__exportStar(__nccwpck_require__(26174), exports);


/***/ }),

/***/ 45917:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromUtf8 = void 0;
const util_buffer_from_1 = __nccwpck_require__(31381);
const fromUtf8 = (input) => {
    const buf = (0, util_buffer_from_1.fromString)(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};
exports.fromUtf8 = fromUtf8;


/***/ }),

/***/ 41895:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(45917), exports);
tslib_1.__exportStar(__nccwpck_require__(95470), exports);
tslib_1.__exportStar(__nccwpck_require__(99960), exports);


/***/ }),

/***/ 95470:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toUint8Array = void 0;
const fromUtf8_1 = __nccwpck_require__(45917);
const toUint8Array = (data) => {
    if (typeof data === "string") {
        return (0, fromUtf8_1.fromUtf8)(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
};
exports.toUint8Array = toUint8Array;


/***/ }),

/***/ 99960:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toUtf8 = void 0;
const util_buffer_from_1 = __nccwpck_require__(31381);
const toUtf8 = (input) => (0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
exports.toUtf8 = toUtf8;


/***/ }),

/***/ 76991:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createWaiter = void 0;
const poller_1 = __nccwpck_require__(39033);
const utils_1 = __nccwpck_require__(26000);
const waiter_1 = __nccwpck_require__(79089);
const abortTimeout = async (abortSignal) => {
    return new Promise((resolve) => {
        abortSignal.onabort = () => resolve({ state: waiter_1.WaiterState.ABORTED });
    });
};
const createWaiter = async (options, input, acceptorChecks) => {
    const params = {
        ...waiter_1.waiterServiceDefaults,
        ...options,
    };
    (0, utils_1.validateWaiterOptions)(params);
    const exitConditions = [(0, poller_1.runPolling)(params, input, acceptorChecks)];
    if (options.abortController) {
        exitConditions.push(abortTimeout(options.abortController.signal));
    }
    if (options.abortSignal) {
        exitConditions.push(abortTimeout(options.abortSignal));
    }
    return Promise.race(exitConditions);
};
exports.createWaiter = createWaiter;


/***/ }),

/***/ 78011:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(76991), exports);
tslib_1.__exportStar(__nccwpck_require__(79089), exports);


/***/ }),

/***/ 39033:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runPolling = void 0;
const sleep_1 = __nccwpck_require__(62380);
const waiter_1 = __nccwpck_require__(79089);
const exponentialBackoffWithJitter = (minDelay, maxDelay, attemptCeiling, attempt) => {
    if (attempt > attemptCeiling)
        return maxDelay;
    const delay = minDelay * 2 ** (attempt - 1);
    return randomInRange(minDelay, delay);
};
const randomInRange = (min, max) => min + Math.random() * (max - min);
const runPolling = async ({ minDelay, maxDelay, maxWaitTime, abortController, client, abortSignal }, input, acceptorChecks) => {
    var _a;
    const { state, reason } = await acceptorChecks(client, input);
    if (state !== waiter_1.WaiterState.RETRY) {
        return { state, reason };
    }
    let currentAttempt = 1;
    const waitUntil = Date.now() + maxWaitTime * 1000;
    const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;
    while (true) {
        if (((_a = abortController === null || abortController === void 0 ? void 0 : abortController.signal) === null || _a === void 0 ? void 0 : _a.aborted) || (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted)) {
            return { state: waiter_1.WaiterState.ABORTED };
        }
        const delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);
        if (Date.now() + delay * 1000 > waitUntil) {
            return { state: waiter_1.WaiterState.TIMEOUT };
        }
        await (0, sleep_1.sleep)(delay);
        const { state, reason } = await acceptorChecks(client, input);
        if (state !== waiter_1.WaiterState.RETRY) {
            return { state, reason };
        }
        currentAttempt += 1;
    }
};
exports.runPolling = runPolling;


/***/ }),

/***/ 26000:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __nccwpck_require__(4351);
tslib_1.__exportStar(__nccwpck_require__(62380), exports);
tslib_1.__exportStar(__nccwpck_require__(6594), exports);


/***/ }),

/***/ 62380:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sleep = void 0;
const sleep = (seconds) => {
    return new Promise((resolve) => setTimeout(resolve, seconds * 1000));
};
exports.sleep = sleep;


/***/ }),

/***/ 6594:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateWaiterOptions = void 0;
const validateWaiterOptions = (options) => {
    if (options.maxWaitTime < 1) {
        throw new Error(`WaiterConfiguration.maxWaitTime must be greater than 0`);
    }
    else if (options.minDelay < 1) {
        throw new Error(`WaiterConfiguration.minDelay must be greater than 0`);
    }
    else if (options.maxDelay < 1) {
        throw new Error(`WaiterConfiguration.maxDelay must be greater than 0`);
    }
    else if (options.maxWaitTime <= options.minDelay) {
        throw new Error(`WaiterConfiguration.maxWaitTime [${options.maxWaitTime}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);
    }
    else if (options.maxDelay < options.minDelay) {
        throw new Error(`WaiterConfiguration.maxDelay [${options.maxDelay}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);
    }
};
exports.validateWaiterOptions = validateWaiterOptions;


/***/ }),

/***/ 79089:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkExceptions = exports.WaiterState = exports.waiterServiceDefaults = void 0;
exports.waiterServiceDefaults = {
    minDelay: 2,
    maxDelay: 120,
};
var WaiterState;
(function (WaiterState) {
    WaiterState["ABORTED"] = "ABORTED";
    WaiterState["FAILURE"] = "FAILURE";
    WaiterState["SUCCESS"] = "SUCCESS";
    WaiterState["RETRY"] = "RETRY";
    WaiterState["TIMEOUT"] = "TIMEOUT";
})(WaiterState = exports.WaiterState || (exports.WaiterState = {}));
const checkExceptions = (result) => {
    if (result.state === WaiterState.ABORTED) {
        const abortError = new Error(`${JSON.stringify({
            ...result,
            reason: "Request was aborted",
        })}`);
        abortError.name = "AbortError";
        throw abortError;
    }
    else if (result.state === WaiterState.TIMEOUT) {
        const timeoutError = new Error(`${JSON.stringify({
            ...result,
            reason: "Waiter has timed out",
        })}`);
        timeoutError.name = "TimeoutError";
        throw timeoutError;
    }
    else if (result.state !== WaiterState.SUCCESS) {
        throw new Error(`${JSON.stringify({ result })}`);
    }
    return result;
};
exports.checkExceptions = checkExceptions;


/***/ }),

/***/ 9417:
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    if(a===b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ 33717:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var concatMap = __nccwpck_require__(86891);
var balanced = __nccwpck_require__(9417);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),

/***/ 86891:
/***/ ((module) => {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ 12603:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const validator = __nccwpck_require__(61739);
const XMLParser = __nccwpck_require__(42380);
const XMLBuilder = __nccwpck_require__(80660);

module.exports = {
  XMLParser: XMLParser,
  XMLValidator: validator,
  XMLBuilder: XMLBuilder
}

/***/ }),

/***/ 38280:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const nameStartChar = ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
const nameChar = nameStartChar + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'
const regexName = new RegExp('^' + nameRegexp + '$');

const getAllMatches = function(string, regex) {
  const matches = [];
  let match = regex.exec(string);
  while (match) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    const len = match.length;
    for (let index = 0; index < len; index++) {
      allmatches.push(match[index]);
    }
    matches.push(allmatches);
    match = regex.exec(string);
  }
  return matches;
};

const isName = function(string) {
  const match = regexName.exec(string);
  return !(match === null || typeof match === 'undefined');
};

exports.isExist = function(v) {
  return typeof v !== 'undefined';
};

exports.isEmptyObject = function(obj) {
  return Object.keys(obj).length === 0;
};

/**
 * Copy all the properties of a into b.
 * @param {*} target
 * @param {*} a
 */
exports.merge = function(target, a, arrayMode) {
  if (a) {
    const keys = Object.keys(a); // will return an array of own properties
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      if (arrayMode === 'strict') {
        target[keys[i]] = [ a[keys[i]] ];
      } else {
        target[keys[i]] = a[keys[i]];
      }
    }
  }
};
/* exports.merge =function (b,a){
  return Object.assign(b,a);
} */

exports.getValue = function(v) {
  if (exports.isExist(v)) {
    return v;
  } else {
    return '';
  }
};

// const fakeCall = function(a) {return a;};
// const fakeCallNoReturn = function() {};

exports.isName = isName;
exports.getAllMatches = getAllMatches;
exports.nameRegexp = nameRegexp;


/***/ }),

/***/ 61739:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const util = __nccwpck_require__(38280);

const defaultOptions = {
  allowBooleanAttributes: false, //A tag can have attributes without any value
  unpairedTags: []
};

//const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
exports.validate = function (xmlData, options) {
  options = Object.assign({}, defaultOptions, options);

  //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
  //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
  //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE
  const tags = [];
  let tagFound = false;

  //indicates that the root tag has been closed (aka. depth 0 has been reached)
  let reachedRoot = false;

  if (xmlData[0] === '\ufeff') {
    // check for byte order mark (BOM)
    xmlData = xmlData.substr(1);
  }
  
  for (let i = 0; i < xmlData.length; i++) {

    if (xmlData[i] === '<' && xmlData[i+1] === '?') {
      i+=2;
      i = readPI(xmlData,i);
      if (i.err) return i;
    }else if (xmlData[i] === '<') {
      //starting of tag
      //read until you reach to '>' avoiding any '>' in attribute value
      let tagStartPos = i;
      i++;
      
      if (xmlData[i] === '!') {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i] === '/') {
          //closing tag
          closingTag = true;
          i++;
        }
        //read tagname
        let tagName = '';
        for (; i < xmlData.length &&
          xmlData[i] !== '>' &&
          xmlData[i] !== ' ' &&
          xmlData[i] !== '\t' &&
          xmlData[i] !== '\n' &&
          xmlData[i] !== '\r'; i++
        ) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        //console.log(tagName);

        if (tagName[tagName.length - 1] === '/') {
          //self closing tag without attributes
          tagName = tagName.substring(0, tagName.length - 1);
          //continue;
          i--;
        }
        if (!validateTagName(tagName)) {
          let msg;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '"+tagName+"' is an invalid name.";
          }
          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));
        }

        const result = readAttributeStr(xmlData, i);
        if (result === false) {
          return getErrorObject('InvalidAttr', "Attributes for '"+tagName+"' have open quote.", getLineNumberForPosition(xmlData, i));
        }
        let attrStr = result.value;
        i = result.index;

        if (attrStr[attrStr.length - 1] === '/') {
          //self closing tag
          const attrStrStart = i - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid = validateAttributeString(attrStr, options);
          if (isValid === true) {
            tagFound = true;
            //continue; //text may presents after self closing tag
          } else {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
          }
        } else if (closingTag) {
          if (!result.tagClosed) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            const otg = tags.pop();
            if (tagName !== otg.tagName) {
              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject('InvalidTag',
                "Expected closing tag '"+otg.tagName+"' (opened in line "+openPos.line+", col "+openPos.col+") instead of closing tag '"+tagName+"'.",
                getLineNumberForPosition(xmlData, tagStartPos));
            }

            //when there are no more tags, we reached the root level.
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          const isValid = validateAttributeString(attrStr, options);
          if (isValid !== true) {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
          }

          //if the root level has been reached before ...
          if (reachedRoot === true) {
            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));
          } else if(options.unpairedTags.indexOf(tagName) !== -1){
            //don't push into stack
          } else {
            tags.push({tagName, tagStartPos});
          }
          tagFound = true;
        }

        //skip tag text value
        //It may include comments and CDATA value
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === '<') {
            if (xmlData[i + 1] === '!') {
              //comment or CADATA
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else if (xmlData[i+1] === '?') {
              i = readPI(xmlData, ++i);
              if (i.err) return i;
            } else{
              break;
            }
          } else if (xmlData[i] === '&') {
            const afterAmp = validateAmpersand(xmlData, i);
            if (afterAmp == -1)
              return getErrorObject('InvalidChar', "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
            i = afterAmp;
          }else{
            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
              return getErrorObject('InvalidXml', "Extra text at the end", getLineNumberForPosition(xmlData, i));
            }
          }
        } //end of reading tag text value
        if (xmlData[i] === '<') {
          i--;
        }
      }
    } else {
      if ( isWhiteSpace(xmlData[i])) {
        continue;
      }
      return getErrorObject('InvalidChar', "char '"+xmlData[i]+"' is not expected.", getLineNumberForPosition(xmlData, i));
    }
  }

  if (!tagFound) {
    return getErrorObject('InvalidXml', 'Start tag expected.', 1);
  }else if (tags.length == 1) {
      return getErrorObject('InvalidTag', "Unclosed tag '"+tags[0].tagName+"'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  }else if (tags.length > 0) {
      return getErrorObject('InvalidXml', "Invalid '"+
          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\r?\n/g, '')+
          "' found.", {line: 1, col: 1});
  }

  return true;
};

function isWhiteSpace(char){
  return char === ' ' || char === '\t' || char === '\n'  || char === '\r';
}
/**
 * Read Processing insstructions and skip
 * @param {*} xmlData
 * @param {*} i
 */
function readPI(xmlData, i) {
  const start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == '?' || xmlData[i] == ' ') {
      //tagname
      const tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === 'xml') {
        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));
      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
        //check if valid attribut string
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}

function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
    //comment
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  } else if (
    xmlData.length > i + 8 &&
    xmlData[i + 1] === 'D' &&
    xmlData[i + 2] === 'O' &&
    xmlData[i + 3] === 'C' &&
    xmlData[i + 4] === 'T' &&
    xmlData[i + 5] === 'Y' &&
    xmlData[i + 6] === 'P' &&
    xmlData[i + 7] === 'E'
  ) {
    let angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === '<') {
        angleBracketsCount++;
      } else if (xmlData[i] === '>') {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (
    xmlData.length > i + 9 &&
    xmlData[i + 1] === '[' &&
    xmlData[i + 2] === 'C' &&
    xmlData[i + 3] === 'D' &&
    xmlData[i + 4] === 'A' &&
    xmlData[i + 5] === 'T' &&
    xmlData[i + 6] === 'A' &&
    xmlData[i + 7] === '['
  ) {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  }

  return i;
}

const doubleQuote = '"';
const singleQuote = "'";

/**
 * Keep reading xmlData until '<' is found outside the attribute value.
 * @param {string} xmlData
 * @param {number} i
 */
function readAttributeStr(xmlData, i) {
  let attrStr = '';
  let startChar = '';
  let tagClosed = false;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === '') {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i]) {
        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa
      } else {
        startChar = '';
      }
    } else if (xmlData[i] === '>') {
      if (startChar === '') {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== '') {
    return false;
  }

  return {
    value: attrStr,
    index: i,
    tagClosed: tagClosed
  };
}

/**
 * Select all the attributes whether valid or invalid.
 */
const validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g');

//attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

function validateAttributeString(attrStr, options) {
  //console.log("start:"+attrStr+":end");

  //if(attrStr.trim().length === 0) return true; //empty string

  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};

  for (let i = 0; i < matches.length; i++) {
    if (matches[i][1].length === 0) {
      //nospace before attribute name: a="sd"b="saf"
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' has no space in starting.", getPositionFromMatch(matches[i]))
    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' is without value.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
      //independent attribute: ab
      return getErrorObject('InvalidAttr', "boolean attribute '"+matches[i][2]+"' is not allowed.", getPositionFromMatch(matches[i]));
    }
    /* else if(matches[i][6] === undefined){//attribute without value: ab=
                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
                } */
    const attrName = matches[i][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is an invalid name.", getPositionFromMatch(matches[i]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      //check for duplicate attribute.
      attrNames[attrName] = 1;
    } else {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is repeated.", getPositionFromMatch(matches[i]));
    }
  }

  return true;
}

function validateNumberAmpersand(xmlData, i) {
  let re = /\d/;
  if (xmlData[i] === 'x') {
    i++;
    re = /[\da-fA-F]/;
  }
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === ';')
      return i;
    if (!xmlData[i].match(re))
      break;
  }
  return -1;
}

function validateAmpersand(xmlData, i) {
  // https://www.w3.org/TR/xml/#dt-charref
  i++;
  if (xmlData[i] === ';')
    return -1;
  if (xmlData[i] === '#') {
    i++;
    return validateNumberAmpersand(xmlData, i);
  }
  let count = 0;
  for (; i < xmlData.length; i++, count++) {
    if (xmlData[i].match(/\w/) && count < 20)
      continue;
    if (xmlData[i] === ';')
      break;
    return -1;
  }
  return i;
}

function getErrorObject(code, message, lineNumber) {
  return {
    err: {
      code: code,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col,
    },
  };
}

function validateAttrName(attrName) {
  return util.isName(attrName);
}

// const startsWithXML = /^xml/i;

function validateTagName(tagname) {
  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;
}

//this function returns the line number for the character at the given index
function getLineNumberForPosition(xmlData, index) {
  const lines = xmlData.substring(0, index).split(/\r?\n/);
  return {
    line: lines.length,

    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}

//this function returns the position of the first character of match within attrStr
function getPositionFromMatch(match) {
  return match.startIndex + match[1].length;
}


/***/ }),

/***/ 80660:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

//parse Empty Node as self closing node
const buildFromOrderedJs = __nccwpck_require__(72462);

const defaultOptions = {
  attributeNamePrefix: '@_',
  attributesGroupName: false,
  textNodeName: '#text',
  ignoreAttributes: true,
  cdataPropName: false,
  format: false,
  indentBy: '  ',
  suppressEmptyNode: false,
  suppressUnpairedNode: true,
  suppressBooleanAttributes: true,
  tagValueProcessor: function(key, a) {
    return a;
  },
  attributeValueProcessor: function(attrName, a) {
    return a;
  },
  preserveOrder: false,
  commentPropName: false,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },//it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("\'", "g"), val: "&apos;" },
    { regex: new RegExp("\"", "g"), val: "&quot;" }
  ],
  processEntities: true,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: false
};

function Builder(options) {
  this.options = Object.assign({}, defaultOptions, options);
  if (this.options.ignoreAttributes || this.options.attributesGroupName) {
    this.isAttribute = function(/*a*/) {
      return false;
    };
  } else {
    this.attrPrefixLen = this.options.attributeNamePrefix.length;
    this.isAttribute = isAttribute;
  }

  this.processTextOrObjNode = processTextOrObjNode

  if (this.options.format) {
    this.indentate = indentate;
    this.tagEndChar = '>\n';
    this.newLine = '\n';
  } else {
    this.indentate = function() {
      return '';
    };
    this.tagEndChar = '>';
    this.newLine = '';
  }
}

Builder.prototype.build = function(jObj) {
  if(this.options.preserveOrder){
    return buildFromOrderedJs(jObj, this.options);
  }else {
    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){
      jObj = {
        [this.options.arrayNodeName] : jObj
      }
    }
    return this.j2x(jObj, 0).val;
  }
};

Builder.prototype.j2x = function(jObj, level) {
  let attrStr = '';
  let val = '';
  for (let key in jObj) {
    if (typeof jObj[key] === 'undefined') {
      // supress undefined node
    } else if (jObj[key] === null) {
      if(key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
      else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
    } else if (jObj[key] instanceof Date) {
      val += this.buildTextValNode(jObj[key], key, '', level);
    } else if (typeof jObj[key] !== 'object') {
      //premitive type
      const attr = this.isAttribute(key);
      if (attr) {
        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);
      }else {
        //tag value
        if (key === this.options.textNodeName) {
          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);
          val += this.replaceEntitiesValue(newval);
        } else {
          val += this.buildTextValNode(jObj[key], key, '', level);
        }
      }
    } else if (Array.isArray(jObj[key])) {
      //repeated nodes
      const arrLen = jObj[key].length;
      let listTagVal = "";
      for (let j = 0; j < arrLen; j++) {
        const item = jObj[key][j];
        if (typeof item === 'undefined') {
          // supress undefined node
        } else if (item === null) {
          if(key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
        } else if (typeof item === 'object') {
          if(this.options.oneListGroup ){
            listTagVal += this.j2x(item, level + 1).val;
          }else{
            listTagVal += this.processTextOrObjNode(item, key, level)
          }
        } else {
          listTagVal += this.buildTextValNode(item, key, '', level);
        }
      }
      if(this.options.oneListGroup){
        listTagVal = this.buildObjectNode(listTagVal, key, '', level);
      }
      val += listTagVal;
    } else {
      //nested node
      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
        const Ks = Object.keys(jObj[key]);
        const L = Ks.length;
        for (let j = 0; j < L; j++) {
          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);
        }
      } else {
        val += this.processTextOrObjNode(jObj[key], key, level)
      }
    }
  }
  return {attrStr: attrStr, val: val};
};

Builder.prototype.buildAttrPairStr = function(attrName, val){
  val = this.options.attributeValueProcessor(attrName, '' + val);
  val = this.replaceEntitiesValue(val);
  if (this.options.suppressBooleanAttributes && val === "true") {
    return ' ' + attrName;
  } else return ' ' + attrName + '="' + val + '"';
}

function processTextOrObjNode (object, key, level) {
  const result = this.j2x(object, level + 1);
  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
  } else {
    return this.buildObjectNode(result.val, key, result.attrStr, level);
  }
}

Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
  if(val === ""){
    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;
    else {
      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }
  }else{

    let tagEndExp = '</' + key + this.tagEndChar;
    let piClosingChar = "";
    
    if(key[0] === "?") {
      piClosingChar = "?";
      tagEndExp = "";
    }
  
    if (attrStr && val.indexOf('<') === -1) {
      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
      return this.indentate(level) + `<!--${val}-->` + this.newLine;
    }else {
      return (
        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +
        val +
        this.indentate(level) + tagEndExp    );
    }
  }
}

Builder.prototype.closeTag = function(key){
  let closeTag = "";
  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired
    if(!this.options.suppressUnpairedNode) closeTag = "/"
  }else if(this.options.suppressEmptyNode){ //empty
    closeTag = "/";
  }else{
    closeTag = `></${key}`
  }
  return closeTag;
}

function buildEmptyObjNode(val, key, attrStr, level) {
  if (val !== '') {
    return this.buildObjectNode(val, key, attrStr, level);
  } else {
    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;
    else {
      return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
      // return this.buildTagStr(level,key, attrStr);
    }
  }
}

Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;
  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
    return this.indentate(level) + `<!--${val}-->` +  this.newLine;
  }else if(key[0] === "?") {//PI tag
    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; 
  }else{
    let textValue = this.options.tagValueProcessor(key, val);
    textValue = this.replaceEntitiesValue(textValue);
  
    if( textValue === ''){
      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }else{
      return this.indentate(level) + '<' + key + attrStr + '>' +
         textValue +
        '</' + key + this.tagEndChar;
    }
  }
}

Builder.prototype.replaceEntitiesValue = function(textValue){
  if(textValue && textValue.length > 0 && this.options.processEntities){
    for (let i=0; i<this.options.entities.length; i++) {
      const entity = this.options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
}

function indentate(level) {
  return this.options.indentBy.repeat(level);
}

function isAttribute(name /*, options*/) {
  if (name.startsWith(this.options.attributeNamePrefix)) {
    return name.substr(this.attrPrefixLen);
  } else {
    return false;
  }
}

module.exports = Builder;


/***/ }),

/***/ 72462:
/***/ ((module) => {

const EOL = "\n";

/**
 * 
 * @param {array} jArray 
 * @param {any} options 
 * @returns 
 */
function toXml(jArray, options) {
    let indentation = "";
    if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
    }
    return arrToStr(jArray, options, "", indentation);
}

function arrToStr(arr, options, jPath, indentation) {
    let xmlStr = "";
    let isPreviousElementTag = false;

    for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i];
        const tagName = propName(tagObj);
        let newJPath = "";
        if (jPath.length === 0) newJPath = tagName
        else newJPath = `${jPath}.${tagName}`;

        if (tagName === options.textNodeName) {
            let tagText = tagObj[tagName];
            if (!isStopNode(newJPath, options)) {
                tagText = options.tagValueProcessor(tagName, tagText);
                tagText = replaceEntitiesValue(tagText, options);
            }
            if (isPreviousElementTag) {
                xmlStr += indentation;
            }
            xmlStr += tagText;
            isPreviousElementTag = false;
            continue;
        } else if (tagName === options.cdataPropName) {
            if (isPreviousElementTag) {
                xmlStr += indentation;
            }
            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
            isPreviousElementTag = false;
            continue;
        } else if (tagName === options.commentPropName) {
            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
            isPreviousElementTag = true;
            continue;
        } else if (tagName[0] === "?") {
            const attStr = attr_to_str(tagObj[":@"], options);
            const tempInd = tagName === "?xml" ? "" : indentation;
            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : ""; //remove extra spacing
            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;
            isPreviousElementTag = true;
            continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
            newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
            if (options.suppressUnpairedNode) xmlStr += tagStart + ">";
            else xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
            xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
            xmlStr += tagStart + ">";
            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
                xmlStr += indentation + options.indentBy + tagValue + indentation;
            } else {
                xmlStr += tagValue;
            }
            xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
    }

    return xmlStr;
}

function propName(obj) {
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key !== ":@") return key;
    }
}

function attr_to_str(attrMap, options) {
    let attrStr = "";
    if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
            attrVal = replaceEntitiesValue(attrVal, options);
            if (attrVal === true && options.suppressBooleanAttributes) {
                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
            } else {
                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
            }
        }
    }
    return attrStr;
}

function isStopNode(jPath, options) {
    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
    for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName) return true;
    }
    return false;
}

function replaceEntitiesValue(textValue, options) {
    if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i = 0; i < options.entities.length; i++) {
            const entity = options.entities[i];
            textValue = textValue.replace(entity.regex, entity.val);
        }
    }
    return textValue;
}
module.exports = toXml;


/***/ }),

/***/ 6072:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const util = __nccwpck_require__(38280);

//TODO: handle comments
function readDocType(xmlData, i){
    
    const entities = {};
    if( xmlData[i + 3] === 'O' &&
         xmlData[i + 4] === 'C' &&
         xmlData[i + 5] === 'T' &&
         xmlData[i + 6] === 'Y' &&
         xmlData[i + 7] === 'P' &&
         xmlData[i + 8] === 'E')
    {    
        i = i+9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp = "";
        for(;i<xmlData.length;i++){
            if (xmlData[i] === '<' && !comment) { //Determine the tag type
                if( hasBody && isEntity(xmlData, i)){
                    i += 7; 
                    [entityName, val,i] = readEntityExp(xmlData,i+1);
                    if(val.indexOf("&") === -1) //Parameter entities are not supported
                        entities[ validateEntityName(entityName) ] = {
                            regx : RegExp( `&${entityName};`,"g"),
                            val: val
                        };
                }
                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported
                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported
                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported
                else if( isComment)                         comment = true;
                else                                        throw new Error("Invalid DOCTYPE");

                angleBracketsCount++;
                exp = "";
            } else if (xmlData[i] === '>') { //Read tag content
                if(comment){
                    if( xmlData[i - 1] === "-" && xmlData[i - 2] === "-"){
                        comment = false;
                        angleBracketsCount--;
                    }
                }else{
                    angleBracketsCount--;
                }
                if (angleBracketsCount === 0) {
                  break;
                }
            }else if( xmlData[i] === '['){
                hasBody = true;
            }else{
                exp += xmlData[i];
            }
        }
        if(angleBracketsCount !== 0){
            throw new Error(`Unclosed DOCTYPE`);
        }
    }else{
        throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return {entities, i};
}

function readEntityExp(xmlData,i){
    //External entities are not supported
    //    <!ENTITY ext SYSTEM "http://normal-website.com" >

    //Parameter entities are not supported
    //    <!ENTITY entityname "&anotherElement;">

    //Internal entities are supported
    //    <!ENTITY entityname "replacement text">
    
    //read EntityName
    let entityName = "";
    for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"' ); i++) {
        // if(xmlData[i] === " ") continue;
        // else 
        entityName += xmlData[i];
    }
    entityName = entityName.trim();
    if(entityName.indexOf(" ") !== -1) throw new Error("External entites are not supported");

    //read Entity Value
    const startChar = xmlData[i++];
    let val = ""
    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {
        val += xmlData[i];
    }
    return [entityName, val, i];
}

function isComment(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === '-' &&
    xmlData[i+3] === '-') return true
    return false
}
function isEntity(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'E' &&
    xmlData[i+3] === 'N' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'I' &&
    xmlData[i+6] === 'T' &&
    xmlData[i+7] === 'Y') return true
    return false
}
function isElement(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'E' &&
    xmlData[i+3] === 'L' &&
    xmlData[i+4] === 'E' &&
    xmlData[i+5] === 'M' &&
    xmlData[i+6] === 'E' &&
    xmlData[i+7] === 'N' &&
    xmlData[i+8] === 'T') return true
    return false
}

function isAttlist(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'A' &&
    xmlData[i+3] === 'T' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'L' &&
    xmlData[i+6] === 'I' &&
    xmlData[i+7] === 'S' &&
    xmlData[i+8] === 'T') return true
    return false
}
function isNotation(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'N' &&
    xmlData[i+3] === 'O' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'A' &&
    xmlData[i+6] === 'T' &&
    xmlData[i+7] === 'I' &&
    xmlData[i+8] === 'O' &&
    xmlData[i+9] === 'N') return true
    return false
}

function validateEntityName(name){
    if (util.isName(name))
	return name;
    else
        throw new Error(`Invalid entity name ${name}`);
}

module.exports = readDocType;


/***/ }),

/***/ 86993:
/***/ ((__unused_webpack_module, exports) => {


const defaultOptions = {
    preserveOrder: false,
    attributeNamePrefix: '@_',
    attributesGroupName: false,
    textNodeName: '#text',
    ignoreAttributes: true,
    removeNSPrefix: false, // remove NS from tag name or attribute name if true
    allowBooleanAttributes: false, //a tag can have attributes without any value
    //ignoreRootElement : false,
    parseTagValue: true,
    parseAttributeValue: false,
    trimValues: true, //Trim string values of tag and attributes
    cdataPropName: false,
    numberParseOptions: {
      hex: true,
      leadingZeros: true,
      eNotation: true
    },
    tagValueProcessor: function(tagName, val) {
      return val;
    },
    attributeValueProcessor: function(attrName, val) {
      return val;
    },
    stopNodes: [], //nested tags will not be parsed even for errors
    alwaysCreateTextNode: false,
    isArray: () => false,
    commentPropName: false,
    unpairedTags: [],
    processEntities: true,
    htmlEntities: false,
    ignoreDeclaration: false,
    ignorePiTags: false,
    transformTagName: false,
    transformAttributeName: false,
    updateTag: function(tagName, jPath, attrs){
      return tagName
    },
    // skipEmptyListItem: false
};
   
const buildOptions = function(options) {
    return Object.assign({}, defaultOptions, options);
};

exports.buildOptions = buildOptions;
exports.defaultOptions = defaultOptions;

/***/ }),

/***/ 25832:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

///@ts-check

const util = __nccwpck_require__(38280);
const xmlNode = __nccwpck_require__(7462);
const readDocType = __nccwpck_require__(6072);
const toNumber = __nccwpck_require__(14526);

const regx =
  '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'
  .replace(/NAME/g, util.nameRegexp);

//const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
//const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");

class OrderedObjParser{
  constructor(options){
    this.options = options;
    this.currentNode = null;
    this.tagsNodeStack = [];
    this.docTypeEntities = {};
    this.lastEntities = {
      "apos" : { regex: /&(apos|#39|#x27);/g, val : "'"},
      "gt" : { regex: /&(gt|#62|#x3E);/g, val : ">"},
      "lt" : { regex: /&(lt|#60|#x3C);/g, val : "<"},
      "quot" : { regex: /&(quot|#34|#x22);/g, val : "\""},
    };
    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : "&"};
    this.htmlEntities = {
      "space": { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      "cent" : { regex: /&(cent|#162);/g, val: "¢" },
      "pound" : { regex: /&(pound|#163);/g, val: "£" },
      "yen" : { regex: /&(yen|#165);/g, val: "¥" },
      "euro" : { regex: /&(euro|#8364);/g, val: "€" },
      "copyright" : { regex: /&(copy|#169);/g, val: "©" },
      "reg" : { regex: /&(reg|#174);/g, val: "®" },
      "inr" : { regex: /&(inr|#8377);/g, val: "₹" },
    };
    this.addExternalEntities = addExternalEntities;
    this.parseXml = parseXml;
    this.parseTextData = parseTextData;
    this.resolveNameSpace = resolveNameSpace;
    this.buildAttributesMap = buildAttributesMap;
    this.isItStopNode = isItStopNode;
    this.replaceEntitiesValue = replaceEntitiesValue;
    this.readStopNodeData = readStopNodeData;
    this.saveTextToParentTag = saveTextToParentTag;
    this.addChild = addChild;
  }

}

function addExternalEntities(externalEntities){
  const entKeys = Object.keys(externalEntities);
  for (let i = 0; i < entKeys.length; i++) {
    const ent = entKeys[i];
    this.lastEntities[ent] = {
       regex: new RegExp("&"+ent+";","g"),
       val : externalEntities[ent]
    }
  }
}

/**
 * @param {string} val
 * @param {string} tagName
 * @param {string} jPath
 * @param {boolean} dontTrim
 * @param {boolean} hasAttributes
 * @param {boolean} isLeafNode
 * @param {boolean} escapeEntities
 */
function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
  if (val !== undefined) {
    if (this.options.trimValues && !dontTrim) {
      val = val.trim();
    }
    if(val.length > 0){
      if(!escapeEntities) val = this.replaceEntitiesValue(val);
      
      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
      if(newval === null || newval === undefined){
        //don't parse
        return val;
      }else if(typeof newval !== typeof val || newval !== val){
        //overwrite
        return newval;
      }else if(this.options.trimValues){
        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
      }else{
        const trimmedVal = val.trim();
        if(trimmedVal === val){
          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
        }else{
          return val;
        }
      }
    }
  }
}

function resolveNameSpace(tagname) {
  if (this.options.removeNSPrefix) {
    const tags = tagname.split(':');
    const prefix = tagname.charAt(0) === '/' ? '/' : '';
    if (tags[0] === 'xmlns') {
      return '';
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}

//TODO: change regex to capture NS
//const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', 'gm');

function buildAttributesMap(attrStr, jPath, tagName) {
  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {
    // attrStr = attrStr.replace(/\r?\n/g, ' ');
    //attrStr = attrStr || attrStr.trim();

    const matches = util.getAllMatches(attrStr, attrsRegx);
    const len = matches.length; //don't make it inline
    const attrs = {};
    for (let i = 0; i < len; i++) {
      const attrName = this.resolveNameSpace(matches[i][1]);
      let oldVal = matches[i][4];
      let aName = this.options.attributeNamePrefix + attrName;
      if (attrName.length) {
        if (this.options.transformAttributeName) {
          aName = this.options.transformAttributeName(aName);
        }
        if(aName === "__proto__") aName  = "#__proto__";
        if (oldVal !== undefined) {
          if (this.options.trimValues) {
            oldVal = oldVal.trim();
          }
          oldVal = this.replaceEntitiesValue(oldVal);
          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
          if(newVal === null || newVal === undefined){
            //don't parse
            attrs[aName] = oldVal;
          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){
            //overwrite
            attrs[aName] = newVal;
          }else{
            //parse
            attrs[aName] = parseValue(
              oldVal,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          }
        } else if (this.options.allowBooleanAttributes) {
          attrs[aName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (this.options.attributesGroupName) {
      const attrCollection = {};
      attrCollection[this.options.attributesGroupName] = attrs;
      return attrCollection;
    }
    return attrs
  }
}

const parseXml = function(xmlData) {
  xmlData = xmlData.replace(/\r\n?/g, "\n"); //TODO: remove this line
  const xmlObj = new xmlNode('!xml');
  let currentNode = xmlObj;
  let textData = "";
  let jPath = "";
  for(let i=0; i< xmlData.length; i++){//for each char in XML data
    const ch = xmlData[i];
    if(ch === '<'){
      // const nextIndex = i+1;
      // const _2ndChar = xmlData[nextIndex];
      if( xmlData[i+1] === '/') {//Closing Tag
        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.")
        let tagName = xmlData.substring(i+2,closeIndex).trim();

        if(this.options.removeNSPrefix){
          const colonIndex = tagName.indexOf(":");
          if(colonIndex !== -1){
            tagName = tagName.substr(colonIndex+1);
          }
        }

        if(this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }

        if(currentNode){
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
        }

        //check if last tag of nested tag was unpaired tag
        const lastTagName = jPath.substring(jPath.lastIndexOf(".")+1);
        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){
          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
        }
        let propIndex = 0
        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){
          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)
          this.tagsNodeStack.pop();
        }else{
          propIndex = jPath.lastIndexOf(".");
        }
        jPath = jPath.substring(0, propIndex);

        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope
        textData = "";
        i = closeIndex;
      } else if( xmlData[i+1] === '?') {

        let tagData = readTagExp(xmlData,i, false, "?>");
        if(!tagData) throw new Error("Pi Tag is not closed.");

        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        if( (this.options.ignoreDeclaration && tagData.tagName === "?xml") || this.options.ignorePiTags){

        }else{
  
          const childNode = new xmlNode(tagData.tagName);
          childNode.add(this.options.textNodeName, "");
          
          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){
            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
          }
          this.addChild(currentNode, childNode, jPath)

        }


        i = tagData.closeIndex + 1;
      } else if(xmlData.substr(i + 1, 3) === '!--') {
        const endIndex = findClosingIndex(xmlData, "-->", i+4, "Comment is not closed.")
        if(this.options.commentPropName){
          const comment = xmlData.substring(i + 4, endIndex - 2);

          textData = this.saveTextToParentTag(textData, currentNode, jPath);

          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);
        }
        i = endIndex;
      } else if( xmlData.substr(i + 1, 2) === '!D') {
        const result = readDocType(xmlData, i);
        this.docTypeEntities = result.entities;
        i = result.i;
      }else if(xmlData.substr(i + 1, 2) === '![') {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
        const tagExp = xmlData.substring(i + 9,closeIndex);

        textData = this.saveTextToParentTag(textData, currentNode, jPath);

        //cdata should be set even if it is 0 length string
        if(this.options.cdataPropName){
          // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + "." + this.options.cdataPropName, true, false, true);
          // if(!val) val = "";
          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);
        }else{
          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
          if(val == undefined) val = "";
          currentNode.add(this.options.textNodeName, val);
        }
        
        i = closeIndex + 2;
      }else {//Opening tag
        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);
        let tagName= result.tagName;
        let tagExp = result.tagExp;
        let attrExpPresent = result.attrExpPresent;
        let closeIndex = result.closeIndex;

        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        
        //save text as child node
        if (currentNode && textData) {
          if(currentNode.tagname !== '!xml'){
            //when nested tag is found
            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
          }
        }

        //check if last tag was unpaired tag
        const lastTag = currentNode;
        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){
          currentNode = this.tagsNodeStack.pop();
          jPath = jPath.substring(0, jPath.lastIndexOf("."));
        }
        if(tagName !== xmlObj.tagname){
          jPath += jPath ? "." + tagName : tagName;
        }
        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) { //TODO: namespace
          let tagContent = "";
          //self-closing tag
          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
            i = result.closeIndex;
          }
          //unpaired tag
          else if(this.options.unpairedTags.indexOf(tagName) !== -1){
            i = result.closeIndex;
          }
          //normal tag
          else{
            //read until closing tag is found
            const result = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
            if(!result) throw new Error(`Unexpected end of ${tagName}`);
            i = result.i;
            tagContent = result.tagContent;
          }

          const childNode = new xmlNode(tagName);
          if(tagName !== tagExp && attrExpPresent){
            childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
          }
          if(tagContent) {
            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
          }
          
          jPath = jPath.substr(0, jPath.lastIndexOf("."));
          childNode.add(this.options.textNodeName, tagContent);
          
          this.addChild(currentNode, childNode, jPath)
        }else{
  //selfClosing tag
          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
            if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
              tagName = tagName.substr(0, tagName.length - 1);
              tagExp = tagName;
            }else{
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            
            if(this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }

            const childNode = new xmlNode(tagName);
            if(tagName !== tagExp && attrExpPresent){
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath)
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
          }
    //opening tag
          else{
            const childNode = new xmlNode( tagName);
            this.tagsNodeStack.push(currentNode);
            
            if(tagName !== tagExp && attrExpPresent){
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath)
            currentNode = childNode;
          }
          textData = "";
          i = closeIndex;
        }
      }
    }else{
      textData += xmlData[i];
    }
  }
  return xmlObj.child;
}

function addChild(currentNode, childNode, jPath){
  const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"])
  if(result === false){
  }else if(typeof result === "string"){
    childNode.tagname = result
    currentNode.addChild(childNode);
  }else{
    currentNode.addChild(childNode);
  }
}

const replaceEntitiesValue = function(val){

  if(this.options.processEntities){
    for(let entityName in this.docTypeEntities){
      const entity = this.docTypeEntities[entityName];
      val = val.replace( entity.regx, entity.val);
    }
    for(let entityName in this.lastEntities){
      const entity = this.lastEntities[entityName];
      val = val.replace( entity.regex, entity.val);
    }
    if(this.options.htmlEntities){
      for(let entityName in this.htmlEntities){
        const entity = this.htmlEntities[entityName];
        val = val.replace( entity.regex, entity.val);
      }
    }
    val = val.replace( this.ampEntity.regex, this.ampEntity.val);
  }
  return val;
}
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
  if (textData) { //store previously collected data as textNode
    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0
    
    textData = this.parseTextData(textData,
      currentNode.tagname,
      jPath,
      false,
      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
      isLeafNode);

    if (textData !== undefined && textData !== "")
      currentNode.add(this.options.textNodeName, textData);
    textData = "";
  }
  return textData;
}

//TODO: use jPath to simplify the logic
/**
 * 
 * @param {string[]} stopNodes 
 * @param {string} jPath
 * @param {string} currentTagName 
 */
function isItStopNode(stopNodes, jPath, currentTagName){
  const allNodesExp = "*." + currentTagName;
  for (const stopNodePath in stopNodes) {
    const stopNodeExp = stopNodes[stopNodePath];
    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;
  }
  return false;
}

/**
 * Returns the tag Expression and where it is ending handling single-double quotes situation
 * @param {string} xmlData 
 * @param {number} i starting index
 * @returns 
 */
function tagExpWithClosingIndex(xmlData, i, closingChar = ">"){
  let attrBoundary;
  let tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) {
        if (ch === attrBoundary) attrBoundary = "";//reset
    } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
    } else if (ch === closingChar[0]) {
      if(closingChar[1]){
        if(xmlData[index + 1] === closingChar[1]){
          return {
            data: tagExp,
            index: index
          }
        }
      }else{
        return {
          data: tagExp,
          index: index
        }
      }
    } else if (ch === '\t') {
      ch = " "
    }
    tagExp += ch;
  }
}

function findClosingIndex(xmlData, str, i, errMsg){
  const closingIndex = xmlData.indexOf(str, i);
  if(closingIndex === -1){
    throw new Error(errMsg)
  }else{
    return closingIndex + str.length - 1;
  }
}

function readTagExp(xmlData,i, removeNSPrefix, closingChar = ">"){
  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);
  if(!result) return;
  let tagExp = result.data;
  const closeIndex = result.index;
  const separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp;
  let attrExpPresent = true;
  if(separatorIndex !== -1){//separate tag name and attributes expression
    tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, '');
    tagExp = tagExp.substr(separatorIndex + 1);
  }

  if(removeNSPrefix){
    const colonIndex = tagName.indexOf(":");
    if(colonIndex !== -1){
      tagName = tagName.substr(colonIndex+1);
      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
    }
  }

  return {
    tagName: tagName,
    tagExp: tagExp,
    closeIndex: closeIndex,
    attrExpPresent: attrExpPresent,
  }
}
/**
 * find paired tag for a stop node
 * @param {string} xmlData 
 * @param {string} tagName 
 * @param {number} i 
 */
function readStopNodeData(xmlData, tagName, i){
  const startIndex = i;
  // Starting at 1 since we already have an open tag
  let openTagCount = 1;

  for (; i < xmlData.length; i++) {
    if( xmlData[i] === "<"){ 
      if (xmlData[i+1] === "/") {//close tag
          const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
          let closeTagName = xmlData.substring(i+2,closeIndex).trim();
          if(closeTagName === tagName){
            openTagCount--;
            if (openTagCount === 0) {
              return {
                tagContent: xmlData.substring(startIndex, i),
                i : closeIndex
              }
            }
          }
          i=closeIndex;
        } else if(xmlData[i+1] === '?') { 
          const closeIndex = findClosingIndex(xmlData, "?>", i+1, "StopNode is not closed.")
          i=closeIndex;
        } else if(xmlData.substr(i + 1, 3) === '!--') { 
          const closeIndex = findClosingIndex(xmlData, "-->", i+3, "StopNode is not closed.")
          i=closeIndex;
        } else if(xmlData.substr(i + 1, 2) === '![') { 
          const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
          i=closeIndex;
        } else {
          const tagData = readTagExp(xmlData, i, '>')

          if (tagData) {
            const openTagName = tagData && tagData.tagName;
            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== "/") {
              openTagCount++;
            }
            i=tagData.closeIndex;
          }
        }
      }
  }//end for loop
}

function parseValue(val, shouldParse, options) {
  if (shouldParse && typeof val === 'string') {
    //console.log(options)
    const newval = val.trim();
    if(newval === 'true' ) return true;
    else if(newval === 'false' ) return false;
    else return toNumber(val, options);
  } else {
    if (util.isExist(val)) {
      return val;
    } else {
      return '';
    }
  }
}


module.exports = OrderedObjParser;


/***/ }),

/***/ 42380:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { buildOptions} = __nccwpck_require__(86993);
const OrderedObjParser = __nccwpck_require__(25832);
const { prettify} = __nccwpck_require__(42882);
const validator = __nccwpck_require__(61739);

class XMLParser{
    
    constructor(options){
        this.externalEntities = {};
        this.options = buildOptions(options);
        
    }
    /**
     * Parse XML dats to JS object 
     * @param {string|Buffer} xmlData 
     * @param {boolean|Object} validationOption 
     */
    parse(xmlData,validationOption){
        if(typeof xmlData === "string"){
        }else if( xmlData.toString){
            xmlData = xmlData.toString();
        }else{
            throw new Error("XML data is accepted in String or Bytes[] form.")
        }
        if( validationOption){
            if(validationOption === true) validationOption = {}; //validate with default options
            
            const result = validator.validate(xmlData, validationOption);
            if (result !== true) {
              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )
            }
          }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;
        else return prettify(orderedResult, this.options);
    }

    /**
     * Add Entity which is not by default supported by this library
     * @param {string} key 
     * @param {string} value 
     */
    addEntity(key, value){
        if(value.indexOf("&") !== -1){
            throw new Error("Entity value can't have '&'")
        }else if(key.indexOf("&") !== -1 || key.indexOf(";") !== -1){
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'")
        }else if(value === "&"){
            throw new Error("An entity with value '&' is not permitted");
        }else{
            this.externalEntities[key] = value;
        }
    }
}

module.exports = XMLParser;

/***/ }),

/***/ 42882:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * 
 * @param {array} node 
 * @param {any} options 
 * @returns 
 */
function prettify(node, options){
  return compress( node, options);
}

/**
 * 
 * @param {array} arr 
 * @param {object} options 
 * @param {string} jPath 
 * @returns object
 */
function compress(arr, options, jPath){
  let text;
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const property = propName(tagObj);
    let newJpath = "";
    if(jPath === undefined) newJpath = property;
    else newJpath = jPath + "." + property;

    if(property === options.textNodeName){
      if(text === undefined) text = tagObj[property];
      else text += "" + tagObj[property];
    }else if(property === undefined){
      continue;
    }else if(tagObj[property]){
      
      let val = compress(tagObj[property], options, newJpath);
      const isLeaf = isLeafTag(val, options);

      if(tagObj[":@"]){
        assignAttributes( val, tagObj[":@"], newJpath, options);
      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){
        val = val[options.textNodeName];
      }else if(Object.keys(val).length === 0){
        if(options.alwaysCreateTextNode) val[options.textNodeName] = "";
        else val = "";
      }

      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
        if(!Array.isArray(compressedObj[property])) {
            compressedObj[property] = [ compressedObj[property] ];
        }
        compressedObj[property].push(val);
      }else{
        //TODO: if a node is not an array, then check if it should be an array
        //also determine if it is a leaf node
        if (options.isArray(property, newJpath, isLeaf )) {
          compressedObj[property] = [val];
        }else{
          compressedObj[property] = val;
        }
      }
    }
    
  }
  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;
  if(typeof text === "string"){
    if(text.length > 0) compressedObj[options.textNodeName] = text;
  }else if(text !== undefined) compressedObj[options.textNodeName] = text;
  return compressedObj;
}

function propName(obj){
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if(key !== ":@") return key;
  }
}

function assignAttributes(obj, attrMap, jpath, options){
  if (attrMap) {
    const keys = Object.keys(attrMap);
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      const atrrName = keys[i];
      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
        obj[atrrName] = [ attrMap[atrrName] ];
      } else {
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
}

function isLeafTag(obj, options){
  const { textNodeName } = options;
  const propCount = Object.keys(obj).length;
  
  if (propCount === 0) {
    return true;
  }

  if (
    propCount === 1 &&
    (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)
  ) {
    return true;
  }

  return false;
}
exports.prettify = prettify;


/***/ }),

/***/ 7462:
/***/ ((module) => {

"use strict";


class XmlNode{
  constructor(tagname) {
    this.tagname = tagname;
    this.child = []; //nested tags, text, cdata, comments in order
    this[":@"] = {}; //attributes map
  }
  add(key,val){
    // this.child.push( {name : key, val: val, isCdata: isCdata });
    if(key === "__proto__") key = "#__proto__";
    this.child.push( {[key]: val });
  }
  addChild(node) {
    if(node.tagname === "__proto__") node.tagname = "#__proto__";
    if(node[":@"] && Object.keys(node[":@"]).length > 0){
      this.child.push( { [node.tagname]: node.child, [":@"]: node[":@"] });
    }else{
      this.child.push( { [node.tagname]: node.child });
    }
  };
};


module.exports = XmlNode;

/***/ }),

/***/ 83973:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = (function () { try { return __nccwpck_require__(71017) } catch (e) {}}()) || {
  sep: '/'
}
minimatch.sep = path.sep

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __nccwpck_require__(33717)

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  b = b || {}
  var t = {}
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch
  }

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }
  m.Minimatch.defaults = function defaults (options) {
    return orig.defaults(ext(def, options)).Minimatch
  }

  m.filter = function filter (pattern, options) {
    return orig.filter(pattern, ext(def, options))
  }

  m.defaults = function defaults (options) {
    return orig.defaults(ext(def, options))
  }

  m.makeRe = function makeRe (pattern, options) {
    return orig.makeRe(pattern, ext(def, options))
  }

  m.braceExpand = function braceExpand (pattern, options) {
    return orig.braceExpand(pattern, ext(def, options))
  }

  m.match = function (list, pattern, options) {
    return orig.match(list, pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  assertValidPattern(pattern)

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  assertValidPattern(pattern)

  if (!options) options = {}

  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (!options.allowWindowsEscape && path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false
  this.partial = !!options.partial

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  assertValidPattern(pattern)

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

var MAX_PATTERN_LENGTH = 1024 * 64
var assertValidPattern = function (pattern) {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern')
  }

  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long')
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  assertValidPattern(pattern)

  var options = this.options

  // shortcuts
  if (pattern === '**') {
    if (!options.noglobstar)
      return GLOBSTAR
    else
      pattern = '*'
  }
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      /* istanbul ignore next */
      case '/': {
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false
      }

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        // split where the last [ was, make sure we don't have
        // an invalid re. if so, re-walk the contents of the
        // would-be class to re-translate any characters that
        // were passed through as-is
        // TODO: It would probably be faster to determine this
        // without a try/catch and a new RegExp, but it's tricky
        // to do safely.  For now, this is safe and works.
        var cs = pattern.substring(classStart + 1, i)
        try {
          RegExp('[' + cs + ']')
        } catch (er) {
          // not a valid class!
          var sp = this.parse(cs, SUBPARSE)
          re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
          hasMagic = hasMagic || sp[1]
          inClass = false
          continue
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '[': case '.': case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) /* istanbul ignore next - should be impossible */ {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) /* istanbul ignore next - should be impossible */ {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = function match (f, partial) {
  if (typeof partial === 'undefined') partial = this.partial
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    /* istanbul ignore if */
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      /* istanbul ignore if */
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      hit = f === p
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else /* istanbul ignore else */ if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    return (fi === fl - 1) && (file[fi] === '')
  }

  // should be unreachable.
  /* istanbul ignore next */
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),

/***/ 14526:
/***/ ((module) => {

const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
const numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
// const octRegex = /0x[a-z0-9]+/;
// const binRegex = /0x[a-z0-9]+/;


//polyfill
if (!Number.parseInt && window.parseInt) {
    Number.parseInt = window.parseInt;
}
if (!Number.parseFloat && window.parseFloat) {
    Number.parseFloat = window.parseFloat;
}

  
const consider = {
    hex :  true,
    leadingZeros: true,
    decimalPoint: "\.",
    eNotation: true
    //skipLike: /regex/
};

function toNumber(str, options = {}){
    // const options = Object.assign({}, consider);
    // if(opt.leadingZeros === false){
    //     options.leadingZeros = false;
    // }else if(opt.hex === false){
    //     options.hex = false;
    // }

    options = Object.assign({}, consider, options );
    if(!str || typeof str !== "string" ) return str;
    
    let trimmedStr  = str.trim();
    // if(trimmedStr === "0.0") return 0;
    // else if(trimmedStr === "+0.0") return 0;
    // else if(trimmedStr === "-0.0") return -0;

    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;
    else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
    // } else if (options.parseOct && octRegex.test(str)) {
    //     return Number.parseInt(val, 8);
    // }else if (options.parseBin && binRegex.test(str)) {
    //     return Number.parseInt(val, 2);
    }else{
        //separate negative sign, leading zeros, and rest number
        const match = numRegex.exec(trimmedStr);
        if(match){
            const sign = match[1];
            const leadingZeros = match[2];
            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros
            //trim ending zeros for floating number
            
            const eNotation = match[4] || match[6];
            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str; //-0123
            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str; //0123
            else{//no leading zeros or leading zeros are allowed
                const num = Number(trimmedStr);
                const numStr = "" + num;
                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(eNotation){ //given number has enotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(trimmedStr.indexOf(".") !== -1){ //floating number
                    // const decimalPart = match[5].substr(1);
                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf("."));

                    
                    // const p = numStr.indexOf(".");
                    // const givenIntPart = numStr.substr(0,p);
                    // const givenDecPart = numStr.substr(p+1);
                    if(numStr === "0" && (numTrimmedByZeros === "") ) return num; //0.0
                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000
                    else if( sign && numStr === "-"+numTrimmedByZeros) return num;
                    else return str;
                }
                
                if(leadingZeros){
                    // if(numTrimmedByZeros === numStr){
                    //     if(options.leadingZeros) return num;
                    //     else return str;
                    // }else return str;
                    if(numTrimmedByZeros === numStr) return num;
                    else if(sign+numTrimmedByZeros === numStr) return num;
                    else return str;
                }

                if(trimmedStr === numStr) return num;
                else if(trimmedStr === sign+numStr) return num;
                // else{
                //     //number with +/- sign
                //     trimmedStr.test(/[-+][0-9]);

                // }
                return str;
            }
            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;
            
        }else{ //non-numeric string
            return str;
        }
    }
}

/**
 * 
 * @param {string} numStr without leading zeros
 * @returns 
 */
function trimZeros(numStr){
    if(numStr && numStr.indexOf(".") !== -1){//float
        numStr = numStr.replace(/0+$/, ""); //remove ending zeros
        if(numStr === ".")  numStr = "0";
        else if(numStr[0] === ".")  numStr = "0"+numStr;
        else if(numStr[numStr.length-1] === ".")  numStr = numStr.substr(0,numStr.length-1);
        return numStr;
    }
    return numStr;
}
module.exports = toNumber


/***/ }),

/***/ 4351:
/***/ ((module) => {

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global global, define, Symbol, Reflect, Promise, SuppressedError */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __esDecorate;
var __runInitializers;
var __propKey;
var __setFunctionName;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __spreadArray;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
var __classPrivateFieldGet;
var __classPrivateFieldSet;
var __classPrivateFieldIn;
var __createBinding;
var __addDisposableResource;
var __disposeResources;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if ( true && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };

    __extends = function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __esDecorate = function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _, done = false;
        for (var i = decorators.length - 1; i >= 0; i--) {
            var context = {};
            for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
            for (var p in contextIn.access) context.access[p] = contextIn.access[p];
            context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
            var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
            if (kind === "accessor") {
                if (result === void 0) continue;
                if (result === null || typeof result !== "object") throw new TypeError("Object expected");
                if (_ = accept(result.get)) descriptor.get = _;
                if (_ = accept(result.set)) descriptor.set = _;
                if (_ = accept(result.init)) initializers.unshift(_);
            }
            else if (_ = accept(result)) {
                if (kind === "field") initializers.unshift(_);
                else descriptor[key] = _;
            }
        }
        if (target) Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
    };

    __runInitializers = function (thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i = 0; i < initializers.length; i++) {
            value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
        }
        return useValue ? value : void 0;
    };

    __propKey = function (x) {
        return typeof x === "symbol" ? x : "".concat(x);
    };

    __setFunctionName = function (f, name, prefix) {
        if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function(m, o) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
    };

    __createBinding = Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    });

    __values = function (o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    /** @deprecated */
    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    /** @deprecated */
    __spreadArrays = function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    __spreadArray = function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    var __setModuleDefault = Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    __classPrivateFieldGet = function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    __classPrivateFieldSet = function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };

    __classPrivateFieldIn = function (state, receiver) {
        if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
    };

    __addDisposableResource = function (env, value, async) {
        if (value !== null && value !== void 0) {
            if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
            var dispose;
            if (async) {
                if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
                dispose = value[Symbol.asyncDispose];
            }
            if (dispose === void 0) {
                if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
                dispose = value[Symbol.dispose];
            }
            if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
            env.stack.push({ value: value, dispose: dispose, async: async });
        }
        else if (async) {
            env.stack.push({ async: true });
        }
        return value;
    };

    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    __disposeResources = function (env) {
        function fail(e) {
            env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
});


/***/ }),

/***/ 74294:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(54219);


/***/ }),

/***/ 54219:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var net = __nccwpck_require__(41808);
var tls = __nccwpck_require__(24404);
var http = __nccwpck_require__(13685);
var https = __nccwpck_require__(95687);
var events = __nccwpck_require__(82361);
var assert = __nccwpck_require__(39491);
var util = __nccwpck_require__(73837);


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),

/***/ 75840:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "v1", ({
  enumerable: true,
  get: function () {
    return _v.default;
  }
}));
Object.defineProperty(exports, "v3", ({
  enumerable: true,
  get: function () {
    return _v2.default;
  }
}));
Object.defineProperty(exports, "v4", ({
  enumerable: true,
  get: function () {
    return _v3.default;
  }
}));
Object.defineProperty(exports, "v5", ({
  enumerable: true,
  get: function () {
    return _v4.default;
  }
}));
Object.defineProperty(exports, "NIL", ({
  enumerable: true,
  get: function () {
    return _nil.default;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function () {
    return _version.default;
  }
}));
Object.defineProperty(exports, "validate", ({
  enumerable: true,
  get: function () {
    return _validate.default;
  }
}));
Object.defineProperty(exports, "stringify", ({
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
}));
Object.defineProperty(exports, "parse", ({
  enumerable: true,
  get: function () {
    return _parse.default;
  }
}));

var _v = _interopRequireDefault(__nccwpck_require__(78628));

var _v2 = _interopRequireDefault(__nccwpck_require__(86409));

var _v3 = _interopRequireDefault(__nccwpck_require__(85122));

var _v4 = _interopRequireDefault(__nccwpck_require__(79120));

var _nil = _interopRequireDefault(__nccwpck_require__(25332));

var _version = _interopRequireDefault(__nccwpck_require__(81595));

var _validate = _interopRequireDefault(__nccwpck_require__(66900));

var _stringify = _interopRequireDefault(__nccwpck_require__(18950));

var _parse = _interopRequireDefault(__nccwpck_require__(62746));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ 4569:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('md5').update(bytes).digest();
}

var _default = md5;
exports["default"] = _default;

/***/ }),

/***/ 25332:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports["default"] = _default;

/***/ }),

/***/ 62746:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(66900));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports["default"] = _default;

/***/ }),

/***/ 40814:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports["default"] = _default;

/***/ }),

/***/ 50807:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = rng;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;

function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    _crypto.default.randomFillSync(rnds8Pool);

    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

/***/ }),

/***/ 85274:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('sha1').update(bytes).digest();
}

var _default = sha1;
exports["default"] = _default;

/***/ }),

/***/ 18950:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(66900));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports["default"] = _default;

/***/ }),

/***/ 78628:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(50807));

var _stringify = _interopRequireDefault(__nccwpck_require__(18950));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports["default"] = _default;

/***/ }),

/***/ 86409:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(65998));

var _md = _interopRequireDefault(__nccwpck_require__(4569));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports["default"] = _default;

/***/ }),

/***/ 65998:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(__nccwpck_require__(18950));

var _parse = _interopRequireDefault(__nccwpck_require__(62746));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ 85122:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(50807));

var _stringify = _interopRequireDefault(__nccwpck_require__(18950));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports["default"] = _default;

/***/ }),

/***/ 79120:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(65998));

var _sha = _interopRequireDefault(__nccwpck_require__(85274));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports["default"] = _default;

/***/ }),

/***/ 66900:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _regex = _interopRequireDefault(__nccwpck_require__(40814));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports["default"] = _default;

/***/ }),

/***/ 81595:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(66900));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports["default"] = _default;

/***/ }),

/***/ 70399:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestRunner = exports.MainRunner = void 0;
const core = __importStar(__nccwpck_require__(42186));
const glob = __importStar(__nccwpck_require__(28090));
const fs_1 = __importStar(__nccwpck_require__(57147));
const path_1 = __importDefault(__nccwpck_require__(71017));
const client_s3_1 = __nccwpck_require__(19250);
const client_cloudfront_1 = __nccwpck_require__(72928);
class MainRunner {
    AWS_KEY_ID;
    SECRET_ACCESS_KEY;
    BUCKET;
    REGION;
    SOURCE_FILES;
    TARGET_DIR;
    INVALIDATION_PATH;
    DISTRIBUTION_ID;
    s3;
    cloudFront;
    constructor() {
        this.AWS_KEY_ID = core.getInput('aws-access-key-id', { required: true });
        this.SECRET_ACCESS_KEY = core.getInput('aws-secret-access-key', {
            required: true
        });
        this.REGION = core.getInput('aws-region');
        this.BUCKET = core.getInput('bucket');
        this.SOURCE_FILES = core.getMultilineInput('source-files');
        this.TARGET_DIR = core.getInput('target-dir');
        this.INVALIDATION_PATH = core.getMultilineInput('invalidation-path');
        this.DISTRIBUTION_ID = core.getInput('distribution-id');
        if (isNotEmpty(this.BUCKET) &&
            isArryNotEmpty(this.SOURCE_FILES) &&
            isNotEmpty(this.TARGET_DIR)) {
            this.s3 = new client_s3_1.S3Client({
                region: this.REGION,
                credentials: {
                    accessKeyId: this.AWS_KEY_ID,
                    secretAccessKey: this.SECRET_ACCESS_KEY
                }
            });
        }
        if (isNotEmpty(this.DISTRIBUTION_ID) &&
            isArryNotEmpty(this.INVALIDATION_PATH)) {
            this.cloudFront = new client_cloudfront_1.CloudFrontClient({
                region: this.REGION,
                credentials: {
                    accessKeyId: this.AWS_KEY_ID,
                    secretAccessKey: this.SECRET_ACCESS_KEY
                }
            });
        }
    }
    async run() {
        try {
            if (this.s3) {
                const rootGlobber = await glob.create('./');
                const rootDir = rootGlobber.getSearchPaths();
                core.info(`🗃️ rootDir === ${rootDir}`);
                const globber = await glob.create(this.SOURCE_FILES.join('\n'));
                const filePathList = await globber.glob();
                core.info(`📋 files to upload:\n${filePathList.join('\n')}`);
                for (const filePath of filePathList) {
                    const key = `${this.TARGET_DIR}${autoFixPath(filePath.replace(rootDir[0], ''))}`;
                    core.info(`⤴️ start upload: ${filePath}, s3Path =  ${key}`);
                    if (isDirectory(filePath)) {
                        continue;
                    }
                    // 创建一个 PutObjectCommand 实例
                    const putObjectCommand = new client_s3_1.PutObjectCommand({
                        Bucket: this.BUCKET,
                        Key: key,
                        Body: fs_1.default.createReadStream(filePath)
                    });
                    const ur = await this.s3.send(putObjectCommand);
                    if (ur && isHttpSuccess(ur.$metadata.httpStatusCode)) {
                        core.info(`✅ ${key} uploaded successfully: ${JSON.stringify(ur)}`);
                    }
                    else {
                        const urJson = JSON.stringify(ur);
                        core.error(`❌ ${key} Error uploading file: ${urJson}`);
                        core.setFailed(urJson);
                    }
                }
            }
            if (this.cloudFront) {
                core.info(`🗑️ paths to invalidation:\n${this.INVALIDATION_PATH?.join('\n')}`);
                // 创建一个 CreateInvalidationCommand 实例
                const invalidationCommand = new client_cloudfront_1.CreateInvalidationCommand({
                    DistributionId: this.DISTRIBUTION_ID,
                    InvalidationBatch: {
                        CallerReference: Date.now().toString(),
                        Paths: {
                            Quantity: 1,
                            Items: this.INVALIDATION_PATH
                        }
                    }
                });
                const ir = await this.cloudFront.send(invalidationCommand);
                if (ir && isHttpSuccess(ir.$metadata.httpStatusCode)) {
                    core.info(`✅ invalidation successfully: ${JSON.stringify(ir)}`);
                }
            }
        }
        catch (error) {
            core.error(`❌ happen Error : ${error}`);
            core.setFailed(`${error}`);
        }
        return true;
    }
    test() {
        core.info('test!');
    }
}
exports.MainRunner = MainRunner;
function isNotEmpty(text) {
    return text != null && text.length > 0;
}
function isArryNotEmpty(text) {
    return text != null && text.length > 0;
}
function isHttpSuccess(code) {
    return code != null && code >= 200 && code < 400;
}
function autoFixPath(rawPath) {
    const splitPath = rawPath.split(path_1.default.sep);
    if (splitPath && splitPath.length > 0) {
        return splitPath.join('/');
    }
    return rawPath;
}
function isDirectory(filePath) {
    try {
        const stat = (0, fs_1.statSync)(filePath);
        return stat.isDirectory();
    }
    catch (e) {
        // 如果路径不存在，则不是文件夹
        return false;
    }
}
class TestRunner {
    test() {
        core.info('test');
    }
}
exports.TestRunner = TestRunner;


/***/ }),

/***/ 39491:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 14300:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 32081:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 6113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 82361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 57147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 13685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 85158:
/***/ ((module) => {

"use strict";
module.exports = require("http2");

/***/ }),

/***/ 95687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 41808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 22037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 71017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 77282:
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ }),

/***/ 12781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 24404:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 57310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 73837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 10273:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-cloudfront","description":"AWS SDK for JavaScript Cloudfront Client for Node.js, Browser and React Native","version":"3.485.0","scripts":{"build":"concurrently \'yarn:build:cjs\' \'yarn:build:es\' \'yarn:build:types\'","build:cjs":"tsc -p tsconfig.cjs.json","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"rimraf ./dist-* && rimraf *.tsbuildinfo","extract:docs":"api-extractor run --local","generate:client":"node ../../scripts/generate-clients/single-service --solo cloudfront"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha256-browser":"3.0.0","@aws-crypto/sha256-js":"3.0.0","@aws-sdk/client-sts":"3.485.0","@aws-sdk/core":"3.485.0","@aws-sdk/credential-provider-node":"3.485.0","@aws-sdk/middleware-host-header":"3.485.0","@aws-sdk/middleware-logger":"3.485.0","@aws-sdk/middleware-recursion-detection":"3.485.0","@aws-sdk/middleware-signing":"3.485.0","@aws-sdk/middleware-user-agent":"3.485.0","@aws-sdk/region-config-resolver":"3.485.0","@aws-sdk/types":"3.485.0","@aws-sdk/util-endpoints":"3.485.0","@aws-sdk/util-user-agent-browser":"3.485.0","@aws-sdk/util-user-agent-node":"3.485.0","@aws-sdk/xml-builder":"3.485.0","@smithy/config-resolver":"^2.0.23","@smithy/core":"^1.2.2","@smithy/fetch-http-handler":"^2.3.2","@smithy/hash-node":"^2.0.18","@smithy/invalid-dependency":"^2.0.16","@smithy/middleware-content-length":"^2.0.18","@smithy/middleware-endpoint":"^2.3.0","@smithy/middleware-retry":"^2.0.26","@smithy/middleware-serde":"^2.0.16","@smithy/middleware-stack":"^2.0.10","@smithy/node-config-provider":"^2.1.9","@smithy/node-http-handler":"^2.2.2","@smithy/protocol-http":"^3.0.12","@smithy/smithy-client":"^2.2.1","@smithy/types":"^2.8.0","@smithy/url-parser":"^2.0.16","@smithy/util-base64":"^2.0.1","@smithy/util-body-length-browser":"^2.0.1","@smithy/util-body-length-node":"^2.1.0","@smithy/util-defaults-mode-browser":"^2.0.24","@smithy/util-defaults-mode-node":"^2.0.32","@smithy/util-endpoints":"^1.0.8","@smithy/util-retry":"^2.0.9","@smithy/util-stream":"^2.0.24","@smithy/util-utf8":"^2.0.2","@smithy/util-waiter":"^2.0.16","fast-xml-parser":"4.2.5","tslib":"^2.5.0"},"devDependencies":{"@smithy/service-client-documentation-generator":"^2.0.0","@tsconfig/node14":"1.0.3","@types/node":"^14.14.31","concurrently":"7.0.0","downlevel-dts":"0.10.1","rimraf":"3.0.2","typescript":"~4.9.5"},"engines":{"node":">=14.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*/**"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-cloudfront","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-cloudfront"}}');

/***/ }),

/***/ 50677:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-s3","description":"AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native","version":"3.485.0","scripts":{"build":"concurrently \'yarn:build:cjs\' \'yarn:build:es\' \'yarn:build:types\'","build:cjs":"tsc -p tsconfig.cjs.json","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"rimraf ./dist-* && rimraf *.tsbuildinfo","extract:docs":"api-extractor run --local","generate:client":"node ../../scripts/generate-clients/single-service --solo s3","test":"yarn test:unit","test:e2e":"yarn test:e2e:node && yarn test:e2e:browser","test:e2e:browser":"ts-mocha test/**/*.browser.ispec.ts && karma start karma.conf.js","test:e2e:node":"jest --c jest.config.e2e.js","test:unit":"ts-mocha test/unit/**/*.spec.ts"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha1-browser":"3.0.0","@aws-crypto/sha256-browser":"3.0.0","@aws-crypto/sha256-js":"3.0.0","@aws-sdk/client-sts":"3.485.0","@aws-sdk/core":"3.485.0","@aws-sdk/credential-provider-node":"3.485.0","@aws-sdk/middleware-bucket-endpoint":"3.485.0","@aws-sdk/middleware-expect-continue":"3.485.0","@aws-sdk/middleware-flexible-checksums":"3.485.0","@aws-sdk/middleware-host-header":"3.485.0","@aws-sdk/middleware-location-constraint":"3.485.0","@aws-sdk/middleware-logger":"3.485.0","@aws-sdk/middleware-recursion-detection":"3.485.0","@aws-sdk/middleware-sdk-s3":"3.485.0","@aws-sdk/middleware-signing":"3.485.0","@aws-sdk/middleware-ssec":"3.485.0","@aws-sdk/middleware-user-agent":"3.485.0","@aws-sdk/region-config-resolver":"3.485.0","@aws-sdk/signature-v4-multi-region":"3.485.0","@aws-sdk/types":"3.485.0","@aws-sdk/util-endpoints":"3.485.0","@aws-sdk/util-user-agent-browser":"3.485.0","@aws-sdk/util-user-agent-node":"3.485.0","@aws-sdk/xml-builder":"3.485.0","@smithy/config-resolver":"^2.0.23","@smithy/core":"^1.2.2","@smithy/eventstream-serde-browser":"^2.0.16","@smithy/eventstream-serde-config-resolver":"^2.0.16","@smithy/eventstream-serde-node":"^2.0.16","@smithy/fetch-http-handler":"^2.3.2","@smithy/hash-blob-browser":"^2.0.17","@smithy/hash-node":"^2.0.18","@smithy/hash-stream-node":"^2.0.18","@smithy/invalid-dependency":"^2.0.16","@smithy/md5-js":"^2.0.18","@smithy/middleware-content-length":"^2.0.18","@smithy/middleware-endpoint":"^2.3.0","@smithy/middleware-retry":"^2.0.26","@smithy/middleware-serde":"^2.0.16","@smithy/middleware-stack":"^2.0.10","@smithy/node-config-provider":"^2.1.9","@smithy/node-http-handler":"^2.2.2","@smithy/protocol-http":"^3.0.12","@smithy/smithy-client":"^2.2.1","@smithy/types":"^2.8.0","@smithy/url-parser":"^2.0.16","@smithy/util-base64":"^2.0.1","@smithy/util-body-length-browser":"^2.0.1","@smithy/util-body-length-node":"^2.1.0","@smithy/util-defaults-mode-browser":"^2.0.24","@smithy/util-defaults-mode-node":"^2.0.32","@smithy/util-endpoints":"^1.0.8","@smithy/util-retry":"^2.0.9","@smithy/util-stream":"^2.0.24","@smithy/util-utf8":"^2.0.2","@smithy/util-waiter":"^2.0.16","fast-xml-parser":"4.2.5","tslib":"^2.5.0"},"devDependencies":{"@smithy/service-client-documentation-generator":"^2.0.0","@tsconfig/node14":"1.0.3","@types/chai":"^4.2.11","@types/mocha":"^8.0.4","@types/node":"^14.14.31","concurrently":"7.0.0","downlevel-dts":"0.10.1","rimraf":"3.0.2","typescript":"~4.9.5"},"engines":{"node":">=14.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*/**"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-s3"}}');

/***/ }),

/***/ 91092:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-sso","description":"AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native","version":"3.485.0","scripts":{"build":"concurrently \'yarn:build:cjs\' \'yarn:build:es\' \'yarn:build:types\'","build:cjs":"tsc -p tsconfig.cjs.json","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"rimraf ./dist-* && rimraf *.tsbuildinfo","extract:docs":"api-extractor run --local","generate:client":"node ../../scripts/generate-clients/single-service --solo sso"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha256-browser":"3.0.0","@aws-crypto/sha256-js":"3.0.0","@aws-sdk/core":"3.485.0","@aws-sdk/middleware-host-header":"3.485.0","@aws-sdk/middleware-logger":"3.485.0","@aws-sdk/middleware-recursion-detection":"3.485.0","@aws-sdk/middleware-user-agent":"3.485.0","@aws-sdk/region-config-resolver":"3.485.0","@aws-sdk/types":"3.485.0","@aws-sdk/util-endpoints":"3.485.0","@aws-sdk/util-user-agent-browser":"3.485.0","@aws-sdk/util-user-agent-node":"3.485.0","@smithy/config-resolver":"^2.0.23","@smithy/core":"^1.2.2","@smithy/fetch-http-handler":"^2.3.2","@smithy/hash-node":"^2.0.18","@smithy/invalid-dependency":"^2.0.16","@smithy/middleware-content-length":"^2.0.18","@smithy/middleware-endpoint":"^2.3.0","@smithy/middleware-retry":"^2.0.26","@smithy/middleware-serde":"^2.0.16","@smithy/middleware-stack":"^2.0.10","@smithy/node-config-provider":"^2.1.9","@smithy/node-http-handler":"^2.2.2","@smithy/protocol-http":"^3.0.12","@smithy/smithy-client":"^2.2.1","@smithy/types":"^2.8.0","@smithy/url-parser":"^2.0.16","@smithy/util-base64":"^2.0.1","@smithy/util-body-length-browser":"^2.0.1","@smithy/util-body-length-node":"^2.1.0","@smithy/util-defaults-mode-browser":"^2.0.24","@smithy/util-defaults-mode-node":"^2.0.32","@smithy/util-endpoints":"^1.0.8","@smithy/util-retry":"^2.0.9","@smithy/util-utf8":"^2.0.2","tslib":"^2.5.0"},"devDependencies":{"@smithy/service-client-documentation-generator":"^2.0.0","@tsconfig/node14":"1.0.3","@types/node":"^14.14.31","concurrently":"7.0.0","downlevel-dts":"0.10.1","rimraf":"3.0.2","typescript":"~4.9.5"},"engines":{"node":">=14.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*/**"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-sso"}}');

/***/ }),

/***/ 7947:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-sts","description":"AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native","version":"3.485.0","scripts":{"build":"concurrently \'yarn:build:cjs\' \'yarn:build:es\' \'yarn:build:types\'","build:cjs":"tsc -p tsconfig.cjs.json","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"rimraf ./dist-* && rimraf *.tsbuildinfo","extract:docs":"api-extractor run --local","generate:client":"node ../../scripts/generate-clients/single-service --solo sts","test":"yarn test:unit","test:unit":"jest"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha256-browser":"3.0.0","@aws-crypto/sha256-js":"3.0.0","@aws-sdk/core":"3.485.0","@aws-sdk/credential-provider-node":"3.485.0","@aws-sdk/middleware-host-header":"3.485.0","@aws-sdk/middleware-logger":"3.485.0","@aws-sdk/middleware-recursion-detection":"3.485.0","@aws-sdk/middleware-user-agent":"3.485.0","@aws-sdk/region-config-resolver":"3.485.0","@aws-sdk/types":"3.485.0","@aws-sdk/util-endpoints":"3.485.0","@aws-sdk/util-user-agent-browser":"3.485.0","@aws-sdk/util-user-agent-node":"3.485.0","@smithy/config-resolver":"^2.0.23","@smithy/core":"^1.2.2","@smithy/fetch-http-handler":"^2.3.2","@smithy/hash-node":"^2.0.18","@smithy/invalid-dependency":"^2.0.16","@smithy/middleware-content-length":"^2.0.18","@smithy/middleware-endpoint":"^2.3.0","@smithy/middleware-retry":"^2.0.26","@smithy/middleware-serde":"^2.0.16","@smithy/middleware-stack":"^2.0.10","@smithy/node-config-provider":"^2.1.9","@smithy/node-http-handler":"^2.2.2","@smithy/protocol-http":"^3.0.12","@smithy/smithy-client":"^2.2.1","@smithy/types":"^2.8.0","@smithy/url-parser":"^2.0.16","@smithy/util-base64":"^2.0.1","@smithy/util-body-length-browser":"^2.0.1","@smithy/util-body-length-node":"^2.1.0","@smithy/util-defaults-mode-browser":"^2.0.24","@smithy/util-defaults-mode-node":"^2.0.32","@smithy/util-endpoints":"^1.0.8","@smithy/util-middleware":"^2.0.9","@smithy/util-retry":"^2.0.9","@smithy/util-utf8":"^2.0.2","fast-xml-parser":"4.2.5","tslib":"^2.5.0"},"devDependencies":{"@smithy/service-client-documentation-generator":"^2.0.0","@tsconfig/node14":"1.0.3","@types/node":"^14.14.31","concurrently":"7.0.0","downlevel-dts":"0.10.1","rimraf":"3.0.2","typescript":"~4.9.5"},"engines":{"node":">=14.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*/**"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-sts"}}');

/***/ }),

/***/ 95367:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"partitions":[{"id":"aws","outputs":{"dnsSuffix":"amazonaws.com","dualStackDnsSuffix":"api.aws","implicitGlobalRegion":"us-east-1","name":"aws","supportsDualStack":true,"supportsFIPS":true},"regionRegex":"^(us|eu|ap|sa|ca|me|af|il)\\\\-\\\\w+\\\\-\\\\d+$","regions":{"af-south-1":{"description":"Africa (Cape Town)"},"ap-east-1":{"description":"Asia Pacific (Hong Kong)"},"ap-northeast-1":{"description":"Asia Pacific (Tokyo)"},"ap-northeast-2":{"description":"Asia Pacific (Seoul)"},"ap-northeast-3":{"description":"Asia Pacific (Osaka)"},"ap-south-1":{"description":"Asia Pacific (Mumbai)"},"ap-south-2":{"description":"Asia Pacific (Hyderabad)"},"ap-southeast-1":{"description":"Asia Pacific (Singapore)"},"ap-southeast-2":{"description":"Asia Pacific (Sydney)"},"ap-southeast-3":{"description":"Asia Pacific (Jakarta)"},"ap-southeast-4":{"description":"Asia Pacific (Melbourne)"},"aws-global":{"description":"AWS Standard global region"},"ca-central-1":{"description":"Canada (Central)"},"ca-west-1":{"description":"Canada West (Calgary)"},"eu-central-1":{"description":"Europe (Frankfurt)"},"eu-central-2":{"description":"Europe (Zurich)"},"eu-north-1":{"description":"Europe (Stockholm)"},"eu-south-1":{"description":"Europe (Milan)"},"eu-south-2":{"description":"Europe (Spain)"},"eu-west-1":{"description":"Europe (Ireland)"},"eu-west-2":{"description":"Europe (London)"},"eu-west-3":{"description":"Europe (Paris)"},"il-central-1":{"description":"Israel (Tel Aviv)"},"me-central-1":{"description":"Middle East (UAE)"},"me-south-1":{"description":"Middle East (Bahrain)"},"sa-east-1":{"description":"South America (Sao Paulo)"},"us-east-1":{"description":"US East (N. Virginia)"},"us-east-2":{"description":"US East (Ohio)"},"us-west-1":{"description":"US West (N. California)"},"us-west-2":{"description":"US West (Oregon)"}}},{"id":"aws-cn","outputs":{"dnsSuffix":"amazonaws.com.cn","dualStackDnsSuffix":"api.amazonwebservices.com.cn","implicitGlobalRegion":"cn-northwest-1","name":"aws-cn","supportsDualStack":true,"supportsFIPS":true},"regionRegex":"^cn\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-cn-global":{"description":"AWS China global region"},"cn-north-1":{"description":"China (Beijing)"},"cn-northwest-1":{"description":"China (Ningxia)"}}},{"id":"aws-us-gov","outputs":{"dnsSuffix":"amazonaws.com","dualStackDnsSuffix":"api.aws","implicitGlobalRegion":"us-gov-west-1","name":"aws-us-gov","supportsDualStack":true,"supportsFIPS":true},"regionRegex":"^us\\\\-gov\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-us-gov-global":{"description":"AWS GovCloud (US) global region"},"us-gov-east-1":{"description":"AWS GovCloud (US-East)"},"us-gov-west-1":{"description":"AWS GovCloud (US-West)"}}},{"id":"aws-iso","outputs":{"dnsSuffix":"c2s.ic.gov","dualStackDnsSuffix":"c2s.ic.gov","implicitGlobalRegion":"us-iso-east-1","name":"aws-iso","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^us\\\\-iso\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-iso-global":{"description":"AWS ISO (US) global region"},"us-iso-east-1":{"description":"US ISO East"},"us-iso-west-1":{"description":"US ISO WEST"}}},{"id":"aws-iso-b","outputs":{"dnsSuffix":"sc2s.sgov.gov","dualStackDnsSuffix":"sc2s.sgov.gov","implicitGlobalRegion":"us-isob-east-1","name":"aws-iso-b","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^us\\\\-isob\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-iso-b-global":{"description":"AWS ISOB (US) global region"},"us-isob-east-1":{"description":"US ISOB East (Ohio)"}}},{"id":"aws-iso-e","outputs":{"dnsSuffix":"cloud.adc-e.uk","dualStackDnsSuffix":"cloud.adc-e.uk","implicitGlobalRegion":"eu-isoe-west-1","name":"aws-iso-e","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^eu\\\\-isoe\\\\-\\\\w+\\\\-\\\\d+$","regions":{}},{"id":"aws-iso-f","outputs":{"dnsSuffix":"csp.hci.ic.gov","dualStackDnsSuffix":"csp.hci.ic.gov","implicitGlobalRegion":"us-isof-south-1","name":"aws-iso-f","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^us\\\\-isof\\\\-\\\\w+\\\\-\\\\d+$","regions":{}}],"version":"1.1"}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;

Object.defineProperty(exports, "__esModule", ({ value: true }));
const main_1 = __nccwpck_require__(70399);
const main = new main_1.MainRunner();
main.run();

})();

module.exports = __webpack_exports__;
/******/ })()
;